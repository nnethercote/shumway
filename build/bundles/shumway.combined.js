// Manifest gfx
console.time("Load Shared Dependencies");
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
///<reference path='references.ts' />
var jsGlobal = (function () {
    return this || (1, eval)('this');
})();
var inBrowser = typeof console != "undefined";

// declare var print;
// declare var console;
// declare var performance;
// declare var XMLHttpRequest;
// declare var document;
// declare var getComputedStyle;
/** @const */ var release = false;
/** @const */ var profile = false;

if (!jsGlobal.performance) {
    jsGlobal.performance = {};
}

if (!jsGlobal.performance.now) {
    jsGlobal.performance.now = typeof dateNow !== 'undefined' ? dateNow : Date.now;
}

function log(message) {
    var optionalParams = [];
    for (var _i = 0; _i < (arguments.length - 1); _i++) {
        optionalParams[_i] = arguments[_i + 1];
    }
    jsGlobal.print.apply(jsGlobal, arguments);
}

function warn(message) {
    var optionalParams = [];
    for (var _i = 0; _i < (arguments.length - 1); _i++) {
        optionalParams[_i] = arguments[_i + 1];
    }
    if (inBrowser) {
        console.warn.apply(console, arguments);
    } else {
        jsGlobal.print(Shumway.IndentingWriter.RED + message + Shumway.IndentingWriter.ENDC);
    }
}

var Shumway;
(function (Shumway) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
    })(Shumway.CharacterCodes || (Shumway.CharacterCodes = {}));
    var CharacterCodes = Shumway.CharacterCodes;

    /**
    * The buffer length required to contain any unsigned 32-bit integer.
    */
    /** @const */ Shumway.UINT32_CHAR_BUFFER_LENGTH = 10;
    /** @const */ Shumway.UINT32_MAX = 0xFFFFFFFF;
    /** @const */ Shumway.UINT32_MAX_DIV_10 = 0x19999999;
    /** @const */ Shumway.UINT32_MAX_MOD_10 = 0x5;

    function isString(value) {
        return typeof value === "string";
    }
    Shumway.isString = isString;

    function isFunction(value) {
        return typeof value === "function";
    }
    Shumway.isFunction = isFunction;

    function isNumber(value) {
        return typeof value === "number";
    }
    Shumway.isNumber = isNumber;

    function isInteger(value) {
        return (value | 0) === value;
    }
    Shumway.isInteger = isInteger;

    function isArray(value) {
        return value instanceof Array;
    }
    Shumway.isArray = isArray;

    function isNumberOrString(value) {
        return typeof value === "number" || typeof value === "string";
    }
    Shumway.isNumberOrString = isNumberOrString;

    function isObject(value) {
        return typeof value === "object" || typeof value === 'function';
    }
    Shumway.isObject = isObject;

    function toNumber(x) {
        return +x;
    }
    Shumway.toNumber = toNumber;

    function isNumericString(value) {
        // ECMAScript 5.1 - 9.8.1 Note 1, this expression is true for all
        // numbers x other than -0.
        return String(Number(value)) === value;
    }
    Shumway.isNumericString = isNumericString;

    /**
    * Whether the specified |value| is a number or the string representation of a number.
    */
    function isNumeric(value) {
        if (typeof value === "number") {
            return true;
        } else if (typeof value === "string") {
            return isIndex(value) || isNumericString(value);
        } else {
            // Debug.notImplemented(typeof value);
            return false;
        }
    }
    Shumway.isNumeric = isNumeric;

    /**
    * Whether the specified |value| is an unsigned 32 bit number expressed as a number
    * or string.
    */
    function isIndex(value) {
        // js/src/vm/String.cpp JSFlatString::isIndexSlow
        // http://dxr.mozilla.org/mozilla-central/source/js/src/vm/String.cpp#474
        var index = 0;
        if (typeof value === "number") {
            index = (value | 0);
            if (value === index && index >= 0) {
                return true;
            }
            return value >>> 0 === value;
        }
        if (typeof value !== "string") {
            return false;
        }
        var length = value.length;
        if (length === 0) {
            return false;
        }
        if (value === "0") {
            return true;
        }

        // Is there any way this will fit?
        if (length > Shumway.UINT32_CHAR_BUFFER_LENGTH) {
            return false;
        }
        var i = 0;
        index = value.charCodeAt(i++) - 48 /* _0 */;
        if (index < 1 || index > 9) {
            return false;
        }
        var oldIndex = 0;
        var c = 0;
        while (i < length) {
            c = value.charCodeAt(i++) - 48 /* _0 */;
            if (c < 0 || c > 9) {
                return false;
            }
            oldIndex = index;
            index = 10 * index + c;
        }

        /*
        * Look out for "4294967296" and larger-number strings that fit in UINT32_CHAR_BUFFER_LENGTH.
        * Only unsigned 32-bit integers shall pass.
        */
        if ((oldIndex < Shumway.UINT32_MAX_DIV_10) || (oldIndex === Shumway.UINT32_MAX_DIV_10 && c <= Shumway.UINT32_MAX_MOD_10)) {
            return true;
        }
        return false;
    }
    Shumway.isIndex = isIndex;

    function isNullOrUndefined(value) {
        return value == undefined;
    }
    Shumway.isNullOrUndefined = isNullOrUndefined;

    (function (Debug) {
        function backtrace() {
            try  {
                throw new Error();
            } catch (e) {
                return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
            }
        }
        Debug.backtrace = backtrace;

        function error(message) {
            if (!inBrowser) {
                warn(message + "\n\nStack Trace:\n" + Debug.backtrace());
            }
            throw new Error(message);
        }
        Debug.error = error;

        function assert(condition) {
            var args = [];
            for (var _i = 0; _i < (arguments.length - 1); _i++) {
                args[_i] = arguments[_i + 1];
            }
            if (condition === "") {
                condition = true;
            }
            if (!condition) {
                var message = Array.prototype.slice.call(arguments);
                message.shift();
                Debug.error(message.join(""));
            }
        }
        Debug.assert = assert;

        function assertUnreachable(msg) {
            var location = new Error().stack.split('\n')[1];
            throw new Error("Reached unreachable location " + location + msg);
        }
        Debug.assertUnreachable = assertUnreachable;

        function assertNotImplemented(condition, message) {
            if (!condition) {
                Debug.error("NotImplemented: " + message);
            }
        }
        Debug.assertNotImplemented = assertNotImplemented;

        function warning(message) {
            release || warn(message);
        }
        Debug.warning = warning;

        function notUsed(message) {
            release || Debug.assert(false, "Not Used " + message);
        }
        Debug.notUsed = notUsed;

        function notImplemented(message) {
            log("release: " + release);
            release || Debug.assert(false, "Not Implemented " + message);
        }
        Debug.notImplemented = notImplemented;

        function abstractMethod(message) {
            Debug.assert(false, "Abstract Method " + message);
        }
        Debug.abstractMethod = abstractMethod;

        var somewhatImplementedCache = {};

        function somewhatImplemented(message) {
            if (somewhatImplementedCache[message]) {
                return;
            }
            somewhatImplementedCache[message] = true;
            Debug.warning("somewhatImplemented: " + message);
        }
        Debug.somewhatImplemented = somewhatImplemented;

        function unexpected(message) {
            Debug.assert(false, "Unexpected: " + message);
        }
        Debug.unexpected = unexpected;

        function untested(message) {
            Debug.warning("Congratulations, you've found a code path for which we haven't found a test case. Please submit the test case: " + message);
        }
        Debug.untested = untested;
    })(Shumway.Debug || (Shumway.Debug = {}));
    var Debug = Shumway.Debug;

    function getTicks() {
        return performance.now();
    }
    Shumway.getTicks = getTicks;

    (function (ArrayUtilities) {
        var assert = Shumway.Debug.assert;

        /**
        * Pops elements from a source array into a destination array. This avoids
        * allocations and should be faster. The elements in the destination array
        * are pushed in the same order as they appear in the source array:
        *
        * popManyInto([1, 2, 3], 2, dst) => dst = [2, 3]
        */
        function popManyInto(src, count, dst) {
            release || assert(src.length >= count);
            for (var i = count - 1; i >= 0; i--) {
                dst[i] = src.pop();
            }
            dst.length = count;
        }
        ArrayUtilities.popManyInto = popManyInto;

        function popMany(array, count) {
            release || assert(array.length >= count);
            var start = array.length - count;
            var result = array.slice(start, this.length);
            array.splice(start, count);
            return result;
        }
        ArrayUtilities.popMany = popMany;

        /**
        * Just deletes several array elements from the end of the list.
        */
        function popManyIntoVoid(array, count) {
            release || assert(array.length >= count);
            array.length = array.length - count;
        }
        ArrayUtilities.popManyIntoVoid = popManyIntoVoid;

        function pushMany(dst, src) {
            for (var i = 0; i < src.length; i++) {
                dst.push(src[i]);
            }
        }
        ArrayUtilities.pushMany = pushMany;

        function top(array) {
            return array.length && array[array.length - 1];
        }
        ArrayUtilities.top = top;

        function last(array) {
            return array.length && array[array.length - 1];
        }
        ArrayUtilities.last = last;

        function peek(array) {
            release || assert(array.length > 0);
            return array[array.length - 1];
        }
        ArrayUtilities.peek = peek;

        function indexOf(array, value) {
            for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }
        ArrayUtilities.indexOf = indexOf;

        function pushUnique(array, value) {
            for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            array.push(value);
            return array.length - 1;
        }
        ArrayUtilities.pushUnique = pushUnique;

        function unique(array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                pushUnique(result, array[i]);
            }
            return result;
        }
        ArrayUtilities.unique = unique;

        function copyFrom(dst, src) {
            dst.length = 0;
            ArrayUtilities.pushMany(dst, src);
        }
        ArrayUtilities.copyFrom = copyFrom;

        /**
        * Makes sure that a typed array has the requested capacity. If required, it creates a new
        * instance of the array's class with a power-of-two capacity at least as large as required.
        *
        * Note: untyped because generics with constraints are pretty annoying.
        */
        function ensureTypedArrayCapacity(array, capacity) {
            if (array.length < capacity) {
                var oldArray = array;
                array = new array.constructor(Shumway.IntegerUtilities.nearestPowerOfTwo(capacity));
                array.set(oldArray, 0);
            }
            return array;
        }
        ArrayUtilities.ensureTypedArrayCapacity = ensureTypedArrayCapacity;

        var ArrayWriter = (function () {
            function ArrayWriter(initialCapacity) {
                if (typeof initialCapacity === "undefined") { initialCapacity = 16; }
                this._u8 = null;
                this._u16 = null;
                this._i32 = null;
                this._f32 = null;
                this._offset = 0;
                this.ensureCapacity(initialCapacity);
            }
            ArrayWriter.prototype.reset = function () {
                this._offset = 0;
            };

            Object.defineProperty(ArrayWriter.prototype, "offset", {
                get: function () {
                    return this._offset;
                },
                enumerable: true,
                configurable: true
            });

            ArrayWriter.prototype.getIndex = function (size) {
                release || assert(size === 1 || size === 2 || size === 4 || size === 8 || size === 16);
                var index = this._offset / size;
                release || assert((index | 0) === index);
                return index;
            };

            ArrayWriter.prototype.ensureAdditionalCapacity = function (size) {
                this.ensureCapacity(this._offset + size);
            };

            ArrayWriter.prototype.ensureCapacity = function (minCapacity) {
                if (!this._u8) {
                    this._u8 = new Uint8Array(minCapacity);
                } else if (this._u8.length > minCapacity) {
                    return;
                }
                var oldCapacity = this._u8.length;

                // var newCapacity = (((oldCapacity * 3) >> 1) + 8) & ~0x7;
                var newCapacity = oldCapacity * 2;
                if (newCapacity < minCapacity) {
                    newCapacity = minCapacity;
                }
                var u8 = new Uint8Array(newCapacity);
                u8.set(this._u8, 0);
                this._u8 = u8;
                this._u16 = new Uint16Array(u8.buffer);
                this._i32 = new Int32Array(u8.buffer);
                this._f32 = new Float32Array(u8.buffer);
            };

            ArrayWriter.prototype.writeInt = function (v) {
                release || assert((this._offset & 0x3) === 0);
                this.ensureCapacity(this._offset + 4);
                this.writeIntUnsafe(v);
            };

            ArrayWriter.prototype.writeIntAt = function (v, offset) {
                release || assert(offset >= 0 && offset <= this._offset);
                release || assert((offset & 0x3) === 0);
                this.ensureCapacity(offset + 4);
                var index = offset >> 2;
                this._i32[index] = v;
            };

            ArrayWriter.prototype.writeIntUnsafe = function (v) {
                var index = this._offset >> 2;
                this._i32[index] = v;
                this._offset += 4;
            };

            ArrayWriter.prototype.writeFloat = function (v) {
                release || assert((this._offset & 0x3) === 0);
                this.ensureCapacity(this._offset + 4);
                this.writeFloatUnsafe(v);
            };

            ArrayWriter.prototype.writeFloatUnsafe = function (v) {
                var index = this._offset >> 2;
                this._f32[index] = v;
                this._offset += 4;
            };

            ArrayWriter.prototype.write4Floats = function (a, b, c, d) {
                release || assert((this._offset & 0x3) === 0);
                this.ensureCapacity(this._offset + 16);
                this.write4FloatsUnsafe(a, b, c, d);
            };

            ArrayWriter.prototype.write4FloatsUnsafe = function (a, b, c, d) {
                var index = this._offset >> 2;
                this._f32[index + 0] = a;
                this._f32[index + 1] = b;
                this._f32[index + 2] = c;
                this._f32[index + 3] = d;
                this._offset += 16;
            };

            ArrayWriter.prototype.write6Floats = function (a, b, c, d, e, f) {
                release || assert((this._offset & 0x3) === 0);
                this.ensureCapacity(this._offset + 24);
                this.write6FloatsUnsafe(a, b, c, d, e, f);
            };

            ArrayWriter.prototype.write6FloatsUnsafe = function (a, b, c, d, e, f) {
                var index = this._offset >> 2;
                this._f32[index + 0] = a;
                this._f32[index + 1] = b;
                this._f32[index + 2] = c;
                this._f32[index + 3] = d;
                this._f32[index + 4] = e;
                this._f32[index + 5] = f;
                this._offset += 24;
            };

            ArrayWriter.prototype.subF32View = function () {
                return this._f32.subarray(0, this._offset >> 2);
            };

            ArrayWriter.prototype.subI32View = function () {
                return this._i32.subarray(0, this._offset >> 2);
            };

            ArrayWriter.prototype.subU16View = function () {
                return this._u16.subarray(0, this._offset >> 1);
            };

            ArrayWriter.prototype.subU8View = function () {
                return this._u8.subarray(0, this._offset);
            };

            ArrayWriter.prototype.hashWords = function (hash, offset, length) {
                var i32 = this._i32;
                for (var i = 0; i < length; i++) {
                    hash = (((31 * hash) | 0) + i32[i]) | 0;
                }
                return hash;
            };

            ArrayWriter.prototype.reserve = function (size) {
                size = (size + 3) & ~0x3; // Round up to multiple of 4.
                this.ensureCapacity(this._offset + size);
                this._offset += size;
            };
            return ArrayWriter;
        })();
        ArrayUtilities.ArrayWriter = ArrayWriter;
    })(Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {}));
    var ArrayUtilities = Shumway.ArrayUtilities;

    var ArrayReader = (function () {
        function ArrayReader(buffer) {
            this._u8 = new Uint8Array(buffer);
            this._u16 = new Uint16Array(buffer);
            this._i32 = new Int32Array(buffer);
            this._f32 = new Float32Array(buffer);
            this._offset = 0;
        }
        Object.defineProperty(ArrayReader.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            enumerable: true,
            configurable: true
        });

        ArrayReader.prototype.isEmpty = function () {
            return this._offset === this._u8.length;
        };

        ArrayReader.prototype.readInt = function () {
            release || Debug.assert((this._offset & 0x3) === 0);
            release || Debug.assert(this._offset <= this._u8.length - 4);
            var v = this._i32[this._offset >> 2];
            this._offset += 4;
            return v;
        };

        ArrayReader.prototype.readFloat = function () {
            release || Debug.assert((this._offset & 0x3) === 0);
            release || Debug.assert(this._offset <= this._u8.length - 4);
            var v = this._f32[this._offset >> 2];
            this._offset += 4;
            return v;
        };
        return ArrayReader;
    })();
    Shumway.ArrayReader = ArrayReader;

    (function (ObjectUtilities) {
        function boxValue(value) {
            if (isNullOrUndefined(value) || isObject(value)) {
                return value;
            }
            return Object(value);
        }
        ObjectUtilities.boxValue = boxValue;

        function toKeyValueArray(object) {
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var array = [];
            for (var k in object) {
                if (hasOwnProperty.call(object, k)) {
                    array.push([k, object[k]]);
                }
            }
            return array;
        }
        ObjectUtilities.toKeyValueArray = toKeyValueArray;

        function isPrototypeWriteable(object) {
            return Object.getOwnPropertyDescriptor(object, "prototype").writable;
        }
        ObjectUtilities.isPrototypeWriteable = isPrototypeWriteable;

        function hasOwnProperty(object, name) {
            return Object.prototype.hasOwnProperty.call(object, name);
        }
        ObjectUtilities.hasOwnProperty = hasOwnProperty;

        function propertyIsEnumerable(object, name) {
            return Object.prototype.propertyIsEnumerable.call(object, name);
        }
        ObjectUtilities.propertyIsEnumerable = propertyIsEnumerable;

        function getOwnPropertyDescriptor(object, name) {
            return Object.getOwnPropertyDescriptor(object, name);
        }
        ObjectUtilities.getOwnPropertyDescriptor = getOwnPropertyDescriptor;

        function hasOwnGetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return !!(d && d.get);
        }
        ObjectUtilities.hasOwnGetter = hasOwnGetter;

        function getOwnGetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return d ? d.get : null;
        }
        ObjectUtilities.getOwnGetter = getOwnGetter;

        function hasOwnSetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return !!(d && !!d.set);
        }
        ObjectUtilities.hasOwnSetter = hasOwnSetter;

        function createObject(prototype) {
            return Object.create(prototype);
        }
        ObjectUtilities.createObject = createObject;

        function createEmptyObject() {
            return Object.create(null);
        }
        ObjectUtilities.createEmptyObject = createEmptyObject;

        function createMap() {
            return Object.create(null);
        }
        ObjectUtilities.createMap = createMap;

        function createArrayMap() {
            return [];
        }
        ObjectUtilities.createArrayMap = createArrayMap;

        function defineReadOnlyProperty(object, name, value) {
            Object.defineProperty(object, name, {
                value: value,
                writable: false,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineReadOnlyProperty = defineReadOnlyProperty;

        function getOwnPropertyDescriptors(object) {
            var o = ObjectUtilities.createMap();
            var properties = Object.getOwnPropertyNames(object);
            for (var i = 0; i < properties.length; i++) {
                o[properties[i]] = Object.getOwnPropertyDescriptor(object, properties[i]);
            }
            return o;
        }
        ObjectUtilities.getOwnPropertyDescriptors = getOwnPropertyDescriptors;

        function cloneObject(object) {
            var clone = ObjectUtilities.createEmptyObject();
            for (var property in object) {
                clone[property] = object[property];
            }
            return clone;
        }
        ObjectUtilities.cloneObject = cloneObject;

        function copyProperties(object, template) {
            for (var property in template) {
                object[property] = template[property];
            }
        }
        ObjectUtilities.copyProperties = copyProperties;

        function copyOwnProperties(object, template) {
            for (var property in template) {
                if (hasOwnProperty(template, property)) {
                    object[property] = template[property];
                }
            }
        }
        ObjectUtilities.copyOwnProperties = copyOwnProperties;

        function copyOwnPropertyDescriptors(object, template) {
            for (var property in template) {
                if (hasOwnProperty(template, property)) {
                    var descriptor = Object.getOwnPropertyDescriptor(template, property);
                    release || Debug.assert(descriptor);
                    try  {
                        Object.defineProperty(object, property, descriptor);
                    } catch (e) {
                        // log("Can't define " + property);
                    }
                }
            }
        }
        ObjectUtilities.copyOwnPropertyDescriptors = copyOwnPropertyDescriptors;

        function getLatestGetterOrSetterPropertyDescriptor(object, name) {
            var descriptor = {};
            while (object) {
                var tmp = Object.getOwnPropertyDescriptor(object, name);
                if (tmp) {
                    descriptor.get = descriptor.get || tmp.get;
                    descriptor.set = descriptor.set || tmp.set;
                }
                if (descriptor.get && descriptor.set) {
                    break;
                }
                object = Object.getPrototypeOf(object);
            }
            return descriptor;
        }
        ObjectUtilities.getLatestGetterOrSetterPropertyDescriptor = getLatestGetterOrSetterPropertyDescriptor;

        function defineNonEnumerableGetterOrSetter(obj, name, value, isGetter) {
            var descriptor = ObjectUtilities.getLatestGetterOrSetterPropertyDescriptor(obj, name);
            descriptor.configurable = true;
            descriptor.enumerable = false;
            if (isGetter) {
                descriptor.get = value;
            } else {
                descriptor.set = value;
            }
            Object.defineProperty(obj, name, descriptor);
        }
        ObjectUtilities.defineNonEnumerableGetterOrSetter = defineNonEnumerableGetterOrSetter;

        function defineNonEnumerableGetter(obj, name, getter) {
            Object.defineProperty(obj, name, {
                get: getter,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableGetter = defineNonEnumerableGetter;

        function defineNonEnumerableSetter(obj, name, setter) {
            Object.defineProperty(obj, name, {
                set: setter,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableSetter = defineNonEnumerableSetter;

        function defineNonEnumerableProperty(obj, name, value) {
            Object.defineProperty(obj, name, {
                value: value,
                writable: true,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableProperty = defineNonEnumerableProperty;

        function defineNonEnumerableForwardingProperty(obj, name, otherName) {
            Object.defineProperty(obj, name, {
                get: FunctionUtilities.makeForwardingGetter(otherName),
                set: FunctionUtilities.makeForwardingSetter(otherName),
                writable: true,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableForwardingProperty = defineNonEnumerableForwardingProperty;

        function defineNewNonEnumerableProperty(obj, name, value) {
            release || Debug.assert(!Object.prototype.hasOwnProperty.call(obj, name), "Property: " + name + " already exits.");
            ObjectUtilities.defineNonEnumerableProperty(obj, name, value);
        }
        ObjectUtilities.defineNewNonEnumerableProperty = defineNewNonEnumerableProperty;
    })(Shumway.ObjectUtilities || (Shumway.ObjectUtilities = {}));
    var ObjectUtilities = Shumway.ObjectUtilities;

    (function (FunctionUtilities) {
        function makeForwardingGetter(target) {
            return new Function("return this[\"" + target + "\"]");
        }
        FunctionUtilities.makeForwardingGetter = makeForwardingGetter;

        function makeForwardingSetter(target) {
            return new Function("value", "this[\"" + target + "\"] = value;");
        }
        FunctionUtilities.makeForwardingSetter = makeForwardingSetter;

        /**
        * Attaches a property to the bound function so we can detect when if it
        * ever gets rebound.
        */
        function bindSafely(fn, object) {
            release || Debug.assert(!fn.boundTo && object);
            var f = fn.bind(object);
            f.boundTo = object;
            return f;
        }
        FunctionUtilities.bindSafely = bindSafely;
    })(Shumway.FunctionUtilities || (Shumway.FunctionUtilities = {}));
    var FunctionUtilities = Shumway.FunctionUtilities;

    (function (StringUtilities) {
        var assert = Shumway.Debug.assert;

        function memorySizeToString(value) {
            value |= 0;
            var K = 1024;
            var M = K * K;
            if (value < K) {
                return value + " B";
            } else if (value < M) {
                return (value / K).toFixed(2) + "KB";
            } else {
                return (value / M).toFixed(2) + "MB";
            }
        }
        StringUtilities.memorySizeToString = memorySizeToString;

        function toSafeString(value) {
            if (typeof value === "string") {
                return "\"" + value + "\"";
            }
            if (typeof value === "number" || typeof value === "boolean") {
                return String(value);
            }
            return typeof value;
        }
        StringUtilities.toSafeString = toSafeString;

        function toSafeArrayString(array) {
            var str = [];
            for (var i = 0; i < array.length; i++) {
                str.push(toSafeString(array[i]));
            }
            return str.join(", ");
        }
        StringUtilities.toSafeArrayString = toSafeArrayString;

        function utf8decode(str) {
            var bytes = new Uint8Array(str.length * 4);
            var b = 0;
            for (var i = 0, j = str.length; i < j; i++) {
                var code = str.charCodeAt(i);
                if (code <= 0x7f) {
                    bytes[b++] = code;
                    continue;
                }

                if (0xD800 <= code && code <= 0xDBFF) {
                    var codeLow = str.charCodeAt(i + 1);
                    if (0xDC00 <= codeLow && codeLow <= 0xDFFF) {
                        // convert only when both high and low surrogates are present
                        code = ((code & 0x3FF) << 10) + (codeLow & 0x3FF) + 0x10000;
                        ++i;
                    }
                }

                if ((code & 0xFFE00000) !== 0) {
                    bytes[b++] = 0xF8 | ((code >>> 24) & 0x03);
                    bytes[b++] = 0x80 | ((code >>> 18) & 0x3F);
                    bytes[b++] = 0x80 | ((code >>> 12) & 0x3F);
                    bytes[b++] = 0x80 | ((code >>> 6) & 0x3F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                } else if ((code & 0xFFFF0000) !== 0) {
                    bytes[b++] = 0xF0 | ((code >>> 18) & 0x07);
                    bytes[b++] = 0x80 | ((code >>> 12) & 0x3F);
                    bytes[b++] = 0x80 | ((code >>> 6) & 0x3F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                } else if ((code & 0xFFFFF800) !== 0) {
                    bytes[b++] = 0xE0 | ((code >>> 12) & 0x0F);
                    bytes[b++] = 0x80 | ((code >>> 6) & 0x3F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                } else {
                    bytes[b++] = 0xC0 | ((code >>> 6) & 0x1F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                }
            }
            return bytes.subarray(0, b);
        }
        StringUtilities.utf8decode = utf8decode;

        function utf8encode(bytes) {
            var j = 0, str = "";
            while (j < bytes.length) {
                var b1 = bytes[j++] & 0xFF;
                if (b1 <= 0x7F) {
                    str += String.fromCharCode(b1);
                } else {
                    var currentPrefix = 0xC0;
                    var validBits = 5;
                    do {
                        var mask = (currentPrefix >> 1) | 0x80;
                        if ((b1 & mask) === currentPrefix)
                            break;
                        currentPrefix = (currentPrefix >> 1) | 0x80;
                        --validBits;
                    } while(validBits >= 0);

                    if (validBits <= 0) {
                        // Invalid UTF8 character -- copying as is
                        str += String.fromCharCode(b1);
                        continue;
                    }
                    var code = (b1 & ((1 << validBits) - 1));
                    var invalid = false;
                    for (var i = 5; i >= validBits; --i) {
                        var bi = bytes[j++];
                        if ((bi & 0xC0) != 0x80) {
                            // Invalid UTF8 character sequence
                            invalid = true;
                            break;
                        }
                        code = (code << 6) | (bi & 0x3F);
                    }
                    if (invalid) {
                        for (var k = j - (7 - i); k < j; ++k) {
                            str += String.fromCharCode(bytes[k] & 255);
                        }
                        continue;
                    }
                    if (code >= 0x10000) {
                        str += String.fromCharCode((((code - 0x10000) >> 10) & 0x3FF) | 0xD800, (code & 0x3FF) | 0xDC00);
                    } else {
                        str += String.fromCharCode(code);
                    }
                }
            }
            return str;
        }
        StringUtilities.utf8encode = utf8encode;

        // https://gist.github.com/958841
        function base64ArrayBuffer(arrayBuffer) {
            var base64 = '';
            var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

            var bytes = new Uint8Array(arrayBuffer);
            var byteLength = bytes.byteLength;
            var byteRemainder = byteLength % 3;
            var mainLength = byteLength - byteRemainder;

            var a, b, c, d;
            var chunk;

            for (var i = 0; i < mainLength; i = i + 3) {
                // Combine the three bytes into a single integer
                chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

                // Use bitmasks to extract 6-bit segments from the triplet
                a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
                b = (chunk & 258048) >> 12; // 258048 = (2^6 - 1) << 12
                c = (chunk & 4032) >> 6; // 4032 = (2^6 - 1) << 6
                d = chunk & 63; // 63 = 2^6 - 1

                // Convert the raw binary segments to the appropriate ASCII encoding
                base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
            }

            // Deal with the remaining bytes and padding
            if (byteRemainder == 1) {
                chunk = bytes[mainLength];

                a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

                // Set the 4 least significant bits to zero
                b = (chunk & 3) << 4; // 3 = 2^2 - 1

                base64 += encodings[a] + encodings[b] + '==';
            } else if (byteRemainder == 2) {
                chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

                a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
                b = (chunk & 1008) >> 4; // 1008 = (2^6 - 1) << 4

                // Set the 2 least significant bits to zero
                c = (chunk & 15) << 2; // 15 = 2^4 - 1

                base64 += encodings[a] + encodings[b] + encodings[c] + '=';
            }
            return base64;
        }
        StringUtilities.base64ArrayBuffer = base64ArrayBuffer;

        function escapeString(str) {
            if (str !== undefined) {
                str = str.replace(/[^\w$]/gi, "$"); /* No dots, colons, dashes and /s */
                if (/^\d/.test(str)) {
                    str = '$' + str;
                }
            }
            return str;
        }
        StringUtilities.escapeString = escapeString;

        /**
        * Workaround for max stack size limit.
        */
        function fromCharCodeArray(buffer) {
            var str = "", SLICE = 1024 * 16;
            for (var i = 0; i < buffer.length; i += SLICE) {
                var chunk = Math.min(buffer.length - i, SLICE);
                str += String.fromCharCode.apply(null, buffer.subarray(i, i + chunk));
            }
            return str;
        }
        StringUtilities.fromCharCodeArray = fromCharCodeArray;

        var _encoding = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_';
        function variableLengthEncodeInt32(n) {
            var e = _encoding;
            var bitCount = (32 - Math.clz32(n));
            release || assert(bitCount <= 32, bitCount);
            var l = Math.ceil(bitCount / 6);

            // Encode length followed by six bit chunks.
            var s = e[l];
            for (var i = l - 1; i >= 0; i--) {
                var offset = (i * 6);
                s += e[(n >> offset) & 0x3F];
            }
            release || assert(StringUtilities.variableLengthDecodeInt32(s) === n, n + " : " + s + " - " + l + " bits: " + bitCount);
            return s;
        }
        StringUtilities.variableLengthEncodeInt32 = variableLengthEncodeInt32;

        function toEncoding(n) {
            return _encoding[n];
        }
        StringUtilities.toEncoding = toEncoding;

        function fromEncoding(s) {
            var c = s.charCodeAt(0);
            var e = 0;
            if (c >= 65 && c <= 90) {
                return c - 65;
            } else if (c >= 97 && c <= 122) {
                return c - 71;
            } else if (c >= 48 && c <= 57) {
                return c + 4;
            } else if (c === 36) {
                return 62;
            } else if (c === 95) {
                return 63;
            }
            release || assert(false, "Invalid Encoding");
        }
        StringUtilities.fromEncoding = fromEncoding;

        function variableLengthDecodeInt32(s) {
            var l = StringUtilities.fromEncoding(s[0]);
            var n = 0;
            for (var i = 0; i < l; i++) {
                var offset = ((l - i - 1) * 6);
                n |= StringUtilities.fromEncoding(s[1 + i]) << offset;
            }
            return n;
        }
        StringUtilities.variableLengthDecodeInt32 = variableLengthDecodeInt32;

        function trimMiddle(s, maxLength) {
            if (s.length <= maxLength) {
                return s;
            }
            var leftHalf = maxLength >> 1;
            var rightHalf = maxLength - leftHalf - 1;
            return s.substr(0, leftHalf) + "\u2026" + s.substr(s.length - rightHalf, rightHalf);
        }
        StringUtilities.trimMiddle = trimMiddle;

        function multiple(s, count) {
            var o = "";
            for (var i = 0; i < count; i++) {
                o += s;
            }
            return o;
        }
        StringUtilities.multiple = multiple;

        function indexOfAny(s, chars, position) {
            var index = s.length;
            for (var i = 0; i < chars.length; i++) {
                var j = s.indexOf(chars[i], position);
                if (j >= 0) {
                    index = Math.min(index, j);
                }
            }
            return index === s.length ? -1 : index;
        }
        StringUtilities.indexOfAny = indexOfAny;
    })(Shumway.StringUtilities || (Shumway.StringUtilities = {}));
    var StringUtilities = Shumway.StringUtilities;

    (function (HashUtilities) {
        var _md5R = new Uint8Array([
            7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
            5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
            4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
            6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);

        var _md5K = new Int32Array([
            -680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426,
            -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162,
            1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632,
            643717713, -373897302, -701558691, 38016083, -660478335, -405537848,
            568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784,
            1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556,
            -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222,
            -722521979, 76029189, -640364487, -421815835, 530742520, -995338651,
            -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606,
            -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649,
            -145523070, -1120210379, 718787259, -343485551]);

        function hashBytesTo32BitsMD5(data, offset, length) {
            var r = _md5R;
            var k = _md5K;
            var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;

            // pre-processing
            var paddedLength = (length + 72) & ~63;
            var padded = new Uint8Array(paddedLength);
            var i, j, n;
            for (i = 0; i < length; ++i) {
                padded[i] = data[offset++];
            }
            padded[i++] = 0x80;
            n = paddedLength - 8;
            while (i < n) {
                padded[i++] = 0;
            }
            padded[i++] = (length << 3) & 0xFF;
            padded[i++] = (length >> 5) & 0xFF;
            padded[i++] = (length >> 13) & 0xFF;
            padded[i++] = (length >> 21) & 0xFF;
            padded[i++] = (length >>> 29) & 0xFF;
            padded[i++] = 0;
            padded[i++] = 0;
            padded[i++] = 0;

            // chunking
            // TODO ArrayBuffer ?
            var w = new Int32Array(16);
            for (i = 0; i < paddedLength;) {
                for (j = 0; j < 16; ++j, i += 4) {
                    w[j] = (padded[i] | (padded[i + 1] << 8) | (padded[i + 2] << 16) | (padded[i + 3] << 24));
                }
                var a = h0, b = h1, c = h2, d = h3, f, g;
                for (j = 0; j < 64; ++j) {
                    if (j < 16) {
                        f = (b & c) | ((~b) & d);
                        g = j;
                    } else if (j < 32) {
                        f = (d & b) | ((~d) & c);
                        g = (5 * j + 1) & 15;
                    } else if (j < 48) {
                        f = b ^ c ^ d;
                        g = (3 * j + 5) & 15;
                    } else {
                        f = c ^ (b | (~d));
                        g = (7 * j) & 15;
                    }
                    var tmp = d, rotateArg = (a + f + k[j] + w[g]) | 0, rotate = r[j];
                    d = c;
                    c = b;
                    b = (b + ((rotateArg << rotate) | (rotateArg >>> (32 - rotate)))) | 0;
                    a = tmp;
                }
                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
            }
            return h0;
        }
        HashUtilities.hashBytesTo32BitsMD5 = hashBytesTo32BitsMD5;

        function hashBytesTo32BitsAdler(data, offset, length) {
            var a = 1;
            var b = 0;
            var end = offset + length;
            for (var i = offset; i < end; ++i) {
                a = (a + (data[i] & 0xff)) % 65521;
                b = (b + a) % 65521;
            }
            return (b << 16) | a;
        }
        HashUtilities.hashBytesTo32BitsAdler = hashBytesTo32BitsAdler;
    })(Shumway.HashUtilities || (Shumway.HashUtilities = {}));
    var HashUtilities = Shumway.HashUtilities;

    /**
    * Marsaglia's algorithm, adapted from V8. Use this if you want a deterministic random number.
    */
    var Random = (function () {
        function Random() {
        }
        Random.seed = function (seed) {
            Random._state[0] = seed;
            Random._state[1] = seed;
        };

        Random.next = function () {
            var s = this._state;
            var r0 = (Math.imul(18273, s[0] & 0xFFFF) + (s[0] >>> 16)) | 0;
            s[0] = r0;
            var r1 = (Math.imul(36969, s[1] & 0xFFFF) + (s[1] >>> 16)) | 0;
            s[1] = r1;
            var x = ((r0 << 16) + (r1 & 0xFFFF)) | 0;

            // Division by 0x100000000 through multiplication by reciprocal.
            return (x < 0 ? (x + 0x100000000) : x) * 2.3283064365386962890625e-10;
        };
        Random._state = new Uint32Array([0xDEAD, 0xBEEF]);
        return Random;
    })();
    Shumway.Random = Random;

    Math.random = function random() {
        return Random.next();
    };

    function polyfillWeakMap() {
        if (typeof jsGlobal.WeakMap === 'function') {
            return;
        }
        var id = 0;
        function WeakMap() {
            this.id = '$weakmap' + (id++);
        }
        ;
        WeakMap.prototype = {
            has: function (obj) {
                return obj.hasOwnProperty(this.id);
            },
            get: function (obj, defaultValue) {
                return obj.hasOwnProperty(this.id) ? obj[this.id] : defaultValue;
            },
            set: function (obj, value) {
                Object.defineProperty(obj, this.id, {
                    value: value,
                    enumerable: false,
                    configurable: true
                });
            }
        };
        jsGlobal.WeakMap = WeakMap;
    }

    polyfillWeakMap();

    var useReferenceCounting = false;

    var WeakList = (function () {
        function WeakList() {
            if (typeof netscape !== "undefined" && netscape.security.PrivilegeManager) {
                this._map = new WeakMap();
            } else {
                this._list = [];
            }
        }
        WeakList.prototype.clear = function () {
            if (this._map) {
                this._map.clear();
            } else {
                this._list.length = 0;
            }
        };
        WeakList.prototype.push = function (value) {
            if (this._map) {
                this._map.set(value, null);
            } else {
                this._list.push(value);
            }
        };
        WeakList.prototype.forEach = function (callback) {
            if (this._map) {
                if (typeof netscape !== "undefined") {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
                }
                Components.utils.nondeterministicGetWeakMapKeys(this._map).forEach(function (value) {
                    if (value._referenceCount !== 0) {
                        callback(value);
                    }
                });
                return;
            }
            var list = this._list;
            var zeroCount = 0;
            for (var i = 0; i < list.length; i++) {
                var value = list[i];
                if (useReferenceCounting && value._referenceCount === 0) {
                    zeroCount++;
                } else {
                    callback(value);
                }
            }
            if (zeroCount > 16 && zeroCount > (list.length >> 2)) {
                var newList = [];
                for (var i = 0; i < list.length; i++) {
                    if (list[i]._referenceCount > 0) {
                        newList.push(list[i]);
                    }
                }
                this._list = newList;
            }
        };
        Object.defineProperty(WeakList.prototype, "length", {
            get: function () {
                if (this._map) {
                    // TODO: Implement this.
                    return -1;
                } else {
                    return this._list.length;
                }
            },
            enumerable: true,
            configurable: true
        });
        return WeakList;
    })();
    Shumway.WeakList = WeakList;

    (function (NumberUtilities) {
        function pow2(exponent) {
            if (exponent === (exponent | 0)) {
                if (exponent < 0) {
                    return 1 / (1 << -exponent);
                }
                return 1 << exponent;
            }
            return Math.pow(2, exponent);
        }
        NumberUtilities.pow2 = pow2;

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        NumberUtilities.clamp = clamp;

        /**
        * Rounds *.5 to the nearest even number.
        * See https://en.wikipedia.org/wiki/Rounding#Round_half_to_even for details.
        */
        function roundHalfEven(value) {
            if (Math.abs(value % 1) === 0.5) {
                var floor = Math.floor(value);
                return floor % 2 === 0 ? floor : Math.ceil(value);
            }
            return Math.round(value);
        }
        NumberUtilities.roundHalfEven = roundHalfEven;

        function epsilonEquals(value, other) {
            return Math.abs(value - other) < 0.0000001;
        }
        NumberUtilities.epsilonEquals = epsilonEquals;
    })(Shumway.NumberUtilities || (Shumway.NumberUtilities = {}));
    var NumberUtilities = Shumway.NumberUtilities;

    (function (Numbers) {
        Numbers[Numbers["MaxU16"] = 0xFFFF] = "MaxU16";
        Numbers[Numbers["MaxI16"] = 0x7FFF] = "MaxI16";
        Numbers[Numbers["MinI16"] = -0x8000] = "MinI16";
    })(Shumway.Numbers || (Shumway.Numbers = {}));
    var Numbers = Shumway.Numbers;

    (function (IntegerUtilities) {
        var sharedBuffer = new ArrayBuffer(8);
        var i8 = new Int8Array(sharedBuffer);
        var i32 = new Int32Array(sharedBuffer);
        var f32 = new Float32Array(sharedBuffer);
        var f64 = new Float64Array(sharedBuffer);
        var nativeLittleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;

        /**
        * Convert a float into 32 bits.
        */
        function floatToInt32(v) {
            f32[0] = v;
            return i32[0];
        }
        IntegerUtilities.floatToInt32 = floatToInt32;

        /**
        * Convert 32 bits into a float.
        */
        function int32ToFloat(i) {
            i32[0] = i;
            return f32[0];
        }
        IntegerUtilities.int32ToFloat = int32ToFloat;

        /**
        * Swap the bytes of a 16 bit number.
        */
        function swap16(i) {
            return ((i & 0xFF) << 8) | ((i >> 8) & 0xFF);
        }
        IntegerUtilities.swap16 = swap16;

        /**
        * Swap the bytes of a 32 bit number.
        */
        function swap32(i) {
            return ((i & 0xFF) << 24) | ((i & 0xFF00) << 8) | ((i >> 8) & 0xFF00) | ((i >> 24) & 0xFF);
        }
        IntegerUtilities.swap32 = swap32;

        /**
        * Converts a number to s8.u8 fixed point representation.
        */
        function toS8U8(v) {
            return ((v * 256) << 16) >> 16;
        }
        IntegerUtilities.toS8U8 = toS8U8;

        /**
        * Converts a number from s8.u8 fixed point representation.
        */
        function fromS8U8(i) {
            return i / 256;
        }
        IntegerUtilities.fromS8U8 = fromS8U8;

        /**
        * Round trips a number through s8.u8 conversion.
        */
        function clampS8U8(v) {
            return fromS8U8(toS8U8(v));
        }
        IntegerUtilities.clampS8U8 = clampS8U8;

        /**
        * Converts a number to signed 16 bits.
        */
        function toS16(v) {
            return (v << 16) >> 16;
        }
        IntegerUtilities.toS16 = toS16;

        function bitCount(i) {
            i = i - ((i >> 1) & 0x55555555);
            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
            return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
        }
        IntegerUtilities.bitCount = bitCount;

        function ones(i) {
            i = i - ((i >> 1) & 0x55555555);
            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
            return ((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
        }
        IntegerUtilities.ones = ones;

        function trailingZeros(i) {
            return IntegerUtilities.ones((i & -i) - 1);
        }
        IntegerUtilities.trailingZeros = trailingZeros;

        function getFlags(i, flags) {
            var str = "";
            for (var i = 0; i < flags.length; i++) {
                if (i & (1 << i)) {
                    str += flags[i] + " ";
                }
            }
            if (str.length === 0) {
                return "";
            }
            return str.trim();
        }
        IntegerUtilities.getFlags = getFlags;

        function isPowerOfTwo(x) {
            return x && ((x & (x - 1)) === 0);
        }
        IntegerUtilities.isPowerOfTwo = isPowerOfTwo;

        function roundToMultipleOfFour(x) {
            return (x + 3) & ~0x3;
        }
        IntegerUtilities.roundToMultipleOfFour = roundToMultipleOfFour;

        function nearestPowerOfTwo(x) {
            x--;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            x++;
            return x;
        }
        IntegerUtilities.nearestPowerOfTwo = nearestPowerOfTwo;

        function roundToMultipleOfPowerOfTwo(i, powerOfTwo) {
            var x = (1 << powerOfTwo) - 1;
            return (i + x) & ~x;
        }
        IntegerUtilities.roundToMultipleOfPowerOfTwo = roundToMultipleOfPowerOfTwo;

        /**
        * Polyfill imul.
        */
        if (!Math.imul) {
            Math.imul = function imul(a, b) {
                var ah = (a >>> 16) & 0xffff;
                var al = a & 0xffff;
                var bh = (b >>> 16) & 0xffff;
                var bl = b & 0xffff;

                // the shift by 0 fixes the sign on the high part
                // the final |0 converts the unsigned value into a signed value
                return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
            };
        }

        /**
        * Polyfill clz32.
        */
        if (!Math.clz32) {
            Math.clz32 = function clz32(i) {
                i |= (i >> 1);
                i |= (i >> 2);
                i |= (i >> 4);
                i |= (i >> 8);
                i |= (i >> 16);
                return 32 - IntegerUtilities.ones(i);
            };
        }
    })(Shumway.IntegerUtilities || (Shumway.IntegerUtilities = {}));
    var IntegerUtilities = Shumway.IntegerUtilities;

    (function (GeometricUtilities) {
        /**
        * Crossing numeber tests to check if a point is inside a polygon. The polygon is given as
        * an array of n + 1 float pairs where the last is equal to the first.
        *
        * http://geomalgorithms.com/a03-_inclusion.html
        */
        function pointInPolygon(x, y, polygon) {
            // release || assert (((polygon.length & 1) === 0) && polygon.length >= 8);
            // release || assert (polygon[0] === polygon[polygon.length - 2] &&
            //        polygon[1] === polygon[polygon.length - 1], "First and last points should be equal.");
            var crosses = 0;
            var n = polygon.length - 2;
            var p = polygon;

            for (var i = 0; i < n; i += 2) {
                var x0 = p[i + 0];
                var y0 = p[i + 1];
                var x1 = p[i + 2];
                var y1 = p[i + 3];
                if (((y0 <= y) && (y1 > y)) || ((y0 > y) && (y1 <= y))) {
                    var t = (y - y0) / (y1 - y0);
                    if (x < x0 + t * (x1 - x0)) {
                        crosses++;
                    }
                }
            }
            return (crosses & 1) === 1;
        }
        GeometricUtilities.pointInPolygon = pointInPolygon;

        /**
        * Signed area of a triangle. If zero then points are collinear, if < 0 then points
        * are clockwise otherwise counter-clockwise.
        */
        function signedArea(x0, y0, x1, y1, x2, y2) {
            return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0);
        }
        GeometricUtilities.signedArea = signedArea;

        function counterClockwise(x0, y0, x1, y1, x2, y2) {
            return signedArea(x0, y0, x1, y1, x2, y2) > 0;
        }
        GeometricUtilities.counterClockwise = counterClockwise;

        function clockwise(x0, y0, x1, y1, x2, y2) {
            return signedArea(x0, y0, x1, y1, x2, y2) < 0;
        }
        GeometricUtilities.clockwise = clockwise;

        function pointInPolygonInt32(x, y, polygon) {
            // release || assert (((polygon.length & 1) === 0) && polygon.length >= 8);
            // release || assert (polygon[0] === polygon[polygon.length - 2] &&
            //        polygon[1] === polygon[polygon.length - 1], "First and last points should be equal.");
            x = x | 0;
            y = y | 0;
            var crosses = 0;
            var n = polygon.length - 2;
            var p = polygon;

            for (var i = 0; i < n; i += 2) {
                var x0 = p[i + 0];
                var y0 = p[i + 1];
                var x1 = p[i + 2];
                var y1 = p[i + 3];
                if (((y0 <= y) && (y1 > y)) || ((y0 > y) && (y1 <= y))) {
                    var t = (y - y0) / (y1 - y0);
                    if (x < x0 + t * (x1 - x0)) {
                        crosses++;
                    }
                }
            }
            return (crosses & 1) === 1;
        }
        GeometricUtilities.pointInPolygonInt32 = pointInPolygonInt32;
    })(Shumway.GeometricUtilities || (Shumway.GeometricUtilities = {}));
    var GeometricUtilities = Shumway.GeometricUtilities;

    (function (LogLevel) {
        LogLevel[LogLevel["Error"] = 0x1] = "Error";
        LogLevel[LogLevel["Warn"] = 0x2] = "Warn";
        LogLevel[LogLevel["Debug"] = 0x4] = "Debug";
        LogLevel[LogLevel["Log"] = 0x8] = "Log";
        LogLevel[LogLevel["Info"] = 0x10] = "Info";
        LogLevel[LogLevel["All"] = 0x1f] = "All";
    })(Shumway.LogLevel || (Shumway.LogLevel = {}));
    var LogLevel = Shumway.LogLevel;

    var IndentingWriter = (function () {
        function IndentingWriter(suppressOutput, out) {
            if (typeof suppressOutput === "undefined") { suppressOutput = false; }
            this._tab = "  ";
            this._padding = "";
            this._suppressOutput = suppressOutput;
            this._out = out || IndentingWriter._consoleOut;
            this._outNoNewline = out || IndentingWriter._consoleOutNoNewline;
        }
        IndentingWriter.prototype.write = function (str, writePadding) {
            if (typeof str === "undefined") { str = ""; }
            if (typeof writePadding === "undefined") { writePadding = false; }
            if (!this._suppressOutput) {
                this._outNoNewline((writePadding ? this._padding : "") + str);
            }
        };

        IndentingWriter.prototype.writeLn = function (str) {
            if (typeof str === "undefined") { str = ""; }
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
        };

        IndentingWriter.prototype.writeComment = function (str) {
            var lines = str.split("\n");
            if (lines.length === 1) {
                this.writeLn("// " + lines[0]);
            } else {
                this.writeLn("/**");
                for (var i = 0; i < lines.length; i++) {
                    this.writeLn(" * " + lines[i]);
                }
                this.writeLn(" */");
            }
        };

        IndentingWriter.prototype.writeLns = function (str) {
            var lines = str.split("\n");
            for (var i = 0; i < lines.length; i++) {
                this.writeLn(lines[i]);
            }
        };

        IndentingWriter.prototype.errorLn = function (str) {
            if (IndentingWriter.logLevel & 1 /* Error */) {
                this.boldRedLn(str);
            }
        };

        IndentingWriter.prototype.warnLn = function (str) {
            if (IndentingWriter.logLevel & 2 /* Warn */) {
                this.yellowLn(str);
            }
        };

        IndentingWriter.prototype.debugLn = function (str) {
            if (IndentingWriter.logLevel & 4 /* Debug */) {
                this.purpleLn(str);
            }
        };

        IndentingWriter.prototype.logLn = function (str) {
            if (IndentingWriter.logLevel & 8 /* Log */) {
                this.writeLn(str);
            }
        };

        IndentingWriter.prototype.infoLn = function (str) {
            if (IndentingWriter.logLevel & 16 /* Info */) {
                this.writeLn(str);
            }
        };

        IndentingWriter.prototype.yellowLn = function (str) {
            this.colorLn(IndentingWriter.YELLOW, str);
        };

        IndentingWriter.prototype.greenLn = function (str) {
            this.colorLn(IndentingWriter.GREEN, str);
        };

        IndentingWriter.prototype.boldRedLn = function (str) {
            this.colorLn(IndentingWriter.BOLD_RED, str);
        };

        IndentingWriter.prototype.redLn = function (str) {
            this.colorLn(IndentingWriter.RED, str);
        };

        IndentingWriter.prototype.purpleLn = function (str) {
            this.colorLn(IndentingWriter.PURPLE, str);
        };

        IndentingWriter.prototype.colorLn = function (color, str) {
            if (!this._suppressOutput) {
                if (!inBrowser) {
                    this._out(this._padding + color + str + IndentingWriter.ENDC);
                } else {
                    this._out(this._padding + str);
                }
            }
        };

        IndentingWriter.prototype.redLns = function (str) {
            this.colorLns(IndentingWriter.RED, str);
        };

        IndentingWriter.prototype.colorLns = function (color, str) {
            var lines = str.split("\n");
            for (var i = 0; i < lines.length; i++) {
                this.colorLn(color, lines[i]);
            }
        };

        IndentingWriter.prototype.enter = function (str) {
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
            this.indent();
        };

        IndentingWriter.prototype.leaveAndEnter = function (str) {
            this.leave(str);
            this.indent();
        };

        IndentingWriter.prototype.leave = function (str) {
            this.outdent();
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
        };

        IndentingWriter.prototype.indent = function () {
            this._padding += this._tab;
        };

        IndentingWriter.prototype.outdent = function () {
            if (this._padding.length > 0) {
                this._padding = this._padding.substring(0, this._padding.length - this._tab.length);
            }
        };

        IndentingWriter.prototype.writeArray = function (arr, detailed, noNumbers) {
            if (typeof detailed === "undefined") { detailed = false; }
            if (typeof noNumbers === "undefined") { noNumbers = false; }
            detailed = detailed || false;
            for (var i = 0, j = arr.length; i < j; i++) {
                var prefix = "";
                if (detailed) {
                    if (arr[i] === null) {
                        prefix = "null";
                    } else if (arr[i] === undefined) {
                        prefix = "undefined";
                    } else {
                        prefix = arr[i].constructor.name;
                    }
                    prefix += " ";
                }
                var number = noNumbers ? "" : ("" + i).padRight(' ', 4);
                this.writeLn(number + prefix + arr[i]);
            }
        };
        IndentingWriter.PURPLE = '\033[94m';
        IndentingWriter.YELLOW = '\033[93m';
        IndentingWriter.GREEN = '\033[92m';
        IndentingWriter.RED = '\033[91m';
        IndentingWriter.BOLD_RED = '\033[1;91m';
        IndentingWriter.ENDC = '\033[0m';

        IndentingWriter.logLevel = 31 /* All */;

        IndentingWriter._consoleOut = inBrowser ? console.info.bind(console) : print;
        IndentingWriter._consoleOutNoNewline = inBrowser ? console.info.bind(console) : putstr;
        return IndentingWriter;
    })();
    Shumway.IndentingWriter = IndentingWriter;

    /**
    * Insertion sort SortedList backed by a linked list.
    */
    var SortedListNode = (function () {
        function SortedListNode(value, next) {
            this.value = value;
            this.next = next;
        }
        return SortedListNode;
    })();

    var SortedList = (function () {
        function SortedList(compare) {
            release || Debug.assert(compare);
            this._compare = compare;
            this._head = null;
            this._length = 0;
        }
        SortedList.prototype.push = function (value) {
            release || Debug.assert(value !== undefined);
            this._length++;
            if (!this._head) {
                this._head = new SortedListNode(value, null);
                return;
            }

            var curr = this._head;
            var prev = null;
            var node = new SortedListNode(value, null);
            var compare = this._compare;
            while (curr) {
                if (compare(curr.value, node.value) > 0) {
                    if (prev) {
                        node.next = curr;
                        prev.next = node;
                    } else {
                        node.next = this._head;
                        this._head = node;
                    }
                    return;
                }
                prev = curr;
                curr = curr.next;
            }
            prev.next = node;
        };

        /**
        * Visitors can return RETURN if they wish to stop the iteration or DELETE if they need to delete the current node.
        * NOTE: DELETE most likley doesn't work if there are multiple active iterations going on.
        */
        SortedList.prototype.forEach = function (visitor) {
            var curr = this._head;
            var last = null;
            while (curr) {
                var result = visitor(curr.value);
                if (result === SortedList.RETURN) {
                    return;
                } else if (result === SortedList.DELETE) {
                    if (!last) {
                        curr = this._head = this._head.next;
                    } else {
                        curr = last.next = curr.next;
                    }
                } else {
                    last = curr;
                    curr = curr.next;
                }
            }
        };

        SortedList.prototype.isEmpty = function () {
            return !this._head;
        };

        SortedList.prototype.pop = function () {
            if (!this._head) {
                return undefined;
            }
            this._length--;
            var ret = this._head;
            this._head = this._head.next;
            return ret.value;
        };

        SortedList.prototype.contains = function (value) {
            var curr = this._head;
            while (curr) {
                if (curr.value === value) {
                    return true;
                }
                curr = curr.next;
            }
            return false;
        };

        SortedList.prototype.toString = function () {
            var str = "[";
            var curr = this._head;
            while (curr) {
                str += curr.value.toString();
                curr = curr.next;
                if (curr) {
                    str += ",";
                }
            }
            str += "]";
            return str;
        };
        SortedList.RETURN = 1;
        SortedList.DELETE = 2;
        return SortedList;
    })();
    Shumway.SortedList = SortedList;

    var CircularBuffer = (function () {
        function CircularBuffer(Type, sizeInBits) {
            if (typeof sizeInBits === "undefined") { sizeInBits = 12; }
            this.index = 0;
            this.start = 0;
            this._size = 1 << sizeInBits;
            this._mask = this._size - 1;
            this.array = new Type(this._size);
        }
        CircularBuffer.prototype.get = function (i) {
            return this.array[i];
        };

        CircularBuffer.prototype.forEachInReverse = function (visitor) {
            if (this.isEmpty()) {
                return;
            }
            var i = this.index === 0 ? this._size - 1 : this.index - 1;
            var end = (this.start - 1) & this._mask;
            while (i !== end) {
                if (visitor(this.array[i], i)) {
                    break;
                }
                i = i === 0 ? this._size - 1 : i - 1;
            }
        };

        CircularBuffer.prototype.write = function (value) {
            this.array[this.index] = value;
            this.index = (this.index + 1) & this._mask;
            if (this.index === this.start) {
                this.start = (this.start + 1) & this._mask;
            }
        };

        CircularBuffer.prototype.isFull = function () {
            return ((this.index + 1) & this._mask) === this.start;
        };

        CircularBuffer.prototype.isEmpty = function () {
            return this.index === this.start;
        };

        CircularBuffer.prototype.reset = function () {
            this.index = 0;
            this.start = 0;
        };
        return CircularBuffer;
    })();
    Shumway.CircularBuffer = CircularBuffer;

    (function (BitSets) {
        var assert = Shumway.Debug.assert;

        BitSets.ADDRESS_BITS_PER_WORD = 5;
        BitSets.BITS_PER_WORD = 1 << BitSets.ADDRESS_BITS_PER_WORD;
        BitSets.BIT_INDEX_MASK = BitSets.BITS_PER_WORD - 1;

        function getSize(length) {
            return ((length + (BitSets.BITS_PER_WORD - 1)) >> BitSets.ADDRESS_BITS_PER_WORD) << BitSets.ADDRESS_BITS_PER_WORD;
        }

        function toBitString(on, off) {
            var self = this;
            on = on || "1";
            off = off || "0";
            var str = "";
            for (var i = 0; i < length; i++) {
                str += self.get(i) ? on : off;
            }
            return str;
        }

        function toString(names) {
            var self = this;
            var set = [];
            for (var i = 0; i < length; i++) {
                if (self.get(i)) {
                    set.push(names ? names[i] : i);
                }
            }
            return set.join(", ");
        }

        var Uint32ArrayBitSet = (function () {
            function Uint32ArrayBitSet(length) {
                this.size = getSize(length);
                this.count = 0;
                this.dirty = 0;
                this.length = length;
                this.bits = new Uint32Array(this.size >> BitSets.ADDRESS_BITS_PER_WORD);
            }
            Uint32ArrayBitSet.prototype.recount = function () {
                if (!this.dirty) {
                    return;
                }

                var bits = this.bits;
                var c = 0;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var v = bits[i];
                    v = v - ((v >> 1) & 0x55555555);
                    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
                    c += ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
                }

                this.count = c;
                this.dirty = 0;
            };

            Uint32ArrayBitSet.prototype.set = function (i) {
                var n = i >> BitSets.ADDRESS_BITS_PER_WORD;
                var old = this.bits[n];
                var b = old | (1 << (i & BitSets.BIT_INDEX_MASK));
                this.bits[n] = b;
                this.dirty |= old ^ b;
            };

            Uint32ArrayBitSet.prototype.setAll = function () {
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    bits[i] = 0xFFFFFFFF;
                }
                this.count = this.size;
                this.dirty = 0;
            };

            Uint32ArrayBitSet.prototype.assign = function (set) {
                this.count = set.count;
                this.dirty = set.dirty;
                this.size = set.size;
                for (var i = 0, j = this.bits.length; i < j; i++) {
                    this.bits[i] = set.bits[i];
                }
            };

            Uint32ArrayBitSet.prototype.clear = function (i) {
                var n = i >> BitSets.ADDRESS_BITS_PER_WORD;
                var old = this.bits[n];
                var b = old & ~(1 << (i & BitSets.BIT_INDEX_MASK));
                this.bits[n] = b;
                this.dirty |= old ^ b;
            };

            Uint32ArrayBitSet.prototype.get = function (i) {
                var word = this.bits[i >> BitSets.ADDRESS_BITS_PER_WORD];
                return ((word & 1 << (i & BitSets.BIT_INDEX_MASK))) !== 0;
            };

            Uint32ArrayBitSet.prototype.clearAll = function () {
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    bits[i] = 0;
                }
                this.count = 0;
                this.dirty = 0;
            };

            Uint32ArrayBitSet.prototype._union = function (other) {
                var dirty = this.dirty;
                var bits = this.bits;
                var otherBits = other.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var old = bits[i];
                    var b = old | otherBits[i];
                    bits[i] = b;
                    dirty |= old ^ b;
                }
                this.dirty = dirty;
            };

            Uint32ArrayBitSet.prototype.intersect = function (other) {
                var dirty = this.dirty;
                var bits = this.bits;
                var otherBits = other.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var old = bits[i];
                    var b = old & otherBits[i];
                    bits[i] = b;
                    dirty |= old ^ b;
                }
                this.dirty = dirty;
            };

            Uint32ArrayBitSet.prototype.subtract = function (other) {
                var dirty = this.dirty;
                var bits = this.bits;
                var otherBits = other.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var old = bits[i];
                    var b = old & ~otherBits[i];
                    bits[i] = b;
                    dirty |= old ^ b;
                }
                this.dirty = dirty;
            };

            Uint32ArrayBitSet.prototype.negate = function () {
                var dirty = this.dirty;
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var old = bits[i];
                    var b = ~old;
                    bits[i] = b;
                    dirty |= old ^ b;
                }
                this.dirty = dirty;
            };

            Uint32ArrayBitSet.prototype.forEach = function (fn) {
                release || assert(fn);
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var word = bits[i];
                    if (word) {
                        for (var k = 0; k < BitSets.BITS_PER_WORD; k++) {
                            if (word & (1 << k)) {
                                fn(i * BitSets.BITS_PER_WORD + k);
                            }
                        }
                    }
                }
            };

            Uint32ArrayBitSet.prototype.toArray = function () {
                var set = [];
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var word = bits[i];
                    if (word) {
                        for (var k = 0; k < BitSets.BITS_PER_WORD; k++) {
                            if (word & (1 << k)) {
                                set.push(i * BitSets.BITS_PER_WORD + k);
                            }
                        }
                    }
                }
                return set;
            };

            Uint32ArrayBitSet.prototype.equals = function (other) {
                if (this.size !== other.size) {
                    return false;
                }
                var bits = this.bits;
                var otherBits = other.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    if (bits[i] !== otherBits[i]) {
                        return false;
                    }
                }
                return true;
            };

            Uint32ArrayBitSet.prototype.contains = function (other) {
                if (this.size !== other.size) {
                    return false;
                }
                var bits = this.bits;
                var otherBits = other.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    if ((bits[i] | otherBits[i]) !== bits[i]) {
                        return false;
                    }
                }
                return true;
            };

            Uint32ArrayBitSet.prototype.isEmpty = function () {
                this.recount();
                return this.count === 0;
            };

            Uint32ArrayBitSet.prototype.clone = function () {
                var set = new Uint32ArrayBitSet(this.length);
                set._union(this);
                return set;
            };
            return Uint32ArrayBitSet;
        })();
        BitSets.Uint32ArrayBitSet = Uint32ArrayBitSet;

        var Uint32BitSet = (function () {
            function Uint32BitSet(length) {
                this.count = 0;
                this.dirty = 0;
                this.size = getSize(length);
                this.bits = 0;
                this.singleWord = true;
                this.length = length;
            }
            Uint32BitSet.prototype.recount = function () {
                if (!this.dirty) {
                    return;
                }

                var c = 0;
                var v = this.bits;
                v = v - ((v >> 1) & 0x55555555);
                v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
                c += ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;

                this.count = c;
                this.dirty = 0;
            };

            Uint32BitSet.prototype.set = function (i) {
                var old = this.bits;
                var b = old | (1 << (i & BitSets.BIT_INDEX_MASK));
                this.bits = b;
                this.dirty |= old ^ b;
            };

            Uint32BitSet.prototype.setAll = function () {
                this.bits = 0xFFFFFFFF;
                this.count = this.size;
                this.dirty = 0;
            };

            Uint32BitSet.prototype.assign = function (set) {
                this.count = set.count;
                this.dirty = set.dirty;
                this.size = set.size;
                this.bits = set.bits;
            };

            Uint32BitSet.prototype.clear = function (i) {
                var old = this.bits;
                var b = old & ~(1 << (i & BitSets.BIT_INDEX_MASK));
                this.bits = b;
                this.dirty |= old ^ b;
            };

            Uint32BitSet.prototype.get = function (i) {
                return ((this.bits & 1 << (i & BitSets.BIT_INDEX_MASK))) !== 0;
            };

            Uint32BitSet.prototype.clearAll = function () {
                this.bits = 0;
                this.count = 0;
                this.dirty = 0;
            };

            Uint32BitSet.prototype._union = function (other) {
                var old = this.bits;
                var b = old | other.bits;
                this.bits = b;
                this.dirty = old ^ b;
            };

            Uint32BitSet.prototype.intersect = function (other) {
                var old = this.bits;
                var b = old & other.bits;
                this.bits = b;
                this.dirty = old ^ b;
            };

            Uint32BitSet.prototype.subtract = function (other) {
                var old = this.bits;
                var b = old & ~other.bits;
                this.bits = b;
                this.dirty = old ^ b;
            };

            Uint32BitSet.prototype.negate = function () {
                var old = this.bits;
                var b = ~old;
                this.bits = b;
                this.dirty = old ^ b;
            };

            Uint32BitSet.prototype.forEach = function (fn) {
                release || assert(fn);
                var word = this.bits;
                if (word) {
                    for (var k = 0; k < BitSets.BITS_PER_WORD; k++) {
                        if (word & (1 << k)) {
                            fn(k);
                        }
                    }
                }
            };

            Uint32BitSet.prototype.toArray = function () {
                var set = [];
                var word = this.bits;
                if (word) {
                    for (var k = 0; k < BitSets.BITS_PER_WORD; k++) {
                        if (word & (1 << k)) {
                            set.push(k);
                        }
                    }
                }
                return set;
            };

            Uint32BitSet.prototype.equals = function (other) {
                return this.bits === other.bits;
            };

            Uint32BitSet.prototype.contains = function (other) {
                var bits = this.bits;
                return (bits | other.bits) === bits;
            };

            Uint32BitSet.prototype.isEmpty = function () {
                this.recount();
                return this.count === 0;
            };

            Uint32BitSet.prototype.clone = function () {
                var set = new Uint32BitSet(this.length);
                set._union(this);
                return set;
            };
            return Uint32BitSet;
        })();
        BitSets.Uint32BitSet = Uint32BitSet;

        Uint32BitSet.prototype.toString = toString;
        Uint32BitSet.prototype.toBitString = toBitString;
        Uint32ArrayBitSet.prototype.toString = toString;
        Uint32ArrayBitSet.prototype.toBitString = toBitString;

        function BitSetFunctor(length) {
            var shouldUseSingleWord = (getSize(length) >> BitSets.ADDRESS_BITS_PER_WORD) === 1;
            var type = (shouldUseSingleWord ? Uint32BitSet : Uint32ArrayBitSet);
            return function () {
                return new type(length);
            };
        }
        BitSets.BitSetFunctor = BitSetFunctor;
    })(Shumway.BitSets || (Shumway.BitSets = {}));
    var BitSets = Shumway.BitSets;

    var ColorStyle = (function () {
        function ColorStyle() {
        }
        ColorStyle.randomStyle = function () {
            if (!ColorStyle._randomStyleCache) {
                ColorStyle._randomStyleCache = [
                    "#ff5e3a",
                    "#ff9500",
                    "#ffdb4c",
                    "#87fc70",
                    "#52edc7",
                    "#1ad6fd",
                    "#c644fc",
                    "#ef4db6",
                    "#4a4a4a",
                    "#dbddde",
                    "#ff3b30",
                    "#ff9500",
                    "#ffcc00",
                    "#4cd964",
                    "#34aadc",
                    "#007aff",
                    "#5856d6",
                    "#ff2d55",
                    "#8e8e93",
                    "#c7c7cc",
                    "#5ad427",
                    "#c86edf",
                    "#d1eefc",
                    "#e0f8d8",
                    "#fb2b69",
                    "#f7f7f7",
                    "#1d77ef",
                    "#d6cec3",
                    "#55efcb",
                    "#ff4981",
                    "#ffd3e0",
                    "#f7f7f7",
                    "#ff1300",
                    "#1f1f21",
                    "#bdbec2",
                    "#ff3a2d"
                ];
            }
            return ColorStyle._randomStyleCache[(ColorStyle._nextStyle++) % ColorStyle._randomStyleCache.length];
        };

        ColorStyle.contrastStyle = function (rgb) {
            // http://www.w3.org/TR/AERT#color-contrast
            var c = parseInt(rgb.substr(1), 16);
            var yiq = (((c >> 16) * 299) + (((c >> 8) & 0xff) * 587) + ((c & 0xff) * 114)) / 1000;
            return (yiq >= 128) ? '#000000' : '#ffffff';
        };

        ColorStyle.reset = function () {
            ColorStyle._nextStyle = 0;
        };
        ColorStyle.TabToolbar = "#252c33";
        ColorStyle.Toolbars = "#343c45";
        ColorStyle.HighlightBlue = "#1d4f73";
        ColorStyle.LightText = "#f5f7fa";
        ColorStyle.ForegroundText = "#b6babf";
        ColorStyle.Black = "#000000";
        ColorStyle.VeryDark = "#14171a";
        ColorStyle.Dark = "#181d20";
        ColorStyle.Light = "#a9bacb";
        ColorStyle.Grey = "#8fa1b2";
        ColorStyle.DarkGrey = "#5f7387";
        ColorStyle.Blue = "#46afe3";
        ColorStyle.Purple = "#6b7abb";
        ColorStyle.Pink = "#df80ff";
        ColorStyle.Red = "#eb5368";
        ColorStyle.Orange = "#d96629";
        ColorStyle.LightOrange = "#d99b28";
        ColorStyle.Green = "#70bf53";
        ColorStyle.BlueGrey = "#5e88b0";

        ColorStyle._nextStyle = 0;
        return ColorStyle;
    })();
    Shumway.ColorStyle = ColorStyle;

    /**
    * Faster release version of bounds.
    */
    var Bounds = (function () {
        function Bounds(xMin, yMin, xMax, yMax) {
            this.xMin = xMin | 0;
            this.yMin = yMin | 0;
            this.xMax = xMax | 0;
            this.yMax = yMax | 0;
        }
        Bounds.FromUntyped = function (source) {
            return new Bounds(source.xMin, source.yMin, source.xMax, source.yMax);
        };

        Bounds.FromRectangle = function (source) {
            return new Bounds(source.x * 20 | 0, source.y * 20 | 0, (source.x + source.width) * 20 | 0, (source.y + source.height) * 20 | 0);
        };

        Bounds.prototype.setElements = function (xMin, yMin, xMax, yMax) {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMax;
            this.yMax = yMax;
        };

        Bounds.prototype.copyFrom = function (source) {
            this.setElements(source.xMin, source.yMin, source.xMax, source.yMax);
        };

        Bounds.prototype.contains = function (x, y) {
            return x < this.xMin !== x < this.xMax && y < this.yMin !== y < this.yMax;
        };

        Bounds.prototype.unionInPlace = function (other) {
            this.xMin = Math.min(this.xMin, other.xMin);
            this.yMin = Math.min(this.yMin, other.yMin);
            this.xMax = Math.max(this.xMax, other.xMax);
            this.yMax = Math.max(this.yMax, other.yMax);
        };

        Bounds.prototype.extendByPoint = function (x, y) {
            this.extendByX(x);
            this.extendByY(y);
        };

        Bounds.prototype.extendByX = function (x) {
            // Exclude default values.
            if (this.xMin === 0x8000000) {
                this.xMin = this.xMax = x;
                return;
            }
            this.xMin = Math.min(this.xMin, x);
            this.xMax = Math.max(this.xMax, x);
        };

        Bounds.prototype.extendByY = function (y) {
            // Exclude default values.
            if (this.yMin === 0x8000000) {
                this.yMin = this.yMax = y;
                return;
            }
            this.yMin = Math.min(this.yMin, y);
            this.yMax = Math.max(this.yMax, y);
        };

        Bounds.prototype.intersects = function (toIntersect) {
            return this.contains(toIntersect.xMin, toIntersect.yMin) || this.contains(toIntersect.xMax, toIntersect.yMax);
        };

        Bounds.prototype.isEmpty = function () {
            return this.xMax <= this.xMin || this.yMax <= this.yMin;
        };

        Object.defineProperty(Bounds.prototype, "width", {
            get: function () {
                return this.xMax - this.xMin;
            },
            set: function (value) {
                this.xMax = this.xMin + value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Bounds.prototype, "height", {
            get: function () {
                return this.yMax - this.yMin;
            },
            set: function (value) {
                this.yMax = this.yMin + value;
            },
            enumerable: true,
            configurable: true
        });


        Bounds.prototype.getBaseWidth = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return u * (this.xMax - this.xMin) + v * (this.yMax - this.yMin);
        };

        Bounds.prototype.getBaseHeight = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return v * (this.xMax - this.xMin) + u * (this.yMax - this.yMin);
        };

        Bounds.prototype.setEmpty = function () {
            this.xMin = this.yMin = this.xMax = this.yMax = 0;
        };

        /**
        * Set all fields to the sentinel value 0x8000000.
        *
        * This is what Flash uses to indicate uninitialized bounds. Important for bounds calculation
        * in `Graphics` instances, which start out with empty bounds but must not just extend them
        * from an 0,0 origin.
        */
        Bounds.prototype.setToSentinels = function () {
            this.xMin = this.yMin = this.xMax = this.yMax = 0x8000000;
        };

        Bounds.prototype.clone = function () {
            return new Bounds(this.xMin, this.yMin, this.xMax, this.yMax);
        };

        Bounds.prototype.toString = function () {
            return "{ " + "xMin: " + this.xMin + ", " + "xMin: " + this.yMin + ", " + "xMax: " + this.xMax + ", " + "xMax: " + this.yMax + " }";
        };
        return Bounds;
    })();
    Shumway.Bounds = Bounds;

    /**
    * Slower debug version of bounds, makes sure that all points have integer coordinates.
    */
    var DebugBounds = (function () {
        function DebugBounds(xMin, yMin, xMax, yMax) {
            Debug.assert(isInteger(xMin));
            Debug.assert(isInteger(yMin));
            Debug.assert(isInteger(xMax));
            Debug.assert(isInteger(yMax));
            this._xMin = xMin | 0;
            this._yMin = yMin | 0;
            this._xMax = xMax | 0;
            this._yMax = yMax | 0;
            this.assertValid();
        }
        DebugBounds.FromUntyped = function (source) {
            return new DebugBounds(source.xMin, source.yMin, source.xMax, source.yMax);
        };

        DebugBounds.FromRectangle = function (source) {
            return new DebugBounds(source.x * 20 | 0, source.y * 20 | 0, (source.x + source.width) * 20 | 0, (source.y + source.height) * 20 | 0);
        };

        DebugBounds.prototype.setElements = function (xMin, yMin, xMax, yMax) {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMax;
            this.yMax = yMax;
        };

        DebugBounds.prototype.copyFrom = function (source) {
            this.setElements(source.xMin, source.yMin, source.xMax, source.yMax);
        };

        DebugBounds.prototype.contains = function (x, y) {
            return x < this.xMin !== x < this.xMax && y < this.yMin !== y < this.yMax;
        };

        DebugBounds.prototype.unionWith = function (other) {
            this._xMin = Math.min(this._xMin, other._xMin);
            this._yMin = Math.min(this._yMin, other._yMin);
            this._xMax = Math.max(this._xMax, other._xMax);
            this._yMax = Math.max(this._yMax, other._yMax);
        };

        DebugBounds.prototype.extendByPoint = function (x, y) {
            this.extendByX(x);
            this.extendByY(y);
        };

        DebugBounds.prototype.extendByX = function (x) {
            if (this.xMin === 0x8000000) {
                this.xMin = this.xMax = x;
                return;
            }
            this.xMin = Math.min(this.xMin, x);
            this.xMax = Math.max(this.xMax, x);
        };

        DebugBounds.prototype.extendByY = function (y) {
            if (this.yMin === 0x8000000) {
                this.yMin = this.yMax = y;
                return;
            }
            this.yMin = Math.min(this.yMin, y);
            this.yMax = Math.max(this.yMax, y);
        };

        DebugBounds.prototype.intersects = function (toIntersect) {
            return this.contains(toIntersect._xMin, toIntersect._yMin) || this.contains(toIntersect._xMax, toIntersect._yMax);
        };

        DebugBounds.prototype.isEmpty = function () {
            return this._xMax <= this._xMin || this._yMax <= this._yMin;
        };


        Object.defineProperty(DebugBounds.prototype, "xMin", {
            get: function () {
                return this._xMin;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._xMin = value;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DebugBounds.prototype, "yMin", {
            get: function () {
                return this._yMin;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._yMin = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DebugBounds.prototype, "xMax", {
            get: function () {
                return this._xMax;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._xMax = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DebugBounds.prototype, "width", {
            get: function () {
                return this._xMax - this._xMin;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DebugBounds.prototype, "yMax", {
            get: function () {
                return this._yMax;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._yMax = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DebugBounds.prototype, "height", {
            get: function () {
                return this._yMax - this._yMin;
            },
            enumerable: true,
            configurable: true
        });

        DebugBounds.prototype.getBaseWidth = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return u * (this._xMax - this._xMin) + v * (this._yMax - this._yMin);
        };

        DebugBounds.prototype.getBaseHeight = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return v * (this._xMax - this._xMin) + u * (this._yMax - this._yMin);
        };

        DebugBounds.prototype.setEmpty = function () {
            this._xMin = this._yMin = this._xMax = this._yMax = 0;
        };

        DebugBounds.prototype.clone = function () {
            return new DebugBounds(this.xMin, this.yMin, this.xMax, this.yMax);
        };

        DebugBounds.prototype.toString = function () {
            return "{ " + "xMin: " + this._xMin + ", " + "xMin: " + this._yMin + ", " + "xMax: " + this._xMax + ", " + "xMax: " + this._yMax + " }";
        };

        DebugBounds.prototype.assertValid = function () {
            //      release || assert(this._xMax >= this._xMin);
            //      release || assert(this._yMax >= this._yMin);
        };
        return DebugBounds;
    })();
    Shumway.DebugBounds = DebugBounds;

    /**
    * Override Bounds with a slower by safer version, don't do this in release mode.
    */
    // Shumway.Bounds = DebugBounds;
    var Color = (function () {
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color.FromARGB = function (argb) {
            return new Color((argb >> 16 & 0xFF) / 255, (argb >> 8 & 0xFF) / 255, (argb >> 0 & 0xFF) / 255, (argb >> 24 & 0xFF) / 255);
        };
        Color.FromRGBA = function (rgba) {
            return Color.FromARGB(ColorUtilities.RGBAToARGB(rgba));
        };
        Color.prototype.toRGBA = function () {
            return (this.r * 255) << 24 | (this.g * 255) << 16 | (this.b * 255) << 8 | (this.a * 255);
        };
        Color.prototype.toCSSStyle = function () {
            return ColorUtilities.rgbaToCSSStyle(this.toRGBA());
        };
        Color.prototype.set = function (other) {
            this.r = other.r;
            this.g = other.g;
            this.b = other.b;
            this.a = other.a;
        };

        Color.randomColor = function (alpha) {
            if (typeof alpha === "undefined") { alpha = 1; }
            return new Color(Math.random(), Math.random(), Math.random(), alpha);
        };
        Color.parseColor = function (color) {
            if (!Color.colorCache) {
                Color.colorCache = Object.create(null);
            }
            if (Color.colorCache[color]) {
                return Color.colorCache[color];
            }

            // TODO: Obviously slow, but it will do for now.
            var span = document.createElement('span');
            document.body.appendChild(span);
            span.style.backgroundColor = color;
            var rgb = getComputedStyle(span).backgroundColor;
            document.body.removeChild(span);
            var m = /^rgb\((\d+), (\d+), (\d+)\)$/.exec(rgb);
            if (!m)
                m = /^rgba\((\d+), (\d+), (\d+), ([\d.]+)\)$/.exec(rgb);
            var result = new Color(0, 0, 0, 0);
            result.r = parseFloat(m[1]) / 255;
            result.g = parseFloat(m[2]) / 255;
            result.b = parseFloat(m[3]) / 255;
            result.a = m[4] ? parseFloat(m[4]) / 255 : 1;
            return Color.colorCache[color] = result;
        };
        Color.Red = new Color(1, 0, 0, 1);
        Color.Green = new Color(0, 1, 0, 1);
        Color.Blue = new Color(0, 0, 1, 1);
        Color.None = new Color(0, 0, 0, 0);
        Color.White = new Color(1, 1, 1, 1);
        Color.Black = new Color(0, 0, 0, 1);
        Color.colorCache = {};
        return Color;
    })();
    Shumway.Color = Color;

    (function (ColorUtilities) {
        function RGBAToARGB(rgba) {
            return ((rgba >> 8) & 0x00ffffff) | ((rgba & 0xff) << 24);
        }
        ColorUtilities.RGBAToARGB = RGBAToARGB;

        function ARGBToRGBA(argb) {
            return argb << 8 | ((argb >> 24) & 0xff);
        }
        ColorUtilities.ARGBToRGBA = ARGBToRGBA;

        function rgbaToCSSStyle(color) {
            return 'rgba(' + (color >> 24 & 0xff) + ',' + (color >> 16 & 0xff) + ',' + (color >> 8 & 0xff) + ',' + ((color & 0xff) / 0xff) + ')';
        }
        ColorUtilities.rgbaToCSSStyle = rgbaToCSSStyle;

        function cssStyleToRGBA(style) {
            if (style[0] === "#") {
                if (style.length === 7) {
                    var value = parseInt(style.substring(1), 16);
                    return (value << 8) | 0xff;
                }
            } else if (style[0] === "r") {
                // We don't parse all types of rgba(....) color styles. We only handle the
                // ones we generate ourselves.
                var values = style.substring(5, style.length - 1).split(",");
                var r = parseInt(values[0]);
                var g = parseInt(values[1]);
                var b = parseInt(values[2]);
                var a = parseFloat(values[3]);
                return (r & 0xff) << 24 | (g & 0xff) << 16 | (b & 0xff) << 8 | ((a * 255) & 0xff);
            }
            return 0xff0000ff;
        }
        ColorUtilities.cssStyleToRGBA = cssStyleToRGBA;

        function hexToRGB(color) {
            return parseInt(color.slice(1), 16);
        }
        ColorUtilities.hexToRGB = hexToRGB;

        function rgbToHex(color) {
            return '#' + ('000000' + color.toString(16)).slice(-6);
        }
        ColorUtilities.rgbToHex = rgbToHex;

        function isValidHexColor(value) {
            return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value);
        }
        ColorUtilities.isValidHexColor = isValidHexColor;

        function clampByte(value) {
            return Math.max(0, Math.min(255, value));
        }
        ColorUtilities.clampByte = clampByte;

        /**
        * Unpremultiplies the given |pARGB| color value.
        */
        function unpremultiplyARGB(pARGB) {
            var b = (pARGB >> 0) & 0xff;
            var g = (pARGB >> 8) & 0xff;
            var r = (pARGB >> 16) & 0xff;
            var a = (pARGB >> 24) & 0xff;
            r = Math.imul(255, r) / a & 0xff;
            g = Math.imul(255, g) / a & 0xff;
            b = Math.imul(255, b) / a & 0xff;
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.unpremultiplyARGB = unpremultiplyARGB;

        /**
        * Premultiplies the given |pARGB| color value.
        */
        function premultiplyARGB(uARGB) {
            var b = (uARGB >> 0) & 0xff;
            var g = (uARGB >> 8) & 0xff;
            var r = (uARGB >> 16) & 0xff;
            var a = (uARGB >> 24) & 0xff;
            r = ((Math.imul(r, a) + 127) / 255) | 0;
            g = ((Math.imul(g, a) + 127) / 255) | 0;
            b = ((Math.imul(b, a) + 127) / 255) | 0;
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.premultiplyARGB = premultiplyARGB;

        var premultiplyTable;

        /**
        * All possible alpha values and colors 256 * 256 = 65536 entries. Experiments
        * indicate that doing unpremultiplication this way is roughly 5x faster.
        *
        * To lookup a color |c| in the table at a given alpha value |a| use:
        * |(a << 8) + c| to compute the index. This layout order was chosen to make
        * table lookups cache friendly, it actually makes a difference.
        *
        * TODO: Figure out if memory / speed tradeoff is worth it.
        */
        var unpremultiplyTable;

        /**
        * Make sure to call this before using the |unpremultiplyARGBUsingTableLookup| or
        * |premultiplyARGBUsingTableLookup| functions. We want to execute this lazily so
        * we don't incur any startup overhead.
        */
        function ensureUnpremultiplyTable() {
            if (!unpremultiplyTable) {
                unpremultiplyTable = new Uint8Array(256 * 256);
                for (var c = 0; c < 256; c++) {
                    for (var a = 0; a < 256; a++) {
                        unpremultiplyTable[(a << 8) + c] = Math.imul(255, c) / a;
                    }
                }
            }
        }
        ColorUtilities.ensureUnpremultiplyTable = ensureUnpremultiplyTable;

        function tableLookupUnpremultiplyARGB(pARGB) {
            pARGB = pARGB | 0;
            var a = (pARGB >> 24) & 0xff;
            if (a === 0) {
                return 0;
            }
            var b = (pARGB >> 0) & 0xff;
            var g = (pARGB >> 8) & 0xff;
            var r = (pARGB >> 16) & 0xff;
            var o = a << 8;
            r = unpremultiplyTable[o + r];
            g = unpremultiplyTable[o + g];
            b = unpremultiplyTable[o + b];
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.tableLookupUnpremultiplyARGB = tableLookupUnpremultiplyARGB;

        var inverseSourceAlphaTable;

        /**
        * Computes all possible inverse source alpha values.
        */
        function ensureInverseSourceAlphaTable() {
            if (inverseSourceAlphaTable) {
                return;
            }
            inverseSourceAlphaTable = new Float64Array(256);
            for (var a = 0; a < 255; a++) {
                inverseSourceAlphaTable[a] = 1 - a / 255;
            }
        }
        ColorUtilities.ensureInverseSourceAlphaTable = ensureInverseSourceAlphaTable;

        /**
        * The blending equation for unpremultiplied alpha is:
        *
        *   (src.rgb * src.a) + (dst.rgb * (1 - src.a))
        *
        * For premultiplied alpha src.rgb and dst.rgb are already
        * premultiplied by alpha, so the equation becomes:
        *
        *   src.rgb + (dst.rgb * (1 - src.a))
        *
        * TODO: Not sure what to do about the dst.rgb which is
        * premultiplied by its alpah, but this appears to work.
        */
        function blendPremultipliedBGRA(tpBGRA, spBGRA) {
            var ta = (tpBGRA >> 0) & 0xff;
            var tr = (tpBGRA >> 8) & 0xff;
            var tg = (tpBGRA >> 16) & 0xff;
            var tb = (tpBGRA >> 24) & 0xff;

            var sa = (spBGRA >> 0) & 0xff;
            var sr = (spBGRA >> 8) & 0xff;
            var sg = (spBGRA >> 16) & 0xff;
            var sb = (spBGRA >> 24) & 0xff;

            // TODO: Clampling.
            var inverseSourceAlpha = inverseSourceAlphaTable[sa];
            var ta = sa + ta * inverseSourceAlpha;
            var tr = sr + tr * inverseSourceAlpha;
            var tg = sg + tg * inverseSourceAlpha;
            var tb = sb + tb * inverseSourceAlpha;
            return tb << 24 | tg << 16 | tr << 8 | ta;
        }
        ColorUtilities.blendPremultipliedBGRA = blendPremultipliedBGRA;
    })(Shumway.ColorUtilities || (Shumway.ColorUtilities = {}));
    var ColorUtilities = Shumway.ColorUtilities;

    /**
    * Simple pool allocator for ArrayBuffers. This reduces memory usage in data structures
    * that resize buffers.
    */
    var ArrayBufferPool = (function () {
        /**
        * Creates a pool that manages a pool of a |maxSize| number of array buffers.
        */
        function ArrayBufferPool(maxSize) {
            if (typeof maxSize === "undefined") { maxSize = 32; }
            this._list = [];
            this._maxSize = maxSize;
        }
        /**
        * Creates or reuses an existing array buffer that is at least the
        * specified |length|.
        */
        ArrayBufferPool.prototype.acquire = function (length) {
            if (ArrayBufferPool._enabled) {
                var list = this._list;
                for (var i = 0; i < list.length; i++) {
                    var buffer = list[i];
                    if (buffer.byteLength >= length) {
                        list.splice(i, 1);
                        return buffer;
                    }
                }
            }
            return new ArrayBuffer(length);
        };

        /**
        * Releases an array buffer that is no longer needed back to the pool.
        */
        ArrayBufferPool.prototype.release = function (buffer) {
            if (ArrayBufferPool._enabled) {
                var list = this._list;
                release || Debug.assert(ArrayUtilities.indexOf(list, buffer) < 0);
                if (list.length === this._maxSize) {
                    list.shift();
                }
                list.push(buffer);
            }
        };

        /**
        * Resizes a Uint8Array to have the given length.
        */
        ArrayBufferPool.prototype.ensureUint8ArrayLength = function (array, length) {
            if (array.length >= length) {
                return array;
            }
            var newLength = Math.max(array.length + length, ((array.length * 3) >> 1) + 1);
            var newArray = new Uint8Array(this.acquire(newLength), 0, newLength);
            newArray.set(array);
            this.release(array.buffer);
            return newArray;
        };

        /**
        * Resizes a Float64Array to have the given length.
        */
        ArrayBufferPool.prototype.ensureFloat64ArrayLength = function (array, length) {
            if (array.length >= length) {
                return array;
            }
            var newLength = Math.max(array.length + length, ((array.length * 3) >> 1) + 1);
            var newArray = new Float64Array(this.acquire(newLength * Float64Array.BYTES_PER_ELEMENT), 0, newLength);
            newArray.set(array);
            this.release(array.buffer);
            return newArray;
        };
        ArrayBufferPool._enabled = true;
        return ArrayBufferPool;
    })();
    Shumway.ArrayBufferPool = ArrayBufferPool;

    (function (Telemetry) {
        (function (Feature) {
            Feature[Feature["EXTERNAL_INTERFACE_FEATURE"] = 1] = "EXTERNAL_INTERFACE_FEATURE";
            Feature[Feature["CLIPBOARD_FEATURE"] = 2] = "CLIPBOARD_FEATURE";
            Feature[Feature["SHAREDOBJECT_FEATURE"] = 3] = "SHAREDOBJECT_FEATURE";
            Feature[Feature["VIDEO_FEATURE"] = 4] = "VIDEO_FEATURE";
            Feature[Feature["SOUND_FEATURE"] = 5] = "SOUND_FEATURE";
            Feature[Feature["NETCONNECTION_FEATURE"] = 6] = "NETCONNECTION_FEATURE";
        })(Telemetry.Feature || (Telemetry.Feature = {}));
        var Feature = Telemetry.Feature;

        (function (ErrorTypes) {
            ErrorTypes[ErrorTypes["AVM1_ERROR"] = 1] = "AVM1_ERROR";
            ErrorTypes[ErrorTypes["AVM2_ERROR"] = 2] = "AVM2_ERROR";
        })(Telemetry.ErrorTypes || (Telemetry.ErrorTypes = {}));
        var ErrorTypes = Telemetry.ErrorTypes;

        Telemetry.instance;
    })(Shumway.Telemetry || (Shumway.Telemetry = {}));
    var Telemetry = Shumway.Telemetry;

    (function (FileLoadingService) {
        FileLoadingService.instance;
    })(Shumway.FileLoadingService || (Shumway.FileLoadingService = {}));
    var FileLoadingService = Shumway.FileLoadingService;

    (function (ExternalInterfaceService) {
        ExternalInterfaceService.instance = {
            enabled: false,
            initJS: function (callback) {
            },
            registerCallback: function (functionName) {
            },
            unregisterCallback: function (functionName) {
            },
            eval: function (expression) {
            },
            call: function (request) {
            },
            getId: function () {
                return null;
            }
        };
    })(Shumway.ExternalInterfaceService || (Shumway.ExternalInterfaceService = {}));
    var ExternalInterfaceService = Shumway.ExternalInterfaceService;

    var Callback = (function () {
        function Callback() {
            this._queues = {};
        }
        Callback.prototype.register = function (type, callback) {
            Debug.assert(type);
            Debug.assert(callback);
            var queue = this._queues[type];
            if (queue) {
                if (queue.indexOf(callback) > -1) {
                    return;
                }
            } else {
                queue = this._queues[type] = [];
            }
            queue.push(callback);
        };

        Callback.prototype.unregister = function (type, callback) {
            Debug.assert(type);
            Debug.assert(callback);
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            var i = queue.indexOf(callback);
            if (i !== -1) {
                queue.splice(i, 1);
            }
            if (queue.length === 0) {
                this._queues[type] = null;
            }
        };

        Callback.prototype.notify = function (type, args) {
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            queue = queue.slice();
            var args = Array.prototype.slice.call(arguments, 0);
            for (var i = 0; i < queue.length; i++) {
                var callback = queue[i];
                callback.apply(null, args);
            }
        };

        Callback.prototype.notify1 = function (type, value) {
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            queue = queue.slice();
            for (var i = 0; i < queue.length; i++) {
                var callback = queue[i];
                callback(type, value);
            }
        };
        return Callback;
    })();
    Shumway.Callback = Callback;

    (function (ImageType) {
        ImageType[ImageType["None"] = 0] = "None";

        /**
        * Premultiplied ARGB (byte-order).
        */
        ImageType[ImageType["PremultipliedAlphaARGB"] = 1] = "PremultipliedAlphaARGB";

        /**
        * Unpremultiplied ARGB (byte-order).
        */
        ImageType[ImageType["StraightAlphaARGB"] = 2] = "StraightAlphaARGB";

        /**
        * Unpremultiplied RGBA (byte-order), this is what putImageData expects.
        */
        ImageType[ImageType["StraightAlphaRGBA"] = 3] = "StraightAlphaRGBA";

        ImageType[ImageType["JPEG"] = 4] = "JPEG";
        ImageType[ImageType["PNG"] = 5] = "PNG";
        ImageType[ImageType["GIF"] = 6] = "GIF";
    })(Shumway.ImageType || (Shumway.ImageType = {}));
    var ImageType = Shumway.ImageType;

    var PromiseWrapper = (function () {
        function PromiseWrapper() {
            this.promise = new Promise(function (resolve, reject) {
                this.resolve = resolve;
                this.reject = reject;
            }.bind(this));
        }
        return PromiseWrapper;
    })();
    Shumway.PromiseWrapper = PromiseWrapper;
})(Shumway || (Shumway = {}));

// Polyfill for Promises
(function PromiseClosure() {
    /*jshint -W061 */
    var global = Function("return this")();
    if (global.Promise) {
        // Promises existing in the DOM/Worker, checking presence of all/resolve
        if (typeof global.Promise.all !== 'function') {
            global.Promise.all = function (iterable) {
                var count = 0, results = [], resolve, reject;
                var promise = new global.Promise(function (resolve_, reject_) {
                    resolve = resolve_;
                    reject = reject_;
                });
                iterable.forEach(function (p, i) {
                    count++;
                    p.then(function (result) {
                        results[i] = result;
                        count--;
                        if (count === 0) {
                            resolve(results);
                        }
                    }, reject);
                });
                if (count === 0) {
                    resolve(results);
                }
                return promise;
            };
        }
        if (typeof global.Promise.resolve !== 'function') {
            global.Promise.resolve = function (x) {
                return new global.Promise(function (resolve) {
                    resolve(x);
                });
            };
        }
        return;
    }

    function getDeferred(C) {
        if (typeof C !== 'function') {
            throw new TypeError('Invalid deferred constructor');
        }
        var resolver = createDeferredConstructionFunctions();
        var promise = new C(resolver);
        var resolve = resolver.resolve;
        if (typeof resolve !== 'function') {
            throw new TypeError('Invalid resolve construction function');
        }
        var reject = resolver.reject;
        if (typeof reject !== 'function') {
            throw new TypeError('Invalid reject construction function');
        }
        return { promise: promise, resolve: resolve, reject: reject };
    }

    function updateDeferredFromPotentialThenable(x, deferred) {
        if (typeof x !== 'object' || x === null) {
            return false;
        }
        try  {
            var then = x.then;
            if (typeof then !== 'function') {
                return false;
            }
            var thenCallResult = then.call(x, deferred.resolve, deferred.reject);
        } catch (e) {
            var reject = deferred.reject;
            reject(e);
        }
        return true;
    }

    function isPromise(x) {
        return typeof x === 'object' && x !== null && typeof x.promiseStatus !== 'undefined';
    }

    function rejectPromise(promise, reason) {
        if (promise.promiseStatus !== 'unresolved') {
            return;
        }
        var reactions = promise.rejectReactions;
        promise.result = reason;
        promise.resolveReactions = undefined;
        promise.rejectReactions = undefined;
        promise.promiseStatus = 'has-rejection';
        triggerPromiseReactions(reactions, reason);
    }

    function resolvePromise(promise, resolution) {
        if (promise.promiseStatus !== 'unresolved') {
            return;
        }
        var reactions = promise.resolveReactions;
        promise.result = resolution;
        promise.resolveReactions = undefined;
        promise.rejectReactions = undefined;
        promise.promiseStatus = 'has-resolution';
        triggerPromiseReactions(reactions, resolution);
    }

    function triggerPromiseReactions(reactions, argument) {
        for (var i = 0; i < reactions.length; i++) {
            queueMicrotask({ reaction: reactions[i], argument: argument });
        }
    }

    function queueMicrotask(task) {
        if (microtasksQueue.length === 0) {
            setTimeout(handleMicrotasksQueue, 0);
        }
        microtasksQueue.push(task);
    }

    function executePromiseReaction(reaction, argument) {
        var deferred = reaction.deferred;
        var handler = reaction.handler;
        var handlerResult, updateResult;
        try  {
            handlerResult = handler(argument);
        } catch (e) {
            var reject = deferred.reject;
            return reject(e);
        }

        if (handlerResult === deferred.promise) {
            var reject = deferred.reject;
            return reject(new TypeError('Self resolution'));
        }

        try  {
            updateResult = updateDeferredFromPotentialThenable(handlerResult, deferred);
            if (!updateResult) {
                var resolve = deferred.resolve;
                return resolve(handlerResult);
            }
        } catch (e) {
            var reject = deferred.reject;
            return reject(e);
        }
    }

    var microtasksQueue = [];

    function handleMicrotasksQueue() {
        while (microtasksQueue.length > 0) {
            var task = microtasksQueue[0];
            try  {
                executePromiseReaction(task.reaction, task.argument);
            } catch (e) {
                // unhandler onFulfillment/onRejection exception
                if (typeof Promise.onerror === 'function') {
                    Promise.onerror(e);
                }
            }
            microtasksQueue.shift();
        }
    }

    function throwerFunction(e) {
        throw e;
    }

    function identityFunction(x) {
        return x;
    }

    function createRejectPromiseFunction(promise) {
        return function (reason) {
            rejectPromise(promise, reason);
        };
    }

    function createResolvePromiseFunction(promise) {
        return function (resolution) {
            resolvePromise(promise, resolution);
        };
    }

    function createDeferredConstructionFunctions() {
        var fn = function (resolve, reject) {
            fn.resolve = resolve;
            fn.reject = reject;
        };
        return fn;
    }

    function createPromiseResolutionHandlerFunctions(promise, fulfillmentHandler, rejectionHandler) {
        return function (x) {
            if (x === promise) {
                return rejectionHandler(new TypeError('Self resolution'));
            }
            var cstr = promise.promiseConstructor;
            if (isPromise(x)) {
                var xConstructor = x.promiseConstructor;
                if (xConstructor === cstr) {
                    return x.then(fulfillmentHandler, rejectionHandler);
                }
            }
            var deferred = getDeferred(cstr);
            var updateResult = updateDeferredFromPotentialThenable(x, deferred);
            if (updateResult) {
                var deferredPromise = deferred.promise;
                return deferredPromise.then(fulfillmentHandler, rejectionHandler);
            }
            return fulfillmentHandler(x);
        };
    }

    function createPromiseAllCountdownFunction(index, values, deferred, countdownHolder) {
        return function (x) {
            values[index] = x;
            countdownHolder.countdown--;
            if (countdownHolder.countdown === 0) {
                deferred.resolve(values);
            }
        };
    }

    function Promise(resolver) {
        if (typeof resolver !== 'function') {
            throw new TypeError('resolver is not a function');
        }
        var promise = this;
        if (typeof promise !== 'object') {
            throw new TypeError('Promise to initialize is not an object');
        }
        promise.promiseStatus = 'unresolved';
        promise.resolveReactions = [];
        promise.rejectReactions = [];
        promise.result = undefined;

        var resolve = createResolvePromiseFunction(promise);
        var reject = createRejectPromiseFunction(promise);

        try  {
            var result = resolver(resolve, reject);
        } catch (e) {
            rejectPromise(promise, e);
        }

        promise.promiseConstructor = Promise;
        return promise;
    }

    Promise.all = function (iterable) {
        var deferred = getDeferred(this);
        var values = [];
        var countdownHolder = { countdown: 0 };
        var index = 0;
        iterable.forEach(function (nextValue) {
            var nextPromise = this.cast(nextValue);
            var fn = createPromiseAllCountdownFunction(index, values, deferred, countdownHolder);
            nextPromise.then(fn, deferred.reject);
            index++;
            countdownHolder.countdown++;
        }, this);
        if (index === 0) {
            deferred.resolve(values);
        }
        return deferred.promise;
    };
    Promise.cast = function (x) {
        if (isPromise(x)) {
            return x;
        }
        var deferred = getDeferred(this);
        deferred.resolve(x);
        return deferred.promise;
    };
    Promise.reject = function (r) {
        var deferred = getDeferred(this);
        var rejectResult = deferred.reject(r);
        return deferred.promise;
    };
    Promise.resolve = function (x) {
        var deferred = getDeferred(this);
        var rejectResult = deferred.resolve(x);
        return deferred.promise;
    };
    Promise.prototype = {
        'catch': function (onRejected) {
            this.then(undefined, onRejected);
        },
        then: function (onFulfilled, onRejected) {
            var promise = this;
            if (!isPromise(promise)) {
                throw new TypeError('this is not a Promises');
            }
            var cstr = promise.promiseConstructor;
            var deferred = getDeferred(cstr);

            var rejectionHandler = typeof onRejected === 'function' ? onRejected : throwerFunction;
            var fulfillmentHandler = typeof onFulfilled === 'function' ? onFulfilled : identityFunction;
            var resolutionHandler = createPromiseResolutionHandlerFunctions(promise, fulfillmentHandler, rejectionHandler);

            var resolveReaction = { deferred: deferred, handler: resolutionHandler };
            var rejectReaction = { deferred: deferred, handler: rejectionHandler };

            switch (promise.promiseStatus) {
                case 'unresolved':
                    promise.resolveReactions.push(resolveReaction);
                    promise.rejectReactions.push(rejectReaction);
                    break;
                case 'has-resolution':
                    var resolution = promise.result;
                    queueMicrotask({ reaction: resolveReaction, argument: resolution });
                    break;
                case 'has-rejection':
                    var rejection = promise.result;
                    queueMicrotask({ reaction: rejectReaction, argument: rejection });
                    break;
            }
            return deferred.promise;
        }
    };

    global.Promise = Promise;
})();

if (typeof exports !== "undefined") {
    exports["Shumway"] = Shumway;
}

/**
* Extend builtin prototypes.
*
* TODO: Go through the code and remove all references to these.
*/
(function () {
    function extendBuiltin(prototype, property, value) {
        if (!prototype[property]) {
            Object.defineProperty(prototype, property, {
                value: value,
                writable: true,
                configurable: true,
                enumerable: false });
        }
    }

    function removeColors(s) {
        return s.replace(/\033\[[0-9]*m/g, "");
    }

    extendBuiltin(String.prototype, "padRight", function (c, n) {
        var str = this;
        var length = removeColors(str).length;
        if (!c || length >= n) {
            return str;
        }
        var max = (n - length) / c.length;
        for (var i = 0; i < max; i++) {
            str += c;
        }
        return str;
    });

    extendBuiltin(String.prototype, "padLeft", function (c, n) {
        var str = this;
        var length = str.length;
        if (!c || length >= n) {
            return str;
        }
        var max = (n - length) / c.length;
        for (var i = 0; i < max; i++) {
            str = c + str;
        }
        return str;
    });

    extendBuiltin(String.prototype, "trim", function () {
        return this.replace(/^\s+|\s+$/g, "");
    });

    extendBuiltin(String.prototype, "endsWith", function (str) {
        return this.indexOf(str, this.length - str.length) !== -1;
    });

    extendBuiltin(Array.prototype, "replace", function (x, y) {
        if (x === y) {
            return 0;
        }
        var count = 0;
        for (var i = 0; i < this.length; i++) {
            if (this[i] === x) {
                this[i] = y;
                count++;
            }
        }
        return count;
    });
})();
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    /**
    * Option and Argument Management
    *
    * Options are configuration settings sprinkled throughout the code. They can be grouped into sets of
    * options called |OptionSets| which can form a hierarchy of options. For instance:
    *
    * var set = new OptionSet();
    * var opt = set.register(new Option("v", "verbose", "boolean", false, "Enables verbose logging."));
    *
    * creates an option set with one option in it. The option can be changed directly using |opt.value = true| or
    * automatically using the |ArgumentParser|:
    *
    * var parser = new ArgumentParser();
    * parser.addBoundOptionSet(set);
    * parser.parse(["-v"]);
    *
    * The |ArgumentParser| can also be used directly:
    *
    * var parser = new ArgumentParser();
    * argumentParser.addArgument("h", "help", "boolean", {parse: function (x) {
    *   printUsage();
    * }});
    */
    ///<reference path='references.ts' />
    (function (Options) {
        var isObject = Shumway.isObject;

        var assert = Shumway.Debug.assert;

        var Argument = (function () {
            function Argument(shortName, longName, type, options) {
                this.shortName = shortName;
                this.longName = longName;
                this.type = type;
                options = options || {};
                this.positional = options.positional;
                this.parseFn = options.parse;
                this.value = options.defaultValue;
            }
            Argument.prototype.parse = function (value) {
                if (this.type === "boolean") {
                    release || assert(typeof value === "boolean");
                    this.value = value;
                } else if (this.type === "number") {
                    release || assert(!isNaN(value), value + " is not a number");
                    this.value = parseInt(value, 10);
                } else {
                    this.value = value;
                }
                if (this.parseFn) {
                    this.parseFn(this.value);
                }
            };
            return Argument;
        })();
        Options.Argument = Argument;

        var ArgumentParser = (function () {
            function ArgumentParser() {
                this.args = [];
            }
            ArgumentParser.prototype.addArgument = function (shortName, longName, type, options) {
                var argument = new Argument(shortName, longName, type, options);
                this.args.push(argument);
                return argument;
            };
            ArgumentParser.prototype.addBoundOption = function (option) {
                var options = { parse: function (x) {
                        option.value = x;
                    } };
                this.args.push(new Argument(option.shortName, option.longName, option.type, options));
            };
            ArgumentParser.prototype.addBoundOptionSet = function (optionSet) {
                var self = this;
                optionSet.options.forEach(function (x) {
                    if (x instanceof OptionSet) {
                        self.addBoundOptionSet(x);
                    } else {
                        release || assert(x instanceof Option);
                        self.addBoundOption(x);
                    }
                });
            };
            ArgumentParser.prototype.getUsage = function () {
                var str = "";
                this.args.forEach(function (x) {
                    if (!x.positional) {
                        str += "[-" + x.shortName + "|--" + x.longName + (x.type === "boolean" ? "" : " " + x.type[0].toUpperCase()) + "]";
                    } else {
                        str += x.longName;
                    }
                    str += " ";
                });
                return str;
            };
            ArgumentParser.prototype.parse = function (args) {
                var nonPositionalArgumentMap = {};
                var positionalArgumentList = [];
                this.args.forEach(function (x) {
                    if (x.positional) {
                        positionalArgumentList.push(x);
                    } else {
                        nonPositionalArgumentMap["-" + x.shortName] = x;
                        nonPositionalArgumentMap["--" + x.longName] = x;
                    }
                });

                var leftoverArguments = [];

                while (args.length) {
                    var argString = args.shift();
                    var argument = null, value = argString;
                    if (argString == '--') {
                        leftoverArguments = leftoverArguments.concat(args);
                        break;
                    } else if (argString.slice(0, 1) == '-' || argString.slice(0, 2) == '--') {
                        argument = nonPositionalArgumentMap[argString];

                        // release || assert(argument, "Argument " + argString + " is unknown.");
                        if (!argument) {
                            continue;
                        }
                        if (argument.type !== "boolean") {
                            value = args.shift();
                            release || assert(value !== "-" && value !== "--", "Argument " + argString + " must have a value.");
                        } else {
                            value = true;
                        }
                    } else if (positionalArgumentList.length) {
                        argument = positionalArgumentList.shift();
                    } else {
                        leftoverArguments.push(value);
                    }
                    if (argument) {
                        argument.parse(value);
                    }
                }
                release || assert(positionalArgumentList.length === 0, "Missing positional arguments.");
                return leftoverArguments;
            };
            return ArgumentParser;
        })();
        Options.ArgumentParser = ArgumentParser;

        var OptionSet = (function () {
            function OptionSet(name, settings) {
                if (typeof settings === "undefined") { settings = null; }
                this.open = false;
                this.name = name;
                this.settings = settings || {};
                this.options = [];
            }
            OptionSet.prototype.register = function (option) {
                if (option instanceof OptionSet) {
                    for (var i = 0; i < this.options.length; i++) {
                        var optionSet = this.options[i];
                        if (optionSet instanceof OptionSet && optionSet.name === option.name) {
                            return optionSet;
                        }
                    }
                }
                this.options.push(option);
                if (this.settings) {
                    if (option instanceof OptionSet) {
                        var optionSettings = this.settings[option.name];
                        if (isObject(optionSettings)) {
                            option.settings = optionSettings.settings;
                            option.open = optionSettings.open;
                        }
                    } else {
                        // build_bundle chokes on this:
                        // if (!isNullOrUndefined(this.settings[option.longName])) {
                        if (typeof this.settings[option.longName] !== "undefined") {
                            switch (option.type) {
                                case "boolean":
                                    option.value = !!this.settings[option.longName];
                                    break;
                                case "number":
                                    option.value = +this.settings[option.longName];
                                    break;
                                default:
                                    option.value = this.settings[option.longName];
                                    break;
                            }
                        }
                    }
                }
                return option;
            };
            OptionSet.prototype.trace = function (writer) {
                writer.enter(this.name + " {");
                this.options.forEach(function (option) {
                    option.trace(writer);
                });
                writer.leave("}");
            };
            OptionSet.prototype.getSettings = function () {
                var settings = {};
                this.options.forEach(function (option) {
                    if (option instanceof OptionSet) {
                        settings[option.name] = {
                            settings: option.getSettings(),
                            open: option.open
                        };
                    } else {
                        settings[option.longName] = option.value;
                    }
                });
                return settings;
            };
            OptionSet.prototype.setSettings = function (settings) {
                if (!settings) {
                    return;
                }
                this.options.forEach(function (option) {
                    if (option instanceof OptionSet) {
                        if (option.name in settings) {
                            option.setSettings(settings[option.name].settings);
                        }
                    } else {
                        if (option.longName in settings) {
                            option.value = settings[option.longName];
                        }
                    }
                });
            };
            return OptionSet;
        })();
        Options.OptionSet = OptionSet;

        var Option = (function () {
            // config:
            //  { range: { min: 1, max: 5, step: 1 } }
            //  { list: [ "item 1", "item 2", "item 3" ] }
            //  { choices: { "choice 1": 1, "choice 2": 2, "choice 3": 3 } }
            function Option(shortName, longName, type, defaultValue, description, config) {
                if (typeof config === "undefined") { config = null; }
                this.longName = longName;
                this.shortName = shortName;
                this.type = type;
                this.defaultValue = defaultValue;
                this.value = defaultValue;
                this.description = description;
                this.config = config;
            }
            Option.prototype.parse = function (value) {
                this.value = value;
            };
            Option.prototype.trace = function (writer) {
                writer.writeLn(("-" + this.shortName + "|--" + this.longName).padRight(" ", 30) + " = " + this.type + " " + this.value + " [" + this.defaultValue + "]" + " (" + this.description + ")");
            };
            return Option;
        })();
        Options.Option = Option;
    })(Shumway.Options || (Shumway.Options = {}));
    var Options = Shumway.Options;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    ///<reference path='references.ts' />
    (function (Settings) {
        Settings.ROOT = "Shumway Options";
        Settings.shumwayOptions = new Shumway.Options.OptionSet(Settings.ROOT, load());

        function isStorageSupported() {
            try  {
                return typeof window !== 'undefined' && "localStorage" in window && window["localStorage"] !== null;
            } catch (e) {
                return false;
            }
        }
        Settings.isStorageSupported = isStorageSupported;

        function load(key) {
            if (typeof key === "undefined") { key = Settings.ROOT; }
            var settings = {};
            if (isStorageSupported()) {
                var lsValue = window.localStorage[key];
                if (lsValue) {
                    try  {
                        settings = JSON.parse(lsValue);
                    } catch (e) {
                    }
                }
            }
            return settings;
        }
        Settings.load = load;

        function save(settings, key) {
            if (typeof settings === "undefined") { settings = null; }
            if (typeof key === "undefined") { key = Settings.ROOT; }
            if (isStorageSupported()) {
                try  {
                    window.localStorage[key] = JSON.stringify(settings ? settings : Settings.shumwayOptions.getSettings());
                } catch (e) {
                }
            }
        }
        Settings.save = save;

        function setSettings(settings) {
            Settings.shumwayOptions.setSettings(settings);
        }
        Settings.setSettings = setSettings;

        function getSettings(settings) {
            return Settings.shumwayOptions.getSettings();
        }
        Settings.getSettings = getSettings;
    })(Shumway.Settings || (Shumway.Settings = {}));
    var Settings = Shumway.Settings;
})(Shumway || (Shumway = {}));
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    ///<reference path='references.ts' />
    (function (Metrics) {
        var Timer = (function () {
            function Timer(parent, name) {
                this._parent = parent;
                this._timers = Shumway.ObjectUtilities.createMap();
                this._name = name;
                this._begin = 0;
                this._last = 0;
                this._total = 0;
                this._count = 0;
            }
            Timer.time = function (name, fn) {
                Timer.start(name);
                fn();
                Timer.stop();
            };
            Timer.start = function (name) {
                Timer._top = Timer._top._timers[name] || (Timer._top._timers[name] = new Timer(Timer._top, name));
                Timer._top.start();
                var tmp = Timer._flat._timers[name] || (Timer._flat._timers[name] = new Timer(Timer._flat, name));
                tmp.start();
                Timer._flatStack.push(tmp);
            };
            Timer.stop = function () {
                Timer._top.stop();
                Timer._top = Timer._top._parent;
                Timer._flatStack.pop().stop();
            };
            Timer.stopStart = function (name) {
                Timer.stop();
                Timer.start(name);
            };
            Timer.prototype.start = function () {
                this._begin = Shumway.getTicks();
            };
            Timer.prototype.stop = function () {
                this._last = Shumway.getTicks() - this._begin;
                this._total += this._last;
                this._count += 1;
            };
            Timer.prototype.toJSON = function () {
                return { name: this._name, total: this._total, timers: this._timers };
            };
            Timer.prototype.trace = function (writer) {
                writer.enter(this._name + ": " + this._total.toFixed(2) + " ms" + ", count: " + this._count + ", average: " + (this._total / this._count).toFixed(2) + " ms");
                for (var name in this._timers) {
                    this._timers[name].trace(writer);
                }
                writer.outdent();
            };
            Timer.trace = function (writer) {
                Timer._base.trace(writer);
                Timer._flat.trace(writer);
            };
            Timer._base = new Timer(null, "Total");
            Timer._top = Timer._base;
            Timer._flat = new Timer(null, "Flat");
            Timer._flatStack = [];
            return Timer;
        })();
        Metrics.Timer = Timer;

        /**
        * Quick way to count named events.
        */
        var Counter = (function () {
            function Counter(enabled) {
                this._enabled = enabled;
                this.clear();
            }
            Object.defineProperty(Counter.prototype, "counts", {
                get: function () {
                    return this._counts;
                },
                enumerable: true,
                configurable: true
            });

            Counter.prototype.setEnabled = function (enabled) {
                this._enabled = enabled;
            };
            Counter.prototype.clear = function () {
                this._counts = Shumway.ObjectUtilities.createMap();
                this._times = Shumway.ObjectUtilities.createMap();
            };
            Counter.prototype.toJSON = function () {
                return {
                    counts: this._counts,
                    times: this._times
                };
            };
            Counter.prototype.count = function (name, increment, time) {
                if (typeof increment === "undefined") { increment = 1; }
                if (typeof time === "undefined") { time = 0; }
                if (!this._enabled) {
                    return;
                }
                if (this._counts[name] === undefined) {
                    this._counts[name] = 0;
                    this._times[name] = 0;
                }
                this._counts[name] += increment;
                this._times[name] += time;
                return this._counts[name];
            };
            Counter.prototype.trace = function (writer) {
                for (var name in this._counts) {
                    writer.writeLn(name + ": " + this._counts[name]);
                }
            };
            Counter.prototype._pairToString = function (times, pair) {
                var name = pair[0];
                var count = pair[1];
                var time = times[name];
                var line = name + ": " + count;
                if (time) {
                    line += ", " + time.toFixed(4);
                    if (count > 1) {
                        line += " (" + (time / count).toFixed(4) + ")";
                    }
                }
                return line;
            };
            Counter.prototype.toStringSorted = function () {
                var self = this;
                var times = this._times;
                var pairs = [];
                for (var name in this._counts) {
                    pairs.push([name, this._counts[name]]);
                }
                pairs.sort(function (a, b) {
                    return b[1] - a[1];
                });
                return (pairs.map(function (pair) {
                    return self._pairToString(times, pair);
                }).join(", "));
            };
            Counter.prototype.traceSorted = function (writer, inline) {
                if (typeof inline === "undefined") { inline = false; }
                var self = this;
                var times = this._times;
                var pairs = [];
                for (var name in this._counts) {
                    pairs.push([name, this._counts[name]]);
                }
                pairs.sort(function (a, b) {
                    return b[1] - a[1];
                });
                if (inline) {
                    writer.writeLn(pairs.map(function (pair) {
                        return self._pairToString(times, pair);
                    }).join(", "));
                } else {
                    pairs.forEach(function (pair) {
                        writer.writeLn(self._pairToString(times, pair));
                    });
                }
            };
            Counter.instance = new Counter(true);
            return Counter;
        })();
        Metrics.Counter = Counter;

        var Average = (function () {
            function Average(max) {
                this._samples = new Float64Array(max);
                this._count = 0;
                this._index = 0;
            }
            Average.prototype.push = function (sample) {
                if (this._count < this._samples.length) {
                    this._count++;
                }
                this._index++;
                this._samples[this._index % this._samples.length] = sample;
            };
            Average.prototype.average = function () {
                var sum = 0;
                for (var i = 0; i < this._count; i++) {
                    sum += this._samples[i];
                }
                return sum / this._count;
            };
            return Average;
        })();
        Metrics.Average = Average;
    })(Shumway.Metrics || (Shumway.Metrics = {}));
    var Metrics = Shumway.Metrics;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    ///<reference path='references.ts' />
    (function (ArrayUtilities) {
        var notImplemented = Shumway.Debug.notImplemented;

        var utf8decode = Shumway.StringUtilities.utf8decode;
        var utf8encode = Shumway.StringUtilities.utf8encode;
        var clamp = Shumway.NumberUtilities.clamp;

        var swap32 = Shumway.IntegerUtilities.swap32;
        var floatToInt32 = Shumway.IntegerUtilities.floatToInt32;
        var int32ToFloat = Shumway.IntegerUtilities.int32ToFloat;

        function throwEOFError() {
            notImplemented("throwEOFError");
            // Runtime.throwErrorFromVM(AVM2.currentDomain(), "flash.errors.EOFError", "End of file was encountered.");
        }

        function throwRangeError() {
            notImplemented("throwRangeError");
            // var error = Errors.ParamRangeError;
            // Runtime.throwErrorFromVM("RangeError", getErrorMessage(error.code), error.code);
        }

        function throwCompressedDataError() {
            notImplemented("throwCompressedDataError");
            //    var error = Errors.CompressedDataError;
            //    Runtime.throwErrorFromVM("CompressedDataError", getErrorMessage(error.code), error.code);
        }

        function checkRange(x, min, max) {
            if (x !== clamp(x, min, max)) {
                throwRangeError();
            }
        }

        function asCoerceString(x) {
            if (typeof x === "string") {
                return x;
            } else if (x == undefined) {
                return null;
            }
            return x + '';
        }

        var PlainObjectDataBuffer = (function () {
            function PlainObjectDataBuffer(buffer, length, littleEndian) {
                this.buffer = buffer;
                this.length = length;
                this.littleEndian = littleEndian;
            }
            return PlainObjectDataBuffer;
        })();
        ArrayUtilities.PlainObjectDataBuffer = PlainObjectDataBuffer;

        var DataBuffer = (function () {
            function DataBuffer(initialSize) {
                if (typeof initialSize === "undefined") { initialSize = DataBuffer.INITIAL_SIZE; }
                this._buffer = new ArrayBuffer(initialSize);
                this._length = 0;
                this._position = 0;
                this._updateViews();
                this._littleEndian = false; // AS3 is bigEndian by default.
                this._bitBuffer = 0;
                this._bitLength = 0;
            }
            DataBuffer.FromArrayBuffer = function (buffer, length) {
                if (typeof length === "undefined") { length = -1; }
                var dataBuffer = Object.create(DataBuffer.prototype);
                dataBuffer._buffer = buffer;
                dataBuffer._length = length === -1 ? buffer.byteLength : length;
                dataBuffer._position = 0;
                dataBuffer._updateViews();
                dataBuffer._littleEndian = false; // AS3 is bigEndian by default.
                dataBuffer._bitBuffer = 0;
                dataBuffer._bitLength = 0;
                return dataBuffer;
            };

            DataBuffer.FromPlainObject = function (source) {
                var dataBuffer = DataBuffer.FromArrayBuffer(source.buffer, source.length);
                dataBuffer._littleEndian = source.littleEndian;
                return dataBuffer;
            };

            DataBuffer.prototype.toPlainObject = function () {
                return new PlainObjectDataBuffer(this._buffer, this._length, this._littleEndian);
            };

            DataBuffer.prototype._get = function (m, size) {
                if (this._position + size > this._length) {
                    throwEOFError();
                }
                var v = this._dataView[m](this._position, this._littleEndian);
                this._position += size;
                return v;
            };

            DataBuffer.prototype._set = function (m, size, v) {
                var length = this._position + size;
                this._ensureCapacity(length);
                this._dataView[m](this._position, v, this._littleEndian);
                this._position = length;
                if (length > this._length) {
                    this._length = length;
                }
            };

            DataBuffer.prototype._updateViews = function () {
                this._i8View = new Int8Array(this._buffer);
                this._u8View = new Uint8Array(this._buffer);
                if ((this._buffer.byteLength & 0x3) === 0) {
                    this._i32View = new Int32Array(this._buffer);
                }
                this._dataView = new DataView(this._buffer);
            };

            DataBuffer.prototype.getBytes = function () {
                return new Uint8Array(this._buffer, 0, this._length);
            };

            DataBuffer.prototype._ensureCapacity = function (length) {
                var currentBuffer = this._buffer;
                if (currentBuffer.byteLength < length) {
                    var newLength = Math.max(currentBuffer.byteLength, 1);
                    while (newLength < length) {
                        newLength *= 2;
                    }
                    var newBuffer = DataBuffer._arrayBufferPool.acquire(newLength);
                    var curentView = this._i8View;
                    this._buffer = newBuffer;
                    this._updateViews();
                    this._i8View.set(curentView);
                    DataBuffer._arrayBufferPool.release(currentBuffer);
                }
            };

            DataBuffer.prototype.clear = function () {
                this._length = 0;
                this._position = 0;
            };

            /**
            * For byte-sized reads and writes we can just go through the |Uint8Array| and not
            * the slower DataView.
            */
            DataBuffer.prototype.readBoolean = function () {
                if (this._position + 1 > this._length) {
                    throwEOFError();
                }
                return this._i8View[this._position++] !== 0;
            };

            DataBuffer.prototype.readByte = function () {
                if (this._position + 1 > this._length) {
                    throwEOFError();
                }
                return this._i8View[this._position++];
            };

            DataBuffer.prototype.readUnsignedByte = function () {
                if (this._position + 1 > this._length) {
                    throwEOFError();
                }
                return this._u8View[this._position++];
            };

            DataBuffer.prototype.readBytes = function (bytes, offset, length) {
                if (typeof offset === "undefined") { offset = 0; }
                if (typeof length === "undefined") { length = 0; }
                var pos = this._position;
                if (!offset) {
                    offset = 0;
                }
                if (!length) {
                    length = this._length - pos;
                }
                if (pos + length > this._length) {
                    throwEOFError();
                }
                if (bytes.length < offset + length) {
                    bytes._ensureCapacity(offset + length);
                    bytes.length = offset + length;
                }
                bytes._i8View.set(new Int8Array(this._buffer, pos, length), offset);
                this._position += length;
            };

            DataBuffer.prototype.readShort = function () {
                return this._get('getInt16', 2);
            };

            DataBuffer.prototype.readUnsignedShort = function () {
                return this._get('getUint16', 2);
            };

            DataBuffer.prototype.readInt = function () {
                if ((this._position & 0x3) === 0 && this._i32View) {
                    if (this._position + 4 > this._length) {
                        throwEOFError();
                    }
                    var value = this._i32View[this._position >> 2];
                    this._position += 4;
                    if (this._littleEndian !== DataBuffer._nativeLittleEndian) {
                        value = swap32(value);
                    }
                    return value;
                } else {
                    return this._get('getInt32', 4);
                }
            };

            DataBuffer.prototype.readUnsignedInt = function () {
                return this._get('getUint32', 4);
            };

            DataBuffer.prototype.readFloat = function () {
                if ((this._position & 0x3) === 0 && this._i32View) {
                    if (this._position + 4 > this._length) {
                        throwEOFError();
                    }
                    var bytes = this._i32View[this._position >> 2];
                    if (this._littleEndian !== DataBuffer._nativeLittleEndian) {
                        bytes = swap32(bytes);
                    }
                    var value = int32ToFloat(bytes);
                    this._position += 4;
                    return value;
                } else {
                    return this._get('getFloat32', 4);
                }
            };

            DataBuffer.prototype.readDouble = function () {
                return this._get('getFloat64', 8);
            };

            DataBuffer.prototype.writeBoolean = function (value) {
                value = !!value;
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._i8View[this._position++] = value ? 1 : 0;
                if (length > this._length) {
                    this._length = length;
                }
            };

            DataBuffer.prototype.writeByte = function (value /*int*/ ) {
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._i8View[this._position++] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };

            DataBuffer.prototype.writeUnsignedByte = function (value /*uint*/ ) {
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._u8View[this._position++] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };

            DataBuffer.prototype.writeRawBytes = function (bytes) {
                var length = this._position + bytes.length;
                this._ensureCapacity(length);
                this._i8View.set(bytes, this._position);
                this._position = length;
                if (length > this._length) {
                    this._length = length;
                }
            };

            DataBuffer.prototype.writeBytes = function (bytes, offset, length) {
                if (typeof offset === "undefined") { offset = 0; }
                if (typeof length === "undefined") { length = 0; }
                if (arguments.length < 2) {
                    offset = 0;
                }
                if (arguments.length < 3) {
                    length = 0;
                }
                checkRange(offset, 0, bytes.length);
                checkRange(offset + length, 0, bytes.length);
                if (length === 0) {
                    length = bytes.length - offset;
                }
                this.writeRawBytes(new Int8Array(bytes._buffer, offset, length));
            };

            DataBuffer.prototype.writeShort = function (value /*int*/ ) {
                this._set('setInt16', 2, value);
            };

            DataBuffer.prototype.writeUnsignedShort = function (value /*uint*/ ) {
                this._set('setUint16', 2, value);
            };

            DataBuffer.prototype.writeInt = function (value /*int*/ ) {
                if ((this._position & 0x3) === 0 && this._i32View) {
                    if (this._littleEndian !== DataBuffer._nativeLittleEndian) {
                        value = swap32(value);
                    }
                    var length = this._position + 4;
                    this._ensureCapacity(length);
                    this._i32View[this._position >> 2] = value;
                    this._position += 4;
                    if (length > this._length) {
                        this._length = length;
                    }
                } else {
                    this._set('setInt32', 4, value);
                }
            };

            DataBuffer.prototype.writeUnsignedInt = function (value /*uint*/ ) {
                this._set('setUint32', 4, value);
            };

            DataBuffer.prototype.writeFloat = function (value) {
                if ((this._position & 0x3) === 0 && this._i32View) {
                    var length = this._position + 4;
                    this._ensureCapacity(length);
                    var bytes = floatToInt32(value);
                    if (this._littleEndian !== DataBuffer._nativeLittleEndian) {
                        bytes = swap32(bytes);
                    }
                    this._i32View[this._position >> 2] = bytes;
                    this._position += 4;
                    if (length > this._length) {
                        this._length = length;
                    }
                } else {
                    this._set('setFloat32', 4, value);
                }
            };

            DataBuffer.prototype.writeDouble = function (value) {
                this._set('setFloat64', 8, value);
            };

            DataBuffer.prototype.readRawBytes = function () {
                return new Int8Array(this._buffer, 0, this._length);
            };

            DataBuffer.prototype.writeUTF = function (value) {
                value = asCoerceString(value);
                var bytes = utf8decode(value);
                this.writeShort(bytes.length);
                this.writeRawBytes(bytes);
            };

            DataBuffer.prototype.writeUTFBytes = function (value) {
                value = asCoerceString(value);
                var bytes = utf8decode(value);
                this.writeRawBytes(bytes);
            };

            DataBuffer.prototype.readUTF = function () {
                return this.readUTFBytes(this.readShort());
            };

            DataBuffer.prototype.readUTFBytes = function (length /*uint*/ ) {
                length = length >>> 0;
                var pos = this._position;
                if (pos + length > this._length) {
                    throwEOFError();
                }
                this._position += length;
                return utf8encode(new Int8Array(this._buffer, pos, length));
            };

            Object.defineProperty(DataBuffer.prototype, "length", {
                get: function () {
                    return this._length;
                },
                set: function (value /*uint*/ ) {
                    value = value >>> 0;
                    var capacity = this._buffer.byteLength;

                    /* XXX: Do we need to zero the difference if length <= cap? */
                    if (value > capacity) {
                        this._ensureCapacity(value);
                    }
                    this._length = value;
                    this._position = clamp(this._position, 0, this._length);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DataBuffer.prototype, "bytesAvailable", {
                get: function () {
                    return this._length - this._position;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DataBuffer.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (position /*uint*/ ) {
                    this._position = position >>> 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DataBuffer.prototype, "buffer", {
                get: function () {
                    return this._buffer;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DataBuffer.prototype, "bytes", {
                get: function () {
                    return this._u8View;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DataBuffer.prototype, "ints", {
                get: function () {
                    return this._i32View;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DataBuffer.prototype, "objectEncoding", {
                get: function () {
                    return this._objectEncoding;
                },
                set: function (version /*uint*/ ) {
                    version = version >>> 0;
                    this._objectEncoding = version;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DataBuffer.prototype, "endian", {
                get: function () {
                    return this._littleEndian ? "littleEndian" : "bigEndian";
                },
                set: function (type) {
                    type = asCoerceString(type);
                    if (type === "auto") {
                        this._littleEndian = DataBuffer._nativeLittleEndian;
                    } else {
                        this._littleEndian = type === "littleEndian";
                    }
                },
                enumerable: true,
                configurable: true
            });


            DataBuffer.prototype.toString = function () {
                return utf8encode(new Int8Array(this._buffer, 0, this._length));
            };

            DataBuffer.prototype.toBlob = function () {
                return new Blob([new Int8Array(this._buffer, this._position, this._length)]);
            };

            DataBuffer.prototype.writeMultiByte = function (value, charSet) {
                value = asCoerceString(value);
                charSet = asCoerceString(charSet);
                notImplemented("packageInternal flash.utils.ObjectOutput::writeMultiByte");
                return;
            };

            DataBuffer.prototype.readMultiByte = function (length /*uint*/ , charSet) {
                length = length >>> 0;
                charSet = asCoerceString(charSet);
                notImplemented("packageInternal flash.utils.ObjectInput::readMultiByte");
                return;
            };

            DataBuffer.prototype.getValue = function (name) {
                name = name | 0;
                if (name >= this._length) {
                    return undefined;
                }
                return this._u8View[name];
            };

            DataBuffer.prototype.setValue = function (name, value) {
                name = name | 0;
                var length = name + 1;
                this._ensureCapacity(length);
                this._u8View[name] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };

            /**
            * Construct tables lazily only if needed in order to avoid startup cost.
            */
            DataBuffer._initializeTables = function () {
                if (DataBuffer._codeLengthOrder) {
                    return;
                }

                DataBuffer._codeLengthOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                DataBuffer._distanceCodes = [];
                DataBuffer._distanceExtraBits = [];

                for (var i = 0, j = 0, code = 1; i < 30; ++i) {
                    DataBuffer._distanceCodes[i] = code;
                    code += 1 << (DataBuffer._distanceExtraBits[i] = ~~((j += (i > 2 ? 1 : 0)) / 2));
                }

                var bitLengths = [];
                for (var i = 0; i < 32; ++i) {
                    bitLengths[i] = 5;
                }

                DataBuffer._fixedDistanceTable = DataBuffer._makeHuffmanTable(bitLengths);

                DataBuffer._lengthCodes = [];
                DataBuffer._lengthExtraBits = [];
                for (var i = 0, j = 0, code = 3; i < 29; ++i) {
                    DataBuffer._lengthCodes[i] = code - (i == 28 ? 1 : 0);
                    code += 1 << (DataBuffer._lengthExtraBits[i] = ~~(((j += (i > 4 ? 1 : 0)) / 4) % 6));
                }

                for (var i = 0; i < 288; ++i) {
                    bitLengths[i] = i < 144 || i > 279 ? 8 : (i < 256 ? 9 : 7);
                }

                DataBuffer._fixedLiteralTable = DataBuffer._makeHuffmanTable(bitLengths);
            };

            DataBuffer._makeHuffmanTable = function (bitLengths) {
                var maxBits = Math.max.apply(null, bitLengths);
                var numLengths = bitLengths.length;
                var size = 1 << maxBits;
                var codes = new Uint32Array(size);
                for (var code = 0, len = 1, skip = 2; len <= maxBits; code <<= 1, ++len, skip <<= 1) {
                    for (var val = 0; val < numLengths; ++val) {
                        if (bitLengths[val] === len) {
                            var lsb = 0;
                            for (var i = 0; i < len; ++i) {
                                lsb = (lsb * 2) + ((code >> i) & 1);
                            }
                            for (var i = lsb; i < size; i += skip) {
                                codes[i] = (len << 16) | val;
                            }
                            ++code;
                        }
                    }
                }
                return { codes: codes, maxBits: maxBits };
            };

            DataBuffer.readBits = function (input, size) {
                var buffer = input._bitBuffer;
                var bufflen = input._bitLength;
                while (size > bufflen) {
                    buffer |= input.readUnsignedByte() << bufflen;
                    bufflen += 8;
                }
                input._bitBuffer = buffer >>> size;
                input._bitLength = bufflen - size;
                return buffer & ((1 << size) - 1);
            };

            DataBuffer.inflateBlock = function (input, output) {
                var readBits = DataBuffer.readBits;
                var header = readBits(input, 3);
                switch (header >> 1) {
                    case 0:
                        input._bitBuffer = input._bitLength = 0;
                        var len = input.readUnsignedShort();
                        var nlen = input.readUnsignedShort();

                        // release || assert((~nlen & 0xffff) === len, 'bad uncompressed block length', 'inflate');
                        if ((~nlen & 0xffff) !== len) {
                            throwCompressedDataError();
                        }
                        output.writeBytes(input, input.position, len);
                        input.position += len;
                        break;
                    case 1:
                        DataBuffer.inflate(input, output, DataBuffer._fixedLiteralTable, DataBuffer._fixedDistanceTable);
                        break;
                    case 2:
                        var bitLength = [];
                        var numLiteralCodes = readBits(input, 5) + 257;
                        var numDistanceCodes = readBits(input, 5) + 1;
                        var numCodes = numLiteralCodes + numDistanceCodes;
                        var numLengthCodes = readBits(input, 4) + 4;
                        for (var i = 0; i < 19; ++i) {
                            bitLength[DataBuffer._codeLengthOrder[i]] = i < numLengthCodes ? readBits(input, 3) : 0;
                        }
                        var codeLengthTable = DataBuffer._makeHuffmanTable(bitLength);
                        bitLength = [];
                        var i = 0;
                        var prev = 0;
                        while (i < numCodes) {
                            var j = 1;
                            var sym = DataBuffer.readCode(input, codeLengthTable);
                            switch (sym) {
                                case 16:
                                    j = readBits(input, 2) + 3;
                                    sym = prev;
                                    break;
                                case 17:
                                    j = readBits(input, 3) + 3;
                                    sym = 0;
                                    break;
                                case 18:
                                    j = readBits(input, 7) + 11;
                                    sym = 0;
                                    break;
                                default:
                                    prev = sym;
                            }
                            while (j--) {
                                bitLength[i++] = sym;
                            }
                        }
                        var distanceTable = DataBuffer._makeHuffmanTable(bitLength.splice(numLiteralCodes, numDistanceCodes));
                        var literalTable = DataBuffer._makeHuffmanTable(bitLength);
                        DataBuffer.inflate(input, output, literalTable, distanceTable);
                        break;
                    default:
                        Shumway.Debug.unexpected('unknown block type: inflate');
                }
            };

            DataBuffer.inflate = function (input, output, literalTable, distanceTable) {
                var readBits = DataBuffer.readBits;
                var readCode = DataBuffer.readCode;
                var lengthCodes = DataBuffer._lengthCodes;
                var lengthExtraBits = DataBuffer._lengthExtraBits;
                var distanceCodes = DataBuffer._distanceCodes;
                var distanceExtraBits = DataBuffer._distanceExtraBits;

                var sym;
                while ((sym = readCode(input, literalTable)) !== 256) {
                    if (sym < 256) {
                        output.writeUnsignedByte(sym);
                    } else {
                        sym -= 257;
                        var len = lengthCodes[sym] + readBits(input, lengthExtraBits[sym]);
                        sym = readCode(input, distanceTable);
                        var distance = distanceCodes[sym] + readBits(input, distanceExtraBits[sym]);
                        output.writeBytes(output, output.position - distance, len);
                    }
                }
            };

            DataBuffer.readCode = function (input, codeTable) {
                var buffer = input._bitBuffer;
                var bitlen = input._bitLength;
                var maxBits = codeTable.maxBits;
                while (maxBits > bitlen) {
                    buffer |= input.readUnsignedByte() << bitlen;
                    bitlen += 8;
                }
                var code = codeTable.codes[buffer & ((1 << maxBits) - 1)];
                var len = code >> 16;

                //release || assert(len, 'bad encoding', 'inflate');
                if (!len) {
                    throwCompressedDataError();
                }
                input._bitBuffer = buffer >>> len;
                input._bitLength = bitlen - len;
                return code & 0xffff;
            };

            DataBuffer.adler32 = function (data, start, end) {
                var a = 1;
                var b = 0;
                for (var i = start; i < end; ++i) {
                    a = (a + (data[i] & 0xff)) % 65521;
                    b = (b + a) % 65521;
                }
                return (b << 16) | a;
            };

            DataBuffer.prototype._compress = function (algorithm) {
                algorithm = asCoerceString(algorithm);
                DataBuffer._initializeTables();

                this._position = 0;
                var output = new DataBuffer();
                switch (algorithm) {
                    case 'zlib':
                        output.writeUnsignedByte(0x78);
                        output.writeUnsignedByte(0x9C);
                    case 'deflate':
                        output._littleEndian = true;

                        var len = this.length;

                        output._ensureCapacity(len + Math.ceil(len / 0xFFFF) * 5 + 4);

                        while (len > 0xFFFF) {
                            output.writeUnsignedByte(0x00);
                            output.writeUnsignedShort(0xFFFF);
                            output.writeUnsignedShort(0x0000);

                            output.writeBytes(this, this._position, 0xFFFF);
                            this._position += 0xFFFF;

                            len -= 0xFFFF;
                        }

                        output.writeUnsignedByte(0x00);
                        output.writeUnsignedShort(len);
                        output.writeUnsignedShort(~len & 0xffff);

                        output.writeBytes(this, this._position, len);

                        if (algorithm === 'zlib') {
                            output.writeUnsignedInt(DataBuffer.adler32(this._u8View, 0, this.length));
                        }
                        break;
                    default:
                        return;
                }

                this._ensureCapacity(output._u8View.length);
                this._u8View.set(output._u8View);
                this.length = output.length;
                this._position = 0;
            };

            DataBuffer.prototype._uncompress = function (algorithm) {
                algorithm = asCoerceString(algorithm);
                DataBuffer._initializeTables();

                var output = new DataBuffer();
                switch (algorithm) {
                    case 'zlib':
                        var header = this.readUnsignedShort();
                        if ((header & 0x0f00) !== 0x0800 || (header % 31) !== 0 || (header & 0x20)) {
                            throwCompressedDataError();
                        }
                    case 'deflate':
                        var littleEndian = this._littleEndian;
                        this._littleEndian = true;
                        while (this._position < this.length - 6) {
                            DataBuffer.inflateBlock(this, output);
                        }
                        this._littleEndian = littleEndian;
                        break;
                    default:
                        return;
                }

                this._ensureCapacity(output._u8View.length);
                this._u8View.set(output._u8View);
                this.length = output.length;
                this._position = 0;
            };
            DataBuffer._nativeLittleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;

            DataBuffer.INITIAL_SIZE = 128;

            DataBuffer._arrayBufferPool = new Shumway.ArrayBufferPool();

            DataBuffer._codeLengthOrder = null;
            DataBuffer._distanceCodes = null;
            DataBuffer._distanceExtraBits = null;

            DataBuffer._fixedLiteralTable = null;
            DataBuffer._fixedDistanceTable = null;

            DataBuffer._lengthCodes = null;
            DataBuffer._lengthExtraBits = null;
            return DataBuffer;
        })();
        ArrayUtilities.DataBuffer = DataBuffer;
    })(Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {}));
    var ArrayUtilities = Shumway.ArrayUtilities;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* Serialization format for shape data:
* (canonical, update this instead of anything else!)
*
* Shape data is serialized into a set of three buffers:
* - `commands`: a Uint8Array for commands
*  - valid values: [1-11] (i.e. one of the PathCommand enum values)
* - `coordinates`: an Int32Array for path coordinates*
*                  OR uint8 thickness iff the current command is PathCommand.LineStyleSolid
*  - valid values: the full range of 32bit numbers, representing x,y coordinates in twips
* - `styles`: a DataBuffer for style definitions
*  - valid values: structs for the various style definitions as described below
*
* (*: with one exception: to make various things faster, stroke widths are stored in the
* coordinates buffer, too.)
*
* All entries always contain all fields, default values aren't omitted.
*
* the various commands write the following sets of values into the various buffers:
*
* moveTo:
* commands:      PathCommand.MoveTo
* coordinates:   target x coordinate, in twips
*                target y coordinate, in twips
* styles:        n/a
*
* lineTo:
* commands:      PathCommand.LineTo
* coordinates:   target x coordinate, in twips
*                target y coordinate, in twips
* styles:        n/a
*
* curveTo:
* commands:      PathCommand.CurveTo
* coordinates:   control point x coordinate, in twips
*                control point y coordinate, in twips
*                target x coordinate, in twips
*                target y coordinate, in twips
* styles:        n/a
*
* cubicCurveTo:
* commands:      PathCommand.CubicCurveTo
* coordinates:   control point 1 x coordinate, in twips
*                control point 1 y coordinate, in twips
*                control point 2 x coordinate, in twips
*                control point 2 y coordinate, in twips
*                target x coordinate, in twips
*                target y coordinate, in twips
* styles:        n/a
*
* beginFill:
* commands:      PathCommand.BeginSolidFill
* coordinates:   n/a
* styles:        uint32 - RGBA color
*
* beginGradientFill:
* commands:      PathCommand.BeginGradientFill
* coordinates:   n/a
* Note: the style fields are ordered this way to optimize performance in the rendering backend
* Note: the style record has a variable length depending on the number of color stops
* styles:        uint8  - GradientType.{LINEAR,RADIAL}
*                fix8   - focalPoint [-128.0xff,127.0xff]
*                matrix - transform (see Matrix#writeExternal for details)
*                uint8  - colorStops (Number of color stop records that follow)
*                list of uint8,uint32 pairs:
*                    uint8  - ratio [0-0xff]
*                    uint32 - RGBA color
*                uint8  - SpreadMethod.{PAD,REFLECT,REPEAT}
*                uint8  - InterpolationMethod.{RGB,LINEAR_RGB}
*
* beginBitmapFill:
* commands:      PathCommand.BeginBitmapFill
* coordinates:   n/a
* styles:        uint32 - Index of the bitmapData object in the Graphics object's `textures`
*                         array
*                matrix - transform (see Matrix#writeExternal for details)
*                bool   - repeat
*                bool   - smooth
*
* lineStyle:
* commands:      PathCommand.LineStyleSolid
* coordinates:   uint32 - thickness (!)
* style:         uint32 - RGBA color
*                bool   - pixelHinting
*                uint8  - LineScaleMode, [0-3] see LineScaleMode.fromNumber for meaning
*                uint8  - CapsStyle, [0-2] see CapsStyle.fromNumber for meaning
*                uint8  - JointStyle, [0-2] see JointStyle.fromNumber for meaning
*                uint8  - miterLimit
*
* lineGradientStyle:
* commands:      PathCommand.LineStyleGradient
* coordinates:   n/a
* Note: the style fields are ordered this way to optimize performance in the rendering backend
* Note: the style record has a variable length depending on the number of color stops
* styles:        uint8  - GradientType.{LINEAR,RADIAL}
*                int8   - focalPoint [-128,127]
*                matrix - transform (see Matrix#writeExternal for details)
*                uint8  - colorStops (Number of color stop records that follow)
*                list of uint8,uint32 pairs:
*                    uint8  - ratio [0-0xff]
*                    uint32 - RGBA color
*                uint8  - SpreadMethod.{PAD,REFLECT,REPEAT}
*                uint8  - InterpolationMethod.{RGB,LINEAR_RGB}
*
* lineBitmapStyle:
* commands:      PathCommand.LineBitmapStyle
* coordinates:   n/a
* styles:        uint32 - Index of the bitmapData object in the Graphics object's `textures`
*                         array
*                matrix - transform (see Matrix#writeExternal for details)
*                bool   - repeat
*                bool   - smooth
*
* lineEnd:
* Note: emitted for invalid `lineStyle` calls
* commands:      PathCommand.LineEnd
* coordinates:   n/a
* styles:        n/a
*
*/
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var ensureTypedArrayCapacity = Shumway.ArrayUtilities.ensureTypedArrayCapacity;

    var assert = Shumway.Debug.assert;

    /**
    * Used for (de-)serializing Graphics path data in defineShape, flash.display.Graphics
    * and the renderer.
    */
    (function (PathCommand) {
        PathCommand[PathCommand["BeginSolidFill"] = 1] = "BeginSolidFill";
        PathCommand[PathCommand["BeginGradientFill"] = 2] = "BeginGradientFill";
        PathCommand[PathCommand["BeginBitmapFill"] = 3] = "BeginBitmapFill";
        PathCommand[PathCommand["EndFill"] = 4] = "EndFill";
        PathCommand[PathCommand["LineStyleSolid"] = 5] = "LineStyleSolid";
        PathCommand[PathCommand["LineStyleGradient"] = 6] = "LineStyleGradient";
        PathCommand[PathCommand["LineStyleBitmap"] = 7] = "LineStyleBitmap";
        PathCommand[PathCommand["LineEnd"] = 8] = "LineEnd";
        PathCommand[PathCommand["MoveTo"] = 9] = "MoveTo";
        PathCommand[PathCommand["LineTo"] = 10] = "LineTo";
        PathCommand[PathCommand["CurveTo"] = 11] = "CurveTo";
        PathCommand[PathCommand["CubicCurveTo"] = 12] = "CubicCurveTo";
    })(Shumway.PathCommand || (Shumway.PathCommand = {}));
    var PathCommand = Shumway.PathCommand;

    (function (GradientType) {
        GradientType[GradientType["Linear"] = 0x10] = "Linear";
        GradientType[GradientType["Radial"] = 0x12] = "Radial";
    })(Shumway.GradientType || (Shumway.GradientType = {}));
    var GradientType = Shumway.GradientType;

    (function (GradientSpreadMethod) {
        GradientSpreadMethod[GradientSpreadMethod["Pad"] = 0] = "Pad";
        GradientSpreadMethod[GradientSpreadMethod["Reflect"] = 1] = "Reflect";
        GradientSpreadMethod[GradientSpreadMethod["Repeat"] = 2] = "Repeat";
    })(Shumway.GradientSpreadMethod || (Shumway.GradientSpreadMethod = {}));
    var GradientSpreadMethod = Shumway.GradientSpreadMethod;

    (function (GradientInterpolationMethod) {
        GradientInterpolationMethod[GradientInterpolationMethod["RGB"] = 0] = "RGB";
        GradientInterpolationMethod[GradientInterpolationMethod["LinearRGB"] = 1] = "LinearRGB";
    })(Shumway.GradientInterpolationMethod || (Shumway.GradientInterpolationMethod = {}));
    var GradientInterpolationMethod = Shumway.GradientInterpolationMethod;

    var PlainObjectShapeData = (function () {
        function PlainObjectShapeData(commands, commandsPosition, coordinates, coordinatesPosition, morphCoordinates, styles, stylesLength) {
            this.commands = commands;
            this.commandsPosition = commandsPosition;
            this.coordinates = coordinates;
            this.coordinatesPosition = coordinatesPosition;
            this.morphCoordinates = morphCoordinates;
            this.styles = styles;
            this.stylesLength = stylesLength;
        }
        return PlainObjectShapeData;
    })();
    Shumway.PlainObjectShapeData = PlainObjectShapeData;

    var DefaultSize;
    (function (DefaultSize) {
        DefaultSize[DefaultSize["Commands"] = 32] = "Commands";
        DefaultSize[DefaultSize["Coordinates"] = 128] = "Coordinates";
        DefaultSize[DefaultSize["Styles"] = 16] = "Styles";
    })(DefaultSize || (DefaultSize = {}));

    var ShapeData = (function () {
        function ShapeData(initialize) {
            if (typeof initialize === "undefined") { initialize = true; }
            if (initialize) {
                this.clear();
            }
        }
        ShapeData.FromPlainObject = function (source) {
            var data = new ShapeData(false);
            data.commands = source.commands;
            data.coordinates = source.coordinates;
            data.morphCoordinates = source.morphCoordinates;
            data.commandsPosition = source.commandsPosition;
            data.coordinatesPosition = source.coordinatesPosition;
            data.styles = DataBuffer.FromArrayBuffer(source.styles, source.stylesLength);
            data.styles.endian = 'auto';
            return data;
        };

        ShapeData.prototype.moveTo = function (x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = 9 /* MoveTo */;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };

        ShapeData.prototype.lineTo = function (x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = 10 /* LineTo */;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };

        ShapeData.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
            this.ensurePathCapacities(1, 4);
            this.commands[this.commandsPosition++] = 11 /* CurveTo */;
            this.coordinates[this.coordinatesPosition++] = controlX;
            this.coordinates[this.coordinatesPosition++] = controlY;
            this.coordinates[this.coordinatesPosition++] = anchorX;
            this.coordinates[this.coordinatesPosition++] = anchorY;
        };

        ShapeData.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
            this.ensurePathCapacities(1, 6);
            this.commands[this.commandsPosition++] = 12 /* CubicCurveTo */;
            this.coordinates[this.coordinatesPosition++] = controlX1;
            this.coordinates[this.coordinatesPosition++] = controlY1;
            this.coordinates[this.coordinatesPosition++] = controlX2;
            this.coordinates[this.coordinatesPosition++] = controlY2;
            this.coordinates[this.coordinatesPosition++] = anchorX;
            this.coordinates[this.coordinatesPosition++] = anchorY;
        };

        ShapeData.prototype.beginFill = function (color) {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 1 /* BeginSolidFill */;
            this.styles.writeUnsignedInt(color);
        };

        ShapeData.prototype.endFill = function () {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 4 /* EndFill */;
        };

        ShapeData.prototype.endLine = function () {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 8 /* LineEnd */;
        };

        ShapeData.prototype.lineStyle = function (thickness, color, pixelHinting, scaleMode, caps, joints, miterLimit) {
            release || assert(thickness === (thickness | 0), thickness >= 0 && thickness <= 0xff * 20);
            this.ensurePathCapacities(2, 0);
            this.commands[this.commandsPosition++] = 5 /* LineStyleSolid */;
            this.coordinates[this.coordinatesPosition++] = thickness;
            var styles = this.styles;
            styles.writeUnsignedInt(color);
            styles.writeBoolean(pixelHinting);
            styles.writeUnsignedByte(scaleMode);
            styles.writeUnsignedByte(caps);
            styles.writeUnsignedByte(joints);
            styles.writeUnsignedByte(miterLimit);
        };

        /**
        * Bitmaps are specified the same for fills and strokes, so we only need to serialize them
        * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
        * be one of BeginBitmapFill and LineStyleBitmap.
        */
        ShapeData.prototype.beginBitmap = function (pathCommand, bitmapId, matrix, repeat, smooth) {
            release || assert(pathCommand === 3 /* BeginBitmapFill */ || pathCommand === 7 /* LineStyleBitmap */);

            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = pathCommand;
            var styles = this.styles;
            styles.writeUnsignedInt(bitmapId);
            this._writeStyleMatrix(matrix);
            styles.writeBoolean(repeat);
            styles.writeBoolean(smooth);
        };

        /**
        * Gradients are specified the same for fills and strokes, so we only need to serialize them
        * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
        * be one of BeginGradientFill and LineStyleGradient.
        */
        ShapeData.prototype.beginGradient = function (pathCommand, colors, ratios, gradientType, matrix, spread, interpolation, focalPointRatio) {
            release || assert(pathCommand === 2 /* BeginGradientFill */ || pathCommand === 6 /* LineStyleGradient */);

            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = pathCommand;
            var styles = this.styles;
            styles.writeUnsignedByte(gradientType);
            release || assert(focalPointRatio === (focalPointRatio | 0));
            styles.writeShort(focalPointRatio);

            this._writeStyleMatrix(matrix);

            var colorStops = colors.length;
            styles.writeByte(colorStops);
            for (var i = 0; i < colorStops; i++) {
                // Ratio must be valid, otherwise we'd have bailed above.
                styles.writeUnsignedByte(ratios[i]);

                // Colors are coerced to uint32, with the highest byte stripped.
                styles.writeUnsignedInt(colors[i]);
            }

            styles.writeUnsignedByte(spread);
            styles.writeUnsignedByte(interpolation);
        };

        ShapeData.prototype.writeCommandAndCoordinates = function (command, x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = command;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };

        ShapeData.prototype.writeCoordinates = function (x, y) {
            this.ensurePathCapacities(0, 2);
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };

        ShapeData.prototype.writeMorphCoordinates = function (x, y) {
            this.morphCoordinates = ensureTypedArrayCapacity(this.morphCoordinates, this.coordinatesPosition);
            this.morphCoordinates[this.coordinatesPosition - 2] = x;
            this.morphCoordinates[this.coordinatesPosition - 1] = y;
        };

        ShapeData.prototype.clear = function () {
            this.commandsPosition = this.coordinatesPosition = 0;
            this.commands = new Uint8Array(32 /* Commands */);
            this.coordinates = new Int32Array(128 /* Coordinates */);
            this.styles = new DataBuffer(16 /* Styles */);
            this.styles.endian = 'auto';
        };

        ShapeData.prototype.isEmpty = function () {
            return this.commandsPosition === 0;
        };

        ShapeData.prototype.clone = function () {
            var copy = new ShapeData(false);
            copy.commands = new Uint8Array(this.commands);
            copy.commandsPosition = this.commandsPosition;
            copy.coordinates = new Int32Array(this.coordinates);
            copy.coordinatesPosition = this.coordinatesPosition;
            copy.styles = new DataBuffer(this.styles.length);
            copy.styles.writeRawBytes(this.styles.bytes);
            return copy;
        };

        ShapeData.prototype.toPlainObject = function () {
            return new PlainObjectShapeData(this.commands, this.commandsPosition, this.coordinates, this.coordinatesPosition, this.morphCoordinates, this.styles.buffer, this.styles.length);
        };

        Object.defineProperty(ShapeData.prototype, "buffers", {
            get: function () {
                var buffers = [this.commands.buffer, this.coordinates.buffer, this.styles.buffer];
                if (this.morphCoordinates) {
                    buffers.push(this.morphCoordinates.buffer);
                }
                return buffers;
            },
            enumerable: true,
            configurable: true
        });

        ShapeData.prototype._writeStyleMatrix = function (matrix) {
            var styles = this.styles;
            styles.writeFloat(matrix.a);
            styles.writeFloat(matrix.b);
            styles.writeFloat(matrix.c);
            styles.writeFloat(matrix.d);
            styles.writeFloat(matrix.tx);
            styles.writeFloat(matrix.ty);
        };

        ShapeData.prototype.ensurePathCapacities = function (numCommands, numCoordinates) {
            // ensureTypedArrayCapacity will hopefully be inlined, in which case the field writes
            // will be optimized out.
            this.commands = ensureTypedArrayCapacity(this.commands, this.commandsPosition + numCommands);
            this.coordinates = ensureTypedArrayCapacity(this.coordinates, this.coordinatesPosition + numCoordinates);
        };
        return ShapeData;
    })();
    Shumway.ShapeData = ShapeData;
})(Shumway || (Shumway = {}));
/* -*- Mode: js, js-indent-level: 2, indent-tabs-mode: nil, tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License"),
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        (function (Parser) {
            (function (SwfTag) {
                SwfTag[SwfTag["CODE_END"] = 0] = "CODE_END";
                SwfTag[SwfTag["CODE_SHOW_FRAME"] = 1] = "CODE_SHOW_FRAME";
                SwfTag[SwfTag["CODE_DEFINE_SHAPE"] = 2] = "CODE_DEFINE_SHAPE";
                SwfTag[SwfTag["CODE_FREE_CHARACTER"] = 3] = "CODE_FREE_CHARACTER";
                SwfTag[SwfTag["CODE_PLACE_OBJECT"] = 4] = "CODE_PLACE_OBJECT";
                SwfTag[SwfTag["CODE_REMOVE_OBJECT"] = 5] = "CODE_REMOVE_OBJECT";
                SwfTag[SwfTag["CODE_DEFINE_BITS"] = 6] = "CODE_DEFINE_BITS";
                SwfTag[SwfTag["CODE_DEFINE_BUTTON"] = 7] = "CODE_DEFINE_BUTTON";
                SwfTag[SwfTag["CODE_JPEG_TABLES"] = 8] = "CODE_JPEG_TABLES";
                SwfTag[SwfTag["CODE_SET_BACKGROUND_COLOR"] = 9] = "CODE_SET_BACKGROUND_COLOR";
                SwfTag[SwfTag["CODE_DEFINE_FONT"] = 10] = "CODE_DEFINE_FONT";
                SwfTag[SwfTag["CODE_DEFINE_TEXT"] = 11] = "CODE_DEFINE_TEXT";
                SwfTag[SwfTag["CODE_DO_ACTION"] = 12] = "CODE_DO_ACTION";
                SwfTag[SwfTag["CODE_DEFINE_FONT_INFO"] = 13] = "CODE_DEFINE_FONT_INFO";
                SwfTag[SwfTag["CODE_DEFINE_SOUND"] = 14] = "CODE_DEFINE_SOUND";
                SwfTag[SwfTag["CODE_START_SOUND"] = 15] = "CODE_START_SOUND";
                SwfTag[SwfTag["CODE_STOP_SOUND"] = 16] = "CODE_STOP_SOUND";
                SwfTag[SwfTag["CODE_DEFINE_BUTTON_SOUND"] = 17] = "CODE_DEFINE_BUTTON_SOUND";
                SwfTag[SwfTag["CODE_SOUND_STREAM_HEAD"] = 18] = "CODE_SOUND_STREAM_HEAD";
                SwfTag[SwfTag["CODE_SOUND_STREAM_BLOCK"] = 19] = "CODE_SOUND_STREAM_BLOCK";
                SwfTag[SwfTag["CODE_DEFINE_BITS_LOSSLESS"] = 20] = "CODE_DEFINE_BITS_LOSSLESS";
                SwfTag[SwfTag["CODE_DEFINE_BITS_JPEG2"] = 21] = "CODE_DEFINE_BITS_JPEG2";
                SwfTag[SwfTag["CODE_DEFINE_SHAPE2"] = 22] = "CODE_DEFINE_SHAPE2";
                SwfTag[SwfTag["CODE_DEFINE_BUTTON_CXFORM"] = 23] = "CODE_DEFINE_BUTTON_CXFORM";
                SwfTag[SwfTag["CODE_PROTECT"] = 24] = "CODE_PROTECT";
                SwfTag[SwfTag["CODE_PATHS_ARE_POSTSCRIPT"] = 25] = "CODE_PATHS_ARE_POSTSCRIPT";
                SwfTag[SwfTag["CODE_PLACE_OBJECT2"] = 26] = "CODE_PLACE_OBJECT2";

                // INVALID                             = 27,
                SwfTag[SwfTag["CODE_REMOVE_OBJECT2"] = 28] = "CODE_REMOVE_OBJECT2";
                SwfTag[SwfTag["CODE_SYNC_FRAME"] = 29] = "CODE_SYNC_FRAME";

                // INVALID                             = 30,
                SwfTag[SwfTag["CODE_FREE_ALL"] = 31] = "CODE_FREE_ALL";
                SwfTag[SwfTag["CODE_DEFINE_SHAPE3"] = 32] = "CODE_DEFINE_SHAPE3";
                SwfTag[SwfTag["CODE_DEFINE_TEXT2"] = 33] = "CODE_DEFINE_TEXT2";
                SwfTag[SwfTag["CODE_DEFINE_BUTTON2"] = 34] = "CODE_DEFINE_BUTTON2";
                SwfTag[SwfTag["CODE_DEFINE_BITS_JPEG3"] = 35] = "CODE_DEFINE_BITS_JPEG3";
                SwfTag[SwfTag["CODE_DEFINE_BITS_LOSSLESS2"] = 36] = "CODE_DEFINE_BITS_LOSSLESS2";
                SwfTag[SwfTag["CODE_DEFINE_EDIT_TEXT"] = 37] = "CODE_DEFINE_EDIT_TEXT";
                SwfTag[SwfTag["CODE_DEFINE_VIDEO"] = 38] = "CODE_DEFINE_VIDEO";
                SwfTag[SwfTag["CODE_DEFINE_SPRITE"] = 39] = "CODE_DEFINE_SPRITE";
                SwfTag[SwfTag["CODE_NAME_CHARACTER"] = 40] = "CODE_NAME_CHARACTER";
                SwfTag[SwfTag["CODE_PRODUCT_INFO"] = 41] = "CODE_PRODUCT_INFO";
                SwfTag[SwfTag["CODE_DEFINE_TEXT_FORMAT"] = 42] = "CODE_DEFINE_TEXT_FORMAT";
                SwfTag[SwfTag["CODE_FRAME_LABEL"] = 43] = "CODE_FRAME_LABEL";
                SwfTag[SwfTag["CODE_DEFINE_BEHAVIOUR"] = 44] = "CODE_DEFINE_BEHAVIOUR";
                SwfTag[SwfTag["CODE_SOUND_STREAM_HEAD2"] = 45] = "CODE_SOUND_STREAM_HEAD2";
                SwfTag[SwfTag["CODE_DEFINE_MORPH_SHAPE"] = 46] = "CODE_DEFINE_MORPH_SHAPE";
                SwfTag[SwfTag["CODE_FRAME_TAG"] = 47] = "CODE_FRAME_TAG";
                SwfTag[SwfTag["CODE_DEFINE_FONT2"] = 48] = "CODE_DEFINE_FONT2";
                SwfTag[SwfTag["CODE_GEN_COMMAND"] = 49] = "CODE_GEN_COMMAND";
                SwfTag[SwfTag["CODE_DEFINE_COMMAND_OBJ"] = 50] = "CODE_DEFINE_COMMAND_OBJ";
                SwfTag[SwfTag["CODE_CHARACTER_SET"] = 51] = "CODE_CHARACTER_SET";
                SwfTag[SwfTag["CODE_FONT_REF"] = 52] = "CODE_FONT_REF";
                SwfTag[SwfTag["CODE_DEFINE_FUNCTION"] = 53] = "CODE_DEFINE_FUNCTION";
                SwfTag[SwfTag["CODE_PLACE_FUNCTION"] = 54] = "CODE_PLACE_FUNCTION";
                SwfTag[SwfTag["CODE_GEN_TAG_OBJECTS"] = 55] = "CODE_GEN_TAG_OBJECTS";
                SwfTag[SwfTag["CODE_EXPORT_ASSETS"] = 56] = "CODE_EXPORT_ASSETS";
                SwfTag[SwfTag["CODE_IMPORT_ASSETS"] = 57] = "CODE_IMPORT_ASSETS";
                SwfTag[SwfTag["CODE_ENABLE_DEBUGGER"] = 58] = "CODE_ENABLE_DEBUGGER";
                SwfTag[SwfTag["CODE_DO_INIT_ACTION"] = 59] = "CODE_DO_INIT_ACTION";
                SwfTag[SwfTag["CODE_DEFINE_VIDEO_STREAM"] = 60] = "CODE_DEFINE_VIDEO_STREAM";
                SwfTag[SwfTag["CODE_VIDEO_FRAME"] = 61] = "CODE_VIDEO_FRAME";
                SwfTag[SwfTag["CODE_DEFINE_FONT_INFO2"] = 62] = "CODE_DEFINE_FONT_INFO2";
                SwfTag[SwfTag["CODE_DEBUG_ID"] = 63] = "CODE_DEBUG_ID";
                SwfTag[SwfTag["CODE_ENABLE_DEBUGGER2"] = 64] = "CODE_ENABLE_DEBUGGER2";
                SwfTag[SwfTag["CODE_SCRIPT_LIMITS"] = 65] = "CODE_SCRIPT_LIMITS";
                SwfTag[SwfTag["CODE_SET_TAB_INDEX"] = 66] = "CODE_SET_TAB_INDEX";

                // CODE_DEFINE_SHAPE4                  = 67,
                // INVALID                             = 68,
                SwfTag[SwfTag["CODE_FILE_ATTRIBUTES"] = 69] = "CODE_FILE_ATTRIBUTES";
                SwfTag[SwfTag["CODE_PLACE_OBJECT3"] = 70] = "CODE_PLACE_OBJECT3";
                SwfTag[SwfTag["CODE_IMPORT_ASSETS2"] = 71] = "CODE_IMPORT_ASSETS2";
                SwfTag[SwfTag["CODE_DO_ABC_"] = 72] = "CODE_DO_ABC_";
                SwfTag[SwfTag["CODE_DEFINE_FONT_ALIGN_ZONES"] = 73] = "CODE_DEFINE_FONT_ALIGN_ZONES";
                SwfTag[SwfTag["CODE_CSM_TEXT_SETTINGS"] = 74] = "CODE_CSM_TEXT_SETTINGS";
                SwfTag[SwfTag["CODE_DEFINE_FONT3"] = 75] = "CODE_DEFINE_FONT3";
                SwfTag[SwfTag["CODE_SYMBOL_CLASS"] = 76] = "CODE_SYMBOL_CLASS";
                SwfTag[SwfTag["CODE_METADATA"] = 77] = "CODE_METADATA";
                SwfTag[SwfTag["CODE_DEFINE_SCALING_GRID"] = 78] = "CODE_DEFINE_SCALING_GRID";

                // INVALID                             = 79,
                // INVALID                             = 80,
                // INVALID                             = 81,
                SwfTag[SwfTag["CODE_DO_ABC"] = 82] = "CODE_DO_ABC";
                SwfTag[SwfTag["CODE_DEFINE_SHAPE4"] = 83] = "CODE_DEFINE_SHAPE4";
                SwfTag[SwfTag["CODE_DEFINE_MORPH_SHAPE2"] = 84] = "CODE_DEFINE_MORPH_SHAPE2";

                // INVALID                             = 85,
                SwfTag[SwfTag["CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA"] = 86] = "CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA";
                SwfTag[SwfTag["CODE_DEFINE_BINARY_DATA"] = 87] = "CODE_DEFINE_BINARY_DATA";
                SwfTag[SwfTag["CODE_DEFINE_FONT_NAME"] = 88] = "CODE_DEFINE_FONT_NAME";
                SwfTag[SwfTag["CODE_START_SOUND2"] = 89] = "CODE_START_SOUND2";
                SwfTag[SwfTag["CODE_DEFINE_BITS_JPEG4"] = 90] = "CODE_DEFINE_BITS_JPEG4";
                SwfTag[SwfTag["CODE_DEFINE_FONT4"] = 91] = "CODE_DEFINE_FONT4";
            })(Parser.SwfTag || (Parser.SwfTag = {}));
            var SwfTag = Parser.SwfTag;

            (function (PlaceObjectFlags) {
                PlaceObjectFlags[PlaceObjectFlags["Reserved"] = 0x800] = "Reserved";
                PlaceObjectFlags[PlaceObjectFlags["OpaqueBackground"] = 0x400] = "OpaqueBackground";
                PlaceObjectFlags[PlaceObjectFlags["HasVisible"] = 0x200] = "HasVisible";
                PlaceObjectFlags[PlaceObjectFlags["HasImage"] = 0x100] = "HasImage";
                PlaceObjectFlags[PlaceObjectFlags["HasClassName"] = 0x800] = "HasClassName";
                PlaceObjectFlags[PlaceObjectFlags["HasCacheAsBitmap"] = 0x400] = "HasCacheAsBitmap";
                PlaceObjectFlags[PlaceObjectFlags["HasBlendMode"] = 0x200] = "HasBlendMode";
                PlaceObjectFlags[PlaceObjectFlags["HasFilterList"] = 0x100] = "HasFilterList";
                PlaceObjectFlags[PlaceObjectFlags["HasClipActions"] = 0x080] = "HasClipActions";
                PlaceObjectFlags[PlaceObjectFlags["HasClipDepth"] = 0x040] = "HasClipDepth";
                PlaceObjectFlags[PlaceObjectFlags["HasName"] = 0x020] = "HasName";
                PlaceObjectFlags[PlaceObjectFlags["HasRatio"] = 0x010] = "HasRatio";
                PlaceObjectFlags[PlaceObjectFlags["HasColorTransform"] = 0x008] = "HasColorTransform";
                PlaceObjectFlags[PlaceObjectFlags["HasMatrix"] = 0x004] = "HasMatrix";
                PlaceObjectFlags[PlaceObjectFlags["HasCharacter"] = 0x002] = "HasCharacter";
                PlaceObjectFlags[PlaceObjectFlags["Move"] = 0x001] = "Move";
            })(Parser.PlaceObjectFlags || (Parser.PlaceObjectFlags = {}));
            var PlaceObjectFlags = Parser.PlaceObjectFlags;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    var unexpected = Shumway.Debug.unexpected;

    var BinaryFileReader = (function () {
        function BinaryFileReader(url, method, mimeType, data) {
            this.url = url;
            this.method = method;
            this.mimeType = mimeType;
            this.data = data;
        }
        BinaryFileReader.prototype.readAll = function (progress, complete) {
            var url = this.url;
            var xhr = new XMLHttpRequest({ mozSystem: true });
            var async = true;
            xhr.open(this.method || "GET", this.url, async);
            xhr.responseType = "arraybuffer";
            if (progress) {
                xhr.onprogress = function (event) {
                    progress(xhr.response, event.loaded, event.total);
                };
            }
            xhr.onreadystatechange = function (event) {
                if (xhr.readyState === 4) {
                    if (xhr.status !== 200 && xhr.status !== 0 || xhr.response === null) {
                        unexpected("Path: " + url + " not found.");
                        complete(null, xhr.statusText);
                        return;
                    }
                    complete(xhr.response);
                }
            };
            if (this.mimeType) {
                xhr.setRequestHeader("Content-Type", this.mimeType);
            }
            xhr.send(this.data || null);
        };

        BinaryFileReader.prototype.readAsync = function (ondata, onerror, onopen, oncomplete, onhttpstatus) {
            var xhr = new XMLHttpRequest({ mozSystem: true });
            var url = this.url;
            xhr.open(this.method || "GET", url, true);
            xhr.responseType = 'moz-chunked-arraybuffer';
            var isNotProgressive = xhr.responseType !== 'moz-chunked-arraybuffer';
            if (isNotProgressive) {
                xhr.responseType = 'arraybuffer';
            }
            xhr.onprogress = function (e) {
                if (isNotProgressive)
                    return;
                ondata(new Uint8Array(xhr.response), { loaded: e.loaded, total: e.total });
            };
            xhr.onreadystatechange = function (event) {
                if (xhr.readyState === 2 && onhttpstatus) {
                    onhttpstatus(url, xhr.status, xhr.getAllResponseHeaders());
                }
                if (xhr.readyState === 4) {
                    if (xhr.status !== 200 && xhr.status !== 0 || xhr.response === null) {
                        onerror(xhr.statusText);
                        return;
                    }
                    if (isNotProgressive) {
                        var buffer = xhr.response;
                        ondata(new Uint8Array(buffer), { loaded: 0, total: buffer.byteLength });
                    }
                    if (oncomplete) {
                        oncomplete();
                    }
                }
            };
            if (this.mimeType) {
                xhr.setRequestHeader("Content-Type", this.mimeType);
            }
            xhr.send(this.data || null);
            if (onopen) {
                onopen();
            }
        };
        return BinaryFileReader;
    })();
    Shumway.BinaryFileReader = BinaryFileReader;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    /**
    * Copyright 2014 Mozilla Foundation
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    (function (Remoting) {
        /**
        * Remoting phases.
        */
        (function (RemotingPhase) {
            /**
            * Objects are serialized. During this phase all reachable remotable objects (all objects
            * reachable from a root set) that are dirty are remoted. This includes all dirty object
            * properties except for dirty references.
            */
            RemotingPhase[RemotingPhase["Objects"] = 0] = "Objects";

            /**
            * Object references are serialized. All objects that are referred to have already been
            * remoted at this point.
            */
            RemotingPhase[RemotingPhase["References"] = 1] = "References";
        })(Remoting.RemotingPhase || (Remoting.RemotingPhase = {}));
        var RemotingPhase = Remoting.RemotingPhase;

        (function (MessageBits) {
            MessageBits[MessageBits["HasMatrix"] = 0x0001] = "HasMatrix";
            MessageBits[MessageBits["HasBounds"] = 0x0002] = "HasBounds";
            MessageBits[MessageBits["HasChildren"] = 0x0004] = "HasChildren";
            MessageBits[MessageBits["HasColorTransform"] = 0x0008] = "HasColorTransform";
            MessageBits[MessageBits["HasClipRect"] = 0x0010] = "HasClipRect";
            MessageBits[MessageBits["HasMiscellaneousProperties"] = 0x0020] = "HasMiscellaneousProperties";
            MessageBits[MessageBits["HasMask"] = 0x0040] = "HasMask";
            MessageBits[MessageBits["HasClip"] = 0x0080] = "HasClip";
        })(Remoting.MessageBits || (Remoting.MessageBits = {}));
        var MessageBits = Remoting.MessageBits;

        (function (IDMask) {
            IDMask[IDMask["None"] = 0x00000000] = "None";
            IDMask[IDMask["Asset"] = 0x08000000] = "Asset";
        })(Remoting.IDMask || (Remoting.IDMask = {}));
        var IDMask = Remoting.IDMask;

        /**
        * Serialization Format. All commands start with a message tag.
        */
        (function (MessageTag) {
            MessageTag[MessageTag["EOF"] = 0] = "EOF";

            /**
            * id                   int32,
            * hasBits              int32,
            * matrix               Matrix,
            * colorMatrix          ColorMatrix,
            * mask                 int32,
            * misc
            *   blendMode          int32,
            *   visible            int32
            *
            * @type {number}
            */
            MessageTag[MessageTag["UpdateFrame"] = 100] = "UpdateFrame";
            MessageTag[MessageTag["UpdateGraphics"] = 101] = "UpdateGraphics";
            MessageTag[MessageTag["UpdateBitmapData"] = 102] = "UpdateBitmapData";
            MessageTag[MessageTag["UpdateTextContent"] = 103] = "UpdateTextContent";
            MessageTag[MessageTag["UpdateStage"] = 104] = "UpdateStage";
            MessageTag[MessageTag["RequestBitmapData"] = 105] = "RequestBitmapData";

            MessageTag[MessageTag["RegisterFont"] = 200] = "RegisterFont";
            MessageTag[MessageTag["DrawToBitmap"] = 201] = "DrawToBitmap";

            MessageTag[MessageTag["MouseEvent"] = 300] = "MouseEvent";
            MessageTag[MessageTag["KeyboardEvent"] = 301] = "KeyboardEvent";
            MessageTag[MessageTag["FocusEvent"] = 302] = "FocusEvent";
        })(Remoting.MessageTag || (Remoting.MessageTag = {}));
        var MessageTag = Remoting.MessageTag;

        /**
        * Dictates how color transforms are encoded. The majority of color transforms are
        * either identity or only modify the alpha multiplier, so we can encode these more
        * efficiently.
        */
        (function (ColorTransformEncoding) {
            /**
            * Identity, no need to serialize all the fields.
            */
            ColorTransformEncoding[ColorTransformEncoding["Identity"] = 0] = "Identity";

            /**
            * Identity w/ AlphaMultiplier, only the alpha multiplier is serialized.
            */
            ColorTransformEncoding[ColorTransformEncoding["AlphaMultiplierOnly"] = 1] = "AlphaMultiplierOnly";

            /**
            * All fields are serialized.
            */
            ColorTransformEncoding[ColorTransformEncoding["All"] = 2] = "All";
        })(Remoting.ColorTransformEncoding || (Remoting.ColorTransformEncoding = {}));
        var ColorTransformEncoding = Remoting.ColorTransformEncoding;

        Remoting.MouseEventNames = [
            'click',
            'dblclick',
            'mousedown',
            'mousemove',
            'mouseup'
        ];

        Remoting.KeyboardEventNames = [
            'keydown',
            'keypress',
            'keyup'
        ];

        (function (KeyboardEventFlags) {
            KeyboardEventFlags[KeyboardEventFlags["CtrlKey"] = 0x0001] = "CtrlKey";
            KeyboardEventFlags[KeyboardEventFlags["AltKey"] = 0x0002] = "AltKey";
            KeyboardEventFlags[KeyboardEventFlags["ShiftKey"] = 0x0004] = "ShiftKey";
        })(Remoting.KeyboardEventFlags || (Remoting.KeyboardEventFlags = {}));
        var KeyboardEventFlags = Remoting.KeyboardEventFlags;

        (function (FocusEventType) {
            FocusEventType[FocusEventType["DocumentHidden"] = 0] = "DocumentHidden";
            FocusEventType[FocusEventType["DocumentVisible"] = 1] = "DocumentVisible";
            FocusEventType[FocusEventType["WindowBlur"] = 2] = "WindowBlur";
            FocusEventType[FocusEventType["WindowFocus"] = 3] = "WindowFocus";
        })(Remoting.FocusEventType || (Remoting.FocusEventType = {}));
        var FocusEventType = Remoting.FocusEventType;
    })(Shumway.Remoting || (Shumway.Remoting = {}));
    var Remoting = Shumway.Remoting;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
///<reference path='es6-promises.d.ts' />
///<reference path='utilities.ts' />
///<reference path='options.ts' />
///<reference path='settings.ts'/>
///<reference path='metrics.ts' />
///<reference path='dataBuffer.ts' />
///<reference path='ShapeData.ts' />
///<reference path='SWFTags.ts' />
///<reference path='binaryFileReader.ts' />
///<reference path='remoting.ts' />
//# sourceMappingURL=base.js.map

var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Theme) {
            var UI = (function () {
                function UI() {
                }
                UI.toRGBA = function (r, g, b, a) {
                    if (typeof a === "undefined") { a = 1; }
                    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
                };
                return UI;
            })();
            Theme.UI = UI;

            var UIThemeDark = (function () {
                function UIThemeDark() {
                }
                // Chrome Colors
                UIThemeDark.prototype.tabToolbar = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(37, 44, 51, a);
                };
                UIThemeDark.prototype.toolbars = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(52, 60, 69, a);
                };
                UIThemeDark.prototype.selectionBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(29, 79, 115, a);
                };
                UIThemeDark.prototype.selectionText = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(245, 247, 250, a);
                };
                UIThemeDark.prototype.splitters = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(0, 0, 0, a);
                };

                // Content Colors
                UIThemeDark.prototype.bodyBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(17, 19, 21, a);
                };
                UIThemeDark.prototype.sidebarBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(24, 29, 32, a);
                };
                UIThemeDark.prototype.attentionBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(161, 134, 80, a);
                };

                // Text Colors
                UIThemeDark.prototype.bodyText = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(143, 161, 178, a);
                };
                UIThemeDark.prototype.foregroundTextGrey = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(182, 186, 191, a);
                };
                UIThemeDark.prototype.contentTextHighContrast = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(169, 186, 203, a);
                };
                UIThemeDark.prototype.contentTextGrey = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(143, 161, 178, a);
                };
                UIThemeDark.prototype.contentTextDarkGrey = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(95, 115, 135, a);
                };

                // Highlight Colors
                UIThemeDark.prototype.blueHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(70, 175, 227, a);
                };
                UIThemeDark.prototype.purpleHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(107, 122, 187, a);
                };
                UIThemeDark.prototype.pinkHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(223, 128, 255, a);
                };
                UIThemeDark.prototype.redHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(235, 83, 104, a);
                };
                UIThemeDark.prototype.orangeHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(217, 102, 41, a);
                };
                UIThemeDark.prototype.lightOrangeHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(217, 155, 40, a);
                };
                UIThemeDark.prototype.greenHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(112, 191, 83, a);
                };
                UIThemeDark.prototype.blueGreyHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(94, 136, 176, a);
                };
                return UIThemeDark;
            })();
            Theme.UIThemeDark = UIThemeDark;

            var UIThemeLight = (function () {
                function UIThemeLight() {
                }
                // Chrome Colors
                UIThemeLight.prototype.tabToolbar = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(235, 236, 237, a);
                };
                UIThemeLight.prototype.toolbars = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(240, 241, 242, a);
                };
                UIThemeLight.prototype.selectionBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(76, 158, 217, a);
                };
                UIThemeLight.prototype.selectionText = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(245, 247, 250, a);
                };
                UIThemeLight.prototype.splitters = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(170, 170, 170, a);
                };

                // Content Colors
                UIThemeLight.prototype.bodyBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(252, 252, 252, a);
                };
                UIThemeLight.prototype.sidebarBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(247, 247, 247, a);
                };
                UIThemeLight.prototype.attentionBackground = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(161, 134, 80, a);
                };

                // Text Colors
                UIThemeLight.prototype.bodyText = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(24, 25, 26, a);
                };
                UIThemeLight.prototype.foregroundTextGrey = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(88, 89, 89, a);
                };
                UIThemeLight.prototype.contentTextHighContrast = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(41, 46, 51, a);
                };
                UIThemeLight.prototype.contentTextGrey = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(143, 161, 178, a);
                };
                UIThemeLight.prototype.contentTextDarkGrey = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(102, 115, 128, a);
                };

                // Highlight Colors
                UIThemeLight.prototype.blueHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(0, 136, 204, a);
                };
                UIThemeLight.prototype.purpleHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(91, 95, 255, a);
                };
                UIThemeLight.prototype.pinkHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(184, 46, 229, a);
                };
                UIThemeLight.prototype.redHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(237, 38, 85, a);
                };
                UIThemeLight.prototype.orangeHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(241, 60, 0, a);
                };
                UIThemeLight.prototype.lightOrangeHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(217, 126, 0, a);
                };
                UIThemeLight.prototype.greenHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(44, 187, 15, a);
                };
                UIThemeLight.prototype.blueGreyHighlight = function (a) {
                    if (typeof a === "undefined") { a = 1; }
                    return UI.toRGBA(95, 136, 176, a);
                };
                return UIThemeLight;
            })();
            Theme.UIThemeLight = UIThemeLight;
        })(Tools.Theme || (Tools.Theme = {}));
        var Theme = Tools.Theme;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var Profile = (function () {
                function Profile(buffers) {
                    this._buffers = buffers || [];
                    this._snapshots = [];
                    this._maxDepth = 0;
                }
                Profile.prototype.addBuffer = function (buffer) {
                    this._buffers.push(buffer);
                };

                Profile.prototype.getSnapshotAt = function (index) {
                    return this._snapshots[index];
                };

                Object.defineProperty(Profile.prototype, "hasSnapshots", {
                    get: function () {
                        return (this.snapshotCount > 0);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "snapshotCount", {
                    get: function () {
                        return this._snapshots.length;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "startTime", {
                    get: function () {
                        return this._startTime;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "endTime", {
                    get: function () {
                        return this._endTime;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "totalTime", {
                    get: function () {
                        return this.endTime - this.startTime;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "windowStart", {
                    get: function () {
                        return this._windowStart;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "windowEnd", {
                    get: function () {
                        return this._windowEnd;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "windowLength", {
                    get: function () {
                        return this.windowEnd - this.windowStart;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Profile.prototype, "maxDepth", {
                    get: function () {
                        return this._maxDepth;
                    },
                    enumerable: true,
                    configurable: true
                });

                Profile.prototype.forEachSnapshot = function (visitor) {
                    for (var i = 0, n = this.snapshotCount; i < n; i++) {
                        visitor(this._snapshots[i], i);
                    }
                };

                Profile.prototype.createSnapshots = function () {
                    var startTime = Number.MAX_VALUE;
                    var endTime = Number.MIN_VALUE;
                    var maxDepth = 0;
                    this._snapshots = [];
                    while (this._buffers.length > 0) {
                        var buffer = this._buffers.shift();
                        var snapshot = buffer.createSnapshot();
                        if (snapshot) {
                            if (startTime > snapshot.startTime) {
                                startTime = snapshot.startTime;
                            }
                            if (endTime < snapshot.endTime) {
                                endTime = snapshot.endTime;
                            }
                            if (maxDepth < snapshot.maxDepth) {
                                maxDepth = snapshot.maxDepth;
                            }
                            this._snapshots.push(snapshot);
                        }
                    }
                    this._startTime = startTime;
                    this._endTime = endTime;
                    this._windowStart = startTime;
                    this._windowEnd = endTime;
                    this._maxDepth = maxDepth;
                };

                Profile.prototype.setWindow = function (start, end) {
                    if (start > end) {
                        var tmp = start;
                        start = end;
                        end = tmp;
                    }
                    var length = Math.min(end - start, this.totalTime);
                    if (start < this._startTime) {
                        start = this._startTime;
                        end = this._startTime + length;
                    } else if (end > this._endTime) {
                        start = this._endTime - length;
                        end = this._endTime;
                    }
                    this._windowStart = start;
                    this._windowEnd = end;
                };

                Profile.prototype.moveWindowTo = function (time) {
                    this.setWindow(time - this.windowLength / 2, time + this.windowLength / 2);
                };
                return Profile;
            })();
            Profiler.Profile = Profile;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var TimelineFrameStatistics = (function () {
                function TimelineFrameStatistics(kind) {
                    this.kind = kind;
                    this.count = 0;
                    this.selfTime = 0;
                    this.totalTime = 0;
                }
                return TimelineFrameStatistics;
            })();
            Profiler.TimelineFrameStatistics = TimelineFrameStatistics;

            /**
            * Represents a single timeline frame range and makes it easier to work with the compacted
            * timeline buffer data.
            */
            var TimelineFrame = (function () {
                function TimelineFrame(parent, kind, startData, endData, startTime, endTime) {
                    this.parent = parent;
                    this.kind = kind;
                    this.startData = startData;
                    this.endData = endData;
                    this.startTime = startTime;
                    this.endTime = endTime;
                    this.maxDepth = 0;
                }
                Object.defineProperty(TimelineFrame.prototype, "totalTime", {
                    get: function () {
                        return this.endTime - this.startTime;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TimelineFrame.prototype, "selfTime", {
                    get: function () {
                        var selfTime = this.totalTime;
                        if (this.children) {
                            for (var i = 0, n = this.children.length; i < n; i++) {
                                var child = this.children[i];
                                selfTime -= (child.endTime - child.startTime);
                            }
                        }
                        return selfTime;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Gets the child index of the first child to overlap the specified time.
                */
                TimelineFrame.prototype.getChildIndex = function (time) {
                    var children = this.children;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.endTime > time) {
                            return i;
                        }
                    }
                    return 0;
                };

                /**
                * Gets the high and low index of the children that intersect the specified time range.
                */
                TimelineFrame.prototype.getChildRange = function (startTime, endTime) {
                    if (this.children && startTime <= this.endTime && endTime >= this.startTime && endTime >= startTime) {
                        var startIdx = this._getNearestChild(startTime);
                        var endIdx = this._getNearestChildReverse(endTime);
                        if (startIdx <= endIdx) {
                            var startTime = this.children[startIdx].startTime;
                            var endTime = this.children[endIdx].endTime;
                            return {
                                startIndex: startIdx,
                                endIndex: endIdx,
                                startTime: startTime,
                                endTime: endTime,
                                totalTime: endTime - startTime
                            };
                        }
                    }
                    return null;
                };

                TimelineFrame.prototype._getNearestChild = function (time) {
                    var children = this.children;
                    if (children && children.length) {
                        if (time <= children[0].endTime) {
                            return 0;
                        }
                        var imid;
                        var imin = 0;
                        var imax = children.length - 1;
                        while (imax > imin) {
                            imid = ((imin + imax) / 2) | 0;
                            var child = children[imid];
                            if (time >= child.startTime && time <= child.endTime) {
                                return imid;
                            } else if (time > child.endTime) {
                                imin = imid + 1;
                            } else {
                                imax = imid;
                            }
                        }
                        return Math.ceil((imin + imax) / 2);
                    } else {
                        return 0;
                    }
                };

                TimelineFrame.prototype._getNearestChildReverse = function (time) {
                    var children = this.children;
                    if (children && children.length) {
                        var imax = children.length - 1;
                        if (time >= children[imax].startTime) {
                            return imax;
                        }
                        var imid;
                        var imin = 0;
                        while (imax > imin) {
                            imid = Math.ceil((imin + imax) / 2);
                            var child = children[imid];
                            if (time >= child.startTime && time <= child.endTime) {
                                return imid;
                            } else if (time > child.endTime) {
                                imin = imid;
                            } else {
                                imax = imid - 1;
                            }
                        }
                        return ((imin + imax) / 2) | 0;
                    } else {
                        return 0;
                    }
                };

                /**
                * Finds the deepest child that intersects with the specified time.
                */
                TimelineFrame.prototype.query = function (time) {
                    if (time < this.startTime || time > this.endTime) {
                        return null;
                    }
                    var children = this.children;
                    if (children && children.length > 0) {
                        var child;
                        var imin = 0;
                        var imax = children.length - 1;
                        while (imax > imin) {
                            var imid = ((imin + imax) / 2) | 0;
                            child = children[imid];
                            if (time >= child.startTime && time <= child.endTime) {
                                return child.query(time);
                            } else if (time > child.endTime) {
                                imin = imid + 1;
                            } else {
                                imax = imid;
                            }
                        }
                        child = children[imax];
                        if (time >= child.startTime && time <= child.endTime) {
                            return child.query(time);
                        }
                    }
                    return this;
                };

                /**
                * When querying a series of samples, if the deepest child for the previous time is known,
                * it is faster to go up the tree from there, until a frame is found that contains the next time,
                * and then go back down.
                *
                * More often than not we don't have to start at the very top.
                */
                TimelineFrame.prototype.queryNext = function (time) {
                    var frame = this;
                    while (time > frame.endTime) {
                        if (frame.parent) {
                            frame = frame.parent;
                        } else {
                            return frame.query(time);
                        }
                    }
                    return frame.query(time);
                };

                /**
                * Gets this frame's distance to the root.
                */
                TimelineFrame.prototype.getDepth = function () {
                    var depth = 0;
                    var self = this;
                    while (self) {
                        depth++;
                        self = self.parent;
                    }
                    return depth;
                };

                TimelineFrame.prototype.calculateStatistics = function () {
                    var statistics = this.statistics = [];
                    function visit(frame) {
                        if (frame.kind) {
                            var s = statistics[frame.kind.id] || (statistics[frame.kind.id] = new TimelineFrameStatistics(frame.kind));
                            s.count++;
                            s.selfTime += frame.selfTime;
                            s.totalTime += frame.totalTime;
                        }
                        if (frame.children) {
                            frame.children.forEach(visit);
                        }
                    }
                    visit(this);
                };
                return TimelineFrame;
            })();
            Profiler.TimelineFrame = TimelineFrame;

            var TimelineBufferSnapshot = (function (_super) {
                __extends(TimelineBufferSnapshot, _super);
                function TimelineBufferSnapshot(name) {
                    _super.call(this, null, null, null, null, NaN, NaN);
                    this.name = name;
                }
                return TimelineBufferSnapshot;
            })(TimelineFrame);
            Profiler.TimelineBufferSnapshot = TimelineBufferSnapshot;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

            /**
            * Records enter / leave events in two circular buffers.
            * The goal here is to be able to handle large amounts of data.
            */
            var TimelineBuffer = (function () {
                function TimelineBuffer(name, startTime) {
                    if (typeof name === "undefined") { name = ""; }
                    this.name = name || "";
                    this._startTime = Shumway.isNullOrUndefined(startTime) ? performance.now() : startTime;
                }
                TimelineBuffer.prototype.getKind = function (kind) {
                    return this._kinds[kind];
                };

                Object.defineProperty(TimelineBuffer.prototype, "kinds", {
                    get: function () {
                        return this._kinds.concat();
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TimelineBuffer.prototype, "depth", {
                    get: function () {
                        return this._depth;
                    },
                    enumerable: true,
                    configurable: true
                });

                TimelineBuffer.prototype._initialize = function () {
                    this._depth = 0;
                    this._stack = [];
                    this._data = [];
                    this._kinds = [];
                    this._kindNameMap = createEmptyObject();
                    this._marks = new Shumway.CircularBuffer(Int32Array, 20);
                    this._times = new Shumway.CircularBuffer(Float64Array, 20);
                };

                TimelineBuffer.prototype._getKindId = function (name) {
                    var kindId = TimelineBuffer.MAX_KINDID;
                    if (this._kindNameMap[name] === undefined) {
                        kindId = this._kinds.length;
                        if (kindId < TimelineBuffer.MAX_KINDID) {
                            var kind = {
                                id: kindId,
                                name: name,
                                visible: true
                            };
                            this._kinds.push(kind);
                            this._kindNameMap[name] = kind;
                        } else {
                            kindId = TimelineBuffer.MAX_KINDID;
                        }
                    } else {
                        kindId = this._kindNameMap[name].id;
                    }
                    return kindId;
                };

                TimelineBuffer.prototype._getMark = function (type, kindId, data) {
                    var dataId = TimelineBuffer.MAX_DATAID;
                    if (!Shumway.isNullOrUndefined(data) && kindId !== TimelineBuffer.MAX_KINDID) {
                        dataId = this._data.length;
                        if (dataId < TimelineBuffer.MAX_DATAID) {
                            this._data.push(data);
                        } else {
                            dataId = TimelineBuffer.MAX_DATAID;
                        }
                    }
                    return type | (dataId << 16) | kindId;
                };

                TimelineBuffer.prototype.enter = function (name, data, time) {
                    time = (Shumway.isNullOrUndefined(time) ? performance.now() : time) - this._startTime;
                    if (!this._marks) {
                        this._initialize();
                    }
                    this._depth++;
                    var kindId = this._getKindId(name);
                    this._marks.write(this._getMark(TimelineBuffer.ENTER, kindId, data));
                    this._times.write(time);
                    this._stack.push(kindId);
                };

                TimelineBuffer.prototype.leave = function (name, data, time) {
                    time = (Shumway.isNullOrUndefined(time) ? performance.now() : time) - this._startTime;
                    var kindId = this._stack.pop();
                    if (name) {
                        kindId = this._getKindId(name);
                    }
                    this._marks.write(this._getMark(TimelineBuffer.LEAVE, kindId, data));
                    this._times.write(time);
                    this._depth--;
                };

                TimelineBuffer.prototype.count = function (name, value, data) {
                    // Not Implemented
                };

                /**
                * Constructs an easier to work with TimelineFrame data structure.
                */
                TimelineBuffer.prototype.createSnapshot = function (count) {
                    if (typeof count === "undefined") { count = Number.MAX_VALUE; }
                    if (!this._marks) {
                        return null;
                    }
                    var times = this._times;
                    var kinds = this._kinds;
                    var datastore = this._data;
                    var snapshot = new Profiler.TimelineBufferSnapshot(this.name);
                    var stack = [snapshot];
                    var topLevelFrameCount = 0;

                    if (!this._marks) {
                        this._initialize();
                    }

                    this._marks.forEachInReverse(function (mark, i) {
                        var dataId = (mark >>> 16) & TimelineBuffer.MAX_DATAID;
                        var data = datastore[dataId];
                        var kindId = mark & TimelineBuffer.MAX_KINDID;
                        var kind = kinds[kindId];
                        if (Shumway.isNullOrUndefined(kind) || kind.visible) {
                            var action = mark & 0x80000000;
                            var time = times.get(i);
                            var stackLength = stack.length;
                            if (action === TimelineBuffer.LEAVE) {
                                if (stackLength === 1) {
                                    topLevelFrameCount++;
                                    if (topLevelFrameCount > count) {
                                        return true;
                                    }
                                }
                                stack.push(new Profiler.TimelineFrame(stack[stackLength - 1], kind, null, data, NaN, time));
                            } else if (action === TimelineBuffer.ENTER) {
                                var node = stack.pop();
                                var top = stack[stack.length - 1];
                                if (top) {
                                    if (!top.children) {
                                        top.children = [node];
                                    } else {
                                        top.children.unshift(node);
                                    }
                                    var currentDepth = stack.length;
                                    node.depth = currentDepth;
                                    node.startData = data;
                                    node.startTime = time;
                                    while (node) {
                                        if (node.maxDepth < currentDepth) {
                                            node.maxDepth = currentDepth;
                                            node = node.parent;
                                        } else {
                                            break;
                                        }
                                    }
                                } else {
                                    return true;
                                }
                            }
                        }
                    });
                    if (snapshot.children && snapshot.children.length) {
                        snapshot.startTime = snapshot.children[0].startTime;
                        snapshot.endTime = snapshot.children[snapshot.children.length - 1].endTime;
                    }
                    return snapshot;
                };

                TimelineBuffer.prototype.reset = function (startTime) {
                    this._startTime = Shumway.isNullOrUndefined(startTime) ? performance.now() : startTime;
                    if (!this._marks) {
                        this._initialize();
                        return;
                    }
                    this._depth = 0;
                    this._data = [];
                    this._marks.reset();
                    this._times.reset();
                };

                TimelineBuffer.FromFirefoxProfile = function (profile, name) {
                    var samples = profile.profile.threads[0].samples;
                    var buffer = new TimelineBuffer(name, samples[0].time);
                    var currentStack = [];
                    var sample;
                    for (var i = 0; i < samples.length; i++) {
                        sample = samples[i];
                        var time = sample.time;
                        var stack = sample.frames;
                        var j = 0;
                        var minStackLen = Math.min(stack.length, currentStack.length);
                        while (j < minStackLen && stack[j].location === currentStack[j].location) {
                            j++;
                        }
                        var leaveCount = currentStack.length - j;
                        for (var k = 0; k < leaveCount; k++) {
                            sample = currentStack.pop();
                            buffer.leave(sample.location, null, time);
                        }
                        while (j < stack.length) {
                            sample = stack[j++];
                            buffer.enter(sample.location, null, time);
                        }
                        currentStack = stack;
                    }
                    while (sample = currentStack.pop()) {
                        buffer.leave(sample.location, null, time);
                    }
                    return buffer;
                };

                TimelineBuffer.FromChromeProfile = function (profile, name) {
                    var timestamps = profile.timestamps;
                    var samples = profile.samples;
                    var buffer = new TimelineBuffer(name, timestamps[0] / 1000);
                    var currentStack = [];
                    var idMap = {};
                    var sample;
                    TimelineBuffer._resolveIds(profile.head, idMap);
                    for (var i = 0; i < timestamps.length; i++) {
                        var time = timestamps[i] / 1000;
                        var stack = [];
                        sample = idMap[samples[i]];
                        while (sample) {
                            stack.unshift(sample);
                            sample = sample.parent;
                        }
                        var j = 0;
                        var minStackLen = Math.min(stack.length, currentStack.length);
                        while (j < minStackLen && stack[j] === currentStack[j]) {
                            j++;
                        }
                        var leaveCount = currentStack.length - j;
                        for (var k = 0; k < leaveCount; k++) {
                            sample = currentStack.pop();
                            buffer.leave(sample.functionName, null, time);
                        }
                        while (j < stack.length) {
                            sample = stack[j++];
                            buffer.enter(sample.functionName, null, time);
                        }
                        currentStack = stack;
                    }
                    while (sample = currentStack.pop()) {
                        buffer.leave(sample.functionName, null, time);
                    }
                    return buffer;
                };

                TimelineBuffer._resolveIds = function (parent, idMap) {
                    idMap[parent.id] = parent;
                    if (parent.children) {
                        for (var i = 0; i < parent.children.length; i++) {
                            parent.children[i].parent = parent;
                            TimelineBuffer._resolveIds(parent.children[i], idMap);
                        }
                    }
                };
                TimelineBuffer.ENTER = 0 << 31;
                TimelineBuffer.LEAVE = 1 << 31;

                TimelineBuffer.MAX_KINDID = 0xffff;
                TimelineBuffer.MAX_DATAID = 0x7fff;
                return TimelineBuffer;
            })();
            Profiler.TimelineBuffer = TimelineBuffer;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            (function (UIThemeType) {
                UIThemeType[UIThemeType["DARK"] = 0] = "DARK";
                UIThemeType[UIThemeType["LIGHT"] = 1] = "LIGHT";
            })(Profiler.UIThemeType || (Profiler.UIThemeType = {}));
            var UIThemeType = Profiler.UIThemeType;

            var Controller = (function () {
                function Controller(container, themeType) {
                    if (typeof themeType === "undefined") { themeType = 0 /* DARK */; }
                    this._container = container;
                    this._headers = [];
                    this._charts = [];
                    this._profiles = [];
                    this._activeProfile = null;
                    this.themeType = themeType;
                    this._tooltip = this._createTooltip();
                }
                Controller.prototype.createProfile = function (buffers, activate) {
                    if (typeof activate === "undefined") { activate = true; }
                    var profile = new Profiler.Profile(buffers);
                    profile.createSnapshots();
                    this._profiles.push(profile);
                    if (activate) {
                        this.activateProfile(profile);
                    }
                    return profile;
                };

                Controller.prototype.activateProfile = function (profile) {
                    this.deactivateProfile();
                    this._activeProfile = profile;
                    this._createViews();
                    this._initializeViews();
                };

                Controller.prototype.activateProfileAt = function (index) {
                    this.activateProfile(this.getProfileAt(index));
                };

                Controller.prototype.deactivateProfile = function () {
                    if (this._activeProfile) {
                        this._destroyViews();
                        this._activeProfile = null;
                    }
                };

                Controller.prototype.resize = function () {
                    this._onResize();
                };

                Controller.prototype.getProfileAt = function (index) {
                    return this._profiles[index];
                };

                Object.defineProperty(Controller.prototype, "activeProfile", {
                    get: function () {
                        return this._activeProfile;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Controller.prototype, "profileCount", {
                    get: function () {
                        return this._profiles.length;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Controller.prototype, "container", {
                    get: function () {
                        return this._container;
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(Controller.prototype, "themeType", {
                    get: function () {
                        return this._themeType;
                    },
                    set: function (value) {
                        switch (value) {
                            case 0 /* DARK */:
                                this._theme = new Tools.Theme.UIThemeDark();
                                break;
                            case 1 /* LIGHT */:
                                this._theme = new Tools.Theme.UIThemeLight();
                                break;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Controller.prototype, "theme", {
                    get: function () {
                        return this._theme;
                    },
                    enumerable: true,
                    configurable: true
                });

                Controller.prototype.getSnapshotAt = function (index) {
                    return this._activeProfile.getSnapshotAt(index);
                };

                Controller.prototype._createViews = function () {
                    if (this._activeProfile) {
                        var self = this;
                        this._overviewHeader = new Profiler.FlameChartHeader(this, 0 /* OVERVIEW */);
                        this._overview = new Profiler.FlameChartOverview(this, 0 /* OVERLAY */);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self._headers.push(new Profiler.FlameChartHeader(self, 1 /* CHART */));
                            self._charts.push(new Profiler.FlameChart(self, snapshot));
                        });
                        window.addEventListener("resize", this._onResize.bind(this));
                    }
                };

                Controller.prototype._destroyViews = function () {
                    if (this._activeProfile) {
                        this._overviewHeader.destroy();
                        this._overview.destroy();
                        while (this._headers.length) {
                            this._headers.pop().destroy();
                        }
                        while (this._charts.length) {
                            this._charts.pop().destroy();
                        }
                        window.removeEventListener("resize", this._onResize.bind(this));
                    }
                };

                Controller.prototype._initializeViews = function () {
                    if (this._activeProfile) {
                        var self = this;
                        var startTime = this._activeProfile.startTime;
                        var endTime = this._activeProfile.endTime;
                        this._overviewHeader.initialize(startTime, endTime);
                        this._overview.initialize(startTime, endTime);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self._headers[index].initialize(startTime, endTime);
                            self._charts[index].initialize(startTime, endTime);
                        });
                    }
                };

                Controller.prototype._onResize = function () {
                    if (this._activeProfile) {
                        var self = this;
                        var width = this._container.offsetWidth;
                        this._overviewHeader.setSize(width);
                        this._overview.setSize(width);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self._headers[index].setSize(width);
                            self._charts[index].setSize(width);
                        });
                    }
                };

                Controller.prototype._updateViews = function () {
                    if (this._activeProfile) {
                        var self = this;
                        var start = this._activeProfile.windowStart;
                        var end = this._activeProfile.windowEnd;
                        this._overviewHeader.setWindow(start, end);
                        this._overview.setWindow(start, end);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self._headers[index].setWindow(start, end);
                            self._charts[index].setWindow(start, end);
                        });
                    }
                };

                Controller.prototype._drawViews = function () {
                    /*
                    var self = this;
                    this._overviewHeader.draw();
                    this._overview.setWindow(start, end);
                    this._profile.forEachBuffer(function(buffer: TimelineBufferSnapshot, index: number) {
                    self._headers[index].setWindow(start, end);
                    self._charts[index].setWindow(start, end);
                    });
                    */
                };

                Controller.prototype._createTooltip = function () {
                    var el = document.createElement("div");
                    el.classList.add("profiler-tooltip");
                    el.style.display = "none";
                    this._container.insertBefore(el, this._container.firstChild);
                    return el;
                };

                /**
                * View callbacks
                */
                Controller.prototype.setWindow = function (start, end) {
                    this._activeProfile.setWindow(start, end);
                    this._updateViews();
                };

                Controller.prototype.moveWindowTo = function (time) {
                    this._activeProfile.moveWindowTo(time);
                    this._updateViews();
                };

                Controller.prototype.showTooltip = function (chart, frame, x, y) {
                    this.removeTooltipContent();
                    this._tooltip.appendChild(this.createTooltipContent(chart, frame));
                    this._tooltip.style.display = "block";
                    var elContent = this._tooltip.firstChild;
                    var tooltipWidth = elContent.clientWidth;
                    var tooltipHeight = elContent.clientHeight;
                    var totalWidth = chart.canvas.clientWidth;
                    x += (x + tooltipWidth >= totalWidth - 50) ? -(tooltipWidth + 20) : 25;
                    y += chart.canvas.offsetTop - tooltipHeight / 2;
                    this._tooltip.style.left = x + "px";
                    this._tooltip.style.top = y + "px";
                };

                Controller.prototype.hideTooltip = function () {
                    this._tooltip.style.display = "none";
                };

                Controller.prototype.createTooltipContent = function (chart, frame) {
                    var totalTime = Math.round(frame.totalTime * 100000) / 100000;
                    var selfTime = Math.round(frame.selfTime * 100000) / 100000;
                    var selfPercent = Math.round(frame.selfTime * 100 * 100 / frame.totalTime) / 100;

                    var elContent = document.createElement("div");

                    var elName = document.createElement("h1");
                    elName.textContent = frame.kind.name;
                    elContent.appendChild(elName);

                    var elTotalTime = document.createElement("p");
                    elTotalTime.textContent = "Total: " + totalTime + " ms";
                    elContent.appendChild(elTotalTime);

                    var elSelfTime = document.createElement("p");
                    elSelfTime.textContent = "Self: " + selfTime + " ms (" + selfPercent + "%)";
                    elContent.appendChild(elSelfTime);

                    var statistics = chart.getStatistics(frame.kind);

                    if (statistics) {
                        var elAllCount = document.createElement("p");
                        elAllCount.textContent = "Count: " + statistics.count;
                        elContent.appendChild(elAllCount);

                        var allTotalTime = Math.round(statistics.totalTime * 100000) / 100000;
                        var elAllTotalTime = document.createElement("p");
                        elAllTotalTime.textContent = "All Total: " + allTotalTime + " ms";
                        elContent.appendChild(elAllTotalTime);

                        var allSelfTime = Math.round(statistics.selfTime * 100000) / 100000;
                        var elAllSelfTime = document.createElement("p");
                        elAllSelfTime.textContent = "All Self: " + allSelfTime + " ms";
                        elContent.appendChild(elAllSelfTime);
                    }

                    this.appendDataElements(elContent, frame.startData);
                    this.appendDataElements(elContent, frame.endData);

                    return elContent;
                };

                Controller.prototype.appendDataElements = function (el, data) {
                    if (!Shumway.isNullOrUndefined(data)) {
                        el.appendChild(document.createElement("hr"));
                        var elData;
                        if (Shumway.isObject(data)) {
                            for (var key in data) {
                                elData = document.createElement("p");
                                elData.textContent = key + ": " + data[key];
                                el.appendChild(elData);
                            }
                        } else {
                            elData = document.createElement("p");
                            elData.textContent = data.toString();
                            el.appendChild(elData);
                        }
                    }
                };

                Controller.prototype.removeTooltipContent = function () {
                    var el = this._tooltip;
                    while (el.firstChild) {
                        el.removeChild(el.firstChild);
                    }
                };
                return Controller;
            })();
            Profiler.Controller = Controller;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var clamp = Shumway.NumberUtilities.clamp;

            var MouseCursor = (function () {
                function MouseCursor(value) {
                    this.value = value;
                }
                MouseCursor.prototype.toString = function () {
                    return this.value;
                };
                MouseCursor.AUTO = new MouseCursor("auto");
                MouseCursor.DEFAULT = new MouseCursor("default");
                MouseCursor.NONE = new MouseCursor("none");
                MouseCursor.HELP = new MouseCursor("help");
                MouseCursor.POINTER = new MouseCursor("pointer");
                MouseCursor.PROGRESS = new MouseCursor("progress");
                MouseCursor.WAIT = new MouseCursor("wait");
                MouseCursor.CELL = new MouseCursor("cell");
                MouseCursor.CROSSHAIR = new MouseCursor("crosshair");
                MouseCursor.TEXT = new MouseCursor("text");
                MouseCursor.ALIAS = new MouseCursor("alias");
                MouseCursor.COPY = new MouseCursor("copy");
                MouseCursor.MOVE = new MouseCursor("move");
                MouseCursor.NO_DROP = new MouseCursor("no-drop");
                MouseCursor.NOT_ALLOWED = new MouseCursor("not-allowed");
                MouseCursor.ALL_SCROLL = new MouseCursor("all-scroll");
                MouseCursor.COL_RESIZE = new MouseCursor("col-resize");
                MouseCursor.ROW_RESIZE = new MouseCursor("row-resize");
                MouseCursor.N_RESIZE = new MouseCursor("n-resize");
                MouseCursor.E_RESIZE = new MouseCursor("e-resize");
                MouseCursor.S_RESIZE = new MouseCursor("s-resize");
                MouseCursor.W_RESIZE = new MouseCursor("w-resize");
                MouseCursor.NE_RESIZE = new MouseCursor("ne-resize");
                MouseCursor.NW_RESIZE = new MouseCursor("nw-resize");
                MouseCursor.SE_RESIZE = new MouseCursor("se-resize");
                MouseCursor.SW_RESIZE = new MouseCursor("sw-resize");
                MouseCursor.EW_RESIZE = new MouseCursor("ew-resize");
                MouseCursor.NS_RESIZE = new MouseCursor("ns-resize");
                MouseCursor.NESW_RESIZE = new MouseCursor("nesw-resize");
                MouseCursor.NWSE_RESIZE = new MouseCursor("nwse-resize");
                MouseCursor.ZOOM_IN = new MouseCursor("zoom-in");
                MouseCursor.ZOOM_OUT = new MouseCursor("zoom-out");
                MouseCursor.GRAB = new MouseCursor("grab");
                MouseCursor.GRABBING = new MouseCursor("grabbing");
                return MouseCursor;
            })();
            Profiler.MouseCursor = MouseCursor;

            var MouseController = (function () {
                function MouseController(target, eventTarget) {
                    this._target = target;
                    this._eventTarget = eventTarget;
                    this._wheelDisabled = false;
                    this._boundOnMouseDown = this._onMouseDown.bind(this);
                    this._boundOnMouseUp = this._onMouseUp.bind(this);
                    this._boundOnMouseOver = this._onMouseOver.bind(this);
                    this._boundOnMouseOut = this._onMouseOut.bind(this);
                    this._boundOnMouseMove = this._onMouseMove.bind(this);
                    this._boundOnMouseWheel = this._onMouseWheel.bind(this);
                    this._boundOnDrag = this._onDrag.bind(this);
                    eventTarget.addEventListener("mousedown", this._boundOnMouseDown, false);
                    eventTarget.addEventListener("mouseover", this._boundOnMouseOver, false);
                    eventTarget.addEventListener("mouseout", this._boundOnMouseOut, false);
                    eventTarget.addEventListener(("onwheel" in document ? "wheel" : "mousewheel"), this._boundOnMouseWheel, false);
                }
                MouseController.prototype.destroy = function () {
                    var eventTarget = this._eventTarget;
                    eventTarget.removeEventListener("mousedown", this._boundOnMouseDown);
                    eventTarget.removeEventListener("mouseover", this._boundOnMouseOver);
                    eventTarget.removeEventListener("mouseout", this._boundOnMouseOut);
                    eventTarget.removeEventListener(("onwheel" in document ? "wheel" : "mousewheel"), this._boundOnMouseWheel);
                    window.removeEventListener("mousemove", this._boundOnDrag);
                    window.removeEventListener("mouseup", this._boundOnMouseUp);
                    this._killHoverCheck();
                    this._eventTarget = null;
                    this._target = null;
                };

                MouseController.prototype.updateCursor = function (cursor) {
                    if (!MouseController._cursorOwner || MouseController._cursorOwner === this._target) {
                        var el = this._eventTarget.parentElement;
                        if (MouseController._cursor !== cursor) {
                            MouseController._cursor = cursor;
                            var self = this;
                            ["", "-moz-", "-webkit-"].forEach(function (prefix) {
                                el.style.cursor = prefix + cursor;
                            });
                        }
                        if (MouseController._cursor === MouseCursor.DEFAULT) {
                            MouseController._cursorOwner = null;
                        } else {
                            MouseController._cursorOwner = this._target;
                        }
                    }
                };

                MouseController.prototype._onMouseDown = function (event) {
                    this._killHoverCheck();
                    if (event.button === 0) {
                        var pos = this._getTargetMousePos(event, (event.target));
                        this._dragInfo = {
                            start: pos,
                            current: pos,
                            delta: { x: 0, y: 0 },
                            hasMoved: false,
                            originalTarget: event.target
                        };
                        window.addEventListener("mousemove", this._boundOnDrag, false);
                        window.addEventListener("mouseup", this._boundOnMouseUp, false);
                        this._target.onMouseDown(pos.x, pos.y);
                    }
                };

                MouseController.prototype._onDrag = function (event) {
                    var dragInfo = this._dragInfo;
                    var current = this._getTargetMousePos(event, dragInfo.originalTarget);
                    var delta = {
                        x: current.x - dragInfo.start.x,
                        y: current.y - dragInfo.start.y
                    };
                    dragInfo.current = current;
                    dragInfo.delta = delta;
                    dragInfo.hasMoved = true;
                    this._target.onDrag(dragInfo.start.x, dragInfo.start.y, current.x, current.y, delta.x, delta.y);
                };

                MouseController.prototype._onMouseUp = function (event) {
                    window.removeEventListener("mousemove", this._boundOnDrag);
                    window.removeEventListener("mouseup", this._boundOnMouseUp);
                    var self = this;
                    var dragInfo = this._dragInfo;
                    if (dragInfo.hasMoved) {
                        this._target.onDragEnd(dragInfo.start.x, dragInfo.start.y, dragInfo.current.x, dragInfo.current.y, dragInfo.delta.x, dragInfo.delta.y);
                    } else {
                        this._target.onClick(dragInfo.current.x, dragInfo.current.y);
                    }
                    this._dragInfo = null;
                    this._wheelDisabled = true;
                    setTimeout(function () {
                        self._wheelDisabled = false;
                    }, 500);
                };

                MouseController.prototype._onMouseOver = function (event) {
                    event.target.addEventListener("mousemove", this._boundOnMouseMove, false);
                    if (!this._dragInfo) {
                        var pos = this._getTargetMousePos(event, (event.target));
                        this._target.onMouseOver(pos.x, pos.y);
                        this._startHoverCheck(event);
                    }
                };

                MouseController.prototype._onMouseOut = function (event) {
                    event.target.removeEventListener("mousemove", this._boundOnMouseMove, false);
                    if (!this._dragInfo) {
                        this._target.onMouseOut();
                    }
                    this._killHoverCheck();
                };

                MouseController.prototype._onMouseMove = function (event) {
                    if (!this._dragInfo) {
                        var pos = this._getTargetMousePos(event, (event.target));
                        this._target.onMouseMove(pos.x, pos.y);
                        this._killHoverCheck();
                        this._startHoverCheck(event);
                    }
                };

                MouseController.prototype._onMouseWheel = function (event) {
                    if (!event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey) {
                        event.preventDefault();
                        if (!this._dragInfo && !this._wheelDisabled) {
                            var pos = this._getTargetMousePos(event, (event.target));
                            var delta = clamp((typeof event.deltaY !== "undefined") ? event.deltaY / 16 : -event.wheelDelta / 40, -1, 1);
                            var zoom = Math.pow(1.2, delta) - 1;
                            this._target.onMouseWheel(pos.x, pos.y, zoom);
                        }
                    }
                };

                MouseController.prototype._startHoverCheck = function (event) {
                    this._hoverInfo = {
                        isHovering: false,
                        timeoutHandle: setTimeout(this._onMouseMoveIdleHandler.bind(this), MouseController.HOVER_TIMEOUT),
                        pos: this._getTargetMousePos(event, (event.target))
                    };
                };

                MouseController.prototype._killHoverCheck = function () {
                    if (this._hoverInfo) {
                        clearTimeout(this._hoverInfo.timeoutHandle);
                        if (this._hoverInfo.isHovering) {
                            this._target.onHoverEnd();
                        }
                        this._hoverInfo = null;
                    }
                };

                MouseController.prototype._onMouseMoveIdleHandler = function () {
                    var hoverInfo = this._hoverInfo;
                    hoverInfo.isHovering = true;
                    this._target.onHoverStart(hoverInfo.pos.x, hoverInfo.pos.y);
                };

                MouseController.prototype._getTargetMousePos = function (event, target) {
                    var rect = target.getBoundingClientRect();
                    return {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    };
                };
                MouseController.HOVER_TIMEOUT = 500;

                MouseController._cursor = MouseCursor.DEFAULT;
                return MouseController;
            })();
            Profiler.MouseController = MouseController;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            (function (FlameChartDragTarget) {
                FlameChartDragTarget[FlameChartDragTarget["NONE"] = 0] = "NONE";
                FlameChartDragTarget[FlameChartDragTarget["WINDOW"] = 1] = "WINDOW";
                FlameChartDragTarget[FlameChartDragTarget["HANDLE_LEFT"] = 2] = "HANDLE_LEFT";
                FlameChartDragTarget[FlameChartDragTarget["HANDLE_RIGHT"] = 3] = "HANDLE_RIGHT";
                FlameChartDragTarget[FlameChartDragTarget["HANDLE_BOTH"] = 4] = "HANDLE_BOTH";
            })(Profiler.FlameChartDragTarget || (Profiler.FlameChartDragTarget = {}));
            var FlameChartDragTarget = Profiler.FlameChartDragTarget;

            var FlameChartBase = (function () {
                function FlameChartBase(controller) {
                    this._controller = controller;
                    this._initialized = false;
                    this._canvas = document.createElement("canvas");
                    this._context = this._canvas.getContext("2d");
                    this._mouseController = new Profiler.MouseController(this, this._canvas);
                    var container = controller.container;
                    container.appendChild(this._canvas);
                    var rect = container.getBoundingClientRect();
                    this.setSize(rect.width);
                }
                Object.defineProperty(FlameChartBase.prototype, "canvas", {
                    get: function () {
                        return this._canvas;
                    },
                    enumerable: true,
                    configurable: true
                });

                FlameChartBase.prototype.setSize = function (width, height) {
                    if (typeof height === "undefined") { height = 20; }
                    this._width = width;
                    this._height = height;
                    this._resetCanvas();
                    this.draw();
                };

                FlameChartBase.prototype.initialize = function (rangeStart, rangeEnd) {
                    this._initialized = true;
                    this.setRange(rangeStart, rangeEnd, false);
                    this.setWindow(rangeStart, rangeEnd, false);
                    this.draw();
                };

                FlameChartBase.prototype.setWindow = function (start, end, draw) {
                    if (typeof draw === "undefined") { draw = true; }
                    this._windowStart = start;
                    this._windowEnd = end;
                    !draw || this.draw();
                };

                FlameChartBase.prototype.setRange = function (start, end, draw) {
                    if (typeof draw === "undefined") { draw = true; }
                    this._rangeStart = start;
                    this._rangeEnd = end;
                    !draw || this.draw();
                };

                FlameChartBase.prototype.destroy = function () {
                    this._mouseController.destroy();
                    this._mouseController = null;
                    this._controller.container.removeChild(this._canvas);
                    this._controller = null;
                };

                FlameChartBase.prototype._resetCanvas = function () {
                    var ratio = window.devicePixelRatio;
                    var canvas = this._canvas;
                    canvas.width = this._width * ratio;
                    canvas.height = this._height * ratio;
                    canvas.style.width = this._width + "px";
                    canvas.style.height = this._height + "px";
                };

                FlameChartBase.prototype.draw = function () {
                };

                FlameChartBase.prototype._almostEq = function (a, b, precision) {
                    if (typeof precision === "undefined") { precision = 10; }
                    var pow10 = Math.pow(10, precision);
                    return Math.abs(a - b) < (1 / pow10);
                };

                FlameChartBase.prototype._windowEqRange = function () {
                    return (this._almostEq(this._windowStart, this._rangeStart) && this._almostEq(this._windowEnd, this._rangeEnd));
                };

                FlameChartBase.prototype._decimalPlaces = function (value) {
                    return ((+value).toFixed(10)).replace(/^-?\d*\.?|0+$/g, '').length;
                };

                FlameChartBase.prototype._toPixelsRelative = function (time) {
                    return 0;
                };
                FlameChartBase.prototype._toPixels = function (time) {
                    return 0;
                };
                FlameChartBase.prototype._toTimeRelative = function (px) {
                    return 0;
                };
                FlameChartBase.prototype._toTime = function (px) {
                    return 0;
                };

                FlameChartBase.prototype.onMouseWheel = function (x, y, delta) {
                    var time = this._toTime(x);
                    var windowStart = this._windowStart;
                    var windowEnd = this._windowEnd;
                    var windowLen = windowEnd - windowStart;

                    /*
                    * Find maximum allowed delta
                    * (windowEnd + (windowEnd - time) * delta) - (windowStart + (windowStart - time) * delta) = LEN
                    * (windowEnd - windowStart) + ((windowEnd - time) * delta) - ((windowStart - time) * delta) = LEN
                    * (windowEnd - windowStart) + ((windowEnd - time) - (windowStart - time)) * delta = LEN
                    * (windowEnd - windowStart) + (windowEnd - windowStart) * delta = LEN
                    * (windowEnd - windowStart) * delta = LEN - (windowEnd - windowStart)
                    * delta = (LEN - (windowEnd - windowStart)) / (windowEnd - windowStart)
                    */
                    var maxDelta = Math.max((FlameChartBase.MIN_WINDOW_LEN - windowLen) / windowLen, delta);
                    var start = windowStart + (windowStart - time) * maxDelta;
                    var end = windowEnd + (windowEnd - time) * maxDelta;
                    this._controller.setWindow(start, end);
                    this.onHoverEnd();
                };

                FlameChartBase.prototype.onMouseDown = function (x, y) {
                };
                FlameChartBase.prototype.onMouseMove = function (x, y) {
                };
                FlameChartBase.prototype.onMouseOver = function (x, y) {
                };
                FlameChartBase.prototype.onMouseOut = function () {
                };
                FlameChartBase.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                };
                FlameChartBase.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                };
                FlameChartBase.prototype.onClick = function (x, y) {
                };
                FlameChartBase.prototype.onHoverStart = function (x, y) {
                };
                FlameChartBase.prototype.onHoverEnd = function () {
                };
                FlameChartBase.DRAGHANDLE_WIDTH = 4;
                FlameChartBase.MIN_WINDOW_LEN = 0.1;
                return FlameChartBase;
            })();
            Profiler.FlameChartBase = FlameChartBase;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var trimMiddle = Shumway.StringUtilities.trimMiddle;
            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

            var FlameChart = (function (_super) {
                __extends(FlameChart, _super);
                function FlameChart(controller, snapshot) {
                    _super.call(this, controller);
                    this._textWidth = {};
                    /**
                    * Don't paint frames whose width is smaller than this value. This helps a lot when drawing
                    * large ranges. This can be < 1 since anti-aliasing can look quite nice.
                    */
                    this._minFrameWidthInPixels = 1;
                    this._snapshot = snapshot;
                    this._kindStyle = createEmptyObject();
                }
                FlameChart.prototype.setSize = function (width, height) {
                    _super.prototype.setSize.call(this, width, height || this._initialized ? this._maxDepth * 12.5 : 100);
                };

                FlameChart.prototype.initialize = function (rangeStart, rangeEnd) {
                    this._initialized = true;
                    this._maxDepth = this._snapshot.maxDepth;
                    this.setRange(rangeStart, rangeEnd, false);
                    this.setWindow(rangeStart, rangeEnd, false);
                    this.setSize(this._width, this._maxDepth * 12.5);
                };

                FlameChart.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);
                    this._snapshot = null;
                };

                FlameChart.prototype.draw = function () {
                    var context = this._context;
                    var ratio = window.devicePixelRatio;

                    Shumway.ColorStyle.reset();

                    context.save();
                    context.scale(ratio, ratio);
                    context.fillStyle = this._controller.theme.bodyBackground(1);
                    context.fillRect(0, 0, this._width, this._height);

                    if (this._initialized) {
                        this._drawChildren(this._snapshot);
                    }

                    context.restore();
                };

                FlameChart.prototype._drawChildren = function (parent, depth) {
                    if (typeof depth === "undefined") { depth = 0; }
                    var range = parent.getChildRange(this._windowStart, this._windowEnd);
                    if (range) {
                        for (var i = range.startIndex; i <= range.endIndex; i++) {
                            var child = parent.children[i];
                            if (this._drawFrame(child, depth)) {
                                this._drawChildren(child, depth + 1);
                            }
                        }
                    }
                };

                FlameChart.prototype._drawFrame = function (frame, depth) {
                    var context = this._context;
                    var frameHPadding = 0.5;
                    var left = this._toPixels(frame.startTime);
                    var right = this._toPixels(frame.endTime);
                    var width = right - left;
                    if (width <= this._minFrameWidthInPixels) {
                        context.fillStyle = this._controller.theme.tabToolbar(1);
                        context.fillRect(left, depth * (12 + frameHPadding), this._minFrameWidthInPixels, 12 + (frame.maxDepth - frame.depth) * 12.5);
                        return false;
                    }
                    if (left < 0) {
                        right = width + left;
                        left = 0;
                    }
                    var adjustedWidth = right - left;
                    var style = this._kindStyle[frame.kind.id];
                    if (!style) {
                        var background = Shumway.ColorStyle.randomStyle();
                        style = this._kindStyle[frame.kind.id] = {
                            bgColor: background,
                            textColor: Shumway.ColorStyle.contrastStyle(background)
                        };
                    }
                    context.save();

                    //if (this._hoveredFrame && this._hoveredFrame.kind !== frame.kind) {
                    //  context.globalAlpha = 0.4;
                    //}
                    context.fillStyle = style.bgColor;
                    context.fillRect(left, depth * (12 + frameHPadding), adjustedWidth, 12);

                    if (width > 12) {
                        var label = frame.kind.name;
                        if (label && label.length) {
                            var labelHPadding = 2;
                            label = this._prepareText(context, label, adjustedWidth - labelHPadding * 2);
                            if (label.length) {
                                context.fillStyle = style.textColor;
                                context.textBaseline = "bottom";
                                context.fillText(label, left + labelHPadding, (depth + 1) * (12 + frameHPadding) - 1);
                            }
                        }
                    }
                    context.restore();
                    return true;
                };

                FlameChart.prototype._prepareText = function (context, title, maxSize) {
                    var titleWidth = this._measureWidth(context, title);
                    if (maxSize > titleWidth) {
                        return title;
                    }
                    var l = 3;
                    var r = title.length;
                    while (l < r) {
                        var m = (l + r) >> 1;
                        if (this._measureWidth(context, trimMiddle(title, m)) < maxSize) {
                            l = m + 1;
                        } else {
                            r = m;
                        }
                    }
                    title = trimMiddle(title, r - 1);
                    titleWidth = this._measureWidth(context, title);
                    if (titleWidth <= maxSize) {
                        return title;
                    }
                    return "";
                };

                FlameChart.prototype._measureWidth = function (context, text) {
                    var width = this._textWidth[text];
                    if (!width) {
                        width = context.measureText(text).width;
                        this._textWidth[text] = width;
                    }
                    return width;
                };

                FlameChart.prototype._toPixelsRelative = function (time) {
                    return time * this._width / (this._windowEnd - this._windowStart);
                };

                FlameChart.prototype._toPixels = function (time) {
                    return this._toPixelsRelative(time - this._windowStart);
                };

                FlameChart.prototype._toTimeRelative = function (px) {
                    return px * (this._windowEnd - this._windowStart) / this._width;
                };

                FlameChart.prototype._toTime = function (px) {
                    return this._toTimeRelative(px) + this._windowStart;
                };

                FlameChart.prototype._getFrameAtPosition = function (x, y) {
                    var time = this._toTime(x);
                    var depth = 1 + (y / 12.5) | 0;
                    var frame = this._snapshot.query(time);
                    if (frame && frame.depth >= depth) {
                        while (frame && frame.depth > depth) {
                            frame = frame.parent;
                        }
                        return frame;
                    }
                    return null;
                };

                FlameChart.prototype.onMouseDown = function (x, y) {
                    if (!this._windowEqRange()) {
                        this._mouseController.updateCursor(Profiler.MouseCursor.ALL_SCROLL);
                        this._dragInfo = {
                            windowStartInitial: this._windowStart,
                            windowEndInitial: this._windowEnd,
                            target: 1 /* WINDOW */
                        };
                    }
                };

                FlameChart.prototype.onMouseMove = function (x, y) {
                };
                FlameChart.prototype.onMouseOver = function (x, y) {
                };
                FlameChart.prototype.onMouseOut = function () {
                };

                FlameChart.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    var dragInfo = this._dragInfo;
                    if (dragInfo) {
                        var delta = this._toTimeRelative(-deltaX);
                        var windowStart = dragInfo.windowStartInitial + delta;
                        var windowEnd = dragInfo.windowEndInitial + delta;
                        this._controller.setWindow(windowStart, windowEnd);
                    }
                };

                FlameChart.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    this._dragInfo = null;
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };

                FlameChart.prototype.onClick = function (x, y) {
                    this._dragInfo = null;
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };

                FlameChart.prototype.onHoverStart = function (x, y) {
                    var frame = this._getFrameAtPosition(x, y);
                    if (frame) {
                        this._hoveredFrame = frame;
                        this._controller.showTooltip(this, frame, x, y);
                        //this._draw();
                    }
                };

                FlameChart.prototype.onHoverEnd = function () {
                    if (this._hoveredFrame) {
                        this._hoveredFrame = null;
                        this._controller.hideTooltip();
                        //this._draw();
                    }
                };

                FlameChart.prototype.getStatistics = function (kind) {
                    var snapshot = this._snapshot;
                    if (!snapshot.statistics) {
                        snapshot.calculateStatistics();
                    }
                    return snapshot.statistics[kind.id];
                };
                return FlameChart;
            })(Profiler.FlameChartBase);
            Profiler.FlameChart = FlameChart;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var clamp = Shumway.NumberUtilities.clamp;

            (function (FlameChartOverviewMode) {
                FlameChartOverviewMode[FlameChartOverviewMode["OVERLAY"] = 0] = "OVERLAY";
                FlameChartOverviewMode[FlameChartOverviewMode["STACK"] = 1] = "STACK";
                FlameChartOverviewMode[FlameChartOverviewMode["UNION"] = 2] = "UNION";
            })(Profiler.FlameChartOverviewMode || (Profiler.FlameChartOverviewMode = {}));
            var FlameChartOverviewMode = Profiler.FlameChartOverviewMode;

            var FlameChartOverview = (function (_super) {
                __extends(FlameChartOverview, _super);
                function FlameChartOverview(controller, mode) {
                    if (typeof mode === "undefined") { mode = 1 /* STACK */; }
                    this._mode = mode;
                    this._overviewCanvasDirty = true;
                    this._overviewCanvas = document.createElement("canvas");
                    this._overviewContext = this._overviewCanvas.getContext("2d");
                    _super.call(this, controller);
                }
                FlameChartOverview.prototype.setSize = function (width, height) {
                    _super.prototype.setSize.call(this, width, height || 64);
                };

                Object.defineProperty(FlameChartOverview.prototype, "mode", {
                    set: function (value) {
                        this._mode = value;
                        this.draw();
                    },
                    enumerable: true,
                    configurable: true
                });

                FlameChartOverview.prototype._resetCanvas = function () {
                    _super.prototype._resetCanvas.call(this);
                    this._overviewCanvas.width = this._canvas.width;
                    this._overviewCanvas.height = this._canvas.height;
                    this._overviewCanvasDirty = true;
                };

                FlameChartOverview.prototype.draw = function () {
                    var context = this._context;
                    var ratio = window.devicePixelRatio;
                    var width = this._width;
                    var height = this._height;

                    context.save();
                    context.scale(ratio, ratio);
                    context.fillStyle = this._controller.theme.bodyBackground(1); //"rgba(17, 19, 21, 1)";
                    context.fillRect(0, 0, width, height);
                    context.restore();

                    if (this._initialized) {
                        if (this._overviewCanvasDirty) {
                            this._drawChart();
                            this._overviewCanvasDirty = false;
                        }
                        context.drawImage(this._overviewCanvas, 0, 0);
                        this._drawSelection();
                    }
                };

                FlameChartOverview.prototype._drawSelection = function () {
                    var context = this._context;
                    var height = this._height;
                    var ratio = window.devicePixelRatio;
                    var left = this._selection ? this._selection.left : this._toPixels(this._windowStart);
                    var right = this._selection ? this._selection.right : this._toPixels(this._windowEnd);
                    var theme = this._controller.theme;

                    context.save();
                    context.scale(ratio, ratio);

                    // Draw fills
                    if (this._selection) {
                        context.fillStyle = theme.selectionText(0.15); //"rgba(245, 247, 250, 0.15)";
                        context.fillRect(left, 1, right - left, height - 1);
                        context.fillStyle = "rgba(133, 0, 0, 1)";
                        context.fillRect(left + 0.5, 0, right - left - 1, 4);
                        context.fillRect(left + 0.5, height - 4, right - left - 1, 4);
                    } else {
                        context.fillStyle = theme.bodyBackground(0.4); //"rgba(17, 19, 21, 0.4)";
                        context.fillRect(0, 1, left, height - 1);
                        context.fillRect(right, 1, this._width, height - 1);
                    }

                    // Draw border lines
                    context.beginPath();
                    context.moveTo(left, 0);
                    context.lineTo(left, height);
                    context.moveTo(right, 0);
                    context.lineTo(right, height);
                    context.lineWidth = 0.5;
                    context.strokeStyle = theme.foregroundTextGrey(1); //"rgba(245, 247, 250, 1)";
                    context.stroke();

                    // Draw info labels
                    var start = this._selection ? this._toTime(this._selection.left) : this._windowStart;
                    var end = this._selection ? this._toTime(this._selection.right) : this._windowEnd;
                    var time = Math.abs(end - start);
                    context.fillStyle = theme.selectionText(0.5); //"rgba(255, 255, 255, 0.5)";
                    context.font = '8px sans-serif';
                    context.textBaseline = "alphabetic";
                    context.textAlign = "end";

                    // Selection Range in MS
                    context.fillText(time.toFixed(2), Math.min(left, right) - 4, 10);

                    // Selection Range in Frames
                    context.fillText((time / 60).toFixed(2), Math.min(left, right) - 4, 20);
                    context.restore();
                };

                FlameChartOverview.prototype._drawChart = function () {
                    var ratio = window.devicePixelRatio;
                    var width = this._width;
                    var height = this._height;
                    var profile = this._controller.activeProfile;
                    var samplesPerPixel = 4;
                    var samplesCount = width * samplesPerPixel;
                    var sampleTimeInterval = profile.totalTime / samplesCount;
                    var contextOverview = this._overviewContext;
                    var overviewChartColor = this._controller.theme.blueHighlight(1);

                    contextOverview.save();
                    contextOverview.translate(0, ratio * height);
                    var yScale = -ratio * height / (profile.maxDepth - 1);
                    contextOverview.scale(ratio / samplesPerPixel, yScale);
                    contextOverview.clearRect(0, 0, samplesCount, profile.maxDepth - 1);
                    if (this._mode == 1 /* STACK */) {
                        contextOverview.scale(1, 1 / profile.snapshotCount);
                    }
                    for (var i = 0, n = profile.snapshotCount; i < n; i++) {
                        var snapshot = profile.getSnapshotAt(i);
                        if (snapshot) {
                            var deepestFrame = null;
                            var depth = 0;
                            contextOverview.beginPath();
                            contextOverview.moveTo(0, 0);
                            for (var x = 0; x < samplesCount; x++) {
                                var time = profile.startTime + x * sampleTimeInterval;
                                if (!deepestFrame) {
                                    deepestFrame = snapshot.query(time);
                                } else {
                                    deepestFrame = deepestFrame.queryNext(time);
                                }
                                depth = deepestFrame ? deepestFrame.getDepth() - 1 : 0;
                                contextOverview.lineTo(x, depth);
                            }
                            contextOverview.lineTo(x, 0);
                            contextOverview.fillStyle = overviewChartColor;
                            contextOverview.fill();
                            if (this._mode == 1 /* STACK */) {
                                contextOverview.translate(0, -height * ratio / yScale);
                            }
                        }
                    }

                    contextOverview.restore();
                };

                FlameChartOverview.prototype._toPixelsRelative = function (time) {
                    return time * this._width / (this._rangeEnd - this._rangeStart);
                };

                FlameChartOverview.prototype._toPixels = function (time) {
                    return this._toPixelsRelative(time - this._rangeStart);
                };

                FlameChartOverview.prototype._toTimeRelative = function (px) {
                    return px * (this._rangeEnd - this._rangeStart) / this._width;
                };

                FlameChartOverview.prototype._toTime = function (px) {
                    return this._toTimeRelative(px) + this._rangeStart;
                };

                FlameChartOverview.prototype._getDragTargetUnderCursor = function (x, y) {
                    if (y >= 0 && y < this._height) {
                        var left = this._toPixels(this._windowStart);
                        var right = this._toPixels(this._windowEnd);
                        var radius = 2 + (Profiler.FlameChartBase.DRAGHANDLE_WIDTH) / 2;
                        var leftHandle = (x >= left - radius && x <= left + radius);
                        var rightHandle = (x >= right - radius && x <= right + radius);
                        if (leftHandle && rightHandle) {
                            return 4 /* HANDLE_BOTH */;
                        } else if (leftHandle) {
                            return 2 /* HANDLE_LEFT */;
                        } else if (rightHandle) {
                            return 3 /* HANDLE_RIGHT */;
                        } else if (!this._windowEqRange() && x > left + radius && x < right - radius) {
                            return 1 /* WINDOW */;
                        }
                    }
                    return 0 /* NONE */;
                };

                FlameChartOverview.prototype.onMouseDown = function (x, y) {
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget === 0 /* NONE */) {
                        this._selection = { left: x, right: x };
                        this.draw();
                    } else {
                        if (dragTarget === 1 /* WINDOW */) {
                            this._mouseController.updateCursor(Profiler.MouseCursor.GRABBING);
                        }
                        this._dragInfo = {
                            windowStartInitial: this._windowStart,
                            windowEndInitial: this._windowEnd,
                            target: dragTarget
                        };
                    }
                };

                FlameChartOverview.prototype.onMouseMove = function (x, y) {
                    var cursor = Profiler.MouseCursor.DEFAULT;
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget !== 0 /* NONE */ && !this._selection) {
                        cursor = (dragTarget === 1 /* WINDOW */) ? Profiler.MouseCursor.GRAB : Profiler.MouseCursor.EW_RESIZE;
                    }
                    this._mouseController.updateCursor(cursor);
                };

                FlameChartOverview.prototype.onMouseOver = function (x, y) {
                    this.onMouseMove(x, y);
                };

                FlameChartOverview.prototype.onMouseOut = function () {
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };

                FlameChartOverview.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    if (this._selection) {
                        this._selection = { left: startX, right: clamp(currentX, 0, this._width - 1) };
                        this.draw();
                    } else {
                        var dragInfo = this._dragInfo;
                        if (dragInfo.target === 4 /* HANDLE_BOTH */) {
                            if (deltaX !== 0) {
                                dragInfo.target = (deltaX < 0) ? 2 /* HANDLE_LEFT */ : 3 /* HANDLE_RIGHT */;
                            } else {
                                return;
                            }
                        }
                        var windowStart = this._windowStart;
                        var windowEnd = this._windowEnd;
                        var delta = this._toTimeRelative(deltaX);
                        switch (dragInfo.target) {
                            case 1 /* WINDOW */:
                                windowStart = dragInfo.windowStartInitial + delta;
                                windowEnd = dragInfo.windowEndInitial + delta;
                                break;
                            case 2 /* HANDLE_LEFT */:
                                windowStart = clamp(dragInfo.windowStartInitial + delta, this._rangeStart, windowEnd - Profiler.FlameChartBase.MIN_WINDOW_LEN);
                                break;
                            case 3 /* HANDLE_RIGHT */:
                                windowEnd = clamp(dragInfo.windowEndInitial + delta, windowStart + Profiler.FlameChartBase.MIN_WINDOW_LEN, this._rangeEnd);
                                break;
                            default:
                                return;
                        }
                        this._controller.setWindow(windowStart, windowEnd);
                    }
                };

                FlameChartOverview.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    if (this._selection) {
                        this._selection = null;
                        this._controller.setWindow(this._toTime(startX), this._toTime(currentX));
                    }
                    this._dragInfo = null;
                    this.onMouseMove(currentX, currentY);
                };

                FlameChartOverview.prototype.onClick = function (x, y) {
                    this._dragInfo = null;
                    this._selection = null;
                    if (!this._windowEqRange()) {
                        var dragTarget = this._getDragTargetUnderCursor(x, y);
                        if (dragTarget === 0 /* NONE */) {
                            this._controller.moveWindowTo(this._toTime(x));
                        }
                        this.onMouseMove(x, y);
                    }
                    this.draw();
                };

                FlameChartOverview.prototype.onHoverStart = function (x, y) {
                };
                FlameChartOverview.prototype.onHoverEnd = function () {
                };
                return FlameChartOverview;
            })(Profiler.FlameChartBase);
            Profiler.FlameChartOverview = FlameChartOverview;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Profiler) {
            var clamp = Shumway.NumberUtilities.clamp;

            (function (FlameChartHeaderType) {
                FlameChartHeaderType[FlameChartHeaderType["OVERVIEW"] = 0] = "OVERVIEW";
                FlameChartHeaderType[FlameChartHeaderType["CHART"] = 1] = "CHART";
            })(Profiler.FlameChartHeaderType || (Profiler.FlameChartHeaderType = {}));
            var FlameChartHeaderType = Profiler.FlameChartHeaderType;

            var FlameChartHeader = (function (_super) {
                __extends(FlameChartHeader, _super);
                function FlameChartHeader(controller, type) {
                    this._type = type;
                    _super.call(this, controller);
                }
                FlameChartHeader.prototype.draw = function () {
                    var context = this._context;
                    var ratio = window.devicePixelRatio;
                    var width = this._width;
                    var height = this._height;

                    context.save();
                    context.scale(ratio, ratio);
                    context.fillStyle = this._controller.theme.tabToolbar(1); //"#252c33";
                    context.fillRect(0, 0, width, height);

                    if (this._initialized) {
                        if (this._type == 0 /* OVERVIEW */) {
                            var left = this._toPixels(this._windowStart);
                            var right = this._toPixels(this._windowEnd);
                            context.fillStyle = this._controller.theme.bodyBackground(1); //"#14171a";
                            context.fillRect(left, 0, right - left, height);
                            this._drawLabels(this._rangeStart, this._rangeEnd);
                            this._drawDragHandle(left);
                            this._drawDragHandle(right);
                        } else {
                            this._drawLabels(this._windowStart, this._windowEnd);
                        }
                    }

                    context.restore();
                };

                FlameChartHeader.prototype._drawLabels = function (rangeStart, rangeEnd) {
                    var context = this._context;
                    var tickInterval = this._calculateTickInterval(rangeStart, rangeEnd);
                    var tick = Math.ceil(rangeStart / tickInterval) * tickInterval;
                    var showSeconds = (tickInterval >= 500);
                    var divisor = showSeconds ? 1000 : 1;
                    var precision = this._decimalPlaces(tickInterval / divisor);
                    var unit = showSeconds ? "s" : "ms";
                    var x = this._toPixels(tick);
                    var y = this._height / 2;
                    var theme = this._controller.theme;
                    context.lineWidth = 1;
                    context.strokeStyle = theme.contentTextDarkGrey(0.5); //"rgba(95, 115, 135, 0.5)";
                    context.fillStyle = theme.contentTextDarkGrey(1); //"rgba(95, 115, 135, 1)";
                    context.textAlign = "right";
                    context.textBaseline = "middle";
                    context.font = '11px sans-serif';
                    var maxWidth = this._width + FlameChartHeader.TICK_MAX_WIDTH;
                    while (x < maxWidth) {
                        var tickStr = (tick / divisor).toFixed(precision) + " " + unit;
                        context.fillText(tickStr, x - 7, y + 1);
                        context.beginPath();
                        context.moveTo(x, 0);
                        context.lineTo(x, this._height + 1);
                        context.closePath();
                        context.stroke();
                        tick += tickInterval;
                        x = this._toPixels(tick);
                    }
                };

                FlameChartHeader.prototype._calculateTickInterval = function (rangeStart, rangeEnd) {
                    // http://stackoverflow.com/a/361687
                    var tickCount = this._width / FlameChartHeader.TICK_MAX_WIDTH;
                    var range = rangeEnd - rangeStart;
                    var minimum = range / tickCount;
                    var magnitude = Math.pow(10, Math.floor(Math.log(minimum) / Math.LN10));
                    var residual = minimum / magnitude;
                    if (residual > 5) {
                        return 10 * magnitude;
                    } else if (residual > 2) {
                        return 5 * magnitude;
                    } else if (residual > 1) {
                        return 2 * magnitude;
                    }
                    return magnitude;
                };

                FlameChartHeader.prototype._drawDragHandle = function (pos) {
                    var context = this._context;
                    context.lineWidth = 2;
                    context.strokeStyle = this._controller.theme.bodyBackground(1); //"#14171a";
                    context.fillStyle = this._controller.theme.foregroundTextGrey(0.7); //"rgba(182, 186, 191, 0.7)";
                    this._drawRoundedRect(context, pos - Profiler.FlameChartBase.DRAGHANDLE_WIDTH / 2, 1, Profiler.FlameChartBase.DRAGHANDLE_WIDTH, this._height - 2, 2, true);
                };

                FlameChartHeader.prototype._drawRoundedRect = function (context, x, y, width, height, radius, stroke, fill) {
                    if (typeof stroke === "undefined") { stroke = true; }
                    if (typeof fill === "undefined") { fill = true; }
                    context.beginPath();
                    context.moveTo(x + radius, y);
                    context.lineTo(x + width - radius, y);
                    context.quadraticCurveTo(x + width, y, x + width, y + radius);
                    context.lineTo(x + width, y + height - radius);
                    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    context.lineTo(x + radius, y + height);
                    context.quadraticCurveTo(x, y + height, x, y + height - radius);
                    context.lineTo(x, y + radius);
                    context.quadraticCurveTo(x, y, x + radius, y);
                    context.closePath();
                    if (stroke) {
                        context.stroke();
                    }
                    if (fill) {
                        context.fill();
                    }
                };

                FlameChartHeader.prototype._toPixelsRelative = function (time) {
                    var range = (this._type === 0 /* OVERVIEW */) ? this._rangeEnd - this._rangeStart : this._windowEnd - this._windowStart;
                    return time * this._width / range;
                };

                FlameChartHeader.prototype._toPixels = function (time) {
                    var start = (this._type === 0 /* OVERVIEW */) ? this._rangeStart : this._windowStart;
                    return this._toPixelsRelative(time - start);
                };

                FlameChartHeader.prototype._toTimeRelative = function (px) {
                    var range = (this._type === 0 /* OVERVIEW */) ? this._rangeEnd - this._rangeStart : this._windowEnd - this._windowStart;
                    return px * range / this._width;
                };

                FlameChartHeader.prototype._toTime = function (px) {
                    var start = (this._type === 0 /* OVERVIEW */) ? this._rangeStart : this._windowStart;
                    return this._toTimeRelative(px) + start;
                };

                FlameChartHeader.prototype._getDragTargetUnderCursor = function (x, y) {
                    if (y >= 0 && y < this._height) {
                        if (this._type === 0 /* OVERVIEW */) {
                            var left = this._toPixels(this._windowStart);
                            var right = this._toPixels(this._windowEnd);
                            var radius = 2 + (Profiler.FlameChartBase.DRAGHANDLE_WIDTH) / 2;
                            var leftHandle = (x >= left - radius && x <= left + radius);
                            var rightHandle = (x >= right - radius && x <= right + radius);
                            if (leftHandle && rightHandle) {
                                return 4 /* HANDLE_BOTH */;
                            } else if (leftHandle) {
                                return 2 /* HANDLE_LEFT */;
                            } else if (rightHandle) {
                                return 3 /* HANDLE_RIGHT */;
                            } else if (!this._windowEqRange()) {
                                return 1 /* WINDOW */;
                            }
                        } else if (!this._windowEqRange()) {
                            return 1 /* WINDOW */;
                        }
                    }
                    return 0 /* NONE */;
                };

                FlameChartHeader.prototype.onMouseDown = function (x, y) {
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget === 1 /* WINDOW */) {
                        this._mouseController.updateCursor(Profiler.MouseCursor.GRABBING);
                    }
                    this._dragInfo = {
                        windowStartInitial: this._windowStart,
                        windowEndInitial: this._windowEnd,
                        target: dragTarget
                    };
                };

                FlameChartHeader.prototype.onMouseMove = function (x, y) {
                    var cursor = Profiler.MouseCursor.DEFAULT;
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget !== 0 /* NONE */) {
                        if (dragTarget !== 1 /* WINDOW */) {
                            cursor = Profiler.MouseCursor.EW_RESIZE;
                        } else if (dragTarget === 1 /* WINDOW */ && !this._windowEqRange()) {
                            cursor = Profiler.MouseCursor.GRAB;
                        }
                    }
                    this._mouseController.updateCursor(cursor);
                };

                FlameChartHeader.prototype.onMouseOver = function (x, y) {
                    this.onMouseMove(x, y);
                };

                FlameChartHeader.prototype.onMouseOut = function () {
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };

                FlameChartHeader.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    var dragInfo = this._dragInfo;
                    if (dragInfo.target === 4 /* HANDLE_BOTH */) {
                        if (deltaX !== 0) {
                            dragInfo.target = (deltaX < 0) ? 2 /* HANDLE_LEFT */ : 3 /* HANDLE_RIGHT */;
                        } else {
                            return;
                        }
                    }
                    var windowStart = this._windowStart;
                    var windowEnd = this._windowEnd;
                    var delta = this._toTimeRelative(deltaX);
                    switch (dragInfo.target) {
                        case 1 /* WINDOW */:
                            var mult = (this._type === 0 /* OVERVIEW */) ? 1 : -1;
                            windowStart = dragInfo.windowStartInitial + mult * delta;
                            windowEnd = dragInfo.windowEndInitial + mult * delta;
                            break;
                        case 2 /* HANDLE_LEFT */:
                            windowStart = clamp(dragInfo.windowStartInitial + delta, this._rangeStart, windowEnd - Profiler.FlameChartBase.MIN_WINDOW_LEN);
                            break;
                        case 3 /* HANDLE_RIGHT */:
                            windowEnd = clamp(dragInfo.windowEndInitial + delta, windowStart + Profiler.FlameChartBase.MIN_WINDOW_LEN, this._rangeEnd);
                            break;
                        default:
                            return;
                    }
                    this._controller.setWindow(windowStart, windowEnd);
                };

                FlameChartHeader.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    this._dragInfo = null;
                    this.onMouseMove(currentX, currentY);
                };

                FlameChartHeader.prototype.onClick = function (x, y) {
                    if (this._dragInfo.target === 1 /* WINDOW */) {
                        this._mouseController.updateCursor(Profiler.MouseCursor.GRAB);
                    }
                };

                FlameChartHeader.prototype.onHoverStart = function (x, y) {
                };
                FlameChartHeader.prototype.onHoverEnd = function () {
                };
                FlameChartHeader.TICK_MAX_WIDTH = 75;
                return FlameChartHeader;
            })(Profiler.FlameChartBase);
            Profiler.FlameChartHeader = FlameChartHeader;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        (function (Profiler) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations under the License.
            */
            (function (_TraceLogger) {
                var TraceLoggerProgressInfo = (function () {
                    function TraceLoggerProgressInfo(pageLoaded, threadsTotal, threadsLoaded, threadFilesTotal, threadFilesLoaded) {
                        this.pageLoaded = pageLoaded;
                        this.threadsTotal = threadsTotal;
                        this.threadsLoaded = threadsLoaded;
                        this.threadFilesTotal = threadFilesTotal;
                        this.threadFilesLoaded = threadFilesLoaded;
                    }
                    TraceLoggerProgressInfo.prototype.toString = function () {
                        return "[" + ["pageLoaded", "threadsTotal", "threadsLoaded", "threadFilesTotal", "threadFilesLoaded"].map(function (value, i, arr) {
                            return value + ":" + this[value];
                        }, this).join(", ") + "]";
                    };
                    return TraceLoggerProgressInfo;
                })();
                _TraceLogger.TraceLoggerProgressInfo = TraceLoggerProgressInfo;

                var TraceLogger = (function () {
                    function TraceLogger(baseUrl) {
                        this._baseUrl = baseUrl;
                        this._threads = [];
                        this._progressInfo = null;
                    }
                    TraceLogger.prototype.loadPage = function (url, callback, progress) {
                        this._threads = [];
                        this._pageLoadCallback = callback;
                        this._pageLoadProgressCallback = progress;
                        this._progressInfo = new TraceLoggerProgressInfo(false, 0, 0, 0, 0);
                        this._loadData([url], this._onLoadPage.bind(this));
                    };

                    Object.defineProperty(TraceLogger.prototype, "buffers", {
                        get: function () {
                            var buffers = [];
                            for (var i = 0, n = this._threads.length; i < n; i++) {
                                buffers.push(this._threads[i].buffer);
                            }
                            return buffers;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    TraceLogger.prototype._onProgress = function () {
                        if (this._pageLoadProgressCallback) {
                            this._pageLoadProgressCallback.call(this, this._progressInfo);
                        }
                    };

                    TraceLogger.prototype._onLoadPage = function (result) {
                        if (result && result.length == 1) {
                            var self = this;
                            var count = 0;
                            var threads = result[0];
                            var threadCount = threads.length;
                            this._threads = Array(threadCount);
                            this._progressInfo.pageLoaded = true;
                            this._progressInfo.threadsTotal = threadCount;
                            for (var i = 0; i < threads.length; i++) {
                                var thread = threads[i];
                                var urls = [thread.dict, thread.tree];
                                if (thread.corrections) {
                                    urls.push(thread.corrections);
                                }
                                this._progressInfo.threadFilesTotal += urls.length;
                                this._loadData(urls, (function (index) {
                                    return function (result) {
                                        if (result) {
                                            var thread = new _TraceLogger.Thread(result);
                                            thread.buffer.name = "Thread " + index;
                                            self._threads[index] = thread;
                                        }
                                        count++;
                                        self._progressInfo.threadsLoaded++;
                                        self._onProgress();
                                        if (count === threadCount) {
                                            self._pageLoadCallback.call(self, null, self._threads);
                                        }
                                    };
                                })(i), function (count) {
                                    self._progressInfo.threadFilesLoaded++;
                                    self._onProgress();
                                });
                            }
                            this._onProgress();
                        } else {
                            this._pageLoadCallback.call(this, "Error loading page.", null);
                        }
                    };

                    TraceLogger.prototype._loadData = function (urls, callback, progress) {
                        var count = 0;
                        var errors = 0;
                        var expected = urls.length;
                        var received = [];
                        received.length = expected;
                        for (var i = 0; i < expected; i++) {
                            var url = this._baseUrl + urls[i];
                            var isTL = /\.tl$/i.test(url);
                            var xhr = new XMLHttpRequest();
                            var responseType = isTL ? "arraybuffer" : "json";
                            xhr.open('GET', url, true);
                            xhr.responseType = responseType;
                            xhr.onload = (function (index, type) {
                                return function (event) {
                                    if (type === "json") {
                                        var json = this.response;
                                        if (typeof json === "string") {
                                            try  {
                                                json = JSON.parse(json);
                                                received[index] = json;
                                            } catch (e) {
                                                errors++;
                                            }
                                        } else {
                                            received[index] = json;
                                        }
                                    } else {
                                        received[index] = this.response;
                                    }
                                    ++count;
                                    if (progress) {
                                        progress(count);
                                    }
                                    if (count === expected) {
                                        callback(received);
                                    }
                                };
                            })(i, responseType);
                            xhr.send();
                        }
                    };

                    TraceLogger.colors = [
                        "#0044ff", "#8c4b00", "#cc5c33", "#ff80c4", "#ffbfd9", "#ff8800", "#8c5e00", "#adcc33", "#b380ff", "#bfd9ff",
                        "#ffaa00", "#8c0038", "#bf8f30", "#f780ff", "#cc99c9", "#aaff00", "#000073", "#452699", "#cc8166", "#cca799",
                        "#000066", "#992626", "#cc6666", "#ccc299", "#ff6600", "#526600", "#992663", "#cc6681", "#99ccc2", "#ff0066",
                        "#520066", "#269973", "#61994d", "#739699", "#ffcc00", "#006629", "#269199", "#94994d", "#738299", "#ff0000",
                        "#590000", "#234d8c", "#8c6246", "#7d7399", "#ee00ff", "#00474d", "#8c2385", "#8c7546", "#7c8c69", "#eeff00",
                        "#4d003d", "#662e1a", "#62468c", "#8c6969", "#6600ff", "#4c2900", "#1a6657", "#8c464f", "#8c6981", "#44ff00",
                        "#401100", "#1a2466", "#663355", "#567365", "#d90074", "#403300", "#101d40", "#59562d", "#66614d", "#cc0000",
                        "#002b40", "#234010", "#4c2626", "#4d5e66", "#00a3cc", "#400011", "#231040", "#4c3626", "#464359", "#0000bf",
                        "#331b00", "#80e6ff", "#311a33", "#4d3939", "#a69b00", "#003329", "#80ffb2", "#331a20", "#40303d", "#00a658",
                        "#40ffd9", "#ffc480", "#ffe1bf", "#332b26", "#8c2500", "#9933cc", "#80fff6", "#ffbfbf", "#303326", "#005e8c",
                        "#33cc47", "#b2ff80", "#c8bfff", "#263332", "#00708c", "#cc33ad", "#ffe680", "#f2ffbf", "#262a33", "#388c00",
                        "#335ccc", "#8091ff", "#bfffd9"
                    ];
                    return TraceLogger;
                })();
                _TraceLogger.TraceLogger = TraceLogger;
            })(Profiler.TraceLogger || (Profiler.TraceLogger = {}));
            var TraceLogger = Profiler.TraceLogger;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Tools) {
        (function (Profiler) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations under the License.
            */
            (function (TraceLogger) {
                var Offsets;
                (function (Offsets) {
                    Offsets[Offsets["START_HI"] = 0] = "START_HI";
                    Offsets[Offsets["START_LO"] = 4] = "START_LO";
                    Offsets[Offsets["STOP_HI"] = 8] = "STOP_HI";
                    Offsets[Offsets["STOP_LO"] = 12] = "STOP_LO";
                    Offsets[Offsets["TEXTID"] = 16] = "TEXTID";
                    Offsets[Offsets["NEXTID"] = 20] = "NEXTID";
                })(Offsets || (Offsets = {}));

                var Thread = (function () {
                    function Thread(data) {
                        if (data.length >= 2) {
                            this._text = data[0];
                            this._data = new DataView(data[1]);
                            this._buffer = new Profiler.TimelineBuffer();
                            this._walkTree(0);
                        }
                    }
                    Object.defineProperty(Thread.prototype, "buffer", {
                        get: function () {
                            return this._buffer;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Thread.prototype._walkTree = function (id) {
                        var data = this._data;
                        var buffer = this._buffer;
                        do {
                            var index = id * Thread.ITEM_SIZE;
                            var start = data.getUint32(index + 0 /* START_HI */) * 4294967295 + data.getUint32(index + 4 /* START_LO */);
                            var stop = data.getUint32(index + 8 /* STOP_HI */) * 4294967295 + data.getUint32(index + 12 /* STOP_LO */);
                            var textId = data.getUint32(index + 16 /* TEXTID */);
                            var nextId = data.getUint32(index + 20 /* NEXTID */);
                            var hasChildren = ((textId & 1) === 1);
                            textId >>>= 1;
                            var text = this._text[textId];
                            buffer.enter(text, null, start / 1000000);
                            if (hasChildren) {
                                this._walkTree(id + 1);
                            }
                            buffer.leave(text, null, stop / 1000000);
                            id = nextId;
                        } while(id !== 0);
                    };
                    Thread.ITEM_SIZE = 8 + 8 + 4 + 4;
                    return Thread;
                })();
                TraceLogger.Thread = Thread;
            })(Profiler.TraceLogger || (Profiler.TraceLogger = {}));
            var TraceLogger = Profiler.TraceLogger;
        })(Tools.Profiler || (Tools.Profiler = {}));
        var Profiler = Tools.Profiler;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
/// <reference path='../references.ts' />
/// <reference path='profile.ts' />
/// <reference path='timelineFrame.ts' />
/// <reference path='timelineBuffer.ts' />
/// <reference path='controller.ts' />
/// <reference path='mouseController.ts' />
/// <reference path='flameChartBase.ts' />
/// <reference path='flameChart.ts' />
/// <reference path='flameChartOverview.ts' />
/// <reference path='flameChartHeader.ts' />
/// <reference path='tracelogger/traceLogger.ts' />
/// <reference path='tracelogger/thread.ts' />
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (_Terminal) {
            var clamp = Shumway.NumberUtilities.clamp;

            var Buffer = (function () {
                function Buffer() {
                    this.length = 0;
                    this.lines = [];
                    this.format = [];
                    this.time = [];
                    this.repeat = [];
                    this.length = 0;
                }
                Buffer.prototype.append = function (line, color) {
                    var lines = this.lines;
                    if (lines.length > 0 && lines[lines.length - 1] === line) {
                        this.repeat[lines.length - 1]++;
                        return;
                    }
                    this.lines.push(line);
                    this.repeat.push(1);
                    this.format.push(color ? { backgroundFillStyle: color } : undefined);
                    this.time.push(performance.now());
                    this.length++;
                };
                Buffer.prototype.get = function (i) {
                    return this.lines[i];
                };
                Buffer.prototype.getFormat = function (i) {
                    return this.format[i];
                };
                Buffer.prototype.getTime = function (i) {
                    return this.time[i];
                };
                Buffer.prototype.getRepeat = function (i) {
                    return this.repeat[i];
                };
                return Buffer;
            })();
            _Terminal.Buffer = Buffer;

            /**
            * If you're going to write a lot of data to the browser console you're gonna have a bad time. This may make your
            * life a little more pleasant.
            */
            var Terminal = (function () {
                function Terminal(canvas) {
                    this.lineColor = "#2A2A2A";
                    this.alternateLineColor = "#262626";
                    this.textColor = "#FFFFFF";
                    this.selectionColor = "#96C9F3";
                    this.selectionTextColor = "#000000";
                    this.ratio = 1;
                    this.showLineNumbers = true;
                    this.showLineTime = false;
                    this.showLineCounter = false;
                    this.canvas = canvas;
                    this.canvas.focus();
                    this.context = canvas.getContext('2d', { original: true });
                    this.context.fillStyle = "#FFFFFF";
                    this.fontSize = 10;
                    this.lineIndex = 0;
                    this.pageIndex = 0;
                    this.columnIndex = 0;
                    this.selection = null;
                    this.lineHeight = 15;
                    this.hasFocus = false;

                    window.addEventListener('resize', this._resizeHandler.bind(this), false);
                    this._resizeHandler();

                    this.textMarginLeft = 4;
                    this.textMarginBottom = 4;
                    this.refreshFrequency = 0;

                    this.buffer = new Buffer();

                    canvas.addEventListener('keydown', onKeyDown.bind(this), false);
                    canvas.addEventListener('focus', onFocusIn.bind(this), false);
                    canvas.addEventListener('blur', onFocusOut.bind(this), false);

                    var PAGE_UP = 33;
                    var PAGE_DOWN = 34;
                    var HOME = 36;
                    var END = 35;
                    var UP = 38;
                    var DOWN = 40;
                    var LEFT = 37;
                    var RIGHT = 39;
                    var KEY_A = 65;
                    var KEY_C = 67;
                    var KEY_F = 70;
                    var ESCAPE = 27;
                    var KEY_N = 78;
                    var KEY_T = 84;

                    function onFocusIn(event) {
                        this.hasFocus = true;
                    }
                    function onFocusOut(event) {
                        this.hasFocus = false;
                    }

                    function onKeyDown(event) {
                        var delta = 0;
                        switch (event.keyCode) {
                            case KEY_N:
                                this.showLineNumbers = !this.showLineNumbers;
                                break;
                            case KEY_T:
                                this.showLineTime = !this.showLineTime;
                                break;
                            case UP:
                                delta = -1;
                                break;
                            case DOWN:
                                delta = +1;
                                break;
                            case PAGE_UP:
                                delta = -this.pageLineCount;
                                break;
                            case PAGE_DOWN:
                                delta = this.pageLineCount;
                                break;
                            case HOME:
                                delta = -this.lineIndex;
                                break;
                            case END:
                                delta = this.buffer.length - this.lineIndex;
                                break;
                            case LEFT:
                                this.columnIndex -= event.metaKey ? 10 : 1;
                                if (this.columnIndex < 0) {
                                    this.columnIndex = 0;
                                }
                                event.preventDefault();
                                break;
                            case RIGHT:
                                this.columnIndex += event.metaKey ? 10 : 1;
                                event.preventDefault();
                                break;
                            case KEY_A:
                                if (event.metaKey) {
                                    this.selection = { start: 0, end: this.buffer.length };
                                    event.preventDefault();
                                }
                                break;
                            case KEY_C:
                                if (event.metaKey) {
                                    var str = "";
                                    if (this.selection) {
                                        for (var i = this.selection.start; i <= this.selection.end; i++) {
                                            str += this.buffer.get(i) + "\n";
                                        }
                                    } else {
                                        str = this.buffer.get(this.lineIndex);
                                    }
                                    alert(str);
                                }
                                break;
                            default:
                                break;
                        }
                        if (event.metaKey) {
                            delta *= this.pageLineCount;
                        }
                        if (delta) {
                            this.scroll(delta);
                            event.preventDefault();
                        }
                        if (delta && event.shiftKey) {
                            if (!this.selection) {
                                if (delta > 0) {
                                    this.selection = { start: this.lineIndex - delta, end: this.lineIndex };
                                } else if (delta < 0) {
                                    this.selection = { start: this.lineIndex, end: this.lineIndex - delta };
                                }
                            } else {
                                if (this.lineIndex > this.selection.start) {
                                    this.selection.end = this.lineIndex;
                                } else {
                                    this.selection.start = this.lineIndex;
                                }
                            }
                        } else if (delta) {
                            this.selection = null;
                        }
                        this.paint();
                    }
                }
                Terminal.prototype.resize = function () {
                    this._resizeHandler();
                };

                Terminal.prototype._resizeHandler = function () {
                    var parent = this.canvas.parentElement;
                    var cw = parent.clientWidth;
                    var ch = parent.clientHeight - 1;

                    var devicePixelRatio = window.devicePixelRatio || 1;
                    var backingStoreRatio = 1;
                    if (devicePixelRatio !== backingStoreRatio) {
                        this.ratio = devicePixelRatio / backingStoreRatio;
                        this.canvas.width = cw * this.ratio;
                        this.canvas.height = ch * this.ratio;
                        this.canvas.style.width = cw + 'px';
                        this.canvas.style.height = ch + 'px';
                    } else {
                        this.ratio = 1;
                        this.canvas.width = cw;
                        this.canvas.height = ch;
                    }
                    this.pageLineCount = Math.floor(this.canvas.height / this.lineHeight);
                };

                Terminal.prototype.gotoLine = function (index) {
                    this.lineIndex = clamp(index, 0, this.buffer.length - 1);
                };
                Terminal.prototype.scrollIntoView = function () {
                    if (this.lineIndex < this.pageIndex) {
                        this.pageIndex = this.lineIndex;
                    } else if (this.lineIndex >= this.pageIndex + this.pageLineCount) {
                        this.pageIndex = this.lineIndex - this.pageLineCount + 1;
                    }
                };
                Terminal.prototype.scroll = function (delta) {
                    this.gotoLine(this.lineIndex + delta);
                    this.scrollIntoView();
                };
                Terminal.prototype.paint = function () {
                    var lineCount = this.pageLineCount;
                    if (this.pageIndex + lineCount > this.buffer.length) {
                        lineCount = this.buffer.length - this.pageIndex;
                    }

                    var charSize = 5;
                    var lineNumberMargin = this.textMarginLeft;
                    var lineTimeMargin = lineNumberMargin + (this.showLineNumbers ? (String(this.buffer.length).length + 2) * charSize : 0);
                    var lineRepeatMargin = lineTimeMargin + (this.showLineTime ? charSize * 8 : 2 * charSize);
                    var lineMargin = lineRepeatMargin + charSize * 5;
                    this.context.font = this.fontSize + 'px Consolas, "Liberation Mono", Courier, monospace';
                    this.context.setTransform(this.ratio, 0, 0, this.ratio, 0, 0);

                    var w = this.canvas.width;
                    var h = this.lineHeight;

                    for (var i = 0; i < lineCount; i++) {
                        var y = i * this.lineHeight;
                        var lineIndex = this.pageIndex + i;
                        var line = this.buffer.get(lineIndex);
                        var lineFormat = this.buffer.getFormat(lineIndex);
                        var lineRepeat = this.buffer.getRepeat(lineIndex);

                        // var lineTimeDelta = lineIndex > 1 ? this.buffer.getTime(lineIndex) - this.buffer.getTime(lineIndex - 1) : 0;
                        var lineTimeDelta = lineIndex > 1 ? this.buffer.getTime(lineIndex) - this.buffer.getTime(0) : 0;

                        this.context.fillStyle = lineIndex % 2 ? this.lineColor : this.alternateLineColor;
                        if (lineFormat && lineFormat.backgroundFillStyle) {
                            this.context.fillStyle = lineFormat.backgroundFillStyle;
                        }
                        this.context.fillRect(0, y, w, h);
                        this.context.fillStyle = this.selectionTextColor;
                        this.context.fillStyle = this.textColor;

                        if (this.selection && lineIndex >= this.selection.start && lineIndex <= this.selection.end) {
                            this.context.fillStyle = this.selectionColor;
                            this.context.fillRect(0, y, w, h);
                            this.context.fillStyle = this.selectionTextColor;
                        }
                        if (this.hasFocus && lineIndex === this.lineIndex) {
                            this.context.fillStyle = this.selectionColor;
                            this.context.fillRect(0, y, w, h);
                            this.context.fillStyle = this.selectionTextColor;
                        }
                        if (this.columnIndex > 0) {
                            line = line.substring(this.columnIndex);
                        }
                        var marginTop = (i + 1) * this.lineHeight - this.textMarginBottom;
                        if (this.showLineNumbers) {
                            this.context.fillText(String(lineIndex), lineNumberMargin, marginTop);
                        }
                        if (this.showLineTime) {
                            this.context.fillText(lineTimeDelta.toFixed(1).padLeft(' ', 6), lineTimeMargin, marginTop);
                        }
                        if (lineRepeat > 1) {
                            this.context.fillText(String(lineRepeat).padLeft(' ', 3), lineRepeatMargin, marginTop);
                        }
                        this.context.fillText(line, lineMargin, marginTop);
                    }
                };

                Terminal.prototype.refreshEvery = function (ms) {
                    var that = this;
                    this.refreshFrequency = ms;
                    function refresh() {
                        that.paint();
                        if (that.refreshFrequency) {
                            setTimeout(refresh, that.refreshFrequency);
                        }
                    }
                    if (that.refreshFrequency) {
                        setTimeout(refresh, that.refreshFrequency);
                    }
                };

                Terminal.prototype.isScrolledToBottom = function () {
                    return this.lineIndex === this.buffer.length - 1;
                };
                return Terminal;
            })();
            _Terminal.Terminal = Terminal;
        })(Tools.Terminal || (Tools.Terminal = {}));
        var Terminal = Tools.Terminal;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
/// <reference path='../references.ts' />
/// <reference path='terminal.ts' />
var Shumway;
(function (Shumway) {
    (function (Tools) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Mini) {
            var FPS = (function () {
                function FPS(canvas) {
                    this._index = 0;
                    this._lastTime = 0;
                    this._lastWeightedTime = 0;
                    this._gradient = [
                        "#FF0000",
                        "#FF1100",
                        "#FF2300",
                        "#FF3400",
                        "#FF4600",
                        "#FF5700",
                        "#FF6900",
                        "#FF7B00",
                        "#FF8C00",
                        "#FF9E00",
                        "#FFAF00",
                        "#FFC100",
                        "#FFD300",
                        "#FFE400",
                        "#FFF600",
                        "#F7FF00",
                        "#E5FF00",
                        "#D4FF00",
                        "#C2FF00",
                        "#B0FF00",
                        "#9FFF00",
                        "#8DFF00",
                        "#7CFF00",
                        "#6AFF00",
                        "#58FF00",
                        "#47FF00",
                        "#35FF00",
                        "#24FF00",
                        "#12FF00",
                        "#00FF00"
                    ];
                    this._canvas = canvas;
                    this._context = canvas.getContext("2d");
                    window.addEventListener('resize', this._resizeHandler.bind(this), false);
                    this._resizeHandler();
                }
                FPS.prototype._resizeHandler = function () {
                    var parent = this._canvas.parentElement;
                    var cw = parent.clientWidth;
                    var ch = parent.clientHeight - 1;
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    var backingStoreRatio = 1;
                    if (devicePixelRatio !== backingStoreRatio) {
                        this._ratio = devicePixelRatio / backingStoreRatio;
                        this._canvas.width = cw * this._ratio;
                        this._canvas.height = ch * this._ratio;
                        this._canvas.style.width = cw + 'px';
                        this._canvas.style.height = ch + 'px';
                    } else {
                        this._ratio = 1;
                        this._canvas.width = cw;
                        this._canvas.height = ch;
                    }
                };

                FPS.prototype.tickAndRender = function (idle) {
                    if (typeof idle === "undefined") { idle = false; }
                    if (this._lastTime === 0) {
                        this._lastTime = performance.now();
                        return;
                    }

                    var elapsedTime = performance.now() - this._lastTime;
                    var weightRatio = 0.3;
                    var weightedTime = elapsedTime * (1 - weightRatio) + this._lastWeightedTime * weightRatio;

                    var context = this._context;
                    var w = 2 * this._ratio;
                    var wPadding = 1;
                    var textWidth = 20;
                    var count = ((this._canvas.width - textWidth) / (w + wPadding)) | 0;

                    var index = this._index++;
                    if (this._index > count) {
                        this._index = 0;
                    }

                    context.globalAlpha = 1;
                    context.fillStyle = "black";
                    context.fillRect(textWidth + index * (w + wPadding), 0, w * 4, this._canvas.height);

                    var r = (1000 / 60) / weightedTime;
                    context.fillStyle = this._gradient[r * (this._gradient.length - 1) | 0];
                    context.globalAlpha = idle ? 0.2 : 1;
                    var v = this._canvas.height * r | 0;

                    context.fillRect(textWidth + index * (w + wPadding), 0, w, v);
                    if (index % 16 === 0) {
                        context.globalAlpha = 1;
                        context.fillStyle = "black";
                        context.fillRect(0, 0, textWidth, this._canvas.height);
                        context.fillStyle = "white";
                        context.font = "10px Arial";
                        context.fillText((1000 / weightedTime).toFixed(0), 2, 8);
                    }

                    this._lastTime = performance.now();
                    this._lastWeightedTime = weightedTime;
                };
                return FPS;
            })();
            Mini.FPS = FPS;
        })(Tools.Mini || (Tools.Mini = {}));
        var Mini = Tools.Mini;
    })(Shumway.Tools || (Shumway.Tools = {}));
    var Tools = Shumway.Tools;
})(Shumway || (Shumway = {}));
/// <reference path='../references.ts' />
/// <reference path='fps.ts' />
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='theme/ui.ts' />
/// <reference path='profiler/references.ts' />
/// <reference path='terminal/references.ts' />
/// <reference path='mini/references.ts' />
//# sourceMappingURL=tools.js.map

console.timeEnd("Load Shared Dependencies");
console.time("Load GFX Dependencies");
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (TraceLevel) {
            TraceLevel[TraceLevel["None"] = 0] = "None";
            TraceLevel[TraceLevel["Brief"] = 1] = "Brief";
            TraceLevel[TraceLevel["Verbose"] = 2] = "Verbose";
        })(GFX.TraceLevel || (GFX.TraceLevel = {}));
        var TraceLevel = GFX.TraceLevel;

        var counter = Shumway.Metrics.Counter.instance;
        GFX.frameCounter = new Shumway.Metrics.Counter(true);

        GFX.traceLevel = 2 /* Verbose */;
        GFX.writer = null;

        function frameCount(name) {
            counter.count(name);
            GFX.frameCounter.count(name);
        }
        GFX.frameCount = frameCount;

        GFX.timelineBuffer = new Shumway.Tools.Profiler.TimelineBuffer("GFX");

        function enterTimeline(name, data) {
            profile && GFX.timelineBuffer && GFX.timelineBuffer.enter(name, data);
        }
        GFX.enterTimeline = enterTimeline;

        function leaveTimeline(name, data) {
            profile && GFX.timelineBuffer && GFX.timelineBuffer.leave(name, data);
        }
        GFX.leaveTimeline = leaveTimeline;

        var nativeAddColorStop = null;
        var nativeCreateLinearGradient = null;
        var nativeCreateRadialGradient = null;

        /**
        * Transforms a fill or stroke style by the given color matrix.
        */
        function transformStyle(context, style, colorMatrix) {
            if (!polyfillColorTransform || !colorMatrix) {
                return style;
            }
            if (typeof style === "string") {
                // Parse CSS color styles and transform them.
                var rgba = Shumway.ColorUtilities.cssStyleToRGBA(style);
                return Shumway.ColorUtilities.rgbaToCSSStyle(colorMatrix.transformRGBA(rgba));
            } else if (style instanceof CanvasGradient) {
                if (style._template) {
                    // If gradient style has a template, construct a new gradient style from it whith
                    // its color stops transformed.
                    return style._template.createCanvasGradient(context, colorMatrix);
                }
            }
            return style;
        }

        /**
        * Whether to polyfill color transforms. This adds a |globalColorMatrix| property on |CanvasRenderingContext2D|
        * that is used to transform all stroke and fill styles before a drawing operation happens.
        */
        var polyfillColorTransform = true;

        /**
        * Gradients are opaque objects and their properties cannot be inspected. Here we hijack gradient style constructors
        * and attach "template" objects on gradients so that we can keep track of their position attributes and color stops.
        * Using these "template" objects, we can clone and transform gradients.
        */
        if (polyfillColorTransform && typeof CanvasRenderingContext2D !== 'undefined') {
            nativeAddColorStop = CanvasGradient.prototype.addColorStop;
            nativeCreateLinearGradient = CanvasRenderingContext2D.prototype.createLinearGradient;
            nativeCreateRadialGradient = CanvasRenderingContext2D.prototype.createRadialGradient;

            CanvasRenderingContext2D.prototype.createLinearGradient = function (x0, y0, x1, y1) {
                var gradient = new CanvasLinearGradient(x0, y0, x1, y1);
                return gradient.createCanvasGradient(this, null);
            };

            CanvasRenderingContext2D.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
                var gradient = new CanvasRadialGradient(x0, y0, r0, x1, y1, r1);
                return gradient.createCanvasGradient(this, null);
            };

            CanvasGradient.prototype.addColorStop = function (offset, color) {
                nativeAddColorStop.call(this, offset, color);
                this._template.addColorStop(offset, color);
            };
        }

        var ColorStop = (function () {
            function ColorStop(offset, color) {
                this.offset = offset;
                this.color = color;
                // ...
            }
            return ColorStop;
        })();

        /**
        * Template for linear gradients.
        */
        var CanvasLinearGradient = (function () {
            function CanvasLinearGradient(x0, y0, x1, y1) {
                this.x0 = x0;
                this.y0 = y0;
                this.x1 = x1;
                this.y1 = y1;
                this.colorStops = [];
                // ...
            }
            CanvasLinearGradient.prototype.addColorStop = function (offset, color) {
                this.colorStops.push(new ColorStop(offset, color));
            };
            CanvasLinearGradient.prototype.createCanvasGradient = function (context, colorMatrix) {
                var gradient = nativeCreateLinearGradient.call(context, this.x0, this.y0, this.x1, this.y1);
                var colorStops = this.colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    var colorStop = colorStops[i];
                    var offset = colorStop.offset;
                    var color = colorStop.color;
                    color = colorMatrix ? transformStyle(context, color, colorMatrix) : color;
                    nativeAddColorStop.call(gradient, offset, color);
                }
                gradient._template = this;
                gradient._transform = this._transform;
                return gradient;
            };
            return CanvasLinearGradient;
        })();

        /**
        * Template for radial gradients.
        */
        var CanvasRadialGradient = (function () {
            function CanvasRadialGradient(x0, y0, r0, x1, y1, r1) {
                this.x0 = x0;
                this.y0 = y0;
                this.r0 = r0;
                this.x1 = x1;
                this.y1 = y1;
                this.r1 = r1;
                this.colorStops = [];
                // ...
            }
            CanvasRadialGradient.prototype.addColorStop = function (offset, color) {
                this.colorStops.push(new ColorStop(offset, color));
            };
            CanvasRadialGradient.prototype.createCanvasGradient = function (context, colorMatrix) {
                var gradient = nativeCreateRadialGradient.call(context, this.x0, this.y0, this.r0, this.x1, this.y1, this.r1);
                var colorStops = this.colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    var colorStop = colorStops[i];
                    var offset = colorStop.offset;
                    var color = colorStop.color;
                    color = colorMatrix ? transformStyle(context, color, colorMatrix) : color;
                    nativeAddColorStop.call(gradient, offset, color);
                }
                gradient._template = this;
                gradient._transform = this._transform;
                return gradient;
            };
            return CanvasRadialGradient;
        })();

        var PathCommand;
        (function (PathCommand) {
            PathCommand[PathCommand["ClosePath"] = 1] = "ClosePath";
            PathCommand[PathCommand["MoveTo"] = 2] = "MoveTo";
            PathCommand[PathCommand["LineTo"] = 3] = "LineTo";
            PathCommand[PathCommand["QuadraticCurveTo"] = 4] = "QuadraticCurveTo";
            PathCommand[PathCommand["BezierCurveTo"] = 5] = "BezierCurveTo";
            PathCommand[PathCommand["ArcTo"] = 6] = "ArcTo";
            PathCommand[PathCommand["Rect"] = 7] = "Rect";
            PathCommand[PathCommand["Arc"] = 8] = "Arc";
            PathCommand[PathCommand["Save"] = 9] = "Save";
            PathCommand[PathCommand["Restore"] = 10] = "Restore";
            PathCommand[PathCommand["Transform"] = 11] = "Transform";
        })(PathCommand || (PathCommand = {}));

        /**
        * Polyfill for missing |Path2D|. An instance of this class keeps a record of all drawing commands
        * ever called on it.
        */
        var Path = (function () {
            function Path(arg) {
                this._commands = new Uint8Array(Path._arrayBufferPool.acquire(8), 0, 8);
                this._commandPosition = 0;

                this._data = new Float64Array(Path._arrayBufferPool.acquire(8 * Float64Array.BYTES_PER_ELEMENT), 0, 8);
                this._dataPosition = 0;

                if (arg instanceof Path) {
                    this.addPath(arg);
                }
            }
            /**
            * Takes a |Path2D| instance and a 2d context to replay the recorded drawing commands.
            */
            Path._apply = function (path, context) {
                var commands = path._commands;
                var d = path._data;
                var i = 0;
                var j = 0;
                context.beginPath();
                var commandPosition = path._commandPosition;
                while (i < commandPosition) {
                    switch (commands[i++]) {
                        case 1 /* ClosePath */:
                            context.closePath();
                            break;
                        case 2 /* MoveTo */:
                            context.moveTo(d[j++], d[j++]);
                            break;
                        case 3 /* LineTo */:
                            context.lineTo(d[j++], d[j++]);
                            break;
                        case 4 /* QuadraticCurveTo */:
                            context.quadraticCurveTo(d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case 5 /* BezierCurveTo */:
                            context.bezierCurveTo(d[j++], d[j++], d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case 6 /* ArcTo */:
                            context.arcTo(d[j++], d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case 7 /* Rect */:
                            context.rect(d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case 8 /* Arc */:
                            context.arc(d[j++], d[j++], d[j++], d[j++], d[j++], !!d[j++]);
                            break;
                        case 9 /* Save */:
                            context.save();
                            break;
                        case 10 /* Restore */:
                            context.restore();
                            break;
                        case 11 /* Transform */:
                            context.transform(d[j++], d[j++], d[j++], d[j++], d[j++], d[j++]);
                            break;
                    }
                }
            };

            Path.prototype._ensureCommandCapacity = function (length) {
                this._commands = Path._arrayBufferPool.ensureUint8ArrayLength(this._commands, length);
            };

            Path.prototype._ensureDataCapacity = function (length) {
                this._data = Path._arrayBufferPool.ensureFloat64ArrayLength(this._data, length);
            };

            Path.prototype._writeCommand = function (command) {
                if (this._commandPosition >= this._commands.length) {
                    this._ensureCommandCapacity(this._commandPosition + 1);
                }
                this._commands[this._commandPosition++] = command;
            };

            Path.prototype._writeData = function (a, b, c, d, e, f, g) {
                var argc = arguments.length;
                if (this._dataPosition + argc >= this._data.length) {
                    this._ensureDataCapacity(this._dataPosition + argc);
                }
                var data = this._data;
                var p = this._dataPosition;
                data[p] = a;
                data[p + 1] = b;
                if (argc > 2) {
                    data[p + 2] = c;
                    data[p + 3] = d;
                    if (argc > 4) {
                        data[p + 4] = e;
                        data[p + 5] = f;
                        if (argc > 5) {
                            data[p + 6] = g;
                        }
                    }
                }
                this._dataPosition += argc;
            };

            Path.prototype.closePath = function () {
                this._writeCommand(1 /* ClosePath */);
            };

            Path.prototype.moveTo = function (x, y) {
                this._writeCommand(2 /* MoveTo */);
                this._writeData(x, y);
            };

            Path.prototype.lineTo = function (x, y) {
                this._writeCommand(3 /* LineTo */);
                this._writeData(x, y);
            };

            Path.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
                this._writeCommand(4 /* QuadraticCurveTo */);
                this._writeData(cpx, cpy, x, y);
            };

            Path.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
                this._writeCommand(5 /* BezierCurveTo */);
                this._writeData(cp1x, cp1y, cp2x, cp2y, x, y);
            };

            Path.prototype.arcTo = function (x1, y1, x2, y2, radius) {
                this._writeCommand(6 /* ArcTo */);
                this._writeData(x1, y1, x2, y2, radius);
            };

            Path.prototype.rect = function (x, y, width, height) {
                this._writeCommand(7 /* Rect */);
                this._writeData(x, y, width, height);
            };

            Path.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
                this._writeCommand(8 /* Arc */);
                this._writeData(x, y, radius, startAngle, endAngle, +anticlockwise);
            };

            /**
            * Copies and transforms all drawing commands stored in |path|.
            */
            Path.prototype.addPath = function (path, transformation) {
                if (transformation) {
                    this._writeCommand(9 /* Save */);
                    this._writeCommand(11 /* Transform */);
                    this._writeData(transformation.a, transformation.b, transformation.c, transformation.d, transformation.e, transformation.f);
                }

                // Copy commands.
                var newCommandPosition = this._commandPosition + path._commandPosition;
                if (newCommandPosition >= this._commands.length) {
                    this._ensureCommandCapacity(newCommandPosition);
                }
                var commands = this._commands;
                var pathCommands = path._commands;
                for (var i = this._commandPosition, j = 0; i < newCommandPosition; i++) {
                    commands[i] = pathCommands[j++];
                }
                this._commandPosition = newCommandPosition;

                // Copy data.
                var newDataPosition = this._dataPosition + path._dataPosition;
                if (newDataPosition >= this._data.length) {
                    this._ensureDataCapacity(newDataPosition);
                }
                var data = this._data;
                var pathData = path._data;
                for (var i = this._dataPosition, j = 0; i < newDataPosition; i++) {
                    data[i] = pathData[j++];
                }
                this._dataPosition = newDataPosition;

                if (transformation) {
                    this._writeCommand(10 /* Restore */);
                }
            };
            Path._arrayBufferPool = new Shumway.ArrayBufferPool();
            return Path;
        })();
        GFX.Path = Path;

        // Polyfill |Path2D| if it is not defined or if its |addPath| method doesn't exist. This means that we
        // always need to polyfill this in FF until addPath lands which sucks.
        if (typeof CanvasRenderingContext2D !== 'undefined' && (typeof Path2D === 'undefined' || !Path2D.prototype.addPath)) {
            /**
            * We override all methods of |CanvasRenderingContext2D| that accept a |Path2D| object as one
            * of its arguments, so that we can apply all recorded drawing commands before calling the
            * original function.
            */
            var nativeFill = CanvasRenderingContext2D.prototype.fill;
            CanvasRenderingContext2D.prototype.fill = (function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    } else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeFill.call(this, fillRule);
                } else {
                    nativeFill.call(this);
                }
            });
            var nativeStroke = CanvasRenderingContext2D.prototype.stroke;
            CanvasRenderingContext2D.prototype.stroke = (function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    } else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeStroke.call(this, fillRule);
                } else {
                    nativeStroke.call(this);
                }
            });
            var nativeClip = CanvasRenderingContext2D.prototype.clip;
            CanvasRenderingContext2D.prototype.clip = (function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    } else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeClip.call(this, fillRule);
                } else {
                    nativeClip.call(this);
                }
            });

            // Expose our pollyfill to the global object.
            window['Path2D'] = Path;
        }

        if (typeof CanvasPattern !== "undefined") {
            /**
            * Polyfill |setTransform| on |CanvasPattern| and |CanvasGradient|. Firefox implements this for |CanvasPattern|
            * in Nightly but doesn't for |CanvasGradient| yet.
            *
            * This polyfill uses |Path2D|, which is polyfilled above. You can get a native implementaiton of |Path2D| in
            * Chrome if you enable experimental canvas features in |chrome://flags/|. In Firefox you'll have to wait for
            * https://bugzilla.mozilla.org/show_bug.cgi?id=985801 to land.
            */
            if (Path2D.prototype.addPath) {
                function setTransform(matrix) {
                    this._transform = matrix;
                    if (this._template) {
                        this._template._transform = matrix;
                    }
                }
                if (!CanvasPattern.prototype.setTransform) {
                    CanvasPattern.prototype.setTransform = setTransform;
                }
                if (!CanvasGradient.prototype.setTransform) {
                    CanvasGradient.prototype.setTransform = setTransform;
                }
                var originalFill = CanvasRenderingContext2D.prototype.fill;
                var originalStroke = CanvasRenderingContext2D.prototype.stroke;

                /**
                * If the current fillStyle is a |CanvasPattern| or |CanvasGradient| that has a SVGMatrix transformed applied to it, we
                * first apply the pattern's transform to the current context and then draw the path with the
                * inverse fillStyle transform applied to it so that it is drawn in the expected original location.
                */
                CanvasRenderingContext2D.prototype.fill = (function fill(path, fillRule) {
                    var supportsStyle = this.fillStyle instanceof CanvasPattern || this.fillStyle instanceof CanvasGradient;
                    var hasStyleTransformation = !!this.fillStyle._transform;
                    if (supportsStyle && hasStyleTransformation && path instanceof Path2D) {
                        var m = this.fillStyle._transform;
                        var i = m.inverse();

                        // Transform the context by the style transform ...
                        this.transform(m.a, m.b, m.c, m.d, m.e, m.f);

                        // transform the path by the inverse of the style transform ...
                        var transformedPath = new Path2D();
                        transformedPath.addPath(path, i);

                        // draw the transformed path, which should render it in its original position but with a transformed style.
                        originalFill.call(this, transformedPath, fillRule);
                        this.transform(i.a, i.b, i.c, i.d, i.e, i.f);
                        return;
                    }
                    if (arguments.length === 0) {
                        originalFill.call(this);
                    } else if (arguments.length === 1) {
                        originalFill.call(this, path);
                    } else if (arguments.length === 2) {
                        originalFill.call(this, path, fillRule);
                    }
                });

                /**
                * Same as for |fill| above.
                */
                CanvasRenderingContext2D.prototype.stroke = (function fill(path) {
                    var supportsStyle = this.strokeStyle instanceof CanvasPattern || this.strokeStyle instanceof CanvasGradient;
                    var hasStyleTransformation = !!this.strokeStyle._transform;
                    if (supportsStyle && hasStyleTransformation && path instanceof Path2D) {
                        var m = this.strokeStyle._transform;
                        var i = m.inverse();

                        // Transform the context by the style transform ...
                        this.transform(m.a, m.b, m.c, m.d, m.e, m.f);

                        // transform the path by the inverse of the style transform ...
                        var transformedPath = new Path2D();
                        transformedPath.addPath(path, i);

                        // draw the transformed path, which should render it in its original position but with a transformed style.
                        var oldLineWidth = this.lineWidth;
                        this.lineWidth *= (i.a + i.d) / 2; // Scale the lineWidth down since it will be scaled up by the current transform.
                        originalStroke.call(this, transformedPath);
                        this.transform(i.a, i.b, i.c, i.d, i.e, i.f);
                        this.lineWidth = oldLineWidth;
                        return;
                    }
                    if (arguments.length === 0) {
                        originalStroke.call(this);
                    } else if (arguments.length === 1) {
                        originalStroke.call(this, path);
                    }
                });
            }
        }

        /**
        * Polyfill |globalColorMatrix| on |CanvasRenderingContext2D|.
        */
        if (typeof CanvasRenderingContext2D !== 'undefined' && CanvasRenderingContext2D.prototype.globalColorMatrix === undefined) {
            var previousFill = CanvasRenderingContext2D.prototype.fill;
            var previousStroke = CanvasRenderingContext2D.prototype.stroke;
            var previousFillText = CanvasRenderingContext2D.prototype.fillText;
            var previousStrokeText = CanvasRenderingContext2D.prototype.strokeText;

            Object.defineProperty(CanvasRenderingContext2D.prototype, "globalColorMatrix", {
                get: function () {
                    if (this._globalColorMatrix) {
                        return this._globalColorMatrix.clone();
                    }
                    return null;
                },
                set: function (matrix) {
                    if (!matrix) {
                        this._globalColorMatrix = null;
                        return;
                    }
                    if (this._globalColorMatrix) {
                        this._globalColorMatrix.copyFrom(matrix);
                    } else {
                        this._globalColorMatrix = matrix.clone();
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Intercept calls to |fill| and transform fill style if a |globalColorMatrix| is set.
            */
            CanvasRenderingContext2D.prototype.fill = (function (a, b) {
                var oldFillStyle = null;
                if (this._globalColorMatrix) {
                    oldFillStyle = this.fillStyle;
                    this.fillStyle = transformStyle(this, this.fillStyle, this._globalColorMatrix);
                }
                if (arguments.length === 0) {
                    previousFill.call(this);
                } else if (arguments.length === 1) {
                    previousFill.call(this, a);
                } else if (arguments.length === 2) {
                    previousFill.call(this, a, b);
                }
                if (oldFillStyle) {
                    this.fillStyle = oldFillStyle;
                }
            });

            /**
            * Same as |fill| above.
            */
            CanvasRenderingContext2D.prototype.stroke = (function (a, b) {
                var oldStrokeStyle = null;
                if (this._globalColorMatrix) {
                    oldStrokeStyle = this.strokeStyle;
                    this.strokeStyle = transformStyle(this, this.strokeStyle, this._globalColorMatrix);
                }
                if (arguments.length === 0) {
                    previousStroke.call(this);
                } else if (arguments.length === 1) {
                    previousStroke.call(this, a);
                }
                if (oldStrokeStyle) {
                    this.strokeStyle = oldStrokeStyle;
                }
            });

            /**
            * Same as |fill| above.
            */
            CanvasRenderingContext2D.prototype.fillText = (function (text, x, y, maxWidth) {
                var oldFillStyle = null;
                if (this._globalColorMatrix) {
                    oldFillStyle = this.fillStyle;
                    this.fillStyle = transformStyle(this, this.fillStyle, this._globalColorMatrix);
                }
                if (arguments.length === 3) {
                    previousFillText.call(this, text, x, y);
                } else if (arguments.length === 4) {
                    previousFillText.call(this, text, x, y, maxWidth);
                } else {
                    Shumway.Debug.unexpected();
                }
                if (oldFillStyle) {
                    this.fillStyle = oldFillStyle;
                }
            });

            /**
            * Same as |fill| above.
            */
            CanvasRenderingContext2D.prototype.strokeText = (function (text, x, y, maxWidth) {
                var oldStrokeStyle = null;
                if (this._globalColorMatrix) {
                    oldStrokeStyle = this.strokeStyle;
                    this.strokeStyle = transformStyle(this, this.strokeStyle, this._globalColorMatrix);
                }
                if (arguments.length === 3) {
                    previousStrokeText.call(this, text, x, y);
                } else if (arguments.length === 4) {
                    previousStrokeText.call(this, text, x, y, maxWidth);
                } else {
                    Shumway.Debug.unexpected();
                }
                if (oldStrokeStyle) {
                    this.strokeStyle = oldStrokeStyle;
                }
            });
        }
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    var assert = Shumway.Debug.assert;

    

    /**
    * Maintains a LRU doubly-linked list.
    */
    var LRUList = (function () {
        function LRUList() {
            this._count = 0;
            this._head = this._tail = null;
        }
        Object.defineProperty(LRUList.prototype, "count", {
            get: function () {
                return this._count;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(LRUList.prototype, "head", {
            /**
            * Gets the node at the front of the list. Returns |null| if the list is empty.
            */
            get: function () {
                return this._head;
            },
            enumerable: true,
            configurable: true
        });

        LRUList.prototype._unshift = function (node) {
            release || assert(!node.next && !node.previous);
            if (this._count === 0) {
                this._head = this._tail = node;
            } else {
                node.next = this._head;
                node.next.previous = node;
                this._head = node;
            }
            this._count++;
        };

        LRUList.prototype._remove = function (node) {
            release || assert(this._count > 0);
            if (node === this._head && node === this._tail) {
                this._head = this._tail = null;
            } else if (node === this._head) {
                this._head = (node.next);
                this._head.previous = null;
            } else if (node == this._tail) {
                this._tail = (node.previous);
                this._tail.next = null;
            } else {
                node.previous.next = node.next;
                node.next.previous = node.previous;
            }
            node.previous = node.next = null;
            this._count--;
        };

        /**
        * Adds or moves a node to the front of the list.
        */
        LRUList.prototype.use = function (node) {
            if (this._head === node) {
                return;
            }
            if (node.next || node.previous || this._tail === node) {
                this._remove(node);
            }
            this._unshift(node);
        };

        /**
        * Removes a node from the front of the list.
        */
        LRUList.prototype.pop = function () {
            if (!this._tail) {
                return null;
            }
            var node = this._tail;
            this._remove(node);
            return node;
        };

        /**
        * Visits each node in the list in the forward or reverse direction as long as
        * the callback returns |true|;
        */
        LRUList.prototype.visit = function (callback, forward) {
            if (typeof forward === "undefined") { forward = true; }
            var node = (forward ? this._head : this._tail);
            while (node) {
                if (!callback(node)) {
                    break;
                }
                node = (forward ? node.next : node.previous);
            }
        };
        return LRUList;
    })();
    Shumway.LRUList = LRUList;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;

        var shumwayOptions = Shumway.Settings.shumwayOptions;

        var rendererOptions = shumwayOptions.register(new OptionSet("Renderer Options"));
        GFX.imageUpdateOption = rendererOptions.register(new Option("", "imageUpdate", "boolean", true, "Enable image conversion."));
        GFX.stageOptions = shumwayOptions.register(new OptionSet("Stage Renderer Options"));
        GFX.forcePaint = GFX.stageOptions.register(new Option("", "forcePaint", "boolean", false, "Force repainting."));
        GFX.ignoreViewport = GFX.stageOptions.register(new Option("", "ignoreViewport", "boolean", false, "Cull elements outside of the viewport."));
        GFX.viewportLoupeDiameter = GFX.stageOptions.register(new Option("", "viewportLoupeDiameter", "number", 256, "Size of the viewport loupe.", { range: { min: 1, max: 1024, step: 1 } }));
        GFX.disableClipping = GFX.stageOptions.register(new Option("", "disableClipping", "boolean", false, "Disable clipping."));
        GFX.debugClipping = GFX.stageOptions.register(new Option("", "debugClipping", "boolean", false, "Disable clipping."));

        GFX.backend = GFX.stageOptions.register(new Option("", "backend", "number", 0, "Backends", {
            choices: {
                Canvas2D: 0,
                WebGL: 1,
                Both: 2
            }
        }));

        GFX.hud = GFX.stageOptions.register(new Option("", "hud", "boolean", false, "Enable HUD."));

        var webGLOptions = GFX.stageOptions.register(new OptionSet("WebGL Options"));
        GFX.perspectiveCamera = webGLOptions.register(new Option("", "pc", "boolean", false, "Use perspective camera."));
        GFX.perspectiveCameraFOV = webGLOptions.register(new Option("", "pcFOV", "number", 60, "Perspective Camera FOV."));
        GFX.perspectiveCameraDistance = webGLOptions.register(new Option("", "pcDistance", "number", 2, "Perspective Camera Distance."));
        GFX.perspectiveCameraAngle = webGLOptions.register(new Option("", "pcAngle", "number", 0, "Perspective Camera Angle."));
        GFX.perspectiveCameraAngleRotate = webGLOptions.register(new Option("", "pcRotate", "boolean", false, "Rotate Use perspective camera."));
        GFX.perspectiveCameraSpacing = webGLOptions.register(new Option("", "pcSpacing", "number", 0.01, "Element Spacing."));
        GFX.perspectiveCameraSpacingInflate = webGLOptions.register(new Option("", "pcInflate", "boolean", false, "Rotate Use perspective camera."));

        GFX.drawTiles = webGLOptions.register(new Option("", "drawTiles", "boolean", false, "Draw WebGL Tiles"));

        GFX.drawSurfaces = webGLOptions.register(new Option("", "drawSurfaces", "boolean", false, "Draw WebGL Surfaces."));
        GFX.drawSurface = webGLOptions.register(new Option("", "drawSurface", "number", -1, "Draw WebGL Surface #"));
        GFX.drawElements = webGLOptions.register(new Option("", "drawElements", "boolean", true, "Actually call gl.drawElements. This is useful to test if the GPU is the bottleneck."));
        GFX.disableSurfaceUploads = webGLOptions.register(new Option("", "disableSurfaceUploads", "boolean", false, "Disable surface uploads."));

        GFX.premultipliedAlpha = webGLOptions.register(new Option("", "premultipliedAlpha", "boolean", false, "Set the premultipliedAlpha flag on getContext()."));
        GFX.unpackPremultiplyAlpha = webGLOptions.register(new Option("", "unpackPremultiplyAlpha", "boolean", true, "Use UNPACK_PREMULTIPLY_ALPHA_WEBGL in pixelStorei."));

        var factorChoices = {
            ZERO: 0,
            ONE: 1,
            SRC_COLOR: 768,
            ONE_MINUS_SRC_COLOR: 769,
            DST_COLOR: 774,
            ONE_MINUS_DST_COLOR: 775,
            SRC_ALPHA: 770,
            ONE_MINUS_SRC_ALPHA: 771,
            DST_ALPHA: 772,
            ONE_MINUS_DST_ALPHA: 773,
            SRC_ALPHA_SATURATE: 776,
            CONSTANT_COLOR: 32769,
            ONE_MINUS_CONSTANT_COLOR: 32770,
            CONSTANT_ALPHA: 32771,
            ONE_MINUS_CONSTANT_ALPHA: 32772
        };

        GFX.sourceBlendFactor = webGLOptions.register(new Option("", "sourceBlendFactor", "number", factorChoices.ONE, "", { choices: factorChoices }));
        GFX.destinationBlendFactor = webGLOptions.register(new Option("", "destinationBlendFactor", "number", factorChoices.ONE_MINUS_SRC_ALPHA, "", { choices: factorChoices }));

        var canvas2DOptions = GFX.stageOptions.register(new OptionSet("Canvas2D Options"));
        GFX.clipDirtyRegions = canvas2DOptions.register(new Option("", "clipDirtyRegions", "boolean", false, "Clip dirty regions."));
        GFX.clipCanvas = canvas2DOptions.register(new Option("", "clipCanvas", "boolean", false, "Clip Regions."));
        GFX.cull = canvas2DOptions.register(new Option("", "cull", "boolean", false, "Enable culling."));
        GFX.compositeMask = canvas2DOptions.register(new Option("", "compositeMask", "boolean", false, "Composite Mask."));

        GFX.snapToDevicePixels = canvas2DOptions.register(new Option("", "snapToDevicePixels", "boolean", false, ""));
        GFX.imageSmoothing = canvas2DOptions.register(new Option("", "imageSmoothing", "boolean", false, ""));
        GFX.blending = canvas2DOptions.register(new Option("", "blending", "boolean", true, ""));
        GFX.cacheShapes = canvas2DOptions.register(new Option("", "cacheShapes", "boolean", false, ""));
        GFX.cacheShapesMaxSize = canvas2DOptions.register(new Option("", "cacheShapesMaxSize", "number", 256, "", { range: { min: 1, max: 1024, step: 1 } }));
        GFX.cacheShapesThreshold = canvas2DOptions.register(new Option("", "cacheShapesThreshold", "number", 256, "", { range: { min: 1, max: 1024, step: 1 } }));
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (Geometry) {
            var clamp = Shumway.NumberUtilities.clamp;
            var pow2 = Shumway.NumberUtilities.pow2;
            var epsilonEquals = Shumway.NumberUtilities.epsilonEquals;
            var assert = Shumway.Debug.assert;

            function radianToDegrees(r) {
                return r * 180 / Math.PI;
            }
            Geometry.radianToDegrees = radianToDegrees;

            function degreesToRadian(d) {
                return d * Math.PI / 180;
            }
            Geometry.degreesToRadian = degreesToRadian;

            function quadraticBezier(from, cp, to, t) {
                var inverseT = 1 - t;
                return from * inverseT * inverseT + 2 * cp * inverseT * t + to * t * t;
            }
            Geometry.quadraticBezier = quadraticBezier;

            function quadraticBezierExtreme(from, cp, to) {
                var t = (from - cp) / (from - 2 * cp + to);
                if (t < 0) {
                    return from;
                }
                if (t > 1) {
                    return to;
                }
                return quadraticBezier(from, cp, to, t);
            }
            Geometry.quadraticBezierExtreme = quadraticBezierExtreme;

            function cubicBezier(from, cp, cp2, to, t) {
                var tSq = t * t;
                var inverseT = 1 - t;
                var inverseTSq = inverseT * inverseT;
                return from * inverseT * inverseTSq + 3 * cp * t * inverseTSq + 3 * cp2 * inverseT * tSq + to * t * tSq;
            }
            Geometry.cubicBezier = cubicBezier;

            function cubicBezierExtremes(from, cp, cp2, to) {
                var d1 = cp - from;
                var d2 = cp2 - cp;

                // We only ever need d2 * 2
                d2 *= 2;
                var d3 = to - cp2;

                // Prevent division by zero by very slightly changing d3 if that would happen
                if (d1 + d3 === d2) {
                    d3 *= 1.0001;
                }
                var fHead = 2 * d1 - d2;
                var part1 = d2 - 2 * d1;
                var fCenter = Math.sqrt(part1 * part1 - 4 * d1 * (d1 - d2 + d3));
                var fTail = 2 * (d1 - d2 + d3);
                var t1 = (fHead + fCenter) / fTail;
                var t2 = (fHead - fCenter) / fTail;
                var result = [];
                if (t1 >= 0 && t1 <= 1) {
                    result.push(cubicBezier(from, cp, cp2, to, t1));
                }
                if (t2 >= 0 && t2 <= 1) {
                    result.push(cubicBezier(from, cp, cp2, to, t2));
                }
                return result;
            }
            Geometry.cubicBezierExtremes = cubicBezierExtremes;

            var E = 0.0001;

            function eqFloat(a, b) {
                return Math.abs(a - b) < E;
            }

            var Point = (function () {
                function Point(x, y) {
                    this.x = x;
                    this.y = y;
                }
                Point.prototype.setElements = function (x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                };

                Point.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    return this;
                };

                Point.prototype.dot = function (other) {
                    return this.x * other.x + this.y * other.y;
                };

                Point.prototype.squaredLength = function () {
                    return this.dot(this);
                };

                Point.prototype.distanceTo = function (other) {
                    return Math.sqrt(this.dot(other));
                };

                Point.prototype.sub = function (other) {
                    this.x -= other.x;
                    this.y -= other.y;
                    return this;
                };

                Point.prototype.mul = function (value) {
                    this.x *= value;
                    this.y *= value;
                    return this;
                };

                Point.prototype.clone = function () {
                    return new Point(this.x, this.y);
                };

                Point.prototype.toString = function () {
                    return "{x: " + this.x + ", y: " + this.y + "}";
                };

                Point.prototype.inTriangle = function (a, b, c) {
                    var s = a.y * c.x - a.x * c.y + (c.y - a.y) * this.x + (a.x - c.x) * this.y;
                    var t = a.x * b.y - a.y * b.x + (a.y - b.y) * this.x + (b.x - a.x) * this.y;
                    if ((s < 0) != (t < 0)) {
                        return false;
                    }
                    var T = -b.y * c.x + a.y * (c.x - b.x) + a.x * (b.y - c.y) + b.x * c.y;
                    if (T < 0.0) {
                        s = -s;
                        t = -t;
                        T = -T;
                    }
                    return s > 0 && t > 0 && (s + t) < T;
                };

                Point.createEmpty = function () {
                    return new Point(0, 0);
                };

                Point.createEmptyPoints = function (count) {
                    var result = [];
                    for (var i = 0; i < count; i++) {
                        result.push(new Point(0, 0));
                    }
                    return result;
                };
                return Point;
            })();
            Geometry.Point = Point;

            var Point3D = (function () {
                function Point3D(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
                Point3D.prototype.setElements = function (x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                };

                Point3D.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    this.z = other.z;
                    return this;
                };

                Point3D.prototype.dot = function (other) {
                    return this.x * other.x + this.y * other.y + this.z * other.z;
                };

                Point3D.prototype.cross = function (other) {
                    var x = this.y * other.z - this.z * other.y;
                    var y = this.z * other.x - this.x * other.z;
                    var z = this.x * other.y - this.y * other.x;
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                };

                Point3D.prototype.squaredLength = function () {
                    return this.dot(this);
                };

                Point3D.prototype.sub = function (other) {
                    this.x -= other.x;
                    this.y -= other.y;
                    this.z -= other.z;
                    return this;
                };

                Point3D.prototype.mul = function (value) {
                    this.x *= value;
                    this.y *= value;
                    this.z *= value;
                    return this;
                };

                Point3D.prototype.normalize = function () {
                    var length = Math.sqrt(this.squaredLength());
                    if (length > 0.00001) {
                        this.mul(1 / length);
                    } else {
                        this.setElements(0, 0, 0);
                    }
                    return this;
                };

                Point3D.prototype.clone = function () {
                    return new Point3D(this.x, this.y, this.z);
                };

                Point3D.prototype.toString = function () {
                    return "{x: " + this.x + ", y: " + this.y + ", z: " + this.z + "}";
                };

                Point3D.createEmpty = function () {
                    return new Point3D(0, 0, 0);
                };

                Point3D.createEmptyPoints = function (count) {
                    var result = [];
                    for (var i = 0; i < count; i++) {
                        result.push(new Point3D(0, 0, 0));
                    }
                    return result;
                };
                return Point3D;
            })();
            Geometry.Point3D = Point3D;

            var Rectangle = (function () {
                function Rectangle(x, y, w, h) {
                    this.setElements(x, y, w, h);
                }
                Rectangle.prototype.setElements = function (x, y, w, h) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                };

                Rectangle.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    this.w = other.w;
                    this.h = other.h;
                };

                Rectangle.prototype.contains = function (other) {
                    var r1 = other.x + other.w;
                    var b1 = other.y + other.h;
                    var r2 = this.x + this.w;
                    var b2 = this.y + this.h;
                    return (other.x >= this.x) && (other.x < r2) && (other.y >= this.y) && (other.y < b2) && (r1 > this.x) && (r1 <= r2) && (b1 > this.y) && (b1 <= b2);
                };

                Rectangle.prototype.containsPoint = function (point) {
                    return (point.x >= this.x) && (point.x < this.x + this.w) && (point.y >= this.y) && (point.y < this.y + this.h);
                };

                Rectangle.prototype.isContained = function (others) {
                    for (var i = 0; i < others.length; i++) {
                        if (others[i].contains(this)) {
                            return true;
                        }
                    }
                    return false;
                };

                Rectangle.prototype.isSmallerThan = function (other) {
                    return this.w < other.w && this.h < other.h;
                };

                Rectangle.prototype.isLargerThan = function (other) {
                    return this.w > other.w && this.h > other.h;
                };

                Rectangle.prototype.union = function (other) {
                    if (this.isEmpty()) {
                        this.set(other);
                        return;
                    }
                    var x = this.x, y = this.y;
                    if (this.x > other.x) {
                        x = other.x;
                    }
                    if (this.y > other.y) {
                        y = other.y;
                    }
                    var x0 = this.x + this.w;
                    if (x0 < other.x + other.w) {
                        x0 = other.x + other.w;
                    }
                    var y0 = this.y + this.h;
                    if (y0 < other.y + other.h) {
                        y0 = other.y + other.h;
                    }
                    this.x = x;
                    this.y = y;
                    this.w = x0 - x;
                    this.h = y0 - y;
                };

                Rectangle.prototype.isEmpty = function () {
                    return this.w <= 0 || this.h <= 0;
                };

                Rectangle.prototype.setEmpty = function () {
                    this.w = 0;
                    this.h = 0;
                };

                Rectangle.prototype.intersect = function (other) {
                    var result = Rectangle.createEmpty();
                    if (this.isEmpty() || other.isEmpty()) {
                        result.setEmpty();
                        return result;
                    }
                    result.x = Math.max(this.x, other.x);
                    result.y = Math.max(this.y, other.y);
                    result.w = Math.min(this.x + this.w, other.x + other.w) - result.x;
                    result.h = Math.min(this.y + this.h, other.y + other.h) - result.y;
                    if (result.isEmpty()) {
                        result.setEmpty();
                    }
                    this.set(result);
                };

                Rectangle.prototype.intersects = function (other) {
                    if (this.isEmpty() || other.isEmpty()) {
                        return false;
                    }
                    var x = Math.max(this.x, other.x);
                    var y = Math.max(this.y, other.y);
                    var w = Math.min(this.x + this.w, other.x + other.w) - x;
                    var h = Math.min(this.y + this.h, other.y + other.h) - y;
                    return !(w <= 0 || h <= 0);
                };

                /**
                * Tests if this rectangle intersects the AABB of the given rectangle.
                */
                Rectangle.prototype.intersectsTransformedAABB = function (other, matrix) {
                    var rectangle = Rectangle._temporary;
                    rectangle.set(other);
                    matrix.transformRectangleAABB(rectangle);
                    return this.intersects(rectangle);
                };

                Rectangle.prototype.intersectsTranslated = function (other, tx, ty) {
                    if (this.isEmpty() || other.isEmpty()) {
                        return false;
                    }
                    var x = Math.max(this.x, other.x + tx);
                    var y = Math.max(this.y, other.y + ty);
                    var w = Math.min(this.x + this.w, other.x + tx + other.w) - x;
                    var h = Math.min(this.y + this.h, other.y + ty + other.h) - y;
                    return !(w <= 0 || h <= 0);
                };

                Rectangle.prototype.area = function () {
                    return this.w * this.h;
                };

                Rectangle.prototype.clone = function () {
                    return new Rectangle(this.x, this.y, this.w, this.h);
                };

                Rectangle.prototype.copyFrom = function (source) {
                    this.x = source.x;
                    this.y = source.y;
                    this.w = source.w;
                    this.h = source.h;
                };

                /**
                * Snaps the rectangle to pixel boundaries. The computed rectangle covers
                * the original rectangle.
                */
                Rectangle.prototype.snap = function () {
                    var x1 = Math.ceil(this.x + this.w);
                    var y1 = Math.ceil(this.y + this.h);
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.w = x1 - this.x;
                    this.h = y1 - this.y;
                    return this;
                };

                Rectangle.prototype.scale = function (x, y) {
                    this.x *= x;
                    this.y *= y;
                    this.w *= x;
                    this.h *= y;
                    return this;
                };

                Rectangle.prototype.offset = function (x, y) {
                    this.x += x;
                    this.y += y;
                    return this;
                };

                Rectangle.prototype.resize = function (w, h) {
                    this.w += w;
                    this.h += h;
                    return this;
                };

                Rectangle.prototype.expand = function (w, h) {
                    this.offset(-w, -h).resize(2 * w, 2 * h);
                    return this;
                };

                Rectangle.prototype.getCenter = function () {
                    return new Point(this.x + this.w / 2, this.y + this.h / 2);
                };

                Rectangle.prototype.getAbsoluteBounds = function () {
                    return new Rectangle(0, 0, this.w, this.h);
                };

                Rectangle.prototype.toString = function () {
                    return "{" + this.x + ", " + this.y + ", " + this.w + ", " + this.h + "}";
                };

                Rectangle.createEmpty = function () {
                    return new Rectangle(0, 0, 0, 0);
                };

                Rectangle.createSquare = function (size) {
                    return new Rectangle(-size / 2, -size / 2, size, size);
                };

                /**
                * Creates the maximum rectangle representable by signed 16 bit integers.
                */
                Rectangle.createMaxI16 = function () {
                    return new Rectangle(Shumway.Numbers.MinI16, Shumway.Numbers.MinI16, 65535 /* MaxU16 */, 65535 /* MaxU16 */);
                };

                Rectangle.prototype.getCorners = function (points) {
                    points[0].x = this.x;
                    points[0].y = this.y;

                    points[1].x = this.x + this.w;
                    points[1].y = this.y;

                    points[2].x = this.x + this.w;
                    points[2].y = this.y + this.h;

                    points[3].x = this.x;
                    points[3].y = this.y + this.h;
                };
                Rectangle._temporary = Rectangle.createEmpty();
                return Rectangle;
            })();
            Geometry.Rectangle = Rectangle;

            var OBB = (function () {
                function OBB(corners) {
                    this.corners = corners.map(function (corner) {
                        return corner.clone();
                    });
                    this.axes = [
                        corners[1].clone().sub(corners[0]),
                        corners[3].clone().sub(corners[0])
                    ];
                    this.origins = [];
                    for (var i = 0; i < 2; i++) {
                        this.axes[i].mul(1 / this.axes[i].squaredLength());
                        this.origins.push(corners[0].dot(this.axes[i]));
                    }
                }
                OBB.prototype.getBounds = function () {
                    return OBB.getBounds(this.corners);
                };
                OBB.getBounds = function (points) {
                    var min = new Point(Number.MAX_VALUE, Number.MAX_VALUE);
                    var max = new Point(Number.MIN_VALUE, Number.MIN_VALUE);
                    for (var i = 0; i < 4; i++) {
                        var x = points[i].x, y = points[i].y;
                        min.x = Math.min(min.x, x);
                        min.y = Math.min(min.y, y);
                        max.x = Math.max(max.x, x);
                        max.y = Math.max(max.y, y);
                    }
                    return new Rectangle(min.x, min.y, max.x - min.x, max.y - min.y);
                };

                /**
                * http://www.flipcode.com/archives/2D_OBB_Intersection.shtml
                */
                OBB.prototype.intersects = function (other) {
                    return this.intersectsOneWay(other) && other.intersectsOneWay(this);
                };
                OBB.prototype.intersectsOneWay = function (other) {
                    for (var i = 0; i < 2; i++) {
                        for (var j = 0; j < 4; j++) {
                            var t = other.corners[j].dot(this.axes[i]);
                            var tMin, tMax;
                            if (j === 0) {
                                tMax = tMin = t;
                            } else {
                                if (t < tMin) {
                                    tMin = t;
                                } else if (t > tMax) {
                                    tMax = t;
                                }
                            }
                        }
                        if ((tMin > 1 + this.origins[i]) || (tMax < this.origins[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                return OBB;
            })();
            Geometry.OBB = OBB;

            var Matrix = (function () {
                function Matrix(a, b, c, d, tx, ty) {
                    this.setElements(a, b, c, d, tx, ty);
                }
                Matrix.prototype.setElements = function (a, b, c, d, tx, ty) {
                    this.a = a;
                    this.b = b;
                    this.c = c;
                    this.d = d;
                    this.tx = tx;
                    this.ty = ty;
                };

                Matrix.prototype.set = function (other) {
                    this.a = other.a;
                    this.b = other.b;
                    this.c = other.c;
                    this.d = other.d;
                    this.tx = other.tx;
                    this.ty = other.ty;
                };

                /**
                * Whether the transformed query rectangle is empty after this transform is applied to it.
                */
                Matrix.prototype.emptyArea = function (query) {
                    // TODO: Work out the details here.
                    if (this.a === 0 || this.d === 0) {
                        return true;
                    }
                    return false;
                };

                /**
                * Whether the area of transformed query rectangle is infinite after this transform is applied to it.
                */
                Matrix.prototype.infiniteArea = function (query) {
                    // TODO: Work out the details here.
                    if (Math.abs(this.a) === Infinity || Math.abs(this.d) === Infinity) {
                        return true;
                    }
                    return false;
                };

                Matrix.prototype.isEqual = function (other) {
                    return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.tx === other.tx && this.ty === other.ty;
                };

                Matrix.prototype.clone = function () {
                    return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
                };

                Matrix.prototype.transform = function (a, b, c, d, tx, ty) {
                    var _a = this.a, _b = this.b, _c = this.c, _d = this.d, _tx = this.tx, _ty = this.ty;
                    this.a = _a * a + _c * b;
                    this.b = _b * a + _d * b;
                    this.c = _a * c + _c * d;
                    this.d = _b * c + _d * d;
                    this.tx = _a * tx + _c * ty + _tx;
                    this.ty = _b * tx + _d * ty + _ty;
                    return this;
                };

                Matrix.prototype.transformRectangle = function (rectangle, points) {
                    var a = this.a;
                    var b = this.b;
                    var c = this.c;
                    var d = this.d;
                    var tx = this.tx;
                    var ty = this.ty;

                    var x = rectangle.x;
                    var y = rectangle.y;
                    var w = rectangle.w;
                    var h = rectangle.h;

                    /*
                    
                    0---1
                    | / |
                    3---2
                    
                    */
                    points[0].x = a * x + c * y + tx;
                    points[0].y = b * x + d * y + ty;
                    points[1].x = a * (x + w) + c * y + tx;
                    points[1].y = b * (x + w) + d * y + ty;
                    points[2].x = a * (x + w) + c * (y + h) + tx;
                    points[2].y = b * (x + w) + d * (y + h) + ty;
                    points[3].x = a * x + c * (y + h) + tx;
                    points[3].y = b * x + d * (y + h) + ty;
                };

                Matrix.prototype.isTranslationOnly = function () {
                    if (this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1) {
                        return true;
                    } else if (epsilonEquals(this.a, 1) && epsilonEquals(this.b, 0) && epsilonEquals(this.c, 0) && epsilonEquals(this.d, 1)) {
                        return true;
                    }
                    return false;
                };

                Matrix.prototype.transformRectangleAABB = function (rectangle) {
                    var a = this.a;
                    var b = this.b;
                    var c = this.c;
                    var d = this.d;
                    var tx = this.tx;
                    var ty = this.ty;

                    var x = rectangle.x;
                    var y = rectangle.y;
                    var w = rectangle.w;
                    var h = rectangle.h;

                    /*
                    
                    0---1
                    | / |
                    3---2
                    
                    */
                    var x0 = a * x + c * y + tx;
                    var y0 = b * x + d * y + ty;

                    var x1 = a * (x + w) + c * y + tx;
                    var y1 = b * (x + w) + d * y + ty;

                    var x2 = a * (x + w) + c * (y + h) + tx;
                    var y2 = b * (x + w) + d * (y + h) + ty;

                    var x3 = a * x + c * (y + h) + tx;
                    var y3 = b * x + d * (y + h) + ty;

                    var tmp = 0;

                    // Manual Min/Max is a lot faster than calling Math.min/max
                    // X Min-Max
                    if (x0 > x1) {
                        tmp = x0;
                        x0 = x1;
                        x1 = tmp;
                    }
                    if (x2 > x3) {
                        tmp = x2;
                        x2 = x3;
                        x3 = tmp;
                    }

                    rectangle.x = x0 < x2 ? x0 : x2;
                    rectangle.w = (x1 > x3 ? x1 : x3) - rectangle.x;

                    // Y Min-Max
                    if (y0 > y1) {
                        tmp = y0;
                        y0 = y1;
                        y1 = tmp;
                    }
                    if (y2 > y3) {
                        tmp = y2;
                        y2 = y3;
                        y3 = tmp;
                    }

                    rectangle.y = y0 < y2 ? y0 : y2;
                    rectangle.h = (y1 > y3 ? y1 : y3) - rectangle.y;
                };

                Matrix.prototype.scale = function (x, y) {
                    this.a *= x;
                    this.b *= y;
                    this.c *= x;
                    this.d *= y;
                    this.tx *= x;
                    this.ty *= y;
                    return this;
                };

                Matrix.prototype.scaleClone = function (x, y) {
                    if (x === 1 && y === 1) {
                        return this;
                    }
                    return this.clone().scale(x, y);
                };

                Matrix.prototype.rotate = function (angle) {
                    var a = this.a, b = this.b, c = this.c, d = this.d, tx = this.tx, ty = this.ty;
                    var cos = Math.cos(angle);
                    var sin = Math.sin(angle);
                    this.a = cos * a - sin * b;
                    this.b = sin * a + cos * b;
                    this.c = cos * c - sin * d;
                    this.d = sin * c + cos * d;
                    this.tx = cos * tx - sin * ty;
                    this.ty = sin * tx + cos * ty;
                    return this;
                };

                Matrix.prototype.concat = function (other) {
                    var a = this.a * other.a;
                    var b = 0.0;
                    var c = 0.0;
                    var d = this.d * other.d;
                    var tx = this.tx * other.a + other.tx;
                    var ty = this.ty * other.d + other.ty;

                    if (this.b !== 0.0 || this.c !== 0.0 || other.b !== 0.0 || other.c !== 0.0) {
                        a += this.b * other.c;
                        d += this.c * other.b;
                        b += this.a * other.b + this.b * other.d;
                        c += this.c * other.a + this.d * other.c;
                        tx += this.ty * other.c;
                        ty += this.tx * other.b;
                    }

                    this.a = a;
                    this.b = b;
                    this.c = c;
                    this.d = d;
                    this.tx = tx;
                    this.ty = ty;
                };

                /**
                * this = other * this
                */
                Matrix.prototype.preMultiply = function (other) {
                    var a = other.a * this.a;
                    var b = 0.0;
                    var c = 0.0;
                    var d = other.d * this.d;
                    var tx = other.tx * this.a + this.tx;
                    var ty = other.ty * this.d + this.ty;

                    if (other.b !== 0.0 || other.c !== 0.0 || this.b !== 0.0 || this.c !== 0.0) {
                        a += other.b * this.c;
                        d += other.c * this.b;
                        b += other.a * this.b + other.b * this.d;
                        c += other.c * this.a + other.d * this.c;
                        tx += other.ty * this.c;
                        ty += other.tx * this.b;
                    }

                    this.a = a;
                    this.b = b;
                    this.c = c;
                    this.d = d;
                    this.tx = tx;
                    this.ty = ty;
                };

                Matrix.prototype.translate = function (x, y) {
                    this.tx += x;
                    this.ty += y;
                    return this;
                };

                Matrix.prototype.setIdentity = function () {
                    this.a = 1;
                    this.b = 0;
                    this.c = 0;
                    this.d = 1;
                    this.tx = 0;
                    this.ty = 0;
                };

                Matrix.prototype.isIdentity = function () {
                    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
                };

                Matrix.prototype.transformPoint = function (point) {
                    var x = point.x;
                    var y = point.y;
                    point.x = this.a * x + this.c * y + this.tx;
                    point.y = this.b * x + this.d * y + this.ty;
                };

                Matrix.prototype.transformPoints = function (points) {
                    for (var i = 0; i < points.length; i++) {
                        this.transformPoint(points[i]);
                    }
                };

                Matrix.prototype.deltaTransformPoint = function (point) {
                    var x = point.x;
                    var y = point.y;
                    point.x = this.a * x + this.c * y;
                    point.y = this.b * x + this.d * y;
                };

                Matrix.prototype.inverse = function (result) {
                    var b = this.b;
                    var c = this.c;
                    var tx = this.tx;
                    var ty = this.ty;
                    if (b === 0 && c === 0) {
                        var a = result.a = 1 / this.a;
                        var d = result.d = 1 / this.d;
                        result.b = 0;
                        result.c = 0;
                        result.tx = -a * tx;
                        result.ty = -d * ty;
                    } else {
                        var a = this.a;
                        var d = this.d;
                        var determinant = a * d - b * c;
                        if (determinant === 0) {
                            result.setIdentity();
                            return;
                        }
                        determinant = 1 / determinant;
                        result.a = d * determinant;
                        b = result.b = -b * determinant;
                        c = result.c = -c * determinant;
                        d = result.d = a * determinant;
                        result.tx = -(result.a * tx + c * ty);
                        result.ty = -(b * tx + d * ty);
                    }
                    return;
                };

                Matrix.prototype.getTranslateX = function () {
                    return this.tx;
                };

                Matrix.prototype.getTranslateY = function () {
                    return this.tx;
                };

                Matrix.prototype.getScaleX = function () {
                    if (this.a === 1 && this.b === 0) {
                        return 1;
                    }
                    var result = Math.sqrt(this.a * this.a + this.b * this.b);
                    return this.a > 0 ? result : -result;
                };

                Matrix.prototype.getScaleY = function () {
                    if (this.c === 0 && this.d === 1) {
                        return 1;
                    }
                    var result = Math.sqrt(this.c * this.c + this.d * this.d);
                    return this.d > 0 ? result : -result;
                };

                Matrix.prototype.getAbsoluteScaleX = function () {
                    return Math.abs(this.getScaleX());
                };

                Matrix.prototype.getAbsoluteScaleY = function () {
                    return Math.abs(this.getScaleY());
                };

                Matrix.prototype.getRotation = function () {
                    return Math.atan(this.b / this.a) * 180 / Math.PI;
                };

                Matrix.prototype.isScaleOrRotation = function () {
                    return Math.abs(this.a * this.c + this.b * this.d) < 0.01;
                };

                Matrix.prototype.toString = function () {
                    return "{" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + "}";
                };

                Matrix.prototype.toWebGLMatrix = function () {
                    return new Float32Array([
                        this.a, this.b, 0, this.c, this.d, 0, this.tx, this.ty, 1
                    ]);
                };

                Matrix.prototype.toCSSTransform = function () {
                    return "matrix(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + ")";
                };

                Matrix.createIdentity = function () {
                    return new Matrix(1, 0, 0, 1, 0, 0);
                };

                Matrix.prototype.toSVGMatrix = function () {
                    var matrix = Matrix._svg.createSVGMatrix();
                    matrix.a = this.a;
                    matrix.b = this.b;
                    matrix.c = this.c;
                    matrix.d = this.d;
                    matrix.e = this.tx;
                    matrix.f = this.ty;
                    return matrix;
                };

                Matrix.prototype.snap = function () {
                    if (this.isTranslationOnly()) {
                        this.a = 1;
                        this.b = 0;
                        this.c = 0;
                        this.d = 1;
                        this.tx = Math.round(this.tx);
                        this.ty = Math.round(this.ty);
                        return true;
                    }
                    return false;
                };
                Matrix._svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

                Matrix.multiply = function (dst, src) {
                    dst.transform(src.a, src.b, src.c, src.d, src.tx, src.ty);
                };
                return Matrix;
            })();
            Geometry.Matrix = Matrix;

            /**
            * Some of the math from: http://games.greggman.com/game/webgl-3d-cameras/
            */
            var Matrix3D = (function () {
                function Matrix3D(m) {
                    this._m = new Float32Array(m);
                }
                Matrix3D.prototype.asWebGLMatrix = function () {
                    return this._m;
                };

                Matrix3D.createCameraLookAt = function (cameraPosition, target, up) {
                    var zAxis = cameraPosition.clone().sub(target).normalize();
                    var xAxis = up.clone().cross(zAxis).normalize();
                    var yAxis = zAxis.clone().cross(xAxis);
                    return new Matrix3D([
                        xAxis.x, xAxis.y, xAxis.z, 0,
                        yAxis.x, yAxis.y, yAxis.z, 0,
                        zAxis.x, zAxis.y, zAxis.z, 0,
                        cameraPosition.x,
                        cameraPosition.y,
                        cameraPosition.z,
                        1
                    ]);
                };

                Matrix3D.createLookAt = function (cameraPosition, target, up) {
                    var zAxis = cameraPosition.clone().sub(target).normalize();
                    var xAxis = up.clone().cross(zAxis).normalize();
                    var yAxis = zAxis.clone().cross(xAxis);
                    return new Matrix3D([
                        xAxis.x, yAxis.x, zAxis.x, 0,
                        yAxis.x, yAxis.y, zAxis.y, 0,
                        zAxis.x, yAxis.z, zAxis.z, 0,
                        -xAxis.dot(cameraPosition),
                        -yAxis.dot(cameraPosition),
                        -zAxis.dot(cameraPosition),
                        1
                    ]);
                };

                Matrix3D.prototype.mul = function (point) {
                    var v = [point.x, point.y, point.z, 0];
                    var m = this._m;
                    var d = [];
                    for (var i = 0; i < 4; i++) {
                        d[i] = 0.0;
                        var row = i * 4;
                        for (var j = 0; j < 4; j++) {
                            d[i] += m[row + j] * v[j];
                        }
                    }
                    return new Point3D(d[0], d[1], d[2]);
                };

                Matrix3D.create2DProjection = function (width, height, depth) {
                    // Note: This matrix flips the Y axis so 0 is at the top.
                    return new Matrix3D([
                        2 / width, 0, 0, 0,
                        0, -2 / height, 0, 0,
                        0, 0, 2 / depth, 0,
                        -1, 1, 0, 1
                    ]);
                };

                Matrix3D.createPerspective = function (fieldOfViewInRadians, aspectRatio, near, far) {
                    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
                    var rangeInverse = 1.0 / (near - far);
                    return new Matrix3D([
                        f / aspectRatio, 0, 0, 0,
                        0, f, 0, 0,
                        0, 0, (near + far) * rangeInverse, -1,
                        0, 0, near * far * rangeInverse * 2, 0
                    ]);
                };

                Matrix3D.createIdentity = function () {
                    return Matrix3D.createTranslation(0, 0, 0);
                };

                Matrix3D.createTranslation = function (tx, ty, tz) {
                    return new Matrix3D([
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        tx, ty, tz, 1
                    ]);
                };

                Matrix3D.createXRotation = function (angleInRadians) {
                    var c = Math.cos(angleInRadians);
                    var s = Math.sin(angleInRadians);
                    return new Matrix3D([
                        1, 0, 0, 0,
                        0, c, s, 0,
                        0, -s, c, 0,
                        0, 0, 0, 1
                    ]);
                };

                Matrix3D.createYRotation = function (angleInRadians) {
                    var c = Math.cos(angleInRadians);
                    var s = Math.sin(angleInRadians);
                    return new Matrix3D([
                        c, 0, -s, 0,
                        0, 1, 0, 0,
                        s, 0, c, 0,
                        0, 0, 0, 1
                    ]);
                };

                Matrix3D.createZRotation = function (angleInRadians) {
                    var c = Math.cos(angleInRadians);
                    var s = Math.sin(angleInRadians);
                    return new Matrix3D([
                        c, s, 0, 0,
                        -s, c, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    ]);
                };

                Matrix3D.createScale = function (sx, sy, sz) {
                    return new Matrix3D([
                        sx, 0, 0, 0,
                        0, sy, 0, 0,
                        0, 0, sz, 0,
                        0, 0, 0, 1
                    ]);
                };

                Matrix3D.createMultiply = function (a, b) {
                    var am = a._m;
                    var bm = b._m;
                    var a00 = am[0 * 4 + 0];
                    var a01 = am[0 * 4 + 1];
                    var a02 = am[0 * 4 + 2];
                    var a03 = am[0 * 4 + 3];
                    var a10 = am[1 * 4 + 0];
                    var a11 = am[1 * 4 + 1];
                    var a12 = am[1 * 4 + 2];
                    var a13 = am[1 * 4 + 3];
                    var a20 = am[2 * 4 + 0];
                    var a21 = am[2 * 4 + 1];
                    var a22 = am[2 * 4 + 2];
                    var a23 = am[2 * 4 + 3];
                    var a30 = am[3 * 4 + 0];
                    var a31 = am[3 * 4 + 1];
                    var a32 = am[3 * 4 + 2];
                    var a33 = am[3 * 4 + 3];
                    var b00 = bm[0 * 4 + 0];
                    var b01 = bm[0 * 4 + 1];
                    var b02 = bm[0 * 4 + 2];
                    var b03 = bm[0 * 4 + 3];
                    var b10 = bm[1 * 4 + 0];
                    var b11 = bm[1 * 4 + 1];
                    var b12 = bm[1 * 4 + 2];
                    var b13 = bm[1 * 4 + 3];
                    var b20 = bm[2 * 4 + 0];
                    var b21 = bm[2 * 4 + 1];
                    var b22 = bm[2 * 4 + 2];
                    var b23 = bm[2 * 4 + 3];
                    var b30 = bm[3 * 4 + 0];
                    var b31 = bm[3 * 4 + 1];
                    var b32 = bm[3 * 4 + 2];
                    var b33 = bm[3 * 4 + 3];
                    return new Matrix3D([
                        a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30,
                        a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31,
                        a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32,
                        a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33,
                        a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30,
                        a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31,
                        a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32,
                        a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33,
                        a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30,
                        a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31,
                        a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32,
                        a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33,
                        a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30,
                        a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31,
                        a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32,
                        a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33
                    ]);
                };

                Matrix3D.createInverse = function (a) {
                    var m = a._m;
                    var m00 = m[0 * 4 + 0];
                    var m01 = m[0 * 4 + 1];
                    var m02 = m[0 * 4 + 2];
                    var m03 = m[0 * 4 + 3];
                    var m10 = m[1 * 4 + 0];
                    var m11 = m[1 * 4 + 1];
                    var m12 = m[1 * 4 + 2];
                    var m13 = m[1 * 4 + 3];
                    var m20 = m[2 * 4 + 0];
                    var m21 = m[2 * 4 + 1];
                    var m22 = m[2 * 4 + 2];
                    var m23 = m[2 * 4 + 3];
                    var m30 = m[3 * 4 + 0];
                    var m31 = m[3 * 4 + 1];
                    var m32 = m[3 * 4 + 2];
                    var m33 = m[3 * 4 + 3];
                    var tmp_0 = m22 * m33;
                    var tmp_1 = m32 * m23;
                    var tmp_2 = m12 * m33;
                    var tmp_3 = m32 * m13;
                    var tmp_4 = m12 * m23;
                    var tmp_5 = m22 * m13;
                    var tmp_6 = m02 * m33;
                    var tmp_7 = m32 * m03;
                    var tmp_8 = m02 * m23;
                    var tmp_9 = m22 * m03;
                    var tmp_10 = m02 * m13;
                    var tmp_11 = m12 * m03;
                    var tmp_12 = m20 * m31;
                    var tmp_13 = m30 * m21;
                    var tmp_14 = m10 * m31;
                    var tmp_15 = m30 * m11;
                    var tmp_16 = m10 * m21;
                    var tmp_17 = m20 * m11;
                    var tmp_18 = m00 * m31;
                    var tmp_19 = m30 * m01;
                    var tmp_20 = m00 * m21;
                    var tmp_21 = m20 * m01;
                    var tmp_22 = m00 * m11;
                    var tmp_23 = m10 * m01;

                    var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
                    var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
                    var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
                    var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

                    var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);

                    return new Matrix3D([
                        d * t0,
                        d * t1,
                        d * t2,
                        d * t3,
                        d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),
                        d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),
                        d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),
                        d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),
                        d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),
                        d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),
                        d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),
                        d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),
                        d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),
                        d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),
                        d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),
                        d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))
                    ]);
                };
                return Matrix3D;
            })();
            Geometry.Matrix3D = Matrix3D;

            var DirtyRegion = (function () {
                function DirtyRegion(w, h, sizeInBits) {
                    if (typeof sizeInBits === "undefined") { sizeInBits = 7; }
                    var size = this.size = 1 << sizeInBits;
                    this.sizeInBits = sizeInBits;
                    this.w = w;
                    this.h = h;
                    this.c = Math.ceil(w / size);
                    this.r = Math.ceil(h / size);
                    this.grid = [];
                    for (var y = 0; y < this.r; y++) {
                        this.grid.push([]);
                        for (var x = 0; x < this.c; x++) {
                            this.grid[y][x] = new DirtyRegion.Cell(new Rectangle(x * size, y * size, size, size));
                        }
                    }
                }
                DirtyRegion.prototype.clear = function () {
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            this.grid[y][x].clear();
                        }
                    }
                };

                DirtyRegion.prototype.getBounds = function () {
                    return new Rectangle(0, 0, this.w, this.h);
                };

                DirtyRegion.prototype.addDirtyRectangle = function (rectangle) {
                    var x = rectangle.x >> this.sizeInBits;
                    var y = rectangle.y >> this.sizeInBits;
                    if (x >= this.c || y >= this.r) {
                        return;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                    if (y < 0) {
                        y = 0;
                    }
                    var cell = this.grid[y][x];
                    rectangle = rectangle.clone();
                    rectangle.snap();

                    if (cell.region.contains(rectangle)) {
                        if (cell.bounds.isEmpty()) {
                            cell.bounds.set(rectangle);
                        } else if (!cell.bounds.contains(rectangle)) {
                            cell.bounds.union(rectangle);
                        }
                    } else {
                        var w = Math.min(this.c, Math.ceil((rectangle.x + rectangle.w) / this.size)) - x;
                        var h = Math.min(this.r, Math.ceil((rectangle.y + rectangle.h) / this.size)) - y;
                        for (var i = 0; i < w; i++) {
                            for (var j = 0; j < h; j++) {
                                var cell = this.grid[y + j][x + i];
                                var intersection = cell.region.clone();
                                intersection.intersect(rectangle);
                                if (!intersection.isEmpty()) {
                                    this.addDirtyRectangle(intersection);
                                }
                            }
                        }
                    }
                };

                DirtyRegion.prototype.gatherRegions = function (regions) {
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            var bounds = this.grid[y][x].bounds;
                            if (!bounds.isEmpty()) {
                                regions.push(this.grid[y][x].bounds);
                            }
                        }
                    }
                };

                DirtyRegion.prototype.gatherOptimizedRegions = function (regions) {
                    this.gatherRegions(regions);
                };

                DirtyRegion.prototype.getDirtyRatio = function () {
                    var totalArea = this.w * this.h;
                    if (totalArea === 0) {
                        return 0;
                    }
                    var dirtyArea = 0;
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            dirtyArea += this.grid[y][x].region.area();
                        }
                    }
                    return dirtyArea / totalArea;
                };

                DirtyRegion.prototype.render = function (context, options) {
                    function drawRectangle(rectangle) {
                        context.rect(rectangle.x, rectangle.y, rectangle.w, rectangle.h);
                    }

                    if (options && options.drawGrid) {
                        context.strokeStyle = "white";
                        for (var y = 0; y < this.r; y++) {
                            for (var x = 0; x < this.c; x++) {
                                var cell = this.grid[y][x];
                                context.beginPath();
                                drawRectangle(cell.region);
                                context.closePath();
                                context.stroke();
                            }
                        }
                    }

                    context.strokeStyle = "#E0F8D8";
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            var cell = this.grid[y][x];
                            context.beginPath();
                            drawRectangle(cell.bounds);
                            context.closePath();
                            context.stroke();
                        }
                    }
                    //      context.strokeStyle = "#5856d6";
                    //      var regions = [];
                    //      this.gatherOptimizedRegions(regions);
                    //      for (var i = 0; i < regions.length; i++) {
                    //        context.beginPath();
                    //        drawRectangle(regions[i]);
                    //        context.closePath();
                    //        context.stroke();
                    //      }
                };
                DirtyRegion.tmpRectangle = Rectangle.createEmpty();
                return DirtyRegion;
            })();
            Geometry.DirtyRegion = DirtyRegion;

            (function (DirtyRegion) {
                var Cell = (function () {
                    function Cell(region) {
                        this.region = region;
                        this.bounds = Rectangle.createEmpty();
                    }
                    Cell.prototype.clear = function () {
                        this.bounds.setEmpty();
                    };
                    return Cell;
                })();
                DirtyRegion.Cell = Cell;
            })(Geometry.DirtyRegion || (Geometry.DirtyRegion = {}));
            var DirtyRegion = Geometry.DirtyRegion;

            var Tile = (function () {
                function Tile(index, x, y, w, h, scale) {
                    this.index = index;
                    this.x = x;
                    this.y = y;
                    this.scale = scale;
                    this.bounds = new Rectangle(x * w, y * h, w, h);
                }
                Tile.prototype.getOBB = function () {
                    if (this._obb) {
                        return this._obb;
                    }
                    this.bounds.getCorners(Tile.corners);
                    return this._obb = new OBB(Tile.corners);
                };
                Tile.corners = Point.createEmptyPoints(4);
                return Tile;
            })();
            Geometry.Tile = Tile;

            /**
            * A grid data structure that lets you query tiles that intersect a transformed rectangle.
            */
            var TileCache = (function () {
                function TileCache(w, h, tileW, tileH, scale) {
                    this.tileW = tileW;
                    this.tileH = tileH;
                    this.scale = scale;
                    this.w = w;
                    this.h = h;
                    this.rows = Math.ceil(h / tileH);
                    this.columns = Math.ceil(w / tileW);
                    release || assert(this.rows < 2048 && this.columns < 2048);
                    this.tiles = [];
                    var index = 0;
                    for (var y = 0; y < this.rows; y++) {
                        for (var x = 0; x < this.columns; x++) {
                            this.tiles.push(new Tile(index++, x, y, tileW, tileH, scale));
                        }
                    }
                }
                /**
                * Query tiles using a transformed rectangle.
                * TODO: Fine-tune these heuristics.
                */
                TileCache.prototype.getTiles = function (query, transform) {
                    if (transform.emptyArea(query)) {
                        return [];
                    } else if (transform.infiniteArea(query)) {
                        return this.tiles;
                    }
                    var tileCount = this.columns * this.rows;

                    // The |getFewTiles| algorithm works better for a few tiles but it can't handle skew transforms.
                    if (tileCount < 40 && transform.isScaleOrRotation()) {
                        var precise = tileCount > 10;
                        return this.getFewTiles(query, transform, precise);
                    } else {
                        return this.getManyTiles(query, transform);
                    }
                };

                /**
                * Precise indicates that we want to do an exact OBB intersection.
                */
                TileCache.prototype.getFewTiles = function (query, transform, precise) {
                    if (typeof precise === "undefined") { precise = true; }
                    if (transform.isTranslationOnly() && this.tiles.length === 1) {
                        if (this.tiles[0].bounds.intersectsTranslated(query, transform.tx, transform.ty)) {
                            return [this.tiles[0]];
                        }
                        return [];
                    }
                    transform.transformRectangle(query, TileCache._points);
                    var queryOBB;
                    var queryBounds = new Rectangle(0, 0, this.w, this.h);
                    if (precise) {
                        queryOBB = new OBB(TileCache._points);
                    }
                    queryBounds.intersect(OBB.getBounds(TileCache._points));

                    if (queryBounds.isEmpty()) {
                        return [];
                    }

                    var minX = queryBounds.x / this.tileW | 0;
                    var minY = queryBounds.y / this.tileH | 0;
                    var maxX = Math.ceil((queryBounds.x + queryBounds.w) / this.tileW) | 0;
                    var maxY = Math.ceil((queryBounds.y + queryBounds.h) / this.tileH) | 0;

                    minX = clamp(minX, 0, this.columns);
                    maxX = clamp(maxX, 0, this.columns);
                    minY = clamp(minY, 0, this.rows);
                    maxY = clamp(maxY, 0, this.rows);

                    var tiles = [];
                    for (var x = minX; x < maxX; x++) {
                        for (var y = minY; y < maxY; y++) {
                            var tile = this.tiles[y * this.columns + x];
                            if (tile.bounds.intersects(queryBounds) && (precise ? tile.getOBB().intersects(queryOBB) : true)) {
                                tiles.push(tile);
                            }
                        }
                    }
                    return tiles;
                };

                TileCache.prototype.getManyTiles = function (query, transform) {
                    function intersectX(x, p1, p2) {
                        // (x - x1) * (y2 - y1) = (y - y1) * (x2 - x1)
                        return (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;
                    }
                    function appendTiles(tiles, cache, column, startRow, endRow) {
                        if (column < 0 || column >= cache.columns) {
                            return;
                        }
                        var j1 = clamp(startRow, 0, cache.rows);
                        var j2 = clamp(endRow + 1, 0, cache.rows);
                        for (var j = j1; j < j2; j++) {
                            tiles.push(cache.tiles[j * cache.columns + column]);
                        }
                    }

                    var rectPoints = TileCache._points;
                    transform.transformRectangle(query, rectPoints);

                    // finding minimal-x point, placing at first (and last)
                    var i1 = rectPoints[0].x < rectPoints[1].x ? 0 : 1;
                    var i2 = rectPoints[2].x < rectPoints[3].x ? 2 : 3;
                    var i0 = rectPoints[i1].x < rectPoints[i2].x ? i1 : i2;
                    var lines = [];
                    for (var j = 0; j < 5; j++, i0++) {
                        lines.push(rectPoints[i0 % 4]);
                    }

                    // and keeping points ordered counterclockwise
                    if ((lines[1].x - lines[0].x) * (lines[3].y - lines[0].y) < (lines[1].y - lines[0].y) * (lines[3].x - lines[0].x)) {
                        var tmp = lines[1];
                        lines[1] = lines[3];
                        lines[3] = tmp;
                    }

                    var tiles = [];

                    var lastY1, lastY2;
                    var i = Math.floor(lines[0].x / this.tileW);
                    var nextX = (i + 1) * this.tileW;
                    if (lines[2].x < nextX) {
                        // edge case: all fits into one column
                        lastY1 = Math.min(lines[0].y, lines[1].y, lines[2].y, lines[3].y);
                        lastY2 = Math.max(lines[0].y, lines[1].y, lines[2].y, lines[3].y);
                        var j1 = Math.floor(lastY1 / this.tileH);
                        var j2 = Math.floor(lastY2 / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        return tiles;
                    }

                    var line1 = 0, line2 = 4;
                    var lastSegment1 = false, lastSegment2 = false;
                    if (lines[0].x === lines[1].x || lines[0].x === lines[3].x) {
                        // edge case: first rectangle side parallel to columns
                        if (lines[0].x === lines[1].x) {
                            lastSegment1 = true;
                            line1++;
                        } else {
                            lastSegment2 = true;
                            line2--;
                        }

                        lastY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                        lastY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);

                        var j1 = Math.floor(lines[line1].y / this.tileH);
                        var j2 = Math.floor(lines[line2].y / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        i++;
                    }

                    do {
                        var nextY1, nextY2;
                        var nextSegment1, nextSegment2;
                        if (lines[line1 + 1].x < nextX) {
                            nextY1 = lines[line1 + 1].y;
                            nextSegment1 = true;
                        } else {
                            nextY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                            nextSegment1 = false;
                        }
                        if (lines[line2 - 1].x < nextX) {
                            nextY2 = lines[line2 - 1].y;
                            nextSegment2 = true;
                        } else {
                            nextY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                            nextSegment2 = false;
                        }

                        var j1 = Math.floor((lines[line1].y < lines[line1 + 1].y ? lastY1 : nextY1) / this.tileH);
                        var j2 = Math.floor((lines[line2].y > lines[line2 - 1].y ? lastY2 : nextY2) / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);

                        if (nextSegment1 && lastSegment1) {
                            break;
                        }

                        if (nextSegment1) {
                            lastSegment1 = true;
                            line1++;
                            lastY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                        } else {
                            lastY1 = nextY1;
                        }
                        if (nextSegment2) {
                            lastSegment2 = true;
                            line2--;
                            lastY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                        } else {
                            lastY2 = nextY2;
                        }
                        i++;
                        nextX = (i + 1) * this.tileW;
                    } while(line1 < line2);
                    return tiles;
                };
                TileCache._points = Point.createEmptyPoints(4);
                return TileCache;
            })();
            Geometry.TileCache = TileCache;

            var MIN_CACHE_LEVELS = 5;
            var MAX_CACHE_LEVELS = 3;

            /**
            * Manages tile caches at different scales.
            */
            var RenderableTileCache = (function () {
                function RenderableTileCache(source, tileSize, minUntiledSize) {
                    this._cacheLevels = [];
                    this._source = source;
                    this._tileSize = tileSize;
                    this._minUntiledSize = minUntiledSize;
                }
                /**
                * Gets the tiles covered by the specified |query| rectangle and transformed by the given |transform| matrix.
                */
                RenderableTileCache.prototype._getTilesAtScale = function (query, transform, scratchBounds) {
                    var transformScale = Math.max(transform.getAbsoluteScaleX(), transform.getAbsoluteScaleY());

                    // Use log2(1 / transformScale) to figure out the tile level.
                    var level = 0;
                    if (transformScale !== 1) {
                        level = clamp(Math.round(Math.log(1 / transformScale) / Math.LN2), -MIN_CACHE_LEVELS, MAX_CACHE_LEVELS);
                    }
                    var scale = pow2(level);

                    // Since we use a single tile for dynamic sources, we've got to make sure that it fits in our surface caches ...
                    if (this._source.hasFlags(1 /* Dynamic */)) {
                        while (true) {
                            scale = pow2(level);
                            if (scratchBounds.contains(this._source.getBounds().getAbsoluteBounds().clone().scale(scale, scale))) {
                                break;
                            }
                            level--;
                            release || assert(level >= -MIN_CACHE_LEVELS);
                        }
                    }

                    // If the source is not scalable don't cache any tiles at a higher scale factor. However, it may still make
                    // sense to cache at a lower scale factor in case we need to evict larger cached images.
                    if (!(this._source.hasFlags(4 /* Scalable */))) {
                        level = clamp(level, -MIN_CACHE_LEVELS, 0);
                    }
                    var scale = pow2(level);
                    var levelIndex = MIN_CACHE_LEVELS + level;
                    var cache = this._cacheLevels[levelIndex];
                    if (!cache) {
                        var bounds = this._source.getBounds().getAbsoluteBounds();
                        var scaledBounds = bounds.clone().scale(scale, scale);
                        var tileW, tileH;
                        if (this._source.hasFlags(1 /* Dynamic */) || !this._source.hasFlags(8 /* Tileable */) || Math.max(scaledBounds.w, scaledBounds.h) <= this._minUntiledSize) {
                            tileW = scaledBounds.w;
                            tileH = scaledBounds.h;
                        } else {
                            tileW = tileH = this._tileSize;
                        }
                        cache = this._cacheLevels[levelIndex] = new TileCache(scaledBounds.w, scaledBounds.h, tileW, tileH, scale);
                    }
                    return cache.getTiles(query, transform.scaleClone(scale, scale));
                };

                RenderableTileCache.prototype.fetchTiles = function (query, transform, scratchContext, cacheImageCallback) {
                    var scratchBounds = new Rectangle(0, 0, scratchContext.canvas.width, scratchContext.canvas.height);
                    var tiles = this._getTilesAtScale(query, transform, scratchBounds);
                    var uncachedTiles;
                    var source = this._source;
                    for (var i = 0; i < tiles.length; i++) {
                        var tile = tiles[i];
                        if (!tile.cachedSurfaceRegion || !tile.cachedSurfaceRegion.surface || (source.hasFlags(1 /* Dynamic */ | 2 /* Dirty */))) {
                            if (!uncachedTiles) {
                                uncachedTiles = [];
                            }
                            uncachedTiles.push(tile);
                        }
                    }
                    if (uncachedTiles) {
                        this._cacheTiles(scratchContext, uncachedTiles, cacheImageCallback, scratchBounds);
                    }
                    source.removeFlags(2 /* Dirty */);
                    return tiles;
                };

                RenderableTileCache.prototype._getTileBounds = function (tiles) {
                    var bounds = Rectangle.createEmpty();
                    for (var i = 0; i < tiles.length; i++) {
                        bounds.union(tiles[i].bounds);
                    }
                    return bounds;
                };

                /**
                * This caches raster versions of the specified |uncachedTiles|. The tiles are generated using a scratch
                * canvas2D context (|scratchContext|) and then cached via |cacheImageCallback|. Ideally, we want to render
                * all tiles in one go, but they may not fit in the |scratchContext| in which case we need to render the
                * source shape several times.
                *
                * TODO: Find a good algorithm to do this since it's quite important that we don't repaint too many times.
                * Spending some time trying to figure out the *optimal* solution may pay-off since painting is soo expensive.
                */
                RenderableTileCache.prototype._cacheTiles = function (scratchContext, uncachedTiles, cacheImageCallback, scratchBounds, maxRecursionDepth) {
                    if (typeof maxRecursionDepth === "undefined") { maxRecursionDepth = 4; }
                    release || assert(maxRecursionDepth > 0, "Infinite recursion is likely.");
                    var uncachedTileBounds = this._getTileBounds(uncachedTiles);
                    scratchContext.save();
                    scratchContext.setTransform(1, 0, 0, 1, 0, 0);
                    scratchContext.clearRect(0, 0, scratchBounds.w, scratchBounds.h);
                    scratchContext.translate(-uncachedTileBounds.x, -uncachedTileBounds.y);
                    scratchContext.scale(uncachedTiles[0].scale, uncachedTiles[0].scale);

                    // Translate so that the source is drawn at the origin.
                    var sourceBounds = this._source.getBounds();
                    scratchContext.translate(-sourceBounds.x, -sourceBounds.y);
                    profile && GFX.timelineBuffer && GFX.timelineBuffer.enter("renderTiles");
                    GFX.traceLevel >= 2 /* Verbose */ && GFX.writer && GFX.writer.writeLn("Rendering Tiles: " + uncachedTileBounds);
                    this._source.render(scratchContext);
                    scratchContext.restore();
                    profile && GFX.timelineBuffer && GFX.timelineBuffer.leave("renderTiles");

                    var remainingUncachedTiles = null;
                    for (var i = 0; i < uncachedTiles.length; i++) {
                        var tile = uncachedTiles[i];
                        var region = tile.bounds.clone();
                        region.x -= uncachedTileBounds.x;
                        region.y -= uncachedTileBounds.y;
                        if (!scratchBounds.contains(region)) {
                            if (!remainingUncachedTiles) {
                                remainingUncachedTiles = [];
                            }
                            remainingUncachedTiles.push(tile);
                        }
                        tile.cachedSurfaceRegion = cacheImageCallback(tile.cachedSurfaceRegion, scratchContext, region);
                    }
                    if (remainingUncachedTiles) {
                        // This is really dumb at the moment; if we have some tiles left over, partition the tile set in half and recurse.
                        if (remainingUncachedTiles.length >= 2) {
                            var a = remainingUncachedTiles.slice(0, remainingUncachedTiles.length / 2 | 0);
                            var b = remainingUncachedTiles.slice(a.length);
                            this._cacheTiles(scratchContext, a, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                            this._cacheTiles(scratchContext, b, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                        } else {
                            this._cacheTiles(scratchContext, remainingUncachedTiles, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                        }
                    }
                };
                return RenderableTileCache;
            })();
            Geometry.RenderableTileCache = RenderableTileCache;

            var MipMapLevel = (function () {
                function MipMapLevel(surfaceRegion, scale) {
                    this.surfaceRegion = surfaceRegion;
                    this.scale = scale;
                    // ...
                }
                return MipMapLevel;
            })();
            Geometry.MipMapLevel = MipMapLevel;

            var MipMap = (function () {
                function MipMap(source, surfaceRegionAllocator, size) {
                    this._source = source;
                    this._levels = [];
                    this._surfaceRegionAllocator = surfaceRegionAllocator;
                    this._size = size;
                }
                MipMap.prototype.render = function (context) {
                };
                MipMap.prototype.getLevel = function (matrix) {
                    var matrixScale = Math.max(matrix.getAbsoluteScaleX(), matrix.getAbsoluteScaleY());
                    var level = 0;
                    if (matrixScale !== 1) {
                        level = clamp(Math.round(Math.log(matrixScale) / Math.LN2), -MIN_CACHE_LEVELS, MAX_CACHE_LEVELS);
                    }
                    if (!(this._source.hasFlags(4 /* Scalable */))) {
                        level = clamp(level, -MIN_CACHE_LEVELS, 0);
                    }
                    var scale = pow2(level);
                    var levelIndex = MIN_CACHE_LEVELS + level;
                    var mipLevel = this._levels[levelIndex];

                    if (!mipLevel) {
                        var bounds = this._source.getBounds();
                        var scaledBounds = bounds.clone();
                        scaledBounds.scale(scale, scale);
                        scaledBounds.snap();
                        var surfaceRegion = this._surfaceRegionAllocator.allocate(scaledBounds.w, scaledBounds.h);
                        var region = surfaceRegion.region;
                        mipLevel = this._levels[levelIndex] = new MipMapLevel(surfaceRegion, scale);

                        // TODO: Should cast to <Canvas2D.Canvas2DSurface> but this is not available in gfx-base. We should probably
                        // move this code outside of geometry.
                        var surface = (mipLevel.surfaceRegion.surface);
                        var context = surface.context;
                        context.save();
                        context.beginPath();
                        context.rect(region.x, region.y, region.w, region.h);
                        context.clip();
                        context.setTransform(scale, 0, 0, scale, region.x - scaledBounds.x, region.y - scaledBounds.y);
                        this._source.render(context);
                        context.restore();
                    }
                    return mipLevel;
                };
                return MipMap;
            })();
            Geometry.MipMap = MipMap;
        })(GFX.Geometry || (GFX.Geometry = {}));
        var Geometry = GFX.Geometry;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var roundToMultipleOfPowerOfTwo = Shumway.IntegerUtilities.roundToMultipleOfPowerOfTwo;
        var assert = Shumway.Debug.assert;
        var Rectangle = GFX.Geometry.Rectangle;

        /**
        * Various 2D rectangular region allocators. These are used to manage
        * areas of surfaces, 2D Canvases or WebGL surfaces. Each allocator
        * implements the |IRegionAllocator| interface and must provied two
        * methods to allocate and free regions.
        *
        * CompactAllocator: Good for tightly packed surface atlases but becomes
        * fragmented easily. Allocation / freeing cost is high and should only
        * be used for long lived regions.
        *
        * GridAllocator: Very fast at allocation and freeing but is not very
        * tightly packed. Space is initially partitioned in equally sized grid
        * cells which may be much larger than the allocated regions. This should
        * be used for fixed size allocation regions.
        *
        * BucketAllocator: Manages a list of GridAllocators with different grid
        * sizes.
        */
        (function (RegionAllocator) {
            var Region = (function (_super) {
                __extends(Region, _super);
                function Region() {
                    _super.apply(this, arguments);
                }
                return Region;
            })(GFX.Geometry.Rectangle);
            RegionAllocator.Region = Region;

            /**
            * Simple 2D bin-packing algorithm that recursively partitions space along the x and y axis. The binary tree
            * can get quite deep so watch out of deep recursive calls. This algorithm works best when inserting items
            * that are sorted by width and height, from largest to smallest.
            */
            var CompactAllocator = (function () {
                function CompactAllocator(w, h) {
                    this._root = new CompactCell(0, 0, w | 0, h | 0, false);
                }
                CompactAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var result = this._root.insert(w, h);
                    if (result) {
                        result.allocator = this;
                        result.allocated = true;
                    }
                    return result;
                };

                CompactAllocator.prototype.free = function (region) {
                    var cell = region;
                    release || assert(cell.allocator === this);
                    cell.clear();
                    region.allocated = false;
                };
                CompactAllocator.RANDOM_ORIENTATION = true;
                CompactAllocator.MAX_DEPTH = 256;
                return CompactAllocator;
            })();
            RegionAllocator.CompactAllocator = CompactAllocator;

            var CompactCell = (function (_super) {
                __extends(CompactCell, _super);
                function CompactCell(x, y, w, h, horizontal) {
                    _super.call(this, x, y, w, h);
                    this._children = null;
                    this._horizontal = horizontal;
                    this.allocated = false;
                }
                CompactCell.prototype.clear = function () {
                    this._children = null;
                    this.allocated = false;
                };
                CompactCell.prototype.insert = function (w, h) {
                    return this._insert(w, h, 0);
                };
                CompactCell.prototype._insert = function (w, h, depth) {
                    if (depth > CompactAllocator.MAX_DEPTH) {
                        return;
                    }
                    if (this.allocated) {
                        return;
                    }
                    if (this.w < w || this.h < h) {
                        return;
                    }
                    if (!this._children) {
                        var orientation = !this._horizontal;
                        if (CompactAllocator.RANDOM_ORIENTATION) {
                            orientation = Math.random() >= 0.5;
                        }
                        if (this._horizontal) {
                            this._children = [
                                new CompactCell(this.x, this.y, this.w, h, false),
                                new CompactCell(this.x, this.y + h, this.w, this.h - h, orientation)
                            ];
                        } else {
                            this._children = [
                                new CompactCell(this.x, this.y, w, this.h, true),
                                new CompactCell(this.x + w, this.y, this.w - w, this.h, orientation)
                            ];
                        }
                        var first = this._children[0];
                        if (first.w === w && first.h === h) {
                            first.allocated = true;
                            return first;
                        }
                        return this._insert(w, h, depth + 1);
                    } else {
                        var result;
                        result = this._children[0]._insert(w, h, depth + 1);
                        if (result) {
                            return result;
                        }
                        result = this._children[1]._insert(w, h, depth + 1);
                        if (result) {
                            return result;
                        }
                    }
                };
                return CompactCell;
            })(RegionAllocator.Region);

            /**
            * Simple grid allocator. Starts off with an empty free list and allocates empty cells. Once a cell
            * is freed it's pushed into the free list. It gets poped off the next time a region is allocated.
            */
            var GridAllocator = (function () {
                function GridAllocator(w, h, sizeW, sizeH) {
                    this._columns = w / sizeW | 0;
                    this._rows = h / sizeH | 0;
                    this._sizeW = sizeW;
                    this._sizeH = sizeH;
                    this._freeList = [];
                    this._index = 0;
                    this._total = this._columns * this._rows;
                }
                GridAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var sizeW = this._sizeW;
                    var sizeH = this._sizeH;
                    if (w > sizeW || h > sizeH) {
                        return null;
                    }
                    var freeList = this._freeList;
                    var index = this._index;
                    if (freeList.length > 0) {
                        var cell = freeList.pop();
                        release || assert(cell.allocated === false);
                        cell.allocated = true;
                        return cell;
                    } else if (index < this._total) {
                        var y = (index / this._columns) | 0;
                        var x = index - (y * this._columns);
                        var cell = new GridCell(x * sizeW, y * sizeH, w, h);
                        cell.index = index;
                        cell.allocator = this;
                        cell.allocated = true;
                        this._index++;
                        return cell;
                    }
                    return null;
                };

                GridAllocator.prototype.free = function (region) {
                    var cell = region;
                    release || assert(cell.allocator === this);
                    cell.allocated = false;
                    this._freeList.push(cell);
                };
                return GridAllocator;
            })();
            RegionAllocator.GridAllocator = GridAllocator;

            var GridCell = (function (_super) {
                __extends(GridCell, _super);
                function GridCell(x, y, w, h) {
                    _super.call(this, x, y, w, h);
                    this.index = -1;
                }
                return GridCell;
            })(RegionAllocator.Region);
            RegionAllocator.GridCell = GridCell;

            var Bucket = (function () {
                function Bucket(size, region, allocator) {
                    this.size = size;
                    this.region = region;
                    this.allocator = allocator;
                }
                return Bucket;
            })();

            var BucketCell = (function (_super) {
                __extends(BucketCell, _super);
                function BucketCell(x, y, w, h, region) {
                    _super.call(this, x, y, w, h);
                    this.region = region;
                }
                return BucketCell;
            })(RegionAllocator.Region);
            RegionAllocator.BucketCell = BucketCell;

            var BucketAllocator = (function () {
                function BucketAllocator(w, h) {
                    release || assert(w > 0 && h > 0);
                    this._buckets = [];
                    this._w = w | 0;
                    this._h = h | 0;
                    this._filled = 0;
                }
                /**
                * Finds the first bucket that is large enough to hold the requested region. If no
                * such bucket exists, then allocates a new bucket if there is room otherwise
                * returns null;
                */
                BucketAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var size = Math.max(w, h);
                    if (w > this._w || h > this._h) {
                        // Too big, cannot allocate this.
                        return null;
                    }
                    var region = null;
                    var bucket;
                    var buckets = this._buckets;
                    do {
                        for (var i = 0; i < buckets.length; i++) {
                            if (buckets[i].size >= size) {
                                bucket = buckets[i];
                                region = bucket.allocator.allocate(w, h);
                                if (region) {
                                    break;
                                }
                            }
                        }
                        if (!region) {
                            var remainingSpace = this._h - this._filled;
                            if (remainingSpace < h) {
                                // Couldn't allocate region and there is no more vertical space to allocate
                                // a new bucket that can fit the requested size. So give up.
                                return null;
                            }
                            var gridSize = roundToMultipleOfPowerOfTwo(size, 2);
                            var bucketHeight = gridSize * 2;
                            if (bucketHeight > remainingSpace) {
                                bucketHeight = remainingSpace;
                            }
                            if (bucketHeight < gridSize) {
                                return null;
                            }
                            var bucketRegion = new Rectangle(0, this._filled, this._w, bucketHeight);
                            this._buckets.push(new Bucket(gridSize, bucketRegion, new GridAllocator(bucketRegion.w, bucketRegion.h, gridSize, gridSize)));
                            this._filled += bucketHeight;
                        }
                    } while(!region);

                    return new BucketCell(bucket.region.x + region.x, bucket.region.y + region.y, region.w, region.h, region);
                };

                BucketAllocator.prototype.free = function (region) {
                    region.region.allocator.free(region.region);
                };
                return BucketAllocator;
            })();
            RegionAllocator.BucketAllocator = BucketAllocator;
        })(GFX.RegionAllocator || (GFX.RegionAllocator = {}));
        var RegionAllocator = GFX.RegionAllocator;

        (function (SurfaceRegionAllocator) {
            var SimpleAllocator = (function () {
                function SimpleAllocator(createSurface) {
                    this._createSurface = createSurface;
                    this._surfaces = [];
                }
                Object.defineProperty(SimpleAllocator.prototype, "surfaces", {
                    get: function () {
                        return this._surfaces;
                    },
                    enumerable: true,
                    configurable: true
                });

                SimpleAllocator.prototype._createNewSurface = function (w, h) {
                    var surface = this._createSurface(w, h);
                    this._surfaces.push(surface);
                    return surface;
                };

                SimpleAllocator.prototype.addSurface = function (surface) {
                    this._surfaces.push(surface);
                };

                SimpleAllocator.prototype.allocate = function (w, h) {
                    for (var i = 0; i < this._surfaces.length; i++) {
                        var region = this._surfaces[i].allocate(w, h);
                        if (region) {
                            return region;
                        }
                    }
                    return this._createNewSurface(w, h).allocate(w, h);
                };

                SimpleAllocator.prototype.free = function (region) {
                };
                return SimpleAllocator;
            })();
            SurfaceRegionAllocator.SimpleAllocator = SimpleAllocator;
        })(GFX.SurfaceRegionAllocator || (GFX.SurfaceRegionAllocator = {}));
        var SurfaceRegionAllocator = GFX.SurfaceRegionAllocator;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Point = GFX.Geometry.Point;
        var Matrix = GFX.Geometry.Matrix;

        var assert = Shumway.Debug.assert;
        var unexpected = Shumway.Debug.unexpected;

        (function (Direction) {
            Direction[Direction["None"] = 0] = "None";
            Direction[Direction["Upward"] = 1] = "Upward";
            Direction[Direction["Downward"] = 2] = "Downward";
        })(GFX.Direction || (GFX.Direction = {}));
        var Direction = GFX.Direction;

        (function (PixelSnapping) {
            PixelSnapping[PixelSnapping["Never"] = 0] = "Never";
            PixelSnapping[PixelSnapping["Always"] = 1] = "Always";
            PixelSnapping[PixelSnapping["Auto"] = 2] = "Auto";
        })(GFX.PixelSnapping || (GFX.PixelSnapping = {}));
        var PixelSnapping = GFX.PixelSnapping;

        (function (Smoothing) {
            Smoothing[Smoothing["Never"] = 0] = "Never";
            Smoothing[Smoothing["Always"] = 1] = "Always";
        })(GFX.Smoothing || (GFX.Smoothing = {}));
        var Smoothing = GFX.Smoothing;

        (function (FrameFlags) {
            FrameFlags[FrameFlags["Empty"] = 0x0000] = "Empty";
            FrameFlags[FrameFlags["Dirty"] = 0x0001] = "Dirty";
            FrameFlags[FrameFlags["IsMask"] = 0x0002] = "IsMask";
            FrameFlags[FrameFlags["IgnoreMask"] = 0x0008] = "IgnoreMask";
            FrameFlags[FrameFlags["IgnoreQuery"] = 0x0010] = "IgnoreQuery";

            /**
            * Frame has invalid bounds because one of its children's bounds have been mutated.
            */
            FrameFlags[FrameFlags["InvalidBounds"] = 0x0020] = "InvalidBounds";

            /**
            * Frame has an invalid concatenated matrix because its matrix or one of its ancestor's matrices has been mutated.
            */
            FrameFlags[FrameFlags["InvalidConcatenatedMatrix"] = 0x0040] = "InvalidConcatenatedMatrix";

            /**
            * Frame has an invalid inverted concatenated matrix because its matrix or one of its ancestor's matrices has been
            * mutated. We don't always need to compute the inverted matrix. This is why we use a sepearete invalid flag for it
            * and don't roll it under the |InvalidConcatenatedMatrix| flag.
            */
            FrameFlags[FrameFlags["InvalidInvertedConcatenatedMatrix"] = 0x0080] = "InvalidInvertedConcatenatedMatrix";

            /**
            * Frame has an invalid concatenated color transform because its color transform or one of its ancestor's color
            * transforms has been mutated.
            */
            FrameFlags[FrameFlags["InvalidConcatenatedColorMatrix"] = 0x0100] = "InvalidConcatenatedColorMatrix";

            /**
            * Frame has invalid contents and needs to be repainted, this bit is culled by the viewport.
            */
            FrameFlags[FrameFlags["InvalidPaint"] = 0x0200] = "InvalidPaint";

            FrameFlags[FrameFlags["EnterClip"] = 0x1000] = "EnterClip";
            FrameFlags[FrameFlags["LeaveClip"] = 0x2000] = "LeaveClip";

            FrameFlags[FrameFlags["Visible"] = 0x4000] = "Visible";
        })(GFX.FrameFlags || (GFX.FrameFlags = {}));
        var FrameFlags = GFX.FrameFlags;

        /**
        * Frame capabilities, the fewer capabilities the better.
        */
        (function (FrameCapabilityFlags) {
            FrameCapabilityFlags[FrameCapabilityFlags["None"] = 0] = "None";

            FrameCapabilityFlags[FrameCapabilityFlags["AllowMatrixWrite"] = 1] = "AllowMatrixWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowColorMatrixWrite"] = 2] = "AllowColorMatrixWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowBlendModeWrite"] = 4] = "AllowBlendModeWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowFiltersWrite"] = 8] = "AllowFiltersWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowMaskWrite"] = 16] = "AllowMaskWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowChildrenWrite"] = 32] = "AllowChildrenWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowClipWrite"] = 64] = "AllowClipWrite";
            FrameCapabilityFlags[FrameCapabilityFlags["AllowAllWrite"] = FrameCapabilityFlags.AllowMatrixWrite | FrameCapabilityFlags.AllowColorMatrixWrite | FrameCapabilityFlags.AllowBlendModeWrite | FrameCapabilityFlags.AllowFiltersWrite | FrameCapabilityFlags.AllowMaskWrite | FrameCapabilityFlags.AllowChildrenWrite | FrameCapabilityFlags.AllowClipWrite] = "AllowAllWrite";
        })(GFX.FrameCapabilityFlags || (GFX.FrameCapabilityFlags = {}));
        var FrameCapabilityFlags = GFX.FrameCapabilityFlags;

        /**
        * The |Frame| class is the base class for all nodes in the frame tree. Frames have several local and computed
        * properties. Computed properties are evaluated lazily and cached locally. Invalid bits are used to mark
        * computed properties as being invalid and may be cleared once these properties are re-evaluated.
        *
        * Capability flags are not yet implemented. The idea is to force some constraits on frames so that algorithms
        * can run more effectively.
        *
        *
        */
        var Frame = (function () {
            function Frame() {
                this._id = Frame._nextID++;
                this._flags = 16384 /* Visible */ | 512 /* InvalidPaint */ | 32 /* InvalidBounds */ | 64 /* InvalidConcatenatedMatrix */ | 128 /* InvalidInvertedConcatenatedMatrix */ | 256 /* InvalidConcatenatedColorMatrix */;

                this._capability = FrameCapabilityFlags.AllowAllWrite;
                this._parent = null;
                this._clip = -1;
                this._blendMode = 1 /* Normal */;
                this._filters = [];
                this._mask = null;
                this._matrix = Matrix.createIdentity();
                this._concatenatedMatrix = Matrix.createIdentity();
                this._invertedConcatenatedMatrix = null;
                this._colorMatrix = GFX.ColorMatrix.createIdentity();
                this._concatenatedColorMatrix = GFX.ColorMatrix.createIdentity();

                this._smoothing = 0 /* Never */;
                this._pixelSnapping = 0 /* Never */;
            }
            /*
            * Return's a list of ancestors excluding the |last|, the return list is reused.
            */
            Frame._getAncestors = function (node, last) {
                if (typeof last === "undefined") { last = null; }
                var path = Frame._path;
                path.length = 0;
                while (node && node !== last) {
                    path.push(node);
                    node = node._parent;
                }
                release || assert(node === last, "Last ancestor is not an ancestor.");
                return path;
            };

            Object.defineProperty(Frame.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Frame.prototype, "id", {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });

            Frame.prototype._setFlags = function (flags) {
                this._flags |= flags;
            };

            Frame.prototype._removeFlags = function (flags) {
                this._flags &= ~flags;
            };

            Frame.prototype._hasFlags = function (flags) {
                return (this._flags & flags) === flags;
            };

            Frame.prototype._toggleFlags = function (flags, on) {
                if (on) {
                    this._flags |= flags;
                } else {
                    this._flags &= ~flags;
                }
            };

            Frame.prototype._hasAnyFlags = function (flags) {
                return !!(this._flags & flags);
            };

            /**
            * Finds the closest ancestor with a given set of flags that are either turned on or off.
            */
            Frame.prototype._findClosestAncestor = function (flags, on) {
                var node = this;
                while (node) {
                    if (node._hasFlags(flags) === on) {
                        return node;
                    }
                    node = node._parent;
                }
                return null;
            };

            /**
            * Tests if this frame is an ancestor of the specified frame.
            */
            Frame.prototype._isAncestor = function (child) {
                var node = child;
                while (node) {
                    if (node === this) {
                        return true;
                    }
                    node = node._parent;
                }
                return false;
            };

            /**
            * Propagates capabilities up and down the frame tree.
            *
            * TODO: Make this non-recursive.
            */
            Frame.prototype.setCapability = function (capability, on, direction) {
                if (typeof on === "undefined") { on = true; }
                if (typeof direction === "undefined") { direction = 0 /* None */; }
                if (on) {
                    this._capability |= capability;
                } else {
                    this._capability &= ~capability;
                }
                if (direction === 1 /* Upward */ && this._parent) {
                    this._parent.setCapability(capability, on, direction);
                } else if (direction === 2 /* Downward */ && this instanceof GFX.FrameContainer) {
                    var frameContainer = this;
                    var children = frameContainer._children;
                    for (var i = 0; i < children.length; i++) {
                        children[i].setCapability(capability, on, direction);
                    }
                }
            };

            Frame.prototype.removeCapability = function (capability) {
                this.setCapability(capability, false);
            };

            Frame.prototype.hasCapability = function (capability) {
                return this._capability & capability;
            };

            Frame.prototype.checkCapability = function (capability) {
                if (!(this._capability & capability)) {
                    unexpected("Frame doesn't have capability: " + FrameCapabilityFlags[capability]);
                }
            };

            /**
            * Propagates flags up the frame tree. Propagation stops if all flags are already set.
            */
            Frame.prototype._propagateFlagsUp = function (flags) {
                if (this._hasFlags(flags)) {
                    return;
                }
                this._setFlags(flags);
                var parent = this._parent;
                if (parent) {
                    parent._propagateFlagsUp(flags);
                }
            };

            /**
            * Propagates flags down the frame tree. Non-containers just set the flags on themselves.
            *
            * Overridden in FrameContainer.
            */
            Frame.prototype._propagateFlagsDown = function (flags) {
                this._setFlags(flags);
            };

            /**
            * Marks this frame as having been moved in its parent frame. This needs to be called whenever the position
            * of a frame changes in the frame tree. For instance, its matrix has been mutated or it has been added or
            * removed from a frame container.
            */
            Frame.prototype._invalidatePosition = function () {
                this._propagateFlagsDown(64 /* InvalidConcatenatedMatrix */ | 128 /* InvalidInvertedConcatenatedMatrix */);
                if (this._parent) {
                    this._parent._invalidateBounds();
                }
                this._invalidateParentPaint();
            };

            /**
            * Marks this frame as needing to be repainted.
            */
            Frame.prototype.invalidatePaint = function () {
                this._propagateFlagsUp(512 /* InvalidPaint */);
            };

            Frame.prototype._invalidateParentPaint = function () {
                if (this._parent) {
                    this._parent._propagateFlagsUp(512 /* InvalidPaint */);
                }
            };

            Frame.prototype._invalidateBounds = function () {
                /* TODO: We should only propagate this bit if the bounds are actually changed. We can do the
                * bounds computation eagerly if the number of children is low. If there are no changes in the
                * bounds we don't need to propagate the bit. */
                this._propagateFlagsUp(32 /* InvalidBounds */);
            };

            Object.defineProperty(Frame.prototype, "properties", {
                get: function () {
                    return this._properties || (this._properties = Object.create(null));
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Frame.prototype, "x", {
                get: function () {
                    return this._matrix.tx;
                },
                set: function (value) {
                    this.checkCapability(1 /* AllowMatrixWrite */);
                    this._matrix.tx = value;
                    this._invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "y", {
                get: function () {
                    return this._matrix.ty;
                },
                set: function (value) {
                    this.checkCapability(1 /* AllowMatrixWrite */);
                    this._matrix.ty = value;
                    this._invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "matrix", {
                get: function () {
                    return this._matrix;
                },
                set: function (value) {
                    this.checkCapability(1 /* AllowMatrixWrite */);
                    this._matrix.set(value);
                    this._invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });



            Object.defineProperty(Frame.prototype, "blendMode", {
                get: function () {
                    return this._blendMode;
                },
                set: function (value) {
                    value = value | 0;
                    this.checkCapability(4 /* AllowBlendModeWrite */);
                    this._blendMode = value;
                    this._invalidateParentPaint();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "filters", {
                get: function () {
                    return this._filters;
                },
                set: function (value) {
                    this.checkCapability(8 /* AllowFiltersWrite */);
                    this._filters = value;
                    this._invalidateParentPaint();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "colorMatrix", {
                get: function () {
                    return this._colorMatrix;
                },
                set: function (value) {
                    this.checkCapability(2 /* AllowColorMatrixWrite */);
                    this._colorMatrix = value;
                    this._propagateFlagsDown(256 /* InvalidConcatenatedColorMatrix */);
                    this._invalidateParentPaint();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "mask", {
                get: function () {
                    return this._mask;
                },
                set: function (value) {
                    this.checkCapability(16 /* AllowMaskWrite */);
                    if (this._mask && this._mask !== value) {
                        this._mask._removeFlags(2 /* IsMask */);
                    }
                    this._mask = value;
                    if (this._mask) {
                        // TODO: Check if this assertion makes sense.
                        // release || assert (!this._mask._hasFlags(FrameFlags.IsMask));
                        this._mask._setFlags(2 /* IsMask */);
                        this._mask.invalidate();
                    }
                    this.invalidate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "clip", {
                get: function () {
                    return this._clip;
                },
                set: function (value) {
                    this.checkCapability(64 /* AllowClipWrite */);
                    this._clip = value;
                },
                enumerable: true,
                configurable: true
            });

            Frame.prototype.getBounds = function () {
                release || assert(false, "Override this.");
                return null;
            };

            Frame.prototype.gatherPreviousDirtyRegions = function () {
                var stage = this.stage;
                if (!stage.trackDirtyRegions) {
                    return;
                }
                this.visit(function (frame) {
                    if (frame instanceof GFX.FrameContainer) {
                        return 0 /* Continue */;
                    }
                    if (frame._previouslyRenderedAABB) {
                        stage.dirtyRegion.addDirtyRectangle(frame._previouslyRenderedAABB);
                    }
                    return 0 /* Continue */;
                });
            };

            Frame.prototype.getConcatenatedColorMatrix = function () {
                if (!this._parent) {
                    return this._colorMatrix;
                }

                // Compute the concatenated color transforms for this node and all of its ancestors.
                if (this._hasFlags(256 /* InvalidConcatenatedColorMatrix */)) {
                    var ancestor = this._findClosestAncestor(256 /* InvalidConcatenatedColorMatrix */, false);
                    var path = Frame._getAncestors(this, ancestor);
                    var m = ancestor ? ancestor._concatenatedColorMatrix.clone() : GFX.ColorMatrix.createIdentity();
                    for (var i = path.length - 1; i >= 0; i--) {
                        var ancestor = path[i];
                        release || assert(ancestor._hasFlags(256 /* InvalidConcatenatedColorMatrix */));

                        // TODO: Premultiply here.
                        m.multiply(ancestor._colorMatrix);
                        ancestor._concatenatedColorMatrix.copyFrom(m);
                        ancestor._removeFlags(256 /* InvalidConcatenatedColorMatrix */);
                    }
                }
                return this._concatenatedColorMatrix;
            };

            Frame.prototype.getConcatenatedAlpha = function (ancestor) {
                if (typeof ancestor === "undefined") { ancestor = null; }
                var frame = this;
                var alpha = 1;
                while (frame && frame !== ancestor) {
                    alpha *= frame._colorMatrix.alphaMultiplier;
                    frame = frame._parent;
                }
                return alpha;
            };

            Object.defineProperty(Frame.prototype, "stage", {
                get: function () {
                    var frame = this;
                    while (frame._parent) {
                        frame = frame._parent;
                    }
                    if (frame instanceof GFX.Stage) {
                        return frame;
                    }
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Frame.prototype.getConcatenatedMatrix = function () {
                // Compute the concatenated transforms for this node and all of its ancestors.
                if (this._hasFlags(64 /* InvalidConcatenatedMatrix */)) {
                    var ancestor = this._findClosestAncestor(64 /* InvalidConcatenatedMatrix */, false);
                    var path = Frame._getAncestors(this, ancestor);
                    var m = ancestor ? ancestor._concatenatedMatrix.clone() : Matrix.createIdentity();
                    for (var i = path.length - 1; i >= 0; i--) {
                        var ancestor = path[i];
                        release || assert(ancestor._hasFlags(64 /* InvalidConcatenatedMatrix */));
                        m.preMultiply(ancestor._matrix);
                        ancestor._concatenatedMatrix.set(m);
                        ancestor._removeFlags(64 /* InvalidConcatenatedMatrix */);
                    }
                }
                return this._concatenatedMatrix;
            };

            Frame.prototype._getInvertedConcatenatedMatrix = function () {
                if (this._hasFlags(128 /* InvalidInvertedConcatenatedMatrix */)) {
                    if (!this._invertedConcatenatedMatrix) {
                        this._invertedConcatenatedMatrix = Matrix.createIdentity();
                    }
                    this._invertedConcatenatedMatrix.set(this.getConcatenatedMatrix());
                    this._invertedConcatenatedMatrix.inverse(this._invertedConcatenatedMatrix);
                    this._removeFlags(128 /* InvalidInvertedConcatenatedMatrix */);
                }
                return this._invertedConcatenatedMatrix;
            };

            Frame.prototype.invalidate = function () {
                this._setFlags(1 /* Dirty */);
            };

            Frame.prototype.visit = function (visitor, transform, flags, visitorFlags) {
                if (typeof flags === "undefined") { flags = 0 /* Empty */; }
                if (typeof visitorFlags === "undefined") { visitorFlags = 0 /* None */; }
                var frameStack;
                var frame;
                var frameContainer;
                var frontToBack = visitorFlags & 8 /* FrontToBack */;
                frameStack = [this];
                var transformStack;
                var calculateTransform = !!transform;
                if (calculateTransform) {
                    transformStack = [transform.clone()];
                }
                var flagsStack = [flags];
                while (frameStack.length > 0) {
                    frame = frameStack.pop();
                    if (calculateTransform) {
                        transform = transformStack.pop();
                    }
                    flags = flagsStack.pop() | frame._flags;
                    var result = visitor(frame, transform, flags);
                    if (result === 0 /* Continue */) {
                        if (frame instanceof GFX.FrameContainer) {
                            frameContainer = frame;
                            var length = frameContainer._children.length;
                            if (visitorFlags & 16 /* Clips */ && !GFX.disableClipping.value) {
                                var leaveClip = frameContainer.gatherLeaveClipEvents();

                                for (var i = length - 1; i >= 0; i--) {
                                    // Check to see if we have any clip leave events that we need to push into the |frameStack|?
                                    if (leaveClip && leaveClip[i]) {
                                        while (leaveClip[i].length) {
                                            var clipFrame = leaveClip[i].shift();
                                            frameStack.push(clipFrame);
                                            flagsStack.push(8192 /* LeaveClip */);
                                            if (calculateTransform) {
                                                var t = transform.clone();
                                                t.preMultiply(clipFrame.matrix);
                                                transformStack.push(t);
                                            }
                                        }
                                    }
                                    var child = frameContainer._children[i];
                                    release || assert(child);
                                    frameStack.push(child);
                                    if (calculateTransform) {
                                        var t = transform.clone();
                                        t.preMultiply(child.matrix);
                                        transformStack.push(t);
                                    }
                                    if (child.clip >= 0) {
                                        flagsStack.push(flags | 4096 /* EnterClip */);
                                    } else {
                                        flagsStack.push(flags);
                                    }
                                }
                            } else {
                                for (var i = 0; i < length; i++) {
                                    var child = frameContainer._children[frontToBack ? i : length - 1 - i];
                                    if (!child) {
                                        continue;
                                    }
                                    frameStack.push(child);
                                    if (calculateTransform) {
                                        var t = transform.clone();
                                        t.preMultiply(child.matrix);
                                        transformStack.push(t);
                                    }
                                    flagsStack.push(flags);
                                }
                            }
                        }
                    } else if (result === 1 /* Stop */) {
                        return;
                    }
                }
            };

            Frame.prototype.getDepth = function () {
                var depth = 0;
                var frame = this;
                while (frame._parent) {
                    depth++;
                    frame = frame._parent;
                }
                return depth;
            };


            Object.defineProperty(Frame.prototype, "smoothing", {
                get: function () {
                    return this._smoothing;
                },
                set: function (value) {
                    this._smoothing = value;
                    this.invalidate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Frame.prototype, "pixelSnapping", {
                get: function () {
                    return this._pixelSnapping;
                },
                set: function (value) {
                    this._pixelSnapping = value;
                    this.invalidate();
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns a list of frames whose bounds intersect the query point. The frames
            * are returned front to back. By default, only the first frame that intersects
            * the query point is returned, unless the |multiple| argument is specified.
            */
            Frame.prototype.queryFramesByPoint = function (query, multiple, includeFrameContainers) {
                if (typeof multiple === "undefined") { multiple = false; }
                if (typeof includeFrameContainers === "undefined") { includeFrameContainers = false; }
                var inverseTransform = Matrix.createIdentity();
                var local = Point.createEmpty();
                var frames = [];
                this.visit(function (frame, transform, flags) {
                    if (flags & 16 /* IgnoreQuery */) {
                        return 2 /* Skip */;
                    }
                    transform.inverse(inverseTransform);
                    local.set(query);
                    inverseTransform.transformPoint(local);
                    if (frame.getBounds().containsPoint(local)) {
                        if (frame instanceof GFX.FrameContainer) {
                            if (includeFrameContainers) {
                                frames.push(frame);
                                if (!multiple) {
                                    return 1 /* Stop */;
                                }
                            }
                            return 0 /* Continue */;
                        } else {
                            frames.push(frame);
                            if (!multiple) {
                                return 1 /* Stop */;
                            }
                        }
                        return 0 /* Continue */;
                    } else {
                        return 2 /* Skip */;
                    }
                }, Matrix.createIdentity(), 0 /* Empty */);

                /*
                *  We can't simply do a back to front traversal here because the order in which we
                *  visit frame containers would make it hard to compute the correct front-to-back
                *  order.
                *
                *       A
                *      / \
                *     /   \
                *    B     E
                *   / \   / \
                *  C   D F   G
                *
                *  The front-to-back order is [A, E, G, F, B, D, C], if G and D are both hit, then the hit order
                *  would be computed as [A, E, G, B, D] when clearly it should be [G, E, D, B, A]. If we walk
                *  the tree in back-to-front order [A, B, C, D, E, F, G] the hit order becomes [A, B, D, E, G]
                *  which we can simply reverse.
                */
                frames.reverse();
                return frames;
            };
            Frame._path = [];

            Frame._nextID = 0;
            return Frame;
        })();
        GFX.Frame = Frame;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Rectangle = GFX.Geometry.Rectangle;

        var assert = Shumway.Debug.assert;

        var FrameContainer = (function (_super) {
            __extends(FrameContainer, _super);
            function FrameContainer() {
                _super.call(this);
                this._children = [];
            }
            FrameContainer.prototype.addChild = function (child) {
                this.checkCapability(32 /* AllowChildrenWrite */);
                if (child) {
                    child._parent = this;
                    child._invalidatePosition();
                }
                this._children.push(child);
                return child;
            };

            FrameContainer.prototype.addChildAt = function (child, index) {
                this.checkCapability(32 /* AllowChildrenWrite */);
                release || assert(index >= 0 && index <= this._children.length);
                if (index === this._children.length) {
                    this._children.push(child);
                } else {
                    this._children.splice(index, 0, child);
                }
                if (child) {
                    child._parent = this;
                    child._invalidatePosition();
                }
                return child;
            };

            FrameContainer.prototype.removeChild = function (child) {
                this.checkCapability(32 /* AllowChildrenWrite */);
                if (child._parent === this) {
                    var index = this._children.indexOf(child);
                    this.removeChildAt(index);
                }
            };

            FrameContainer.prototype.removeChildAt = function (index) {
                this.checkCapability(32 /* AllowChildrenWrite */);
                release || assert(index >= 0 && index < this._children.length);
                var result = this._children.splice(index, 1);
                var child = result[0];
                if (!child) {
                    return;
                }
                child._parent = undefined;
                child._invalidatePosition();
            };

            FrameContainer.prototype.clearChildren = function () {
                this.checkCapability(32 /* AllowChildrenWrite */);
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    if (child) {
                        child._invalidatePosition();
                        // child.gatherPreviousDirtyRegions();
                    }
                }
                this._children.length = 0;
            };

            /**
            * Propagates flags down the frame tree. Propagation stops if all flags are already set.
            */
            FrameContainer.prototype._propagateFlagsDown = function (flags) {
                if (this._hasFlags(flags)) {
                    return;
                }
                this._setFlags(flags);
                var children = this._children;
                for (var i = 0; i < children.length; i++) {
                    children[i]._propagateFlagsDown(flags);
                }
            };

            FrameContainer.prototype.getBounds = function () {
                if (!this._hasFlags(32 /* InvalidBounds */)) {
                    return this._bounds;
                }
                var bounds = Rectangle.createEmpty();
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    var childBounds = child.getBounds().clone();
                    child.matrix.transformRectangleAABB(childBounds);
                    bounds.union(childBounds);
                }
                this._bounds = bounds;
                this._removeFlags(32 /* InvalidBounds */);
                return bounds;
            };

            /**
            * Returns an array that marks leave clip events.
            *
            * i:  0  1  2  3  4  5  6  7  8  9
            * A:  ---[--------------------]---
            * B:  ------[-----------------]---
            * C:  ---------[-----------]------
            * D:  ---------------|------------
            *
            * In this example, frame A is at index 1 and has a clip value of 7 meaning it clips the next 7 frames in its container, frame B
            * at index 2 has a clip value of 6 and frame C at index 3 has a clip value of 4. The frame visitor needs to know when clips end
            * and start so here we collect all clip leave events. Clip start events are easier to identify, just check the clip value. Also
            * no more than one clip region starts at a given index, this is not true of clip ends.
            *
            * Here we return the sparse array: [8: [A, B], 7: [C], 5: [D]].
            */
            FrameContainer.prototype.gatherLeaveClipEvents = function () {
                var length = this._children.length;
                var leaveClip = null;
                for (var i = 0; i < length; i++) {
                    var child = this._children[i];
                    if (child.clip >= 0) {
                        var clipLeaveIndex = i + child.clip;
                        leaveClip = leaveClip || [];
                        if (!leaveClip[clipLeaveIndex]) {
                            leaveClip[clipLeaveIndex] = [];
                        }
                        leaveClip[clipLeaveIndex].push(child);
                    }
                }
                return leaveClip;
            };
            return FrameContainer;
        })(GFX.Frame);
        GFX.FrameContainer = FrameContainer;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Rectangle = GFX.Geometry.Rectangle;

        var DirtyRegion = GFX.Geometry.DirtyRegion;

        var assert = Shumway.Debug.assert;

        (function (BlendMode) {
            BlendMode[BlendMode["Normal"] = 1] = "Normal";
            BlendMode[BlendMode["Layer"] = 2] = "Layer";
            BlendMode[BlendMode["Multiply"] = 3] = "Multiply";
            BlendMode[BlendMode["Screen"] = 4] = "Screen";
            BlendMode[BlendMode["Lighten"] = 5] = "Lighten";
            BlendMode[BlendMode["Darken"] = 6] = "Darken";
            BlendMode[BlendMode["Difference"] = 7] = "Difference";
            BlendMode[BlendMode["Add"] = 8] = "Add";
            BlendMode[BlendMode["Subtract"] = 9] = "Subtract";
            BlendMode[BlendMode["Invert"] = 10] = "Invert";
            BlendMode[BlendMode["Alpha"] = 11] = "Alpha";
            BlendMode[BlendMode["Erase"] = 12] = "Erase";
            BlendMode[BlendMode["Overlay"] = 13] = "Overlay";
            BlendMode[BlendMode["HardLight"] = 14] = "HardLight";
        })(GFX.BlendMode || (GFX.BlendMode = {}));
        var BlendMode = GFX.BlendMode;

        /**
        * Controls how the visitor walks the display tree.
        */
        (function (VisitorFlags) {
            VisitorFlags[VisitorFlags["None"] = 0] = "None";

            /**
            * Continue with normal traversal.
            */
            VisitorFlags[VisitorFlags["Continue"] = 0] = "Continue";

            /**
            * Not used yet, should probably just stop the visitor.
            */
            VisitorFlags[VisitorFlags["Stop"] = 1] = "Stop";

            /**
            * Skip processing current frame.
            */
            VisitorFlags[VisitorFlags["Skip"] = 2] = "Skip";

            /**
            * Visit front to back.
            */
            VisitorFlags[VisitorFlags["FrontToBack"] = 8] = "FrontToBack";

            /**
            * Visit clip leave events.
            */
            VisitorFlags[VisitorFlags["Clips"] = 16] = "Clips";
        })(GFX.VisitorFlags || (GFX.VisitorFlags = {}));
        var VisitorFlags = GFX.VisitorFlags;

        function getRandomIntInclusive(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        var StageRendererOptions = (function () {
            function StageRendererOptions() {
                this.debug = false;
                this.paintRenderable = true;
                this.paintBounds = false;
                this.paintFlashing = false;
                this.paintViewport = false;
            }
            return StageRendererOptions;
        })();
        GFX.StageRendererOptions = StageRendererOptions;

        (function (Backend) {
            Backend[Backend["Canvas2D"] = 0] = "Canvas2D";
            Backend[Backend["WebGL"] = 1] = "WebGL";
            Backend[Backend["Both"] = 2] = "Both";
            Backend[Backend["DOM"] = 3] = "DOM";
            Backend[Backend["SVG"] = 4] = "SVG";
        })(GFX.Backend || (GFX.Backend = {}));
        var Backend = GFX.Backend;

        var StageRenderer = (function () {
            function StageRenderer(canvas, stage, options) {
                this._canvas = canvas;
                this._stage = stage;
                this._options = options;
                this._viewport = Rectangle.createSquare(1024);
            }
            Object.defineProperty(StageRenderer.prototype, "viewport", {
                set: function (viewport) {
                    this._viewport.set(viewport);
                },
                enumerable: true,
                configurable: true
            });

            StageRenderer.prototype.render = function () {
            };

            /**
            * Notify renderer that the viewport has changed.
            */
            StageRenderer.prototype.resize = function () {
            };
            return StageRenderer;
        })();
        GFX.StageRenderer = StageRenderer;

        var Stage = (function (_super) {
            __extends(Stage, _super);
            function Stage(w, h, trackDirtyRegions) {
                if (typeof trackDirtyRegions === "undefined") { trackDirtyRegions = false; }
                _super.call(this);
                this.w = w;
                this.h = h;
                this.dirtyRegion = new DirtyRegion(w, h);
                this.trackDirtyRegions = trackDirtyRegions;
                this._setFlags(1 /* Dirty */);
            }
            /**
            * Checks to see if we should render and if so, clears any relevant dirty flags. Returns
            * true if rendering should commence. Flag clearing is made optional here in case there
            * is any code that needs to check if rendering is about to happen.
            */
            Stage.prototype.readyToRender = function (clearFlags) {
                if (typeof clearFlags === "undefined") { clearFlags = true; }
                if (!this._hasFlags(512 /* InvalidPaint */)) {
                    return false;
                } else if (clearFlags) {
                    GFX.enterTimeline("readyToRender");
                    this.visit(function (frame) {
                        if (frame._hasFlags(512 /* InvalidPaint */)) {
                            frame._toggleFlags(512 /* InvalidPaint */, false);
                            return 0 /* Continue */;
                        } else {
                            return 2 /* Skip */;
                        }
                    });
                    GFX.leaveTimeline();
                }
                return true;
            };

            Stage.prototype.gatherMarkedDirtyRegions = function (transform) {
                var self = this;

                // Find all invalid frames.
                this.visit(function (frame, transform, flags) {
                    frame._removeFlags(1 /* Dirty */);
                    if (frame instanceof GFX.FrameContainer) {
                        return 0 /* Continue */;
                    }
                    if (flags & 1 /* Dirty */) {
                        var rectangle = frame.getBounds().clone();
                        transform.transformRectangleAABB(rectangle);
                        self.dirtyRegion.addDirtyRectangle(rectangle);
                        if (frame._previouslyRenderedAABB) {
                            // Add last render position to dirty list.
                            self.dirtyRegion.addDirtyRectangle(frame._previouslyRenderedAABB);
                        }
                    }
                    return 0 /* Continue */;
                }, transform, 0 /* Empty */);
            };

            Stage.prototype.gatherFrames = function () {
                var frames = [];
                this.visit(function (frame, transform) {
                    if (!(frame instanceof GFX.FrameContainer)) {
                        frames.push(frame);
                    }
                    return 0 /* Continue */;
                }, this.matrix);
                return frames;
            };

            Stage.prototype.gatherLayers = function () {
                var layers = [];
                var currentLayer;
                this.visit(function (frame, transform) {
                    if (frame instanceof GFX.FrameContainer) {
                        return 0 /* Continue */;
                    }
                    var rectangle = frame.getBounds().clone();
                    transform.transformRectangleAABB(rectangle);
                    if (frame._hasFlags(1 /* Dirty */)) {
                        if (currentLayer) {
                            layers.push(currentLayer);
                        }
                        layers.push(rectangle.clone());
                        currentLayer = null;
                    } else {
                        if (!currentLayer) {
                            currentLayer = rectangle.clone();
                        } else {
                            currentLayer.union(rectangle);
                        }
                    }
                    return 0 /* Continue */;
                }, this.matrix);

                if (currentLayer) {
                    layers.push(currentLayer);
                }

                return layers;
            };
            return Stage;
        })(GFX.FrameContainer);
        GFX.Stage = Stage;

        /**
        * A frame container that clips everything outside of its bounds.
        */
        var ClipRectangle = (function (_super) {
            __extends(ClipRectangle, _super);
            function ClipRectangle(w, h) {
                _super.call(this);
                this.color = Shumway.Color.None;
                this._bounds = new Rectangle(0, 0, w, h);
            }
            ClipRectangle.prototype.setBounds = function (bounds) {
                this._bounds.set(bounds);
            };

            ClipRectangle.prototype.getBounds = function () {
                return this._bounds;
            };
            return ClipRectangle;
        })(GFX.FrameContainer);
        GFX.ClipRectangle = ClipRectangle;

        var Shape = (function (_super) {
            __extends(Shape, _super);
            function Shape(source) {
                _super.call(this);
                release || assert(source);
                this._source = source;
            }
            Object.defineProperty(Shape.prototype, "source", {
                get: function () {
                    return this._source;
                },
                enumerable: true,
                configurable: true
            });

            Shape.prototype.getBounds = function () {
                return this.source.getBounds();
            };
            return Shape;
        })(GFX.Frame);
        GFX.Shape = Shape;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Rectangle = GFX.Geometry.Rectangle;
        var PathCommand = Shumway.PathCommand;
        var Matrix = GFX.Geometry.Matrix;

        var swap32 = Shumway.IntegerUtilities.swap32;
        var memorySizeToString = Shumway.StringUtilities.memorySizeToString;
        var assertUnreachable = Shumway.Debug.assertUnreachable;

        var tableLookupUnpremultiplyARGB = Shumway.ColorUtilities.tableLookupUnpremultiplyARGB;
        var assert = Shumway.Debug.assert;
        var unexpected = Shumway.Debug.unexpected;
        var notImplemented = Shumway.Debug.notImplemented;

        var indexOf = Shumway.ArrayUtilities.indexOf;

        (function (RenderableFlags) {
            RenderableFlags[RenderableFlags["None"] = 0] = "None";

            /**
            * Whether source has dynamic content.
            */
            RenderableFlags[RenderableFlags["Dynamic"] = 1] = "Dynamic";

            /**
            * Whether the source's dynamic content has changed. This is only defined if |isDynamic| is true.
            */
            RenderableFlags[RenderableFlags["Dirty"] = 2] = "Dirty";

            /**
            * Whether the source's content can be scaled and drawn at a higher resolution.
            */
            RenderableFlags[RenderableFlags["Scalable"] = 4] = "Scalable";

            /**
            * Whether the source's content should be tiled.
            */
            RenderableFlags[RenderableFlags["Tileable"] = 8] = "Tileable";

            /**
            * Whether the source's content is loading and thus not available yet. Once loading
            * is complete this flag is cleared and the |Dirty| flag is set.
            */
            RenderableFlags[RenderableFlags["Loading"] = 16] = "Loading";
        })(GFX.RenderableFlags || (GFX.RenderableFlags = {}));
        var RenderableFlags = GFX.RenderableFlags;

        /**
        * Represents some source renderable content.
        */
        var Renderable = (function () {
            function Renderable(bounds) {
                /**
                * Flags
                */
                this._flags = 0 /* None */;
                /**
                * Property bag used to attach dynamic properties to this object.
                */
                this.properties = {};
                /**
                * Back reference to frames that use this renderable.
                */
                this._frameReferrers = [];
                /**
                * Back reference to renderables that use this renderable.
                */
                this._renderableReferrers = [];
                this._bounds = bounds.clone();
            }
            Renderable.prototype.setFlags = function (flags) {
                this._flags |= flags;
            };

            Renderable.prototype.hasFlags = function (flags) {
                return (this._flags & flags) === flags;
            };

            Renderable.prototype.removeFlags = function (flags) {
                this._flags &= ~flags;
            };

            Renderable.prototype.addFrameReferrer = function (frame) {
                release && assert(frame);
                var index = indexOf(this._frameReferrers, frame);
                release && assert(index < 0);
                this._frameReferrers.push(frame);
            };

            Renderable.prototype.addRenderableReferrer = function (renderable) {
                release && assert(renderable);
                var index = indexOf(this._renderableReferrers, renderable);
                release && assert(index < 0);
                this._renderableReferrers.push(renderable);
            };

            Renderable.prototype.invalidatePaint = function () {
                this.setFlags(2 /* Dirty */);
                var frames = this._frameReferrers;
                for (var i = 0; i < frames.length; i++) {
                    frames[i].invalidatePaint();
                }
                var renderables = this._renderableReferrers;
                for (var i = 0; i < renderables.length; i++) {
                    renderables[i].invalidatePaint();
                }
            };

            /**
            * Bounds of the source content. This should never change.
            */
            Renderable.prototype.getBounds = function () {
                return this._bounds;
            };

            /**
            * Render source content in the specified |context|. If specified, the rectangular |cullBounds| can be used to cull parts of the shape
            * for better performance. If specified, |
            * Region| indicates whether the shape's fills should be used as clip regions instead.
            */
            Renderable.prototype.render = function (context, cullBounds, clipRegion) {
            };
            return Renderable;
        })();
        GFX.Renderable = Renderable;

        var CustomRenderable = (function (_super) {
            __extends(CustomRenderable, _super);
            function CustomRenderable(bounds, render) {
                _super.call(this, bounds);
                this.render = render;
            }
            return CustomRenderable;
        })(Renderable);
        GFX.CustomRenderable = CustomRenderable;

        var RenderableBitmap = (function (_super) {
            __extends(RenderableBitmap, _super);
            function RenderableBitmap(canvas, bounds) {
                _super.call(this, bounds);
                this._flags = 1 /* Dynamic */ | 2 /* Dirty */;
                this.properties = {};
                this._canvas = canvas;
            }
            RenderableBitmap._convertImage = function (sourceFormat, targetFormat, source, target) {
                if (source !== target) {
                    release || assert(source.buffer !== target.buffer, "Can't handle overlapping views.");
                }
                if (sourceFormat === targetFormat) {
                    if (source === target) {
                        return;
                    }
                    var length = source.length;
                    for (var i = 0; i < length; i++) {
                        target[i] = source[i];
                    }
                    return;
                }
                GFX.enterTimeline("convertImage", Shumway.ImageType[sourceFormat] + " to " + Shumway.ImageType[targetFormat] + " (" + memorySizeToString(source.length));
                if (sourceFormat === 1 /* PremultipliedAlphaARGB */ && targetFormat === 3 /* StraightAlphaRGBA */) {
                    Shumway.ColorUtilities.ensureUnpremultiplyTable();
                    var length = source.length;
                    for (var i = 0; i < length; i++) {
                        var pARGB = swap32(source[i]);

                        // TODO: Make sure this is inlined!
                        var uARGB = tableLookupUnpremultiplyARGB(pARGB);
                        var uABGR = (uARGB & 0xFF00FF00) | (uARGB >> 16) & 0xff | (uARGB & 0xff) << 16;
                        target[i] = uABGR;
                    }
                } else if (sourceFormat === 2 /* StraightAlphaARGB */ && targetFormat === 3 /* StraightAlphaRGBA */) {
                    for (var i = 0; i < length; i++) {
                        target[i] = swap32(source[i]);
                    }
                } else {
                    notImplemented("Image Format Conversion: " + Shumway.ImageType[sourceFormat] + " -> " + Shumway.ImageType[targetFormat]);
                }
                GFX.leaveTimeline("convertImage");
            };

            RenderableBitmap.FromDataBuffer = function (type, dataBuffer, bounds) {
                GFX.enterTimeline("RenderableBitmap.FromDataBuffer");
                var canvas = document.createElement("canvas");
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                var renderableBitmap = new RenderableBitmap(canvas, bounds);
                renderableBitmap.updateFromDataBuffer(type, dataBuffer);
                GFX.leaveTimeline("RenderableBitmap.FromDataBuffer");
                return renderableBitmap;
            };

            RenderableBitmap.FromFrame = function (source, matrix, colorMatrix, blendMode, clipRect) {
                GFX.enterTimeline("RenderableBitmap.FromFrame");
                var canvas = document.createElement("canvas");
                var bounds = source.getBounds();
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                var renderableBitmap = new RenderableBitmap(canvas, bounds);
                renderableBitmap.drawFrame(source, matrix, colorMatrix, blendMode, clipRect);
                GFX.leaveTimeline("RenderableBitmap.FromFrame");
                return renderableBitmap;
            };

            RenderableBitmap.prototype.updateFromDataBuffer = function (type, dataBuffer) {
                if (!GFX.imageUpdateOption.value) {
                    return;
                }
                GFX.enterTimeline("RenderableBitmap.updateFromDataBuffer", this);
                var context = this._canvas.getContext("2d");
                if (type === 4 /* JPEG */ || type === 5 /* PNG */ || type === 6 /* GIF */) {
                    var self = this;
                    self.setFlags(16 /* Loading */);
                    var image = new Image();
                    image.src = URL.createObjectURL(dataBuffer.toBlob());
                    image.onload = function () {
                        context.drawImage(image, 0, 0);
                        self.removeFlags(16 /* Loading */);
                        self.invalidatePaint();
                    };
                    image.onerror = function () {
                        unexpected("Image loading error: " + Shumway.ImageType[type]);
                    };
                } else {
                    var imageData = context.createImageData(this._bounds.w, this._bounds.h);
                    RenderableBitmap._convertImage(type, 3 /* StraightAlphaRGBA */, new Int32Array(dataBuffer.buffer), new Int32Array(imageData.data.buffer));
                    GFX.enterTimeline("putImageData");
                    context.putImageData(imageData, 0, 0);
                    GFX.leaveTimeline("putImageData");
                }
                this.invalidatePaint();
                GFX.leaveTimeline("RenderableBitmap.updateFromDataBuffer");
            };

            /**
            * Writes the image data into the given |output| data buffer.
            */
            RenderableBitmap.prototype.readImageData = function (output) {
                var context = this._canvas.getContext("2d");
                var data = context.getImageData(0, 0, this._canvas.width, this._canvas.height).data;
                output.writeRawBytes(data);
            };

            RenderableBitmap.prototype.render = function (context, cullBounds) {
                GFX.enterTimeline("RenderableBitmap.render");
                if (this._canvas) {
                    context.drawImage(this._canvas, 0, 0);
                } else {
                    this._renderFallback(context);
                }
                GFX.leaveTimeline("RenderableBitmap.render");
            };

            RenderableBitmap.prototype.drawFrame = function (source, matrix, colorMatrix, blendMode, clipRect) {
                // TODO: Support colorMatrix and blendMode.
                GFX.enterTimeline("RenderableBitmap.drawFrame");

                // TODO: Hack to be able to compile this as part of gfx-base.
                var Canvas2D = GFX.Canvas2D;
                var bounds = this.getBounds();
                var options = new Canvas2D.Canvas2DStageRendererOptions();
                options.cacheShapes = true;
                var renderer = new Canvas2D.Canvas2DStageRenderer(this._canvas, null, options);
                renderer.renderFrame(source, clipRect || bounds, matrix);
                GFX.leaveTimeline("RenderableBitmap.drawFrame");
            };

            RenderableBitmap.prototype._renderFallback = function (context) {
                if (!this.fillStyle) {
                    this.fillStyle = Shumway.ColorStyle.randomStyle();
                }
                var bounds = this._bounds;
                context.save();
                context.beginPath();
                context.lineWidth = 2;
                context.fillStyle = this.fillStyle;
                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                context.restore();
            };
            return RenderableBitmap;
        })(Renderable);
        GFX.RenderableBitmap = RenderableBitmap;

        var PathType;
        (function (PathType) {
            PathType[PathType["Fill"] = 0] = "Fill";
            PathType[PathType["Stroke"] = 1] = "Stroke";
            PathType[PathType["StrokeFill"] = 2] = "StrokeFill";
        })(PathType || (PathType = {}));

        var StyledPath = (function () {
            function StyledPath(type, style, smoothImage, strokeProperties) {
                this.type = type;
                this.style = style;
                this.smoothImage = smoothImage;
                this.strokeProperties = strokeProperties;
                this.path = new Path2D();
                release || assert((type === 1 /* Stroke */) === !!strokeProperties);
            }
            return StyledPath;
        })();

        var StrokeProperties = (function () {
            function StrokeProperties(thickness, capsStyle, jointsStyle, miterLimit) {
                this.thickness = thickness;
                this.capsStyle = capsStyle;
                this.jointsStyle = jointsStyle;
                this.miterLimit = miterLimit;
            }
            return StrokeProperties;
        })();

        var RenderableShape = (function (_super) {
            __extends(RenderableShape, _super);
            function RenderableShape(id, pathData, textures, bounds) {
                _super.call(this, bounds);
                this._flags = 2 /* Dirty */ | 4 /* Scalable */ | 8 /* Tileable */;
                this.properties = {};
                this._id = id;
                this._pathData = pathData;
                this._textures = textures;
                if (textures.length) {
                    this.setFlags(1 /* Dynamic */);
                }
            }
            RenderableShape.prototype.update = function (pathData, textures, bounds) {
                this._bounds = bounds;
                this._pathData = pathData;
                this._paths = null;
                this._textures = textures;
            };

            RenderableShape.prototype.getBounds = function () {
                return this._bounds;
            };

            /**
            * If |clipRegion| is |true| then we must call |clip| instead of |fill|. We also cannot call
            * |save| or |restore| because those functions reset the current clipping region. It looks
            * like Flash ignores strokes when clipping so we can also ignore stroke paths when computing
            * the clip region.
            */
            RenderableShape.prototype.render = function (context, cullBounds, clipRegion) {
                if (typeof clipRegion === "undefined") { clipRegion = false; }
                context.fillStyle = context.strokeStyle = 'transparent';

                // Wait to deserialize paths until all textures have been loaded.
                var textures = this._textures;
                for (var i = 0; i < textures.length; i++) {
                    if (textures[i].hasFlags(16 /* Loading */)) {
                        return;
                    }
                }

                var data = this._pathData;
                if (data) {
                    this._deserializePaths(data, context);
                }

                var paths = this._paths;
                release || assert(paths);

                GFX.enterTimeline("RenderableShape.render", this);
                for (var i = 0; i < paths.length; i++) {
                    var path = paths[i];
                    context['mozImageSmoothingEnabled'] = context.msImageSmoothingEnabled = context['imageSmoothingEnabled'] = path.smoothImage;
                    if (path.type === 0 /* Fill */) {
                        context.fillStyle = path.style;
                        clipRegion ? context.clip(path.path, 'evenodd') : context.fill(path.path, 'evenodd');
                        context.fillStyle = 'transparent';
                    } else if (!clipRegion) {
                        context.strokeStyle = path.style;
                        if (path.strokeProperties) {
                            context.lineWidth = path.strokeProperties.thickness;
                            context.lineCap = path.strokeProperties.capsStyle;
                            context.lineJoin = path.strokeProperties.jointsStyle;
                            context.miterLimit = path.strokeProperties.miterLimit;
                        }

                        // Special-cases 1px and 3px lines by moving the drawing position down/right by 0.5px.
                        // Flash apparently does this to create sharp, non-aliased lines in the normal case of thin
                        // lines drawn on round pixel values.
                        // Our handling doesn't always create the same results: for drawing coordinates with
                        // fractional values, Flash draws blurry lines. We do, too, but we still move the line
                        // down/right. Flash does something slightly different, with the result that a line drawn
                        // on coordinates slightly below round pixels (0.8, say) will be moved up/left.
                        // Properly fixing this would probably have to happen in the rasterizer. Or when replaying
                        // all the drawing commands, which seems expensive.
                        var lineWidth = context.lineWidth;
                        var isSpecialCaseWidth = lineWidth === 1 || lineWidth === 3;
                        if (isSpecialCaseWidth) {
                            context.translate(0.5, 0.5);
                        }
                        context.stroke(path.path);
                        if (isSpecialCaseWidth) {
                            context.translate(-0.5, -0.5);
                        }
                        context.strokeStyle = 'transparent';
                    }
                }
                GFX.leaveTimeline("RenderableShape.render");
            };

            RenderableShape.prototype._deserializePaths = function (data, context) {
                release || assert(!this._paths);
                GFX.enterTimeline("RenderableShape.deserializePaths");

                // TODO: Optimize path handling to use only one path if possible.
                // If both line and fill style are set at the same time, we don't need to duplicate the
                // geometry.
                this._paths = [];

                var fillPath = null;
                var strokePath = null;

                // We have to alway store the last position because Flash keeps the drawing cursor where it
                // was when changing fill or line style, whereas Canvas forgets it on beginning a new path.
                var x = 0;
                var y = 0;
                var cpX;
                var cpY;
                var formOpen = false;
                var formOpenX = 0;
                var formOpenY = 0;
                var commands = data.commands;
                var coordinates = data.coordinates;
                var styles = data.styles;
                styles.position = 0;
                var coordinatesIndex = 0;
                var commandsCount = data.commandsPosition;

                for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                    var command = commands[commandIndex];
                    switch (command) {
                        case 9 /* MoveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                            if (formOpen && fillPath) {
                                fillPath.lineTo(formOpenX, formOpenY);
                                strokePath && strokePath.lineTo(formOpenX, formOpenY);
                            }
                            formOpen = true;
                            x = formOpenX = coordinates[coordinatesIndex++] / 20;
                            y = formOpenY = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.moveTo(x, y);
                            strokePath && strokePath.moveTo(x, y);
                            break;
                        case 10 /* LineTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                            x = coordinates[coordinatesIndex++] / 20;
                            y = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.lineTo(x, y);
                            strokePath && strokePath.lineTo(x, y);
                            break;
                        case 11 /* CurveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                            cpX = coordinates[coordinatesIndex++] / 20;
                            cpY = coordinates[coordinatesIndex++] / 20;
                            x = coordinates[coordinatesIndex++] / 20;
                            y = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.quadraticCurveTo(cpX, cpY, x, y);
                            strokePath && strokePath.quadraticCurveTo(cpX, cpY, x, y);
                            break;
                        case 12 /* CubicCurveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                            cpX = coordinates[coordinatesIndex++] / 20;
                            cpY = coordinates[coordinatesIndex++] / 20;
                            var cpX2 = coordinates[coordinatesIndex++] / 20;
                            var cpY2 = coordinates[coordinatesIndex++] / 20;
                            x = coordinates[coordinatesIndex++] / 20;
                            y = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                            strokePath && strokePath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                            break;
                        case 1 /* BeginSolidFill */:
                            release || assert(styles.bytesAvailable >= 4);
                            fillPath = this._createPath(0 /* Fill */, Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt()), false, null, x, y);
                            break;
                        case 3 /* BeginBitmapFill */:
                            var bitmapStyle = this._readBitmap(styles, context);
                            fillPath = this._createPath(0 /* Fill */, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                            break;
                        case 2 /* BeginGradientFill */:
                            fillPath = this._createPath(0 /* Fill */, this._readGradient(styles, context), false, null, x, y);
                            break;
                        case 4 /* EndFill */:
                            fillPath = null;
                            break;
                        case 5 /* LineStyleSolid */:
                            var color = Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt());

                            // Skip pixel hinting and scale mode for now.
                            styles.position += 2;
                            var capsStyle = RenderableShape.LINE_CAPS_STYLES[styles.readByte()];
                            var jointsStyle = RenderableShape.LINE_JOINTS_STYLES[styles.readByte()];
                            var strokeProperties = new StrokeProperties(coordinates[coordinatesIndex++] / 20, capsStyle, jointsStyle, styles.readByte());
                            strokePath = this._createPath(1 /* Stroke */, color, false, strokeProperties, x, y);
                            break;
                        case 6 /* LineStyleGradient */:
                            strokePath = this._createPath(2 /* StrokeFill */, this._readGradient(styles, context), false, null, x, y);
                            break;
                        case 7 /* LineStyleBitmap */:
                            var bitmapStyle = this._readBitmap(styles, context);
                            strokePath = this._createPath(2 /* StrokeFill */, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                            break;
                        case 8 /* LineEnd */:
                            strokePath = null;
                            break;
                        default:
                            release || assertUnreachable('Invalid command ' + command + ' encountered at index' + commandIndex + ' of ' + commandsCount);
                    }
                }
                release || assert(styles.bytesAvailable === 0);
                release || assert(commandIndex === commandsCount);
                release || assert(coordinatesIndex === data.coordinatesPosition);
                if (formOpen && fillPath) {
                    fillPath.lineTo(formOpenX, formOpenY);
                    strokePath && strokePath.lineTo(formOpenX, formOpenY);
                }
                this._pathData = null;
                GFX.leaveTimeline("RenderableShape.deserializePaths");
            };

            RenderableShape.prototype._createPath = function (type, style, smoothImage, strokeProperties, x, y) {
                var path = new StyledPath(type, style, smoothImage, strokeProperties);
                this._paths.push(path);
                path.path.moveTo(x, y);
                return path.path;
            };

            RenderableShape.prototype._readMatrix = function (data) {
                return new Matrix(data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat());
            };

            RenderableShape.prototype._readGradient = function (styles, context) {
                // Assert at least one color stop.
                release || assert(styles.bytesAvailable >= 1 + 1 + 6 * 4 + 1 + 1 + 4 + 1 + 1);
                var gradientType = styles.readUnsignedByte();
                var focalPoint = styles.readShort() * 2 / 0xff;
                release || assert(focalPoint >= -1 && focalPoint <= 1);
                var transform = this._readMatrix(styles);
                var gradient = gradientType === 16 /* Linear */ ? context.createLinearGradient(-1, 0, 1, 0) : context.createRadialGradient(focalPoint, 0, 0, 0, 0, 1);
                gradient.setTransform && gradient.setTransform(transform.toSVGMatrix());
                var colorStopsCount = styles.readUnsignedByte();
                for (var i = 0; i < colorStopsCount; i++) {
                    var ratio = styles.readUnsignedByte() / 0xff;
                    var cssColor = Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt());
                    gradient.addColorStop(ratio, cssColor);
                }

                // Skip spread and interpolation modes for now.
                styles.position += 2;

                return gradient;
            };

            RenderableShape.prototype._readBitmap = function (styles, context) {
                release || assert(styles.bytesAvailable >= 4 + 6 * 4 + 1 + 1);
                var textureIndex = styles.readUnsignedInt();
                var fillTransform = this._readMatrix(styles);
                var repeat = styles.readBoolean() ? 'repeat' : 'no-repeat';
                var smooth = styles.readBoolean();
                var texture = this._textures[textureIndex];
                release || assert(texture._canvas);
                var fillStyle = context.createPattern(texture._canvas, repeat);
                fillStyle.setTransform(fillTransform.toSVGMatrix());
                return { style: fillStyle, smoothImage: smooth };
            };

            RenderableShape.prototype._renderFallback = function (context) {
                if (!this.fillStyle) {
                    this.fillStyle = Shumway.ColorStyle.randomStyle();
                }
                var bounds = this._bounds;
                context.save();
                context.beginPath();
                context.lineWidth = 2;
                context.fillStyle = this.fillStyle;
                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);

                //      context.textBaseline = "top";
                //      context.fillStyle = "white";
                //      context.fillText(String(id), bounds.x, bounds.y);
                context.restore();
            };
            RenderableShape.LINE_CAPS_STYLES = ['round', 'butt', 'square'];
            RenderableShape.LINE_JOINTS_STYLES = ['round', 'bevel', 'miter'];
            return RenderableShape;
        })(Renderable);
        GFX.RenderableShape = RenderableShape;

        var TextLine = (function () {
            function TextLine() {
                this.x = 0;
                this.y = 0;
                this.width = 0;
                this.ascent = 0;
                this.descent = 0;
                this.leading = 0;
                this.align = 0;
                this.runs = [];
            }
            TextLine.prototype.addRun = function (font, fillStyle, text, underline) {
                if (text) {
                    TextLine._measureContext.font = font;
                    var width = TextLine._measureContext.measureText(text).width | 0;
                    this.runs.push(new TextRun(font, fillStyle, text, width, underline));
                    this.width += width;
                }
            };

            TextLine.prototype.wrap = function (maxWidth) {
                var lines = [this];
                var runs = this.runs;

                var currentLine = this;
                currentLine.width = 0;
                currentLine.runs = [];

                var measureContext = TextLine._measureContext;

                for (var i = 0; i < runs.length; i++) {
                    var run = runs[i];
                    var text = run.text;
                    run.text = '';
                    run.width = 0;
                    measureContext.font = run.font;
                    var spaceLeft = maxWidth;
                    var words = text.split(/[\s.-]/);
                    var offset = 0;
                    for (var j = 0; j < words.length; j++) {
                        var word = words[j];
                        var chunk = text.substr(offset, word.length + 1);
                        var wordWidth = measureContext.measureText(chunk).width | 0;
                        if (wordWidth > spaceLeft) {
                            do {
                                currentLine.runs.push(run);
                                currentLine.width += run.width;
                                run = new TextRun(run.font, run.fillStyle, '', 0, run.underline);
                                var newLine = new TextLine();
                                newLine.y = (currentLine.y + currentLine.descent + currentLine.leading + currentLine.ascent) | 0;
                                newLine.ascent = currentLine.ascent;
                                newLine.descent = currentLine.descent;
                                newLine.leading = currentLine.leading;
                                newLine.align = currentLine.align;
                                lines.push(newLine);
                                currentLine = newLine;
                                spaceLeft = maxWidth - wordWidth;
                                if (spaceLeft < 0) {
                                    var k = chunk.length;
                                    var t;
                                    var w;
                                    do {
                                        k--;
                                        t = chunk.substr(0, k);
                                        w = measureContext.measureText(t).width | 0;
                                    } while(w > maxWidth);
                                    run.text = t;
                                    run.width = w;
                                    chunk = chunk.substr(k);
                                    wordWidth = measureContext.measureText(chunk).width | 0;
                                }
                            } while(spaceLeft < 0);
                        } else {
                            spaceLeft = spaceLeft - wordWidth;
                        }
                        run.text += chunk;
                        run.width += wordWidth;
                        offset += word.length + 1;
                    }
                    currentLine.runs.push(run);
                    currentLine.width += run.width;
                }

                return lines;
            };
            TextLine._measureContext = document.createElement('canvas').getContext('2d');
            return TextLine;
        })();
        GFX.TextLine = TextLine;

        var TextRun = (function () {
            function TextRun(font, fillStyle, text, width, underline) {
                if (typeof font === "undefined") { font = ''; }
                if (typeof fillStyle === "undefined") { fillStyle = ''; }
                if (typeof text === "undefined") { text = ''; }
                if (typeof width === "undefined") { width = 0; }
                if (typeof underline === "undefined") { underline = false; }
                this.font = font;
                this.fillStyle = fillStyle;
                this.text = text;
                this.width = width;
                this.underline = underline;
            }
            return TextRun;
        })();
        GFX.TextRun = TextRun;

        var RenderableText = (function (_super) {
            __extends(RenderableText, _super);
            function RenderableText(bounds) {
                _super.call(this, bounds);
                this._flags = 1 /* Dynamic */ | 2 /* Dirty */;
                this.properties = {};
                this._textBounds = bounds.clone();
                this._textRunData = null;
                this._plainText = '';
                this._backgroundColor = 0;
                this._borderColor = 0;
                this._matrix = null;
                this._coords = null;
                this.textRect = bounds.clone();
                this.lines = [];
            }
            RenderableText.prototype.setBounds = function (bounds) {
                this._bounds.copyFrom(bounds);
                this._textBounds.copyFrom(bounds);
                this.textRect.setElements(bounds.x + 2, bounds.y + 2, bounds.x - 2, bounds.x - 2);
            };

            RenderableText.prototype.setContent = function (plainText, textRunData, matrix, coords) {
                this._textRunData = textRunData;
                this._plainText = plainText;
                this._matrix = matrix;
                this._coords = coords;
                this.lines = [];
            };

            RenderableText.prototype.setStyle = function (backgroundColor, borderColor) {
                this._backgroundColor = backgroundColor;
                this._borderColor = borderColor;
            };

            RenderableText.prototype.reflow = function (autoSize, wordWrap) {
                var textRunData = this._textRunData;

                if (!textRunData) {
                    return;
                }

                var bounds = this._bounds;
                var availableWidth = bounds.w - 4;
                var plainText = this._plainText;
                var lines = this.lines;

                var currentLine = new TextLine();
                var baseLinePos = 0;
                var maxWidth = 0;
                var maxAscent = 0;
                var maxDescent = 0;
                var maxLeading = 0;
                var firstAlign = -1;

                var finishLine = function () {
                    if (!currentLine.runs.length) {
                        baseLinePos += maxAscent + maxDescent + maxLeading;
                        return;
                    }

                    baseLinePos += maxAscent;
                    currentLine.y = baseLinePos | 0;
                    baseLinePos += maxDescent + maxLeading;
                    currentLine.ascent = maxAscent;
                    currentLine.descent = maxDescent;
                    currentLine.leading = maxLeading;
                    currentLine.align = firstAlign;

                    if (wordWrap && currentLine.width > availableWidth) {
                        var wrappedLines = currentLine.wrap(availableWidth);
                        for (var i = 0; i < wrappedLines.length; i++) {
                            var line = wrappedLines[i];
                            baseLinePos = line.y + line.descent + line.leading;
                            lines.push(line);
                            if (line.width > maxWidth) {
                                maxWidth = line.width;
                            }
                        }
                    } else {
                        lines.push(currentLine);
                        if (currentLine.width > maxWidth) {
                            maxWidth = currentLine.width;
                        }
                    }

                    currentLine = new TextLine();
                };

                GFX.enterTimeline("RenderableText.reflow");

                while (textRunData.position < textRunData.length) {
                    var beginIndex = textRunData.readInt();
                    var endIndex = textRunData.readInt();

                    var size = textRunData.readInt();
                    var fontId = textRunData.readInt();
                    var fontName;
                    if (fontId) {
                        fontName = 'swffont' + fontId;
                    } else {
                        fontName = textRunData.readUTF();
                    }

                    var ascent = textRunData.readInt();
                    var descent = textRunData.readInt();
                    var leading = textRunData.readInt();
                    if (ascent > maxAscent) {
                        maxAscent = ascent;
                    }
                    if (descent > maxDescent) {
                        maxDescent = descent;
                    }
                    if (leading > maxLeading) {
                        maxLeading = leading;
                    }

                    var bold = textRunData.readBoolean();
                    var italic = textRunData.readBoolean();
                    var boldItalic = '';
                    if (italic) {
                        boldItalic += 'italic';
                    }
                    if (bold) {
                        boldItalic += ' bold';
                    }
                    var font = boldItalic + ' ' + size + 'px ' + fontName;

                    var color = textRunData.readInt();
                    var fillStyle = Shumway.ColorUtilities.rgbToHex(color);

                    var align = textRunData.readInt();
                    if (firstAlign === -1) {
                        firstAlign = align;
                    }

                    var bullet = textRunData.readBoolean();

                    //var display = textRunData.readInt();
                    var indent = textRunData.readInt();

                    //var blockIndent = textRunData.readInt();
                    var kerning = textRunData.readInt();
                    var leftMargin = textRunData.readInt();
                    var letterSpacing = textRunData.readInt();
                    var rightMargin = textRunData.readInt();

                    //var tabStops = textRunData.readInt();
                    var underline = textRunData.readBoolean();

                    var text = '';
                    var eof = false;
                    for (var i = beginIndex; !eof; i++) {
                        var eof = i >= endIndex - 1;

                        var char = plainText[i];
                        if (char !== '\r' && char !== '\n') {
                            text += char;
                            if (i < plainText.length - 1) {
                                continue;
                            }
                        }
                        currentLine.addRun(font, fillStyle, text, underline);
                        finishLine();
                        text = '';

                        if (eof) {
                            maxAscent = 0;
                            maxDescent = 0;
                            maxLeading = 0;
                            firstAlign = -1;
                            break;
                        }

                        if (char === '\r' && plainText[i + 1] === '\n') {
                            i++;
                        }
                    }
                    currentLine.addRun(font, fillStyle, text, underline);
                }

                var rect = this.textRect;
                rect.w = maxWidth;
                rect.h = baseLinePos;

                if (autoSize) {
                    if (!wordWrap) {
                        availableWidth = maxWidth;
                        var width = bounds.w;
                        switch (autoSize) {
                            case 1:
                                rect.x = (width - (availableWidth + 4)) >> 1;
                                break;
                            case 2:
                                break;
                            case 3:
                                rect.x = width - (availableWidth + 4);
                                break;
                        }
                        this._textBounds.setElements(rect.x - 2, rect.y - 2, rect.w + 4, rect.h + 4);
                    }
                    bounds.h = baseLinePos + 4;
                } else {
                    this._textBounds = bounds;
                }

                var numLines = lines.length;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line.width < availableWidth) {
                        switch (line.align) {
                            case 0:
                                break;
                            case 1:
                                line.x = (availableWidth - line.width) | 0;
                                break;
                            case 2:
                                line.x = ((availableWidth - line.width) / 2) | 0;
                                break;
                        }
                    }
                }

                this.invalidatePaint();
                GFX.leaveTimeline("RenderableText.reflow");
            };

            RenderableText.prototype.getBounds = function () {
                return this._bounds;
            };

            RenderableText.prototype.render = function (context) {
                GFX.enterTimeline("RenderableText.render");
                context.save();

                var rect = this._textBounds;
                if (this._backgroundColor) {
                    context.fillStyle = Shumway.ColorUtilities.rgbaToCSSStyle(this._backgroundColor);
                    context.fillRect(rect.x, rect.y, rect.w, rect.h);
                }
                if (this._borderColor) {
                    context.strokeStyle = Shumway.ColorUtilities.rgbaToCSSStyle(this._borderColor);
                    context.lineCap = 'square';
                    context.lineWidth = 1;
                    context.strokeRect(rect.x, rect.y, rect.w, rect.h);
                }

                if (this._coords) {
                    this._renderChars(context);
                } else {
                    this._renderLines(context);
                }

                context.restore();
                GFX.leaveTimeline("RenderableText.render");
            };

            RenderableText.prototype._renderChars = function (context) {
                if (this._matrix) {
                    var m = this._matrix;
                    context.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                }
                var lines = this.lines;
                var coords = this._coords;
                coords.position = 0;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var runs = line.runs;
                    for (var j = 0; j < runs.length; j++) {
                        var run = runs[j];
                        context.font = run.font;
                        context.fillStyle = run.fillStyle;
                        var text = run.text;
                        for (var k = 0; k < text.length; k++) {
                            var x = coords.readInt() / 20;
                            var y = coords.readInt() / 20;
                            context.fillText(text[k], x, y);
                        }
                    }
                }
            };

            RenderableText.prototype._renderLines = function (context) {
                // TODO: Render bullet points.
                var bounds = this._textBounds;
                context.beginPath();
                context.rect(bounds.x, bounds.y, bounds.w, bounds.h);
                context.clip();
                context.translate(bounds.x + 2, bounds.y + 2);
                var lines = this.lines;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var x = line.x;
                    var y = line.y;
                    var runs = line.runs;
                    for (var j = 0; j < runs.length; j++) {
                        var run = runs[j];
                        context.font = run.font;
                        context.fillStyle = run.fillStyle;
                        if (run.underline) {
                            context.fillRect(x, (y + (line.descent / 2)) | 0, run.width, 1);
                        }
                        context.fillText(run.text, x, y);
                        x += run.width;
                    }
                }
            };
            return RenderableText;
        })(Renderable);
        GFX.RenderableText = RenderableText;

        var Label = (function (_super) {
            __extends(Label, _super);
            function Label(w, h) {
                _super.call(this, new Rectangle(0, 0, w, h));
                this._flags = 1 /* Dynamic */ | 4 /* Scalable */;
                this.properties = {};
            }
            Object.defineProperty(Label.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (value) {
                    this._text = value;
                },
                enumerable: true,
                configurable: true
            });


            Label.prototype.render = function (context, cullBounds) {
                context.save();
                context.textBaseline = "top";
                context.fillStyle = "white";
                context.fillText(this.text, 0, 0);
                context.restore();
            };
            return Label;
        })(Renderable);
        GFX.Label = Label;

        var Grid = (function (_super) {
            __extends(Grid, _super);
            function Grid() {
                _super.call(this, Rectangle.createMaxI16());
                this._flags = 2 /* Dirty */ | 4 /* Scalable */ | 8 /* Tileable */;
                this.properties = {};
            }
            Grid.prototype.render = function (context, cullBounds) {
                context.save();

                var gridBounds = cullBounds || this.getBounds();

                context.fillStyle = Shumway.ColorStyle.VeryDark;
                context.fillRect(gridBounds.x, gridBounds.y, gridBounds.w, gridBounds.h);

                function gridPath(level) {
                    var vStart = Math.floor(gridBounds.x / level) * level;
                    var vEnd = Math.ceil((gridBounds.x + gridBounds.w) / level) * level;

                    for (var x = vStart; x < vEnd; x += level) {
                        context.moveTo(x + 0.5, gridBounds.y);
                        context.lineTo(x + 0.5, gridBounds.y + gridBounds.h);
                    }

                    var hStart = Math.floor(gridBounds.y / level) * level;
                    var hEnd = Math.ceil((gridBounds.y + gridBounds.h) / level) * level;

                    for (var y = hStart; y < hEnd; y += level) {
                        context.moveTo(gridBounds.x, y + 0.5);
                        context.lineTo(gridBounds.x + gridBounds.w, y + 0.5);
                    }
                }

                context.beginPath();
                gridPath(100);
                context.lineWidth = 1;
                context.strokeStyle = Shumway.ColorStyle.Dark;
                context.stroke();

                context.beginPath();
                gridPath(500);
                context.lineWidth = 1;
                context.strokeStyle = Shumway.ColorStyle.TabToolbar;
                context.stroke();

                context.beginPath();
                gridPath(1000);
                context.lineWidth = 3;
                context.strokeStyle = Shumway.ColorStyle.Toolbars;
                context.stroke();

                var MAX = 1024 * 1024;
                context.lineWidth = 3;
                context.beginPath();
                context.moveTo(-MAX, 0.5);
                context.lineTo(MAX, 0.5);
                context.moveTo(0.5, -MAX);
                context.lineTo(0.5, MAX);
                context.strokeStyle = Shumway.ColorStyle.Orange;
                context.stroke();

                context.restore();
            };
            return Grid;
        })(Renderable);
        GFX.Grid = Grid;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var clampByte = Shumway.ColorUtilities.clampByte;

        var assert = Shumway.Debug.assert;

        var Filter = (function () {
            function Filter() {
            }
            return Filter;
        })();
        GFX.Filter = Filter;

        var BlurFilter = (function (_super) {
            __extends(BlurFilter, _super);
            function BlurFilter(blurX, blurY, quality) {
                _super.call(this);
                this.blurX = blurX;
                this.blurY = blurY;
                this.quality = quality;
            }
            return BlurFilter;
        })(Filter);
        GFX.BlurFilter = BlurFilter;

        var DropshadowFilter = (function (_super) {
            __extends(DropshadowFilter, _super);
            function DropshadowFilter(alpha, angle, blurX, blurY, color, distance, hideObject, inner, knockout, quality, strength) {
                _super.call(this);
                this.alpha = alpha;
                this.angle = angle;
                this.blurX = blurX;
                this.blurY = blurY;
                this.color = color;
                this.distance = distance;
                this.hideObject = hideObject;
                this.inner = inner;
                this.knockout = knockout;
                this.quality = quality;
                this.strength = strength;
            }
            return DropshadowFilter;
        })(Filter);
        GFX.DropshadowFilter = DropshadowFilter;

        var GlowFilter = (function (_super) {
            __extends(GlowFilter, _super);
            function GlowFilter(alpha, blurX, blurY, color, inner, knockout, quality, strength) {
                _super.call(this);
                this.alpha = alpha;
                this.blurX = blurX;
                this.blurY = blurY;
                this.color = color;
                this.inner = inner;
                this.knockout = knockout;
                this.quality = quality;
                this.strength = strength;
            }
            return GlowFilter;
        })(Filter);
        GFX.GlowFilter = GlowFilter;

        var ColorMatrix = (function () {
            function ColorMatrix(m) {
                release || assert(m.length === 20);
                this._m = new Float32Array(m);
            }
            ColorMatrix.prototype.clone = function () {
                return new ColorMatrix(this._m);
            };

            ColorMatrix.prototype.copyFrom = function (other) {
                this._m.set(other._m);
            };

            ColorMatrix.prototype.toWebGLMatrix = function () {
                return new Float32Array(this._m);
            };

            ColorMatrix.prototype.asWebGLMatrix = function () {
                return this._m.subarray(0, 16);
            };

            ColorMatrix.prototype.asWebGLVector = function () {
                return this._m.subarray(16, 20);
            };

            ColorMatrix.prototype.getColorMatrix = function () {
                var t = new Float32Array(20);
                var m = this._m;
                t[0] = m[0];
                t[1] = m[4];
                t[2] = m[8];
                t[3] = m[12];
                t[4] = m[16] * 255;
                t[5] = m[1];
                t[6] = m[5];
                t[7] = m[9];
                t[8] = m[13];
                t[9] = m[17] * 255;
                t[10] = m[2];
                t[11] = m[6];
                t[12] = m[10];
                t[13] = m[14];
                t[14] = m[18] * 255;
                t[15] = m[3];
                t[16] = m[7];
                t[17] = m[11];
                t[18] = m[15];
                t[19] = m[19] * 255;
                return t;
            };

            ColorMatrix.prototype.getColorTransform = function () {
                var t = new Float32Array(8);
                var m = this._m;
                t[0] = m[0];
                t[1] = m[5];
                t[2] = m[10];
                t[3] = m[15];
                t[4] = m[16] * 255;
                t[5] = m[17] * 255;
                t[6] = m[18] * 255;
                t[7] = m[19] * 255;
                return t;
            };

            ColorMatrix.prototype.isIdentity = function () {
                var m = this._m;
                return m[0] == 1 && m[1] == 0 && m[2] == 0 && m[3] == 0 && m[4] == 0 && m[5] == 1 && m[6] == 0 && m[7] == 0 && m[8] == 0 && m[9] == 0 && m[10] == 1 && m[11] == 0 && m[12] == 0 && m[13] == 0 && m[14] == 0 && m[15] == 1 && m[16] == 0 && m[17] == 0 && m[18] == 0 && m[19] == 0;
            };

            ColorMatrix.createIdentity = function () {
                return new ColorMatrix([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                    0, 0, 0, 0
                ]);
            };

            ColorMatrix.fromMultipliersAndOffsets = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                return new ColorMatrix([
                    redMultiplier, 0, 0, 0,
                    0, greenMultiplier, 0, 0,
                    0, 0, blueMultiplier, 0,
                    0, 0, 0, alphaMultiplier,
                    redOffset, greenOffset, blueOffset, alphaOffset
                ]);
            };

            ColorMatrix.prototype.transformRGBA = function (rgba) {
                var r = (rgba >> 24) & 0xff;
                var g = (rgba >> 16) & 0xff;
                var b = (rgba >> 8) & 0xff;
                var a = rgba & 0xff;

                var m = this._m;
                var R = clampByte(r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[16]);
                var G = clampByte(r * m[4] + g * m[5] + b * m[6] + a * m[7] + m[17]);
                var B = clampByte(r * m[8] + g * m[9] + b * m[10] + a * m[11] + m[18]);
                var A = clampByte(r * m[12] + g * m[13] + b * m[14] + a * m[15] + m[19]);

                return R << 24 | G << 16 | B << 8 | A;
            };

            ColorMatrix.prototype.multiply = function (other) {
                var a = this._m, b = other._m;
                var a00 = a[0 * 4 + 0];
                var a01 = a[0 * 4 + 1];
                var a02 = a[0 * 4 + 2];
                var a03 = a[0 * 4 + 3];
                var a10 = a[1 * 4 + 0];
                var a11 = a[1 * 4 + 1];
                var a12 = a[1 * 4 + 2];
                var a13 = a[1 * 4 + 3];
                var a20 = a[2 * 4 + 0];
                var a21 = a[2 * 4 + 1];
                var a22 = a[2 * 4 + 2];
                var a23 = a[2 * 4 + 3];
                var a30 = a[3 * 4 + 0];
                var a31 = a[3 * 4 + 1];
                var a32 = a[3 * 4 + 2];
                var a33 = a[3 * 4 + 3];
                var a40 = a[4 * 4 + 0];
                var a41 = a[4 * 4 + 1];
                var a42 = a[4 * 4 + 2];
                var a43 = a[4 * 4 + 3];

                var b00 = b[0 * 4 + 0];
                var b01 = b[0 * 4 + 1];
                var b02 = b[0 * 4 + 2];
                var b03 = b[0 * 4 + 3];
                var b10 = b[1 * 4 + 0];
                var b11 = b[1 * 4 + 1];
                var b12 = b[1 * 4 + 2];
                var b13 = b[1 * 4 + 3];
                var b20 = b[2 * 4 + 0];
                var b21 = b[2 * 4 + 1];
                var b22 = b[2 * 4 + 2];
                var b23 = b[2 * 4 + 3];
                var b30 = b[3 * 4 + 0];
                var b31 = b[3 * 4 + 1];
                var b32 = b[3 * 4 + 2];
                var b33 = b[3 * 4 + 3];
                var b40 = b[4 * 4 + 0];
                var b41 = b[4 * 4 + 1];
                var b42 = b[4 * 4 + 2];
                var b43 = b[4 * 4 + 3];

                a[0 * 4 + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
                a[0 * 4 + 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
                a[0 * 4 + 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
                a[0 * 4 + 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
                a[1 * 4 + 0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
                a[1 * 4 + 1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
                a[1 * 4 + 2] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
                a[1 * 4 + 3] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
                a[2 * 4 + 0] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
                a[2 * 4 + 1] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
                a[2 * 4 + 2] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
                a[2 * 4 + 3] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
                a[3 * 4 + 0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
                a[3 * 4 + 1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
                a[3 * 4 + 2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
                a[3 * 4 + 3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;

                a[4 * 4 + 0] = a00 * b40 + a10 * b41 + a20 * b42 + a30 * b43 + a40;
                a[4 * 4 + 1] = a01 * b40 + a11 * b41 + a21 * b42 + a31 * b43 + a41;
                a[4 * 4 + 2] = a02 * b40 + a12 * b41 + a22 * b42 + a32 * b43 + a42;
                a[4 * 4 + 3] = a03 * b40 + a13 * b41 + a23 * b42 + a33 * b43 + a43;
            };

            Object.defineProperty(ColorMatrix.prototype, "alphaMultiplier", {
                get: function () {
                    return this._m[15];
                },
                enumerable: true,
                configurable: true
            });

            ColorMatrix.prototype.hasOnlyAlphaMultiplier = function () {
                var m = this._m;
                return m[0] == 1 && m[1] == 0 && m[2] == 0 && m[3] == 0 && m[4] == 0 && m[5] == 1 && m[6] == 0 && m[7] == 0 && m[8] == 0 && m[9] == 0 && m[10] == 1 && m[11] == 0 && m[12] == 0 && m[13] == 0 && m[14] == 0 && m[16] == 0 && m[17] == 0 && m[18] == 0 && m[19] == 0;
            };

            ColorMatrix.prototype.equals = function (other) {
                if (!other) {
                    return false;
                }
                var a = this._m;
                var b = other._m;
                for (var i = 0; i < 20; i++) {
                    if (Math.abs(a[i] - b[i]) > 0.001) {
                        return false;
                    }
                }
                return true;
            };
            return ColorMatrix;
        })();
        GFX.ColorMatrix = ColorMatrix;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
/// <reference path='module.ts' />
/// <reference path='utilities.ts' />
/// <reference path='options.ts'/>
/// <reference path='geometry.ts'/>
/// <reference path='regionAllocator.ts'/>
/// <reference path='frame.ts'/>
/// <reference path='frameContainer.ts'/>
/// <reference path='stage.ts'/>
/// <reference path='renderables/renderables.ts'/>
/// <reference path='filters.ts'/>
//# sourceMappingURL=gfx-base.js.map

var Shumway;
(function (Shumway) {
    (function (GFX) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (WebGL) {
            var Point3D = GFX.Geometry.Point3D;

            var Matrix3D = GFX.Geometry.Matrix3D;

            var degreesToRadian = GFX.Geometry.degreesToRadian;

            var assert = Shumway.Debug.assert;
            var unexpected = Shumway.Debug.unexpected;
            var notImplemented = Shumway.Debug.notImplemented;

            WebGL.SHADER_ROOT = "shaders/";

            function endsWith(str, end) {
                return str.indexOf(end, this.length - end.length) !== -1;
            }

            var WebGLContext = (function () {
                function WebGLContext(canvas, options) {
                    this._fillColor = Shumway.Color.Red;
                    this._surfaceRegionCache = new Shumway.LRUList();
                    this.modelViewProjectionMatrix = Matrix3D.createIdentity();
                    this._canvas = canvas;
                    this._options = options;
                    this.gl = (canvas.getContext("experimental-webgl", {
                        // preserveDrawingBuffer: true,
                        preserveDrawingBuffer: false,
                        antialias: true,
                        stencil: true,
                        premultipliedAlpha: false
                    }));
                    release || assert(this.gl, "Cannot create WebGL context.");
                    this._programCache = Object.create(null);
                    this._resize();
                    this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.unpackPremultiplyAlpha ? this.gl.ONE : this.gl.ZERO);
                    this._backgroundColor = Shumway.Color.Black;

                    this._geometry = new WebGL.WebGLGeometry(this);
                    this._tmpVertices = WebGL.Vertex.createEmptyVertices(WebGL.Vertex, 64);

                    this._maxSurfaces = options.maxSurfaces;
                    this._maxSurfaceSize = options.maxSurfaceSize;

                    // this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                    this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
                    this.gl.enable(this.gl.BLEND);

                    // this.gl.enable(this.gl.DEPTH_TEST);
                    this.modelViewProjectionMatrix = Matrix3D.create2DProjection(this._w, this._h, 2000);

                    var self = this;
                    this._surfaceRegionAllocator = new GFX.SurfaceRegionAllocator.SimpleAllocator(function () {
                        var texture = self._createTexture(1024, 1024);
                        return new WebGL.WebGLSurface(1024, 1024, texture);
                    });
                }
                Object.defineProperty(WebGLContext.prototype, "surfaces", {
                    get: function () {
                        return (this._surfaceRegionAllocator.surfaces);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(WebGLContext.prototype, "fillStyle", {
                    set: function (value) {
                        this._fillColor.set(Shumway.Color.parseColor(value));
                    },
                    enumerable: true,
                    configurable: true
                });

                WebGLContext.prototype.setBlendMode = function (value) {
                    var gl = this.gl;
                    switch (value) {
                        case 8 /* Add */:
                            gl.blendFunc(gl.SRC_ALPHA, gl.DST_ALPHA);
                            break;
                        case 3 /* Multiply */:
                            gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 4 /* Screen */:
                            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                            break;
                        case 2 /* Layer */:
                        case 1 /* Normal */:
                            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            break;
                        default:
                            notImplemented("Blend Mode: " + value);
                    }
                };

                WebGLContext.prototype.setBlendOptions = function () {
                    this.gl.blendFunc(this._options.sourceBlendFactor, this._options.destinationBlendFactor);
                };

                /**
                * Whether the blend mode can be performed using |blendFunc|.
                */
                WebGLContext.glSupportedBlendMode = function (value) {
                    switch (value) {
                        case 8 /* Add */:
                        case 3 /* Multiply */:
                        case 4 /* Screen */:
                        case 1 /* Normal */:
                            return true;
                        default:
                            return false;
                    }
                };

                WebGLContext.prototype.create2DProjectionMatrix = function () {
                    return Matrix3D.create2DProjection(this._w, this._h, -this._w);
                };

                WebGLContext.prototype.createPerspectiveMatrix = function (cameraDistance, fov, angle) {
                    var cameraAngleRadians = degreesToRadian(angle);

                    // Compute the projection matrix
                    var projectionMatrix = Matrix3D.createPerspective(degreesToRadian(fov), 1, 0.1, 5000);

                    var up = new Point3D(0, 1, 0);
                    var target = new Point3D(0, 0, 0);
                    var camera = new Point3D(0, 0, cameraDistance);
                    var cameraMatrix = Matrix3D.createCameraLookAt(camera, target, up);
                    var viewMatrix = Matrix3D.createInverse(cameraMatrix);

                    var matrix = Matrix3D.createIdentity();
                    matrix = Matrix3D.createMultiply(matrix, Matrix3D.createTranslation(-this._w / 2, -this._h / 2, 0));
                    matrix = Matrix3D.createMultiply(matrix, Matrix3D.createScale(1 / this._w, -1 / this._h, 1 / 100));
                    matrix = Matrix3D.createMultiply(matrix, Matrix3D.createYRotation(cameraAngleRadians));
                    matrix = Matrix3D.createMultiply(matrix, viewMatrix);
                    matrix = Matrix3D.createMultiply(matrix, projectionMatrix);
                    return matrix;
                };

                WebGLContext.prototype.discardCachedImages = function () {
                    GFX.traceLevel >= 2 /* Verbose */ && GFX.writer && GFX.writer.writeLn("Discard Cache");
                    var count = this._surfaceRegionCache.count / 2 | 0;
                    for (var i = 0; i < count; i++) {
                        var surfaceRegion = this._surfaceRegionCache.pop();
                        GFX.traceLevel >= 2 /* Verbose */ && GFX.writer && GFX.writer.writeLn("Discard: " + surfaceRegion);
                        surfaceRegion.texture.atlas.remove(surfaceRegion.region);
                        surfaceRegion.texture = null;
                    }
                };

                WebGLContext.prototype.cacheImage = function (image) {
                    var w = image.width;
                    var h = image.height;
                    var surfaceRegion = this.allocateSurfaceRegion(w, h);
                    GFX.traceLevel >= 2 /* Verbose */ && GFX.writer && GFX.writer.writeLn("Uploading Image: @ " + surfaceRegion.region);
                    this._surfaceRegionCache.use(surfaceRegion);
                    this.updateSurfaceRegion(image, surfaceRegion);
                    return surfaceRegion;
                };

                WebGLContext.prototype.allocateSurfaceRegion = function (w, h, discardCache) {
                    if (typeof discardCache === "undefined") { discardCache = true; }
                    return this._surfaceRegionAllocator.allocate(w, h);
                };

                /*
                public allocateTextureRegion(w: number, h: number, discardCache: boolean = true): WebGLSurfaceRegion {
                var imageIsTileSized = (w === h) && (w === TILE_SIZE);
                var texture, region;
                for (var i = 0; i < this._surfaces.length; i++) {
                texture = this._surfaces[i];
                if (imageIsTileSized && texture.atlas.compact) {
                continue;
                }
                region = texture.atlas.add(null, w, h);
                if (region) {
                break;
                }
                }
                if (!region) {
                if (w >= this._maxTextureSize || h >= this._maxTextureSize) {
                // Region cannot possibly fit in the standard texture atlas.
                texture = this.createTexture(w, h, !imageIsTileSized);
                } else if (this._surfaces.length === this._maxTextures) {
                if (discardCache) {
                this.discardCachedImages();
                return this.allocateTextureRegion(w, h, false);
                }
                return null;
                } else {
                texture = this.createTexture(this._maxTextureSize, this._maxTextureSize, !imageIsTileSized);
                }
                this._surfaces.push(texture);
                region = texture.atlas.add(null, w, h);
                release || assert (region);
                }
                return new WebGLSurfaceRegion(texture, region);
                }
                */
                WebGLContext.prototype.updateSurfaceRegion = function (image, surfaceRegion) {
                    var gl = this.gl;
                    gl.bindTexture(gl.TEXTURE_2D, surfaceRegion.surface.texture);
                    GFX.enterTimeline("texSubImage2D");
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, surfaceRegion.region.x, surfaceRegion.region.y, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    GFX.leaveTimeline("texSubImage2D");
                };

                WebGLContext.prototype._resize = function () {
                    var gl = this.gl;
                    this._w = this._canvas.width;
                    this._h = this._canvas.height;
                    gl.viewport(0, 0, this._w, this._h);
                    for (var k in this._programCache) {
                        this._initializeProgram(this._programCache[k]);
                    }
                };

                WebGLContext.prototype._initializeProgram = function (program) {
                    var gl = this.gl;
                    gl.useProgram(program);
                    // gl.uniform2f(program.uniforms.uResolution.location, this._w, this._h);
                };

                WebGLContext.prototype._createShaderFromFile = function (file) {
                    var path = WebGL.SHADER_ROOT + file;
                    var gl = this.gl;
                    var request = new XMLHttpRequest();
                    request.open("GET", path, false);
                    request.send();
                    release || assert(request.status === 200 || request.status === 0, "File : " + path + " not found.");
                    var shaderType;
                    if (endsWith(path, ".vert")) {
                        shaderType = gl.VERTEX_SHADER;
                    } else if (endsWith(path, ".frag")) {
                        shaderType = gl.FRAGMENT_SHADER;
                    } else {
                        throw "Shader Type: not supported.";
                    }
                    return this._createShader(shaderType, request.responseText);
                };

                WebGLContext.prototype.createProgramFromFiles = function (vertex, fragment) {
                    var key = vertex + "-" + fragment;
                    var program = this._programCache[key];
                    if (!program) {
                        program = this._createProgram([
                            this._createShaderFromFile(vertex),
                            this._createShaderFromFile(fragment)
                        ]);
                        this._queryProgramAttributesAndUniforms(program);
                        this._initializeProgram(program);
                        this._programCache[key] = program;
                    }
                    return program;
                };

                WebGLContext.prototype._createProgram = function (shaders) {
                    var gl = this.gl;
                    var program = gl.createProgram();
                    shaders.forEach(function (shader) {
                        gl.attachShader(program, shader);
                    });
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        var lastError = gl.getProgramInfoLog(program);
                        unexpected("Cannot link program: " + lastError);
                        gl.deleteProgram(program);
                    }
                    return program;
                };

                WebGLContext.prototype._createShader = function (shaderType, shaderSource) {
                    var gl = this.gl;
                    var shader = gl.createShader(shaderType);
                    gl.shaderSource(shader, shaderSource);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        var lastError = gl.getShaderInfoLog(shader);
                        unexpected("Cannot compile shader: " + lastError);
                        gl.deleteShader(shader);
                        return null;
                    }
                    return shader;
                };

                WebGLContext.prototype._createTexture = function (w, h) {
                    var gl = this.gl;
                    var texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    return texture;
                };

                WebGLContext.prototype._createFramebuffer = function (texture) {
                    var gl = this.gl;
                    var framebuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    return framebuffer;
                };

                WebGLContext.prototype._queryProgramAttributesAndUniforms = function (program) {
                    program.uniforms = {};
                    program.attributes = {};

                    var gl = this.gl;
                    for (var i = 0, j = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES); i < j; i++) {
                        var attribute = gl.getActiveAttrib(program, i);
                        program.attributes[attribute.name] = attribute;
                        attribute.location = gl.getAttribLocation(program, attribute.name);
                    }
                    for (var i = 0, j = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i < j; i++) {
                        var uniform = gl.getActiveUniform(program, i);
                        program.uniforms[uniform.name] = uniform;
                        uniform.location = gl.getUniformLocation(program, uniform.name);
                    }
                };

                Object.defineProperty(WebGLContext.prototype, "target", {
                    set: function (surface) {
                        var gl = this.gl;
                        if (surface) {
                            gl.viewport(0, 0, surface.w, surface.h);
                            gl.bindFramebuffer(gl.FRAMEBUFFER, surface.framebuffer);
                        } else {
                            gl.viewport(0, 0, this._w, this._h);
                            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });

                WebGLContext.prototype.clear = function (color) {
                    if (typeof color === "undefined") { color = Shumway.Color.None; }
                    var gl = this.gl;
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                };

                WebGLContext.prototype.clearTextureRegion = function (surfaceRegion, color) {
                    if (typeof color === "undefined") { color = Shumway.Color.None; }
                    var gl = this.gl;
                    var region = surfaceRegion.region;
                    this.target = surfaceRegion.surface;
                    gl.enable(gl.SCISSOR_TEST);
                    gl.scissor(region.x, region.y, region.w, region.h);
                    gl.clearColor(color.r, color.g, color.b, color.a);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.disable(gl.SCISSOR_TEST);
                };

                WebGLContext.prototype.sizeOf = function (type) {
                    var gl = this.gl;
                    switch (type) {
                        case gl.UNSIGNED_BYTE:
                            return 1;
                        case gl.UNSIGNED_SHORT:
                            return 2;
                        case this.gl.INT:
                        case this.gl.FLOAT:
                            return 4;
                        default:
                            notImplemented(type);
                    }
                };
                WebGLContext.MAX_SURFACES = 8;
                return WebGLContext;
            })();
            WebGL.WebGLContext = WebGLContext;
        })(GFX.WebGL || (GFX.WebGL = {}));
        var WebGL = GFX.WebGL;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (WebGL) {
            var release = false;

            var assert = Shumway.Debug.assert;

            /**
            * Utility class to help when writing to GL buffers.
            */
            var BufferWriter = (function (_super) {
                __extends(BufferWriter, _super);
                function BufferWriter() {
                    _super.apply(this, arguments);
                }
                BufferWriter.prototype.ensureVertexCapacity = function (count) {
                    release || assert((this._offset & 0x3) === 0);
                    this.ensureCapacity(this._offset + count * 8);
                };

                BufferWriter.prototype.writeVertex = function (x, y) {
                    release || assert((this._offset & 0x3) === 0);
                    this.ensureCapacity(this._offset + 8);
                    this.writeVertexUnsafe(x, y);
                };

                BufferWriter.prototype.writeVertexUnsafe = function (x, y) {
                    var index = this._offset >> 2;
                    this._f32[index] = x;
                    this._f32[index + 1] = y;
                    this._offset += 8;
                };

                BufferWriter.prototype.writeVertex3D = function (x, y, z) {
                    release || assert((this._offset & 0x3) === 0);
                    this.ensureCapacity(this._offset + 12);
                    this.writeVertex3DUnsafe(x, y, z);
                };

                BufferWriter.prototype.writeVertex3DUnsafe = function (x, y, z) {
                    var index = this._offset >> 2;
                    this._f32[index] = x;
                    this._f32[index + 1] = y;
                    this._f32[index + 2] = z;
                    this._offset += 12;
                };

                BufferWriter.prototype.writeTriangleElements = function (a, b, c) {
                    release || assert((this._offset & 0x1) === 0);
                    this.ensureCapacity(this._offset + 6);
                    var index = this._offset >> 1;
                    this._u16[index] = a;
                    this._u16[index + 1] = b;
                    this._u16[index + 2] = c;
                    this._offset += 6;
                };

                BufferWriter.prototype.ensureColorCapacity = function (count) {
                    release || assert((this._offset & 0x2) === 0);
                    this.ensureCapacity(this._offset + count * 16);
                };

                BufferWriter.prototype.writeColorFloats = function (r, g, b, a) {
                    release || assert((this._offset & 0x2) === 0);
                    this.ensureCapacity(this._offset + 16);
                    this.writeColorFloatsUnsafe(r, g, b, a);
                };

                BufferWriter.prototype.writeColorFloatsUnsafe = function (r, g, b, a) {
                    var index = this._offset >> 2;
                    this._f32[index] = r;
                    this._f32[index + 1] = g;
                    this._f32[index + 2] = b;
                    this._f32[index + 3] = a;
                    this._offset += 16;
                };

                BufferWriter.prototype.writeColor = function (r, g, b, a) {
                    release || assert((this._offset & 0x3) === 0);
                    this.ensureCapacity(this._offset + 4);
                    var index = this._offset >> 2;
                    this._i32[index] = a << 24 | b << 16 | g << 8 | r;
                    this._offset += 4;
                };

                BufferWriter.prototype.writeColorUnsafe = function (r, g, b, a) {
                    var index = this._offset >> 2;
                    this._i32[index] = a << 24 | b << 16 | g << 8 | r;
                    this._offset += 4;
                };

                BufferWriter.prototype.writeRandomColor = function () {
                    this.writeColor(Math.random(), Math.random(), Math.random(), Math.random() / 2);
                };
                return BufferWriter;
            })(Shumway.ArrayUtilities.ArrayWriter);
            WebGL.BufferWriter = BufferWriter;

            var WebGLAttribute = (function () {
                function WebGLAttribute(name, size, type, normalized) {
                    if (typeof normalized === "undefined") { normalized = false; }
                    this.name = name;
                    this.size = size;
                    this.type = type;
                    this.normalized = normalized;
                }
                return WebGLAttribute;
            })();
            WebGL.WebGLAttribute = WebGLAttribute;

            var WebGLAttributeList = (function () {
                function WebGLAttributeList(attributes) {
                    this.size = 0;
                    this.attributes = attributes;
                }
                WebGLAttributeList.prototype.initialize = function (context) {
                    var offset = 0;
                    for (var i = 0; i < this.attributes.length; i++) {
                        this.attributes[i].offset = offset;
                        offset += context.sizeOf(this.attributes[i].type) * this.attributes[i].size;
                    }
                    this.size = offset;
                };
                return WebGLAttributeList;
            })();
            WebGL.WebGLAttributeList = WebGLAttributeList;

            var WebGLGeometry = (function () {
                function WebGLGeometry(context) {
                    this.triangleCount = 0;
                    this._elementOffset = 0;
                    this.context = context;
                    this.array = new BufferWriter(8);
                    this.buffer = context.gl.createBuffer();

                    this.elementArray = new BufferWriter(8);
                    this.elementBuffer = context.gl.createBuffer();
                }
                Object.defineProperty(WebGLGeometry.prototype, "elementOffset", {
                    get: function () {
                        return this._elementOffset;
                    },
                    enumerable: true,
                    configurable: true
                });

                WebGLGeometry.prototype.addQuad = function () {
                    var offset = this._elementOffset;
                    this.elementArray.writeTriangleElements(offset, offset + 1, offset + 2);
                    this.elementArray.writeTriangleElements(offset, offset + 2, offset + 3);
                    this.triangleCount += 2;
                    this._elementOffset += 4;
                };

                WebGLGeometry.prototype.resetElementOffset = function () {
                    this._elementOffset = 0;
                };

                WebGLGeometry.prototype.reset = function () {
                    this.array.reset();
                    this.elementArray.reset();
                    this.resetElementOffset();
                    this.triangleCount = 0;
                };

                WebGLGeometry.prototype.uploadBuffers = function () {
                    var gl = this.context.gl;
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, this.array.subU8View(), gl.DYNAMIC_DRAW);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.elementArray.subU8View(), gl.DYNAMIC_DRAW);
                };
                return WebGLGeometry;
            })();
            WebGL.WebGLGeometry = WebGLGeometry;

            var Vertex = (function (_super) {
                __extends(Vertex, _super);
                function Vertex(x, y, z) {
                    _super.call(this, x, y, z);
                }
                Vertex.createEmptyVertices = function (type, count) {
                    var result = [];
                    for (var i = 0; i < count; i++) {
                        result.push(new type(0, 0, 0));
                    }
                    return result;
                };
                return Vertex;
            })(GFX.Geometry.Point3D);
            WebGL.Vertex = Vertex;

            (function (WebGLBlendFactor) {
                WebGLBlendFactor[WebGLBlendFactor["ZERO"] = 0] = "ZERO";
                WebGLBlendFactor[WebGLBlendFactor["ONE"] = 1] = "ONE";
                WebGLBlendFactor[WebGLBlendFactor["SRC_COLOR"] = 768] = "SRC_COLOR";
                WebGLBlendFactor[WebGLBlendFactor["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
                WebGLBlendFactor[WebGLBlendFactor["DST_COLOR"] = 774] = "DST_COLOR";
                WebGLBlendFactor[WebGLBlendFactor["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
                WebGLBlendFactor[WebGLBlendFactor["SRC_ALPHA"] = 770] = "SRC_ALPHA";
                WebGLBlendFactor[WebGLBlendFactor["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
                WebGLBlendFactor[WebGLBlendFactor["DST_ALPHA"] = 772] = "DST_ALPHA";
                WebGLBlendFactor[WebGLBlendFactor["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
                WebGLBlendFactor[WebGLBlendFactor["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
                WebGLBlendFactor[WebGLBlendFactor["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
                WebGLBlendFactor[WebGLBlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
                WebGLBlendFactor[WebGLBlendFactor["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
                WebGLBlendFactor[WebGLBlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
            })(WebGL.WebGLBlendFactor || (WebGL.WebGLBlendFactor = {}));
            var WebGLBlendFactor = WebGL.WebGLBlendFactor;
        })(GFX.WebGL || (GFX.WebGL = {}));
        var WebGL = GFX.WebGL;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (WebGL) {
            var release = false;

            var WebGLSurface = (function () {
                function WebGLSurface(w, h, texture) {
                    this.texture = texture;
                    this.w = w;
                    this.h = h;
                    this._regionAllocator = new GFX.RegionAllocator.CompactAllocator(this.w, this.h);
                }
                WebGLSurface.prototype.allocate = function (w, h) {
                    var region = this._regionAllocator.allocate(w, h);
                    if (region) {
                        return new WebGLSurfaceRegion(this, region);
                    }
                    return null;
                };
                WebGLSurface.prototype.free = function (surfaceRegion) {
                    this._regionAllocator.free(surfaceRegion.region);
                };
                return WebGLSurface;
            })();
            WebGL.WebGLSurface = WebGLSurface;

            /**
            * A (region, texture) pair. These objects can appear in linked lists hence the next and previous pointers. Regions
            * don't necessarily need to have a texture reference. Setting the texture reference to null is a way to indicate
            * that the region no longer points to valid texture data.
            */
            var WebGLSurfaceRegion = (function () {
                function WebGLSurfaceRegion(surface, region) {
                    this.surface = surface;
                    this.region = region;
                    this.next = this.previous = null;
                }
                return WebGLSurfaceRegion;
            })();
            WebGL.WebGLSurfaceRegion = WebGLSurfaceRegion;
        })(GFX.WebGL || (GFX.WebGL = {}));
        var WebGL = GFX.WebGL;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (WebGL) {
            var Color = Shumway.Color;
            var SCRATCH_CANVAS_SIZE = 1024 * 2;

            WebGL.TILE_SIZE = 256;
            WebGL.MIN_UNTILED_SIZE = 256;

            function getTileSize(bounds) {
                if (bounds.w < WebGL.TILE_SIZE || bounds.h < WebGL.TILE_SIZE) {
                    return Math.min(bounds.w, bounds.h);
                }
                return WebGL.TILE_SIZE;
            }

            var Matrix = GFX.Geometry.Matrix;

            var Rectangle = GFX.Geometry.Rectangle;
            var RenderableTileCache = GFX.Geometry.RenderableTileCache;

            var Shape = Shumway.GFX.Shape;

            var ColorMatrix = Shumway.GFX.ColorMatrix;
            var VisitorFlags = Shumway.GFX.VisitorFlags;

            var unexpected = Shumway.Debug.unexpected;

            var WebGLStageRendererOptions = (function (_super) {
                __extends(WebGLStageRendererOptions, _super);
                function WebGLStageRendererOptions() {
                    _super.apply(this, arguments);
                    this.maxSurfaces = 8;
                    this.maxSurfaceSize = 2048 * 2;
                    this.animateZoom = true;
                    /**
                    * Sometimes it's useful to temporarily disable texture uploads to see if rendering
                    * is texture upload bound.
                    */
                    this.disableSurfaceUploads = false;
                    this.frameSpacing = 0.0001;
                    this.ignoreColorMatrix = false;
                    this.drawSurfaces = false;
                    this.drawSurface = -1;
                    this.premultipliedAlpha = false;
                    this.unpackPremultiplyAlpha = true;
                    this.showTemporaryCanvases = false;
                    this.sourceBlendFactor = 1 /* ONE */;
                    this.destinationBlendFactor = 771 /* ONE_MINUS_SRC_ALPHA */;
                }
                return WebGLStageRendererOptions;
            })(GFX.StageRendererOptions);
            WebGL.WebGLStageRendererOptions = WebGLStageRendererOptions;

            var WebGLStageRenderer = (function (_super) {
                __extends(WebGLStageRenderer, _super);
                function WebGLStageRenderer(canvas, stage, options) {
                    if (typeof options === "undefined") { options = new WebGLStageRendererOptions(); }
                    _super.call(this, canvas, stage, options);
                    this._tmpVertices = WebGL.Vertex.createEmptyVertices(WebGL.Vertex, 64);
                    this._cachedTiles = [];
                    var context = this._context = new WebGL.WebGLContext(this._canvas, options);

                    this.resize();

                    this._brush = new WebGL.WebGLCombinedBrush(context, new WebGL.WebGLGeometry(context));
                    this._stencilBrush = new WebGL.WebGLCombinedBrush(context, new WebGL.WebGLGeometry(context));

                    this._scratchCanvas = document.createElement("canvas");
                    this._scratchCanvas.width = this._scratchCanvas.height = SCRATCH_CANVAS_SIZE;
                    this._scratchCanvasContext = this._scratchCanvas.getContext("2d", {
                        willReadFrequently: true
                    });

                    this._dynamicScratchCanvas = document.createElement("canvas");
                    this._dynamicScratchCanvas.width = this._dynamicScratchCanvas.height = 0;
                    this._dynamicScratchCanvasContext = this._dynamicScratchCanvas.getContext("2d", {
                        willReadFrequently: true
                    });

                    this._uploadCanvas = document.createElement("canvas");
                    this._uploadCanvas.width = this._uploadCanvas.height = 0;
                    this._uploadCanvasContext = this._uploadCanvas.getContext("2d", {
                        willReadFrequently: true
                    });

                    if (options.showTemporaryCanvases) {
                        document.getElementById("temporaryCanvasPanelContainer").appendChild(this._uploadCanvas);
                        document.getElementById("temporaryCanvasPanelContainer").appendChild(this._scratchCanvas);
                    }

                    this._clipStack = [];
                }
                WebGLStageRenderer.prototype.resize = function () {
                    this._viewport = new Rectangle(0, 0, this._canvas.width, this._canvas.height);
                    this._context._resize();
                };

                WebGLStageRenderer.prototype._cacheImageCallback = function (oldSurfaceRegion, src, srcBounds) {
                    /*
                    * To avoid seeming caused by linear texture sampling we need to pad each atlased image with a 1 pixel border that duplicates
                    * edge pixels, similar to CLAMP_TO_EDGE
                    *
                    * See the discussion here: http://gamedev.stackexchange.com/questions/61796/sprite-sheet-textures-picking-up-edges-of-adjacent-texture
                    *
                    * For the image:
                    *
                    *    +---+
                    *    |123|
                    *    |456|
                    *    |789|
                    *    +---+
                    *
                    * We instead create:
                    *
                    *  +-------+
                    *  |? 123 ?|
                    *  | +---+ |
                    *  |1|123|3|
                    *  |4|456|6|
                    *  |7|789|9|
                    *  | +---+ |
                    *  |? 789 ?|
                    *  +-------+
                    *
                    *  I don't know what to do about corners yet. Might not be a problem, I don't see any artifacts if they are left empty.
                    */
                    var w = srcBounds.w;
                    var h = srcBounds.h;
                    var sx = srcBounds.x;
                    var sy = srcBounds.y;

                    this._uploadCanvas.width = w + 2;
                    this._uploadCanvas.height = h + 2;

                    // Draw Image
                    this._uploadCanvasContext.drawImage(src.canvas, sx, sy, w, h, 1, 1, w, h);

                    // Top & Bottom Margins
                    this._uploadCanvasContext.drawImage(src.canvas, sx, sy, w, 1, 1, 0, w, 1);
                    this._uploadCanvasContext.drawImage(src.canvas, sx, sy + h - 1, w, 1, 1, h + 1, w, 1);

                    // Left & Right Margins
                    this._uploadCanvasContext.drawImage(src.canvas, sx, sy, 1, h, 0, 1, 1, h);
                    this._uploadCanvasContext.drawImage(src.canvas, sx + w - 1, sy, 1, h, w + 1, 1, 1, h);

                    if (!oldSurfaceRegion || !oldSurfaceRegion.surface) {
                        return this._context.cacheImage(this._uploadCanvas);
                    } else {
                        if (!this._options.disableSurfaceUploads) {
                            this._context.updateSurfaceRegion(this._uploadCanvas, oldSurfaceRegion);
                        }
                        return oldSurfaceRegion;
                    }
                };

                WebGLStageRenderer.prototype._enterClip = function (clip, matrix, brush, viewport) {
                    brush.flush();
                    var gl = this._context.gl;
                    if (this._clipStack.length === 0) {
                        gl.enable(gl.STENCIL_TEST);
                        gl.clear(gl.STENCIL_BUFFER_BIT);
                        gl.stencilFunc(gl.ALWAYS, 1, 1);
                    }
                    this._clipStack.push(clip);
                    gl.colorMask(false, false, false, false);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    this._renderFrame(clip, matrix, brush, viewport, 0);
                    brush.flush();
                    gl.colorMask(true, true, true, true);
                    gl.stencilFunc(gl.NOTEQUAL, 0, this._clipStack.length);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                };

                WebGLStageRenderer.prototype._leaveClip = function (clip, matrix, brush, viewport) {
                    brush.flush();
                    var gl = this._context.gl;
                    var clip = this._clipStack.pop();
                    if (clip) {
                        gl.colorMask(false, false, false, false);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        this._renderFrame(clip, matrix, brush, viewport, 0);
                        brush.flush();
                        gl.colorMask(true, true, true, true);
                        gl.stencilFunc(gl.NOTEQUAL, 0, this._clipStack.length);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                    if (this._clipStack.length === 0) {
                        gl.disable(gl.STENCIL_TEST);
                    }
                };

                WebGLStageRenderer.prototype._renderFrame = function (root, matrix, brush, viewport, depth) {
                    if (typeof depth === "undefined") { depth = 0; }
                    var self = this;
                    var options = this._options;
                    var context = this._context;
                    var gl = context.gl;
                    var cacheImageCallback = this._cacheImageCallback.bind(this);
                    var tileMatrix = Matrix.createIdentity();
                    var colorMatrix = ColorMatrix.createIdentity();
                    var inverseMatrix = Matrix.createIdentity();
                    root.visit(function (frame, matrix, flags) {
                        depth += options.frameSpacing;

                        var bounds = frame.getBounds();

                        if (flags & 4096 /* EnterClip */) {
                            self._enterClip(frame, matrix, brush, viewport);
                            return;
                        } else if (flags & 8192 /* LeaveClip */) {
                            self._leaveClip(frame, matrix, brush, viewport);
                            return;
                        }

                        // Return early if the bounds are not within the viewport.
                        if (!viewport.intersectsTransformedAABB(bounds, matrix)) {
                            return 2 /* Skip */;
                        }

                        var alpha = frame.getConcatenatedAlpha(root);
                        if (!options.ignoreColorMatrix) {
                            colorMatrix = frame.getConcatenatedColorMatrix();
                        }

                        if (frame instanceof GFX.FrameContainer) {
                            if (frame instanceof GFX.ClipRectangle || options.paintBounds) {
                                if (!frame.color) {
                                    frame.color = Color.randomColor(0.3);
                                }
                                brush.fillRectangle(bounds, frame.color, matrix, depth);
                            }
                            //          if (frame !== root && frame.blendMode !== BlendMode.Normal) {
                            //            // self._renderFrameLayer(frame, matrix, brush);
                            //            // self._renderFrameIntoTextureRegion(frame, transform);
                            //            return VisitorFlags.Skip;
                            //          }
                        } else if (frame instanceof Shape) {
                            if (frame.blendMode !== 1 /* Normal */) {
                                if (!WebGL.WebGLContext.glSupportedBlendMode(frame.blendMode)) {
                                    // gl.TEXTURE_2D
                                    // gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 4, 4, 16, 16);
                                    // Now we need to render the frame into a texture.
                                }
                                return 2 /* Skip */;
                            }
                            var shape = frame;
                            var bounds = shape.source.getBounds();
                            if (!bounds.isEmpty()) {
                                var source = shape.source;
                                var tileCache = source.properties["tileCache"];
                                if (!tileCache) {
                                    tileCache = source.properties["tileCache"] = new RenderableTileCache(source, WebGL.TILE_SIZE, WebGL.MIN_UNTILED_SIZE);
                                }
                                var t = Matrix.createIdentity().translate(bounds.x, bounds.y);
                                t.concat(matrix);
                                t.inverse(inverseMatrix);
                                var tiles = tileCache.fetchTiles(viewport, inverseMatrix, self._scratchCanvasContext, cacheImageCallback);
                                for (var i = 0; i < tiles.length; i++) {
                                    var tile = tiles[i];
                                    tileMatrix.setIdentity();
                                    tileMatrix.translate(tile.bounds.x, tile.bounds.y);
                                    tileMatrix.scale(1 / tile.scale, 1 / tile.scale);
                                    tileMatrix.translate(bounds.x, bounds.y);
                                    tileMatrix.concat(matrix);
                                    var src = (tile.cachedSurfaceRegion);
                                    if (src && src.surface) {
                                        context._surfaceRegionCache.use(src);
                                    }
                                    var color = new Color(1, 1, 1, alpha);
                                    if (options.paintFlashing) {
                                        color = Color.randomColor(1);
                                    }
                                    if (!brush.drawImage(src, new Rectangle(0, 0, tile.bounds.w, tile.bounds.h), color, colorMatrix, tileMatrix, depth, frame.blendMode)) {
                                        unexpected();
                                    }
                                    if (options.drawTiles) {
                                        var srcBounds = tile.bounds.clone();
                                        if (!tile.color) {
                                            tile.color = Color.randomColor(0.4);
                                        }
                                        brush.fillRectangle(new Rectangle(0, 0, srcBounds.w, srcBounds.h), tile.color, tileMatrix, depth);
                                    }
                                }
                            }
                        }
                        return 0 /* Continue */;
                    }, matrix, 0 /* Empty */, 16 /* Clips */);
                };

                WebGLStageRenderer.prototype._renderSurfaces = function (brush) {
                    var options = this._options;
                    var context = this._context;
                    var viewport = this._viewport;
                    if (options.drawSurfaces) {
                        var surfaces = context.surfaces;
                        var matrix = Matrix.createIdentity();
                        if (options.drawSurface >= 0 && options.drawSurface < surfaces.length) {
                            var surface = surfaces[options.drawSurface | 0];
                            var src = new Rectangle(0, 0, surface.w, surface.h);
                            var dst = src.clone();
                            while (dst.w > viewport.w) {
                                dst.scale(0.5, 0.5);
                            }
                            brush.drawImage(new WebGL.WebGLSurfaceRegion(surface, src), dst, Color.White, null, matrix, 0.2);
                        } else {
                            var surfaceWindowSize = viewport.w / 5;
                            if (surfaceWindowSize > viewport.h / surfaces.length) {
                                surfaceWindowSize = viewport.h / surfaces.length;
                            }
                            brush.fillRectangle(new Rectangle(viewport.w - surfaceWindowSize, 0, surfaceWindowSize, viewport.h), new Color(0, 0, 0, 0.5), matrix, 0.1);
                            for (var i = 0; i < surfaces.length; i++) {
                                var surface = surfaces[i];
                                var surfaceWindow = new Rectangle(viewport.w - surfaceWindowSize, i * surfaceWindowSize, surfaceWindowSize, surfaceWindowSize);
                                brush.drawImage(new WebGL.WebGLSurfaceRegion(surface, new Rectangle(0, 0, surface.w, surface.h)), surfaceWindow, Color.White, null, matrix, 0.2);
                            }
                        }
                        brush.flush();
                    }
                };

                WebGLStageRenderer.prototype.render = function () {
                    var self = this;
                    var stage = this._stage;
                    var options = this._options;
                    var context = this._context;
                    var gl = context.gl;

                    // TODO: Only set the camera once, not every frame.
                    if (options.perspectiveCamera) {
                        this._context.modelViewProjectionMatrix = this._context.createPerspectiveMatrix(options.perspectiveCameraDistance + (options.animateZoom ? Math.sin(Date.now() / 3000) * 0.8 : 0), options.perspectiveCameraFOV, options.perspectiveCameraAngle);
                    } else {
                        this._context.modelViewProjectionMatrix = this._context.create2DProjectionMatrix();
                    }

                    var brush = this._brush;

                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    brush.reset();

                    var viewport = this._viewport;

                    GFX.enterTimeline("_renderFrame");
                    this._renderFrame(stage, stage.matrix, brush, viewport, 0);
                    GFX.leaveTimeline();

                    brush.flush();

                    if (options.paintViewport) {
                        brush.fillRectangle(viewport, new Color(0.5, 0, 0, 0.25), Matrix.createIdentity(), 0);
                        brush.flush();
                    }

                    this._renderSurfaces(brush);
                };
                return WebGLStageRenderer;
            })(GFX.StageRenderer);
            WebGL.WebGLStageRenderer = WebGLStageRenderer;
        })(GFX.WebGL || (GFX.WebGL = {}));
        var WebGL = GFX.WebGL;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (WebGL) {
            var Color = Shumway.Color;
            var Point = GFX.Geometry.Point;

            var Matrix3D = GFX.Geometry.Matrix3D;

            var WebGLBrush = (function () {
                function WebGLBrush(context, geometry, target) {
                    this._target = target;
                    this._context = context;
                    this._geometry = geometry;
                }
                WebGLBrush.prototype.reset = function () {
                    Shumway.Debug.abstractMethod("reset");
                };

                WebGLBrush.prototype.flush = function () {
                    Shumway.Debug.abstractMethod("flush");
                };


                Object.defineProperty(WebGLBrush.prototype, "target", {
                    get: function () {
                        return this._target;
                    },
                    set: function (target) {
                        if (this._target !== target) {
                            this.flush();
                        }
                        this._target = target;
                    },
                    enumerable: true,
                    configurable: true
                });
                return WebGLBrush;
            })();
            WebGL.WebGLBrush = WebGLBrush;

            (function (WebGLCombinedBrushKind) {
                WebGLCombinedBrushKind[WebGLCombinedBrushKind["FillColor"] = 0] = "FillColor";
                WebGLCombinedBrushKind[WebGLCombinedBrushKind["FillTexture"] = 1] = "FillTexture";
                WebGLCombinedBrushKind[WebGLCombinedBrushKind["FillTextureWithColorMatrix"] = 2] = "FillTextureWithColorMatrix";
            })(WebGL.WebGLCombinedBrushKind || (WebGL.WebGLCombinedBrushKind = {}));
            var WebGLCombinedBrushKind = WebGL.WebGLCombinedBrushKind;

            var WebGLCombinedBrushVertex = (function (_super) {
                __extends(WebGLCombinedBrushVertex, _super);
                function WebGLCombinedBrushVertex(x, y, z) {
                    _super.call(this, x, y, z);
                    this.kind = 0 /* FillColor */;
                    this.color = new Color(0, 0, 0, 0);
                    this.sampler = 0;
                    this.coordinate = new Point(0, 0);
                }
                WebGLCombinedBrushVertex.initializeAttributeList = function (context) {
                    var gl = context.gl;
                    if (WebGLCombinedBrushVertex.attributeList) {
                        return;
                    }
                    WebGLCombinedBrushVertex.attributeList = new WebGL.WebGLAttributeList([
                        new WebGL.WebGLAttribute("aPosition", 3, gl.FLOAT),
                        new WebGL.WebGLAttribute("aCoordinate", 2, gl.FLOAT),
                        new WebGL.WebGLAttribute("aColor", 4, gl.UNSIGNED_BYTE, true),
                        new WebGL.WebGLAttribute("aKind", 1, gl.FLOAT),
                        new WebGL.WebGLAttribute("aSampler", 1, gl.FLOAT)
                    ]);
                    WebGLCombinedBrushVertex.attributeList.initialize(context);
                };

                WebGLCombinedBrushVertex.prototype.writeTo = function (geometry) {
                    var array = geometry.array;
                    array.ensureAdditionalCapacity(68);
                    array.writeVertex3DUnsafe(this.x, this.y, this.z);
                    array.writeVertexUnsafe(this.coordinate.x, this.coordinate.y);
                    array.writeColorUnsafe(this.color.r * 255, this.color.g * 255, this.color.b * 255, this.color.a * 255);
                    array.writeFloatUnsafe(this.kind);
                    array.writeFloatUnsafe(this.sampler);
                };
                return WebGLCombinedBrushVertex;
            })(WebGL.Vertex);
            WebGL.WebGLCombinedBrushVertex = WebGLCombinedBrushVertex;

            var WebGLCombinedBrush = (function (_super) {
                __extends(WebGLCombinedBrush, _super);
                function WebGLCombinedBrush(context, geometry, target) {
                    if (typeof target === "undefined") { target = null; }
                    _super.call(this, context, geometry, target);
                    this._blendMode = 1 /* Normal */;
                    this._program = context.createProgramFromFiles("combined.vert", "combined.frag");
                    this._surfaces = [];
                    WebGLCombinedBrushVertex.initializeAttributeList(this._context);
                }
                WebGLCombinedBrush.prototype.reset = function () {
                    this._surfaces = [];
                    this._geometry.reset();
                };

                WebGLCombinedBrush.prototype.drawImage = function (src, dstRectangle, color, colorMatrix, matrix, depth, blendMode) {
                    if (typeof depth === "undefined") { depth = 0; }
                    if (typeof blendMode === "undefined") { blendMode = 1 /* Normal */; }
                    if (!src || !src.surface) {
                        return true;
                    }
                    dstRectangle = dstRectangle.clone();
                    if (this._colorMatrix) {
                        if (!colorMatrix || !this._colorMatrix.equals(colorMatrix)) {
                            this.flush();
                        }
                    }
                    this._colorMatrix = colorMatrix;
                    if (this._blendMode !== blendMode) {
                        this.flush();
                        this._blendMode = blendMode;
                    }
                    var sampler = this._surfaces.indexOf(src.surface);
                    if (sampler < 0) {
                        if (this._surfaces.length === 8) {
                            this.flush();
                        }
                        this._surfaces.push(src.surface);

                        // if (this._surfaces.length > 8) {
                        //   return false;
                        //   notImplemented("Cannot handle more than 8 texture samplers.");
                        // }
                        sampler = this._surfaces.length - 1;
                    }
                    var tmpVertices = WebGLCombinedBrush._tmpVertices;
                    var srcRectangle = src.region.clone();

                    // TODO: This takes into the consideration the 1 pixel border added around tiles in the atlas. It should
                    // probably be moved elsewhere.
                    srcRectangle.offset(1, 1).resize(-2, -2);
                    srcRectangle.scale(1 / src.surface.w, 1 / src.surface.h);
                    matrix.transformRectangle(dstRectangle, tmpVertices);
                    for (var i = 0; i < 4; i++) {
                        tmpVertices[i].z = depth;
                    }
                    tmpVertices[0].coordinate.x = srcRectangle.x;
                    tmpVertices[0].coordinate.y = srcRectangle.y;
                    tmpVertices[1].coordinate.x = srcRectangle.x + srcRectangle.w;
                    tmpVertices[1].coordinate.y = srcRectangle.y;
                    tmpVertices[2].coordinate.x = srcRectangle.x + srcRectangle.w;
                    tmpVertices[2].coordinate.y = srcRectangle.y + srcRectangle.h;
                    tmpVertices[3].coordinate.x = srcRectangle.x;
                    tmpVertices[3].coordinate.y = srcRectangle.y + srcRectangle.h;

                    for (var i = 0; i < 4; i++) {
                        var vertex = WebGLCombinedBrush._tmpVertices[i];
                        vertex.kind = colorMatrix ? 2 /* FillTextureWithColorMatrix */ : 1 /* FillTexture */;
                        vertex.color.set(color);
                        vertex.sampler = sampler;
                        vertex.writeTo(this._geometry);
                    }
                    this._geometry.addQuad();
                    return true;
                };

                WebGLCombinedBrush.prototype.fillRectangle = function (rectangle, color, matrix, depth) {
                    if (typeof depth === "undefined") { depth = 0; }
                    matrix.transformRectangle(rectangle, WebGLCombinedBrush._tmpVertices);
                    for (var i = 0; i < 4; i++) {
                        var vertex = WebGLCombinedBrush._tmpVertices[i];
                        vertex.kind = 0 /* FillColor */;
                        vertex.color.set(color);
                        vertex.z = depth;
                        vertex.writeTo(this._geometry);
                    }
                    this._geometry.addQuad();
                };

                WebGLCombinedBrush.prototype.flush = function () {
                    GFX.enterTimeline("WebGLCombinedBrush.flush");
                    var g = this._geometry;
                    var p = this._program;
                    var gl = this._context.gl;
                    var matrix;

                    g.uploadBuffers();
                    gl.useProgram(p);
                    if (this._target) {
                        matrix = Matrix3D.create2DProjection(this._target.w, this._target.h, 2000);
                        matrix = Matrix3D.createMultiply(matrix, Matrix3D.createScale(1, -1, 1));
                    } else {
                        matrix = this._context.modelViewProjectionMatrix;
                    }
                    gl.uniformMatrix4fv(p.uniforms.uTransformMatrix3D.location, false, matrix.asWebGLMatrix());
                    if (this._colorMatrix) {
                        gl.uniformMatrix4fv(p.uniforms.uColorMatrix.location, false, this._colorMatrix.asWebGLMatrix());
                        gl.uniform4fv(p.uniforms.uColorVector.location, this._colorMatrix.asWebGLVector());
                    }

                    for (var i = 0; i < this._surfaces.length; i++) {
                        gl.activeTexture(gl.TEXTURE0 + i);
                        gl.bindTexture(gl.TEXTURE_2D, this._surfaces[i].texture);
                    }
                    gl.uniform1iv(p.uniforms["uSampler[0]"].location, [0, 1, 2, 3, 4, 5, 6, 7]);

                    // Bind vertex buffer.
                    gl.bindBuffer(gl.ARRAY_BUFFER, g.buffer);
                    var size = WebGLCombinedBrushVertex.attributeList.size;
                    var attributeList = WebGLCombinedBrushVertex.attributeList;
                    var attributes = attributeList.attributes;
                    for (var i = 0; i < attributes.length; i++) {
                        var attribute = attributes[i];
                        var position = p.attributes[attribute.name].location;
                        gl.enableVertexAttribArray(position);
                        gl.vertexAttribPointer(position, attribute.size, attribute.type, attribute.normalized, size, attribute.offset);
                    }

                    // this._context.setBlendMode(this._blendMode);
                    this._context.setBlendOptions();

                    // Bind target.
                    this._context.target = this._target;

                    // Bind elements buffer.
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, g.elementBuffer);

                    gl.drawElements(gl.TRIANGLES, g.triangleCount * 3, gl.UNSIGNED_SHORT, 0);
                    this.reset();
                    GFX.leaveTimeline("WebGLCombinedBrush.flush");
                };
                WebGLCombinedBrush._tmpVertices = WebGL.Vertex.createEmptyVertices(WebGLCombinedBrushVertex, 4);

                WebGLCombinedBrush._depth = 1;
                return WebGLCombinedBrush;
            })(WebGLBrush);
            WebGL.WebGLCombinedBrush = WebGLCombinedBrush;
        })(GFX.WebGL || (GFX.WebGL = {}));
        var WebGL = GFX.WebGL;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (Canvas2D) {
            var assert = Shumway.Debug.assert;

            var originalSave = CanvasRenderingContext2D.prototype.save;
            var originalClip = CanvasRenderingContext2D.prototype.clip;
            var originalFill = CanvasRenderingContext2D.prototype.fill;
            var originalStroke = CanvasRenderingContext2D.prototype.stroke;
            var originalRestore = CanvasRenderingContext2D.prototype.restore;
            var originalBeginPath = CanvasRenderingContext2D.prototype.beginPath;

            function debugSave() {
                if (this.stackDepth === undefined) {
                    this.stackDepth = 0;
                }
                if (this.clipStack === undefined) {
                    this.clipStack = [0];
                } else {
                    this.clipStack.push(0);
                }
                this.stackDepth++;
                originalSave.call(this);
            }

            function debugRestore() {
                this.stackDepth--;
                this.clipStack.pop();
                originalRestore.call(this);
            }

            function debugFill() {
                assert(!this.buildingClippingRegionDepth);
                originalFill.apply(this, arguments);
            }

            function debugStroke() {
                assert(GFX.debugClipping.value || !this.buildingClippingRegionDepth);
                originalStroke.apply(this, arguments);
            }

            function debugBeginPath() {
                originalBeginPath.call(this);
            }

            function debugClip() {
                if (this.clipStack === undefined) {
                    this.clipStack = [0];
                }
                this.clipStack[this.clipStack.length - 1]++;
                if (GFX.debugClipping.value) {
                    this.strokeStyle = Shumway.ColorStyle.Pink;
                    this.stroke.apply(this, arguments);
                } else {
                    originalClip.apply(this, arguments);
                }
            }

            function notifyReleaseChanged() {
                if (release) {
                    CanvasRenderingContext2D.prototype.save = originalSave;
                    CanvasRenderingContext2D.prototype.clip = originalClip;
                    CanvasRenderingContext2D.prototype.fill = originalFill;
                    CanvasRenderingContext2D.prototype.stroke = originalStroke;
                    CanvasRenderingContext2D.prototype.restore = originalRestore;
                    CanvasRenderingContext2D.prototype.beginPath = originalBeginPath;
                } else {
                    CanvasRenderingContext2D.prototype.save = debugSave;
                    CanvasRenderingContext2D.prototype.clip = debugClip;
                    CanvasRenderingContext2D.prototype.fill = debugFill;
                    CanvasRenderingContext2D.prototype.stroke = debugStroke;
                    CanvasRenderingContext2D.prototype.restore = debugRestore;
                    CanvasRenderingContext2D.prototype.beginPath = debugBeginPath;
                }
            }
            Canvas2D.notifyReleaseChanged = notifyReleaseChanged;

            CanvasRenderingContext2D.prototype.enterBuildingClippingRegion = function () {
                if (!this.buildingClippingRegionDepth) {
                    this.buildingClippingRegionDepth = 0;
                }
                this.buildingClippingRegionDepth++;
            };

            CanvasRenderingContext2D.prototype.leaveBuildingClippingRegion = function () {
                this.buildingClippingRegionDepth--;
            };
        })(GFX.Canvas2D || (GFX.Canvas2D = {}));
        var Canvas2D = GFX.Canvas2D;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (Canvas2D) {
            var Canvas2DSurfaceRegion = (function () {
                function Canvas2DSurfaceRegion(surface, region) {
                    this.surface = surface;
                    this.region = region;
                    // ...
                }
                return Canvas2DSurfaceRegion;
            })();
            Canvas2D.Canvas2DSurfaceRegion = Canvas2DSurfaceRegion;

            var Canvas2DSurface = (function () {
                function Canvas2DSurface(canvas, regionAllocator) {
                    this.canvas = canvas;
                    this.context = canvas.getContext("2d");
                    this.w = canvas.width;
                    this.h = canvas.height;
                    this._regionAllocator = regionAllocator;
                }
                Canvas2DSurface.prototype.allocate = function (w, h) {
                    var region = this._regionAllocator.allocate(w, h);
                    if (region) {
                        return new Canvas2DSurfaceRegion(this, region);
                    }
                    return null;
                };
                Canvas2DSurface.prototype.free = function (surfaceRegion) {
                    this._regionAllocator.free(surfaceRegion.region);
                };
                return Canvas2DSurface;
            })();
            Canvas2D.Canvas2DSurface = Canvas2DSurface;
        })(GFX.Canvas2D || (GFX.Canvas2D = {}));
        var Canvas2D = GFX.Canvas2D;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (Canvas2D) {
            var Rectangle = Shumway.GFX.Geometry.Rectangle;

            var BlendMode = Shumway.GFX.BlendMode;

            var MipMap = Shumway.GFX.Geometry.MipMap;

            (function (FillRule) {
                FillRule[FillRule["NonZero"] = 0] = "NonZero";
                FillRule[FillRule["EvenOdd"] = 1] = "EvenOdd";
            })(Canvas2D.FillRule || (Canvas2D.FillRule = {}));
            var FillRule = Canvas2D.FillRule;

            var Canvas2DStageRendererOptions = (function (_super) {
                __extends(Canvas2DStageRendererOptions, _super);
                function Canvas2DStageRendererOptions() {
                    _super.apply(this, arguments);
                    /**
                    * Whether to force snapping matrices to device pixels.
                    */
                    this.snapToDevicePixels = true;
                    /**
                    * Whether to force image smoothing when drawing images.
                    */
                    this.imageSmoothing = true;
                    /**
                    * Whether to enablel blending.
                    */
                    this.blending = true;
                    /**
                    * Whether to cache shapes as images.
                    */
                    this.cacheShapes = false;
                    /**
                    * Shapes above this size are not cached.
                    */
                    this.cacheShapesMaxSize = 256;
                    /**
                    * Number of times a shape is rendered before it's elligible for caching.
                    */
                    this.cacheShapesThreshold = 16;
                }
                return Canvas2DStageRendererOptions;
            })(GFX.StageRendererOptions);
            Canvas2D.Canvas2DStageRendererOptions = Canvas2DStageRendererOptions;

            /**
            * Rendering state threaded through rendering methods.
            */
            var Canvas2DStageRendererState = (function () {
                function Canvas2DStageRendererState(options, clipRegion, ignoreMask) {
                    if (typeof clipRegion === "undefined") { clipRegion = false; }
                    if (typeof ignoreMask === "undefined") { ignoreMask = null; }
                    this.options = options;
                    this.clipRegion = clipRegion;
                    this.ignoreMask = ignoreMask;
                    // ...
                }
                return Canvas2DStageRendererState;
            })();
            Canvas2D.Canvas2DStageRendererState = Canvas2DStageRendererState;

            var Canvas2DStageRenderer = (function (_super) {
                __extends(Canvas2DStageRenderer, _super);
                function Canvas2DStageRenderer(canvas, stage, options) {
                    if (typeof options === "undefined") { options = new Canvas2DStageRendererOptions(); }
                    _super.call(this, canvas, stage, options);
                    var fillRule = 0 /* NonZero */;
                    var context = this.context = canvas.getContext("2d");
                    this._viewport = new Rectangle(0, 0, canvas.width, canvas.height);
                    this._fillRule = fillRule === 1 /* EvenOdd */ ? 'evenodd' : 'nonzero';
                    context.fillRule = context.mozFillRule = this._fillRule;
                    Canvas2DStageRenderer._prepareSurfaceAllocators();
                }
                Canvas2DStageRenderer._prepareSurfaceAllocators = function () {
                    if (Canvas2DStageRenderer._initializedCaches) {
                        return;
                    }

                    Canvas2DStageRenderer._surfaceCache = new GFX.SurfaceRegionAllocator.SimpleAllocator(function (w, h) {
                        var canvas = document.createElement("canvas");
                        if (typeof registerScratchCanvas !== "undefined") {
                            registerScratchCanvas(canvas);
                        }

                        // Surface caches are at least this size.
                        var W = Math.max(1024, w);
                        var H = Math.max(1024, h);
                        canvas.width = W;
                        canvas.height = H;
                        var allocator = null;
                        if (w >= 1024 || h >= 1024) {
                            // The requested size is pretty large, so create a single grid allocator
                            // with there requested size. This will only hold one image.
                            allocator = new GFX.RegionAllocator.GridAllocator(W, H, W, H);
                        } else {
                            allocator = new GFX.RegionAllocator.BucketAllocator(W, H);
                        }
                        return new Canvas2D.Canvas2DSurface(canvas, allocator);
                    });

                    Canvas2DStageRenderer._shapeCache = new GFX.SurfaceRegionAllocator.SimpleAllocator(function (w, h) {
                        var canvas = document.createElement("canvas");
                        if (typeof registerScratchCanvas !== "undefined") {
                            registerScratchCanvas(canvas);
                        }
                        var W = 1024, H = 1024;
                        canvas.width = W;
                        canvas.height = H;

                        // Shape caches can be compact since regions are never freed explicitly.
                        var allocator = allocator = new GFX.RegionAllocator.CompactAllocator(W, H);
                        return new Canvas2D.Canvas2DSurface(canvas, allocator);
                    });

                    Canvas2DStageRenderer._initializedCaches = true;
                };

                Canvas2DStageRenderer.prototype.resize = function () {
                    // TODO: We need to resize all the scratch canvases and recreate allocators.
                };

                Canvas2DStageRenderer.prototype.render = function () {
                    var stage = this._stage;
                    var context = this.context;

                    context.setTransform(1, 0, 0, 1, 0, 0);

                    context.save();
                    var options = this._options;

                    var lastDirtyRectangles = [];
                    var dirtyRectangles = lastDirtyRectangles.slice(0);

                    context.globalAlpha = 1;

                    var viewport = this._viewport;
                    this.renderFrame(stage, viewport, stage.matrix, true);

                    if (stage.trackDirtyRegions) {
                        stage.dirtyRegion.clear();
                    }

                    context.restore();

                    if (options && options.paintViewport) {
                        context.beginPath();
                        context.rect(viewport.x, viewport.y, viewport.w, viewport.h);
                        context.strokeStyle = "#FF4981";
                        context.stroke();
                    }
                };

                Canvas2DStageRenderer.prototype.renderFrame = function (root, viewport, matrix, clearTargetBeforeRendering) {
                    if (typeof clearTargetBeforeRendering === "undefined") { clearTargetBeforeRendering = false; }
                    var context = this.context;
                    context.save();
                    if (!this._options.paintViewport) {
                        context.beginPath();
                        context.rect(viewport.x, viewport.y, viewport.w, viewport.h);
                        context.clip();
                    }
                    if (clearTargetBeforeRendering) {
                        context.clearRect(viewport.x, viewport.y, viewport.w, viewport.h);
                    }
                    this._renderFrame(context, root, matrix, viewport, new Canvas2DStageRendererState(this._options));
                    context.restore();
                };

                /**
                * Renders the frame into a temporary surface region in device coordinates clipped by the viewport.
                */
                Canvas2DStageRenderer.prototype._renderToSurfaceRegion = function (frame, transform, viewport) {
                    var bounds = frame.getBounds();
                    var boundsAABB = bounds.clone();
                    transform.transformRectangleAABB(boundsAABB);
                    boundsAABB.snap();
                    var dx = boundsAABB.x;
                    var dy = boundsAABB.y;
                    var clippedBoundsAABB = boundsAABB.clone();
                    clippedBoundsAABB.intersect(viewport);
                    clippedBoundsAABB.snap();

                    dx += clippedBoundsAABB.x - boundsAABB.x;
                    dy += clippedBoundsAABB.y - boundsAABB.y;

                    var surfaceRegion = (Canvas2DStageRenderer._surfaceCache.allocate(clippedBoundsAABB.w, clippedBoundsAABB.h));
                    var region = surfaceRegion.region;

                    // Region bounds may be smaller than the allocated surface region.
                    var surfaceRegionBounds = new Rectangle(region.x, region.y, clippedBoundsAABB.w, clippedBoundsAABB.h);

                    var context = surfaceRegion.surface.context;
                    context.setTransform(1, 0, 0, 1, 0, 0);

                    // Prepare region bounds for painting.
                    context.clearRect(surfaceRegionBounds.x, surfaceRegionBounds.y, surfaceRegionBounds.w, surfaceRegionBounds.h);
                    transform = transform.clone();

                    transform.translate(surfaceRegionBounds.x - dx, surfaceRegionBounds.y - dy);

                    // Clip region bounds so we don't paint outside.
                    context.save();
                    context.beginPath();
                    context.rect(surfaceRegionBounds.x, surfaceRegionBounds.y, surfaceRegionBounds.w, surfaceRegionBounds.h);
                    context.clip();
                    this._renderFrame(context, frame, transform, surfaceRegionBounds, new Canvas2DStageRendererState(this._options));
                    context.restore();
                    return {
                        surfaceRegion: surfaceRegion,
                        surfaceRegionBounds: surfaceRegionBounds,
                        clippedBounds: clippedBoundsAABB
                    };
                };

                Canvas2DStageRenderer.prototype._renderShape = function (context, shape, matrix, viewport, state) {
                    var self = this;
                    var bounds = shape.getBounds();
                    if (!bounds.isEmpty() && state.options.paintRenderable) {
                        var source = shape.source;
                        var renderCount = source.properties["renderCount"] || 0;
                        var cacheShapesMaxSize = state.options.cacheShapesMaxSize;
                        var matrixScale = Math.max(matrix.getAbsoluteScaleX(), matrix.getAbsoluteScaleY());
                        if (!state.clipRegion && !source.hasFlags(1 /* Dynamic */) && state.options.cacheShapes && renderCount > state.options.cacheShapesThreshold && bounds.w * matrixScale <= cacheShapesMaxSize && bounds.h * matrixScale <= cacheShapesMaxSize) {
                            var mipMap = source.properties["mipMap"];
                            if (!mipMap) {
                                mipMap = source.properties["mipMap"] = new MipMap(source, Canvas2DStageRenderer._shapeCache, cacheShapesMaxSize);
                            }
                            var mipMapLevel = mipMap.getLevel(matrix);
                            var mipMapLevelSurfaceRegion = (mipMapLevel.surfaceRegion);
                            var region = mipMapLevelSurfaceRegion.region;
                            if (mipMapLevel) {
                                context.drawImage(mipMapLevelSurfaceRegion.surface.canvas, region.x, region.y, region.w, region.h, bounds.x, bounds.y, bounds.w, bounds.h);
                            }
                            if (state.options.paintFlashing) {
                                context.fillStyle = Shumway.ColorStyle.Green;
                                context.globalAlpha = 0.5;
                                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                            }
                        } else {
                            source.properties["renderCount"] = ++renderCount;
                            source.render(context, null, state.clipRegion);
                            if (state.options.paintFlashing) {
                                context.fillStyle = Shumway.ColorStyle.randomStyle();
                                context.globalAlpha = 0.1;
                                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                            }
                        }
                    }
                };

                Canvas2DStageRenderer.prototype._renderFrame = function (context, root, matrix, viewport, state, skipRoot) {
                    if (typeof skipRoot === "undefined") { skipRoot = false; }
                    var self = this;
                    root.visit(function visitFrame(frame, matrix, flags) {
                        if (skipRoot && root === frame) {
                            return 0 /* Continue */;
                        }

                        if (!frame._hasFlags(16384 /* Visible */)) {
                            return 2 /* Skip */;
                        }

                        var bounds = frame.getBounds();

                        if (state.ignoreMask !== frame && frame.mask && !state.clipRegion) {
                            context.save();
                            self._renderFrame(context, frame.mask, frame.mask.getConcatenatedMatrix(), viewport, new Canvas2DStageRendererState(state.options, true));
                            self._renderFrame(context, frame, matrix, viewport, new Canvas2DStageRendererState(state.options, false, frame));
                            context.restore();
                            return 2 /* Skip */;
                        }

                        if (flags & 4096 /* EnterClip */) {
                            context.save();
                            context.enterBuildingClippingRegion();
                            self._renderFrame(context, frame, matrix, viewport, new Canvas2DStageRendererState(state.options, true));
                            context.leaveBuildingClippingRegion();
                            return;
                        } else if (flags & 8192 /* LeaveClip */) {
                            context.restore();
                            return;
                        }

                        // Return early if the bounds are not within the viewport.
                        if (!viewport.intersectsTransformedAABB(bounds, matrix)) {
                            return 2 /* Skip */;
                        }

                        if (frame.pixelSnapping === 1 /* Always */ || state.options.snapToDevicePixels) {
                            matrix.snap();
                        }

                        context.imageSmoothingEnabled = frame.smoothing === 1 /* Always */ || state.options.imageSmoothing;

                        context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);

                        var concatenatedColorMatrix = frame.getConcatenatedColorMatrix();

                        if (concatenatedColorMatrix.isIdentity()) {
                            context.globalAlpha = 1;
                            context.globalColorMatrix = null;
                        } else if (concatenatedColorMatrix.hasOnlyAlphaMultiplier()) {
                            context.globalAlpha = concatenatedColorMatrix.alphaMultiplier;
                            context.globalColorMatrix = null;
                        } else {
                            context.globalAlpha = 1;
                            context.globalColorMatrix = concatenatedColorMatrix;
                        }

                        if (flags & 2 /* IsMask */ && !state.clipRegion) {
                            return 2 /* Skip */;
                        }

                        var boundsAABB = frame.getBounds().clone();
                        matrix.transformRectangleAABB(boundsAABB);
                        boundsAABB.snap();

                        if (frame !== root && state.options.blending) {
                            context.globalCompositeOperation = self._getCompositeOperation(frame.blendMode);
                            if (frame.blendMode !== 1 /* Normal */) {
                                var result = self._renderToSurfaceRegion(frame, matrix, viewport);
                                var surfaceRegion = result.surfaceRegion;
                                var surfaceRegionBounds = result.surfaceRegionBounds;
                                var clippedBounds = result.clippedBounds;
                                var region = surfaceRegion.region;
                                context.setTransform(1, 0, 0, 1, 0, 0);
                                context.drawImage(surfaceRegion.surface.canvas, surfaceRegionBounds.x, surfaceRegionBounds.y, surfaceRegionBounds.w, surfaceRegionBounds.h, clippedBounds.x, clippedBounds.y, surfaceRegionBounds.w, surfaceRegionBounds.h);
                                surfaceRegion.surface.free(surfaceRegion);
                                return 2 /* Skip */;
                            }
                        }

                        if (frame instanceof GFX.Shape) {
                            frame._previouslyRenderedAABB = boundsAABB;
                            self._renderShape(context, frame, matrix, viewport, state);
                        } else if (frame instanceof GFX.ClipRectangle) {
                            var clipRectangle = frame;
                            context.save();
                            context.beginPath();
                            context.rect(bounds.x, bounds.y, bounds.w, bounds.h);
                            context.clip();
                            boundsAABB.intersect(viewport);

                            // Fill Background
                            context.fillStyle = clipRectangle.color.toCSSStyle();
                            context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);

                            self._renderFrame(context, frame, matrix, boundsAABB, state, true);
                            context.restore();
                            return 2 /* Skip */;
                        } else if (state.options.paintBounds && frame instanceof GFX.FrameContainer) {
                            var bounds = frame.getBounds().clone();
                            context.strokeStyle = Shumway.ColorStyle.LightOrange;
                            context.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);
                        }
                        return 0 /* Continue */;
                    }, matrix, 0 /* Empty */, 16 /* Clips */);
                };

                Canvas2DStageRenderer.prototype._getCompositeOperation = function (blendMode) {
                    // TODO:
                    // These Flash blend modes have no canvas equivalent:
                    // - blendModeClass.SUBTRACT
                    // - blendModeClass.INVERT
                    // - blendModeClass.SHADER
                    // - blendModeClass.ADD
                    // These blend modes are actually Porter-Duff compositing operators.
                    // The backdrop is the nearest parent with blendMode set to LAYER.
                    // When there is no LAYER parent, they are ignored (treated as NORMAL).
                    // - blendModeClass.ALPHA (destination-in)
                    // - blendModeClass.ERASE (destination-out)
                    // - blendModeClass.LAYER [defines backdrop]
                    var compositeOp = "source-over";
                    switch (blendMode) {
                        case 3 /* Multiply */:
                            compositeOp = "multiply";
                            break;
                        case 4 /* Screen */:
                            compositeOp = "screen";
                            break;
                        case 5 /* Lighten */:
                            compositeOp = "lighten";
                            break;
                        case 6 /* Darken */:
                            compositeOp = "darken";
                            break;
                        case 7 /* Difference */:
                            compositeOp = "difference";
                            break;
                        case 13 /* Overlay */:
                            compositeOp = "overlay";
                            break;
                        case 14 /* HardLight */:
                            compositeOp = "hard-light";
                            break;
                    }
                    return compositeOp;
                };
                Canvas2DStageRenderer._initializedCaches = false;
                return Canvas2DStageRenderer;
            })(GFX.StageRenderer);
            Canvas2D.Canvas2DStageRenderer = Canvas2DStageRenderer;
        })(GFX.Canvas2D || (GFX.Canvas2D = {}));
        var Canvas2D = GFX.Canvas2D;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var VisitorFlags = Shumway.GFX.VisitorFlags;

        var DOMStageRenderer = (function () {
            function DOMStageRenderer(container, pixelRatio) {
                this.container = container;
                this.pixelRatio = pixelRatio;
            }
            DOMStageRenderer.prototype.render = function (stage, options) {
                var stageScale = 1 / this.pixelRatio;
                var that = this;
                stage.visit(function visitFrame(frame, transform) {
                    transform = transform.clone();
                    transform.scale(stageScale, stageScale);
                    if (frame instanceof GFX.Shape) {
                        var shape = frame;
                        var div = that.getDIV(shape);
                        div.style.transform = div.style["webkitTransform"] = transform.toCSSTransform();
                    }
                    return 0 /* Continue */;
                }, stage.matrix);
            };

            /**
            * Constructs a div element with a canvas element inside of it.
            */
            DOMStageRenderer.prototype.getDIV = function (shape) {
                var shapeProperties = shape.properties;
                var div = shapeProperties["div"];
                if (!div) {
                    div = shapeProperties["div"] = document.createElement("div");

                    // div.style.backgroundColor = Shumway.ColorStyle.randomStyle();
                    div.style.width = shape.w + "px";
                    div.style.height = shape.h + "px";
                    div.style.position = "absolute";
                    var canvas = document.createElement("canvas");
                    canvas.width = shape.w;
                    canvas.height = shape.h;
                    shape.source.render(canvas.getContext("2d"));
                    div.appendChild(canvas);
                    div.style.transformOrigin = div.style["webkitTransformOrigin"] = 0 + "px " + 0 + "px";
                    div.appendChild(canvas);
                    this.container.appendChild(div);
                }
                return div;
            };
            return DOMStageRenderer;
        })();
        GFX.DOMStageRenderer = DOMStageRenderer;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Point = GFX.Geometry.Point;
        var Matrix = GFX.Geometry.Matrix;
        var Rectangle = GFX.Geometry.Rectangle;

        var WebGLStageRenderer = Shumway.GFX.WebGL.WebGLStageRenderer;
        var WebGLStageRendererOptions = Shumway.GFX.WebGL.WebGLStageRendererOptions;

        var FPS = Shumway.Tools.Mini.FPS;

        var State = (function () {
            function State() {
            }
            State.prototype.onMouseUp = function (easel, event) {
                easel.state = this;
            };

            State.prototype.onMouseDown = function (easel, event) {
                easel.state = this;
            };

            State.prototype.onMouseMove = function (easel, event) {
                easel.state = this;
            };

            State.prototype.onMouseClick = function (easel, event) {
                easel.state = this;
            };

            State.prototype.onKeyUp = function (easel, event) {
                easel.state = this;
            };

            State.prototype.onKeyDown = function (easel, event) {
                easel.state = this;
            };

            State.prototype.onKeyPress = function (easel, event) {
                easel.state = this;
            };
            return State;
        })();
        GFX.State = State;

        var StartState = (function (_super) {
            __extends(StartState, _super);
            function StartState() {
                _super.apply(this, arguments);
                this._keyCodes = [];
            }
            StartState.prototype.onMouseDown = function (easel, event) {
                if (this._keyCodes[32]) {
                    easel.state = new DragState(easel.worldView, easel.getMousePosition(event, null), easel.worldView.matrix.clone());
                } else {
                    // easel.state = new MouseDownState();
                }
            };

            StartState.prototype.onMouseClick = function (easel, event) {
            };

            StartState.prototype.onKeyDown = function (easel, event) {
                this._keyCodes[event.keyCode] = true;
                this._updateCursor(easel);
            };

            StartState.prototype.onKeyUp = function (easel, event) {
                this._keyCodes[event.keyCode] = false;
                this._updateCursor(easel);
            };

            StartState.prototype._updateCursor = function (easel) {
                if (this._keyCodes[32]) {
                    easel.cursor = "move";
                } else {
                    easel.cursor = "auto";
                }
            };
            return StartState;
        })(State);

        var PersistentState = (function (_super) {
            __extends(PersistentState, _super);
            function PersistentState() {
                _super.apply(this, arguments);
                this._keyCodes = [];
                this._paused = false;
                this._mousePosition = new Point(0, 0);
            }
            PersistentState.prototype.onMouseMove = function (easel, event) {
                this._mousePosition = easel.getMousePosition(event, null);
                this._update(easel);
            };

            PersistentState.prototype.onMouseDown = function (easel, event) {
            };

            PersistentState.prototype.onMouseClick = function (easel, event) {
            };

            PersistentState.prototype.onKeyPress = function (easel, event) {
                if (event.keyCode === 112) {
                    this._paused = !this._paused;
                }
                if (this._keyCodes[83]) {
                    easel.toggleOption("paintRenderable");
                }
                if (this._keyCodes[86]) {
                    easel.toggleOption("paintViewport");
                }
                if (this._keyCodes[66]) {
                    easel.toggleOption("paintBounds");
                }
                if (this._keyCodes[70]) {
                    easel.toggleOption("paintFlashing");
                }
                this._update(easel);
            };

            PersistentState.prototype.onKeyDown = function (easel, event) {
                this._keyCodes[event.keyCode] = true;
                this._update(easel);
            };

            PersistentState.prototype.onKeyUp = function (easel, event) {
                this._keyCodes[event.keyCode] = false;
                this._update(easel);
            };

            PersistentState.prototype._update = function (easel) {
                easel.paused = this._paused;
                if (easel.getOption("paintViewport")) {
                    var w = GFX.viewportLoupeDiameter.value, h = GFX.viewportLoupeDiameter.value;
                    easel.viewport = new Rectangle(this._mousePosition.x - w / 2, this._mousePosition.y - h / 2, w, h);
                } else {
                    easel.viewport = null;
                }
            };
            return PersistentState;
        })(State);

        var MouseDownState = (function (_super) {
            __extends(MouseDownState, _super);
            function MouseDownState() {
                _super.apply(this, arguments);
                this._startTime = Date.now();
            }
            MouseDownState.prototype.onMouseMove = function (easel, event) {
                if (Date.now() - this._startTime < 10) {
                    return;
                }
                var frame = easel.queryFrameUnderMouse(event);
                if (frame && frame.hasCapability(1 /* AllowMatrixWrite */)) {
                    easel.state = new DragState(frame, easel.getMousePosition(event, null), frame.matrix.clone());
                }
            };

            MouseDownState.prototype.onMouseUp = function (easel, event) {
                easel.state = new StartState();
                easel.selectFrameUnderMouse(event);
            };
            return MouseDownState;
        })(State);

        var DragState = (function (_super) {
            __extends(DragState, _super);
            function DragState(target, startPosition, startMatrix) {
                _super.call(this);
                this._target = target;
                this._startPosition = startPosition;
                this._startMatrix = startMatrix;
            }
            DragState.prototype.onMouseMove = function (easel, event) {
                event.preventDefault();
                var p = easel.getMousePosition(event, null);
                p.sub(this._startPosition);
                this._target.matrix = this._startMatrix.clone().translate(p.x, p.y);
                easel.state = this;
            };
            DragState.prototype.onMouseUp = function (easel, event) {
                easel.state = new StartState();
            };
            return DragState;
        })(State);

        var Easel = (function () {
            function Easel(container, backend, disableHidpi) {
                if (typeof disableHidpi === "undefined") { disableHidpi = false; }
                this._state = new StartState();
                this._persistentState = new PersistentState();
                this.paused = false;
                this.viewport = null;
                this._selectedFrames = [];
                this._eventListeners = Shumway.ObjectUtilities.createEmptyObject();
                var stage = this._stage = new GFX.Stage(128, 128, true);
                this._worldView = new GFX.FrameContainer();
                this._worldViewOverlay = new GFX.FrameContainer();
                this._world = new GFX.FrameContainer();
                this._stage.addChild(this._worldView);
                this._worldView.addChild(this._world);
                this._worldView.addChild(this._worldViewOverlay);
                this._disableHidpi = disableHidpi;

                if (GFX.hud.value) {
                    var fpsCanvasContainer = document.createElement("div");
                    fpsCanvasContainer.style.position = "absolute";
                    fpsCanvasContainer.style.top = "0";
                    fpsCanvasContainer.style.width = "100%";
                    fpsCanvasContainer.style.height = "10px";
                    this._fpsCanvas = document.createElement("canvas");
                    fpsCanvasContainer.appendChild(this._fpsCanvas);
                    container.appendChild(fpsCanvasContainer);
                    this._fps = new FPS(this._fpsCanvas);
                } else {
                    this._fps = null;
                }

                window.addEventListener('resize', this._deferredResizeHandler.bind(this), false);

                var options = this._options = [];
                var canvases = this._canvases = [];
                var renderers = this._renderers = [];

                function addCanvas2DBackend() {
                    var canvas = document.createElement("canvas");
                    canvas.style.backgroundColor = "#14171a";
                    container.appendChild(canvas);
                    canvases.push(canvas);
                    var o = new GFX.Canvas2D.Canvas2DStageRendererOptions();
                    options.push(o);
                    renderers.push(new GFX.Canvas2D.Canvas2DStageRenderer(canvas, stage, o));
                }

                function addWebGLBackend() {
                    var canvas = document.createElement("canvas");
                    canvas.style.backgroundColor = "#14171a";
                    container.appendChild(canvas);
                    canvases.push(canvas);
                    var o = new WebGLStageRendererOptions();
                    options.push(o);
                    renderers.push(new WebGLStageRenderer(canvas, stage, o));
                }

                switch (backend) {
                    case 0 /* Canvas2D */:
                        addCanvas2DBackend();
                        break;
                    case 1 /* WebGL */:
                        addWebGLBackend();
                        break;
                    case 2 /* Both */:
                        addCanvas2DBackend();
                        addWebGLBackend();
                        break;
                }

                this._resizeHandler();
                this._onMouseUp = this._onMouseUp.bind(this);
                this._onMouseDown = this._onMouseDown.bind(this);
                this._onMouseMove = this._onMouseMove.bind(this);

                var self = this;

                window.addEventListener("mouseup", function (event) {
                    self._state.onMouseUp(self, event);
                    self._render();
                }, false);

                window.addEventListener("mousemove", function (event) {
                    var p = self.getMousePosition(event, self._world);
                    self._state.onMouseMove(self, event);
                    self._persistentState.onMouseMove(self, event);
                }, false);

                canvases.forEach(function (canvas) {
                    return canvas.addEventListener("mousedown", function (event) {
                        self._state.onMouseDown(self, event);
                    }, false);
                });

                window.addEventListener("keydown", function (event) {
                    self._state.onKeyDown(self, event);
                    self._persistentState.onKeyDown(self, event);
                }, false);

                window.addEventListener("keypress", function (event) {
                    self._state.onKeyPress(self, event);
                    self._persistentState.onKeyPress(self, event);
                }, false);

                window.addEventListener("keyup", function (event) {
                    self._state.onKeyUp(self, event);
                    self._persistentState.onKeyUp(self, event);
                }, false);

                this._enterRenderLoop();
            }
            /**
            * Primitive event dispatching features.
            */
            Easel.prototype.addEventListener = function (type, listener) {
                if (!this._eventListeners[type]) {
                    this._eventListeners[type] = [];
                }
                this._eventListeners[type].push(listener);
            };

            Easel.prototype._dispatchEvent = function (type) {
                var listeners = this._eventListeners[type];
                if (!listeners) {
                    return;
                }
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i]();
                }
            };

            Easel.prototype._enterRenderLoop = function () {
                var self = this;
                requestAnimationFrame(function tick() {
                    self.render();
                    requestAnimationFrame(tick);
                });
            };

            Object.defineProperty(Easel.prototype, "state", {
                set: function (state) {
                    this._state = state;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Easel.prototype, "cursor", {
                set: function (cursor) {
                    this._canvases.forEach(function (x) {
                        return x.style.cursor = cursor;
                    });
                },
                enumerable: true,
                configurable: true
            });

            Easel.prototype._render = function () {
                var mustRender = (this._stage.readyToRender() || GFX.forcePaint.value) && !this.paused;
                if (mustRender) {
                    for (var i = 0; i < this._renderers.length; i++) {
                        var renderer = this._renderers[i];
                        if (this.viewport) {
                            renderer.viewport = this.viewport;
                        } else {
                            renderer.viewport = new Rectangle(0, 0, this._canvases[i].width, this._canvases[i].height);
                        }
                        this._dispatchEvent("render");
                        GFX.enterTimeline("Render");
                        renderer.render();
                        GFX.leaveTimeline("Render");
                    }
                }
                if (this._fps) {
                    this._fps.tickAndRender(!mustRender);
                }
            };

            Easel.prototype.render = function () {
                this._render();
            };

            Object.defineProperty(Easel.prototype, "world", {
                get: function () {
                    return this._world;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Easel.prototype, "worldView", {
                get: function () {
                    return this._worldView;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Easel.prototype, "worldOverlay", {
                get: function () {
                    return this._worldViewOverlay;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Easel.prototype, "stage", {
                get: function () {
                    return this._stage;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Easel.prototype, "options", {
                get: function () {
                    return this._options[0];
                },
                enumerable: true,
                configurable: true
            });

            Easel.prototype.toggleOption = function (name) {
                for (var i = 0; i < this._options.length; i++) {
                    var option = this._options[i];
                    option[name] = !option[name];
                }
            };

            Easel.prototype.getOption = function (name) {
                return this._options[0][name];
            };

            Easel.prototype._deferredResizeHandler = function () {
                clearTimeout(this._deferredResizeHandlerTimeout);
                this._deferredResizeHandlerTimeout = setTimeout(this._resizeHandler.bind(this), 1000);
            };

            Easel.prototype._resizeHandler = function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var backingStoreRatio = 1;
                var ratio = 1;
                if (devicePixelRatio !== backingStoreRatio && !this._disableHidpi) {
                    ratio = devicePixelRatio / backingStoreRatio;
                }

                for (var i = 0; i < this._canvases.length; i++) {
                    var canvas = this._canvases[i];
                    var parent = canvas.parentElement;
                    var cw = parent.clientWidth;
                    var ch = (parent.clientHeight) / this._canvases.length;

                    if (ratio > 1) {
                        canvas.width = cw * ratio;
                        canvas.height = ch * ratio;
                        canvas.style.width = cw + 'px';
                        canvas.style.height = ch + 'px';
                    } else {
                        canvas.width = cw;
                        canvas.height = ch;
                    }
                    this._stage.w = canvas.width;
                    this._stage.h = canvas.height;
                    this._renderers[i].resize();
                }
                this._stage.matrix.set(new Matrix(ratio, 0, 0, ratio, 0, 0));
            };

            Easel.prototype.resize = function () {
                this._resizeHandler();
            };

            Easel.prototype.queryFrameUnderMouse = function (event) {
                var frames = this.stage.queryFramesByPoint(this.getMousePosition(event, null), true, true);
                return frames.length > 0 ? frames[0] : null;
            };

            Easel.prototype.selectFrameUnderMouse = function (event) {
                var frame = this.queryFrameUnderMouse(event);
                if (frame && frame.hasCapability(1 /* AllowMatrixWrite */)) {
                    this._selectedFrames.push(frame);
                } else {
                    this._selectedFrames = [];
                }
                this._render();
            };

            Easel.prototype.getMousePosition = function (event, coordinateSpace) {
                var canvas = this._canvases[0];
                var bRect = canvas.getBoundingClientRect();
                var x = (event.clientX - bRect.left) * (canvas.width / bRect.width);
                var y = (event.clientY - bRect.top) * (canvas.height / bRect.height);
                var p = new Point(x, y);
                if (!coordinateSpace) {
                    return p;
                }
                var m = Matrix.createIdentity();
                coordinateSpace.getConcatenatedMatrix().inverse(m);
                m.transformPoint(p);
                return p;
            };

            Easel.prototype.getMouseWorldPosition = function (event) {
                return this.getMousePosition(event, this._world);
            };

            Easel.prototype._onMouseDown = function (event) {
                this._renderers.forEach(function (renderer) {
                    return renderer.render();
                });
            };

            Easel.prototype._onMouseUp = function (event) {
            };

            Easel.prototype._onMouseMove = function (event) {
            };
            return Easel;
        })();
        GFX.Easel = Easel;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Rectangle = Shumway.GFX.Geometry.Rectangle;

        var Matrix = Shumway.GFX.Geometry.Matrix;

        (function (Layout) {
            Layout[Layout["Simple"] = 0] = "Simple";
        })(GFX.Layout || (GFX.Layout = {}));
        var Layout = GFX.Layout;

        var TreeStageRendererOptions = (function (_super) {
            __extends(TreeStageRendererOptions, _super);
            function TreeStageRendererOptions() {
                _super.apply(this, arguments);
                this.layout = 0 /* Simple */;
            }
            return TreeStageRendererOptions;
        })(GFX.StageRendererOptions);
        GFX.TreeStageRendererOptions = TreeStageRendererOptions;

        var TreeStageRenderer = (function (_super) {
            __extends(TreeStageRenderer, _super);
            function TreeStageRenderer(canvas, stage, options) {
                if (typeof options === "undefined") { options = new TreeStageRendererOptions(); }
                _super.call(this, canvas, stage, options);
                this.context = canvas.getContext("2d");
                this._viewport = new Rectangle(0, 0, canvas.width, canvas.height);
            }
            TreeStageRenderer.prototype.render = function () {
                var context = this.context;
                context.save();
                context.clearRect(0, 0, this._stage.w, this._stage.h);
                context.scale(1, 1);
                if (this._options.layout === 0 /* Simple */) {
                    this._renderFrameSimple(this.context, this._stage, Matrix.createIdentity(), this._viewport, []);
                }
                context.restore();
            };

            TreeStageRenderer.clearContext = function (context, rectangle) {
                var canvas = context.canvas;
                context.clearRect(rectangle.x, rectangle.y, rectangle.w, rectangle.h);
            };

            TreeStageRenderer.prototype._renderFrameSimple = function (context, root, transform, clipRectangle, cullRectanglesAABB) {
                var self = this;
                context.save();
                context.fillStyle = "white";
                var x = 0, y = 0;
                var w = 6, h = 2, hPadding = 1, wColPadding = 8;
                var colX = 0;
                var maxX = 0;
                function visit(frame) {
                    var isFrameContainer = frame instanceof GFX.FrameContainer;
                    if (frame._hasFlags(512 /* InvalidPaint */)) {
                        context.fillStyle = "red";
                    } else if (frame._hasFlags(64 /* InvalidConcatenatedMatrix */)) {
                        context.fillStyle = "blue";
                    } else {
                        context.fillStyle = "white";
                    }
                    var t = isFrameContainer ? 2 : w;
                    context.fillRect(x, y, t, h);
                    if (isFrameContainer) {
                        x += t + 2;
                        maxX = Math.max(maxX, x + w);
                        var frameContainer = frame;
                        var children = frameContainer._children;
                        for (var i = 0; i < children.length; i++) {
                            visit(children[i]);
                            if (i < children.length - 1) {
                                y += h + hPadding;
                                if (y > self._canvas.height) {
                                    context.fillStyle = "gray";
                                    context.fillRect(maxX + 4, 0, 2, self._canvas.height);
                                    x = x - colX + maxX + wColPadding;
                                    colX = maxX + wColPadding;
                                    y = 0;
                                    context.fillStyle = "white";
                                }
                            }
                        }
                        x -= t + 2;
                    }
                }
                visit(root);
                context.restore();
            };
            return TreeStageRenderer;
        })(GFX.StageRenderer);
        GFX.TreeStageRenderer = TreeStageRenderer;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Remoting) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (GFX) {
            var FrameFlags = Shumway.GFX.FrameFlags;
            var Shape = Shumway.GFX.Shape;

            var RenderableShape = Shumway.GFX.RenderableShape;
            var RenderableBitmap = Shumway.GFX.RenderableBitmap;
            var RenderableText = Shumway.GFX.RenderableText;
            var ColorMatrix = Shumway.GFX.ColorMatrix;
            var FrameContainer = Shumway.GFX.FrameContainer;
            var ClipRectangle = Shumway.GFX.ClipRectangle;
            var ShapeData = Shumway.ShapeData;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

            var Matrix = Shumway.GFX.Geometry.Matrix;
            var Rectangle = Shumway.GFX.Geometry.Rectangle;

            var assert = Shumway.Debug.assert;
            var writer = null;

            var GFXChannelSerializer = (function () {
                function GFXChannelSerializer() {
                }
                GFXChannelSerializer.prototype.writeMouseEvent = function (event, point) {
                    var output = this.output;
                    output.writeInt(300 /* MouseEvent */);
                    var typeId = Shumway.Remoting.MouseEventNames.indexOf(event.type);
                    output.writeInt(typeId);
                    output.writeFloat(point.x);
                    output.writeFloat(point.y);
                    output.writeInt(event.buttons);
                    var flags = (event.ctrlKey ? 1 /* CtrlKey */ : 0) | (event.altKey ? 2 /* AltKey */ : 0) | (event.shiftKey ? 4 /* ShiftKey */ : 0);
                    output.writeInt(flags);
                };

                GFXChannelSerializer.prototype.writeKeyboardEvent = function (event) {
                    var output = this.output;
                    output.writeInt(301 /* KeyboardEvent */);
                    var typeId = Shumway.Remoting.KeyboardEventNames.indexOf(event.type);
                    output.writeInt(typeId);
                    output.writeInt(event.keyCode);
                    output.writeInt(event.charCode);
                    output.writeInt(event.location);
                    var flags = (event.ctrlKey ? 1 /* CtrlKey */ : 0) | (event.altKey ? 2 /* AltKey */ : 0) | (event.shiftKey ? 4 /* ShiftKey */ : 0);
                    output.writeInt(flags);
                };

                GFXChannelSerializer.prototype.writeFocusEvent = function (type) {
                    var output = this.output;
                    output.writeInt(302 /* FocusEvent */);
                    output.writeInt(type);
                };
                return GFXChannelSerializer;
            })();
            GFX.GFXChannelSerializer = GFXChannelSerializer;

            var GFXChannelDeserializerContext = (function () {
                function GFXChannelDeserializerContext(root) {
                    this.root = new ClipRectangle(128, 128);
                    root.addChild(this.root);
                    this._frames = [];
                    this._assets = [];
                }
                GFXChannelDeserializerContext.prototype._registerAsset = function (id, symbolId, asset) {
                    if (typeof registerInspectorAsset !== "undefined") {
                        registerInspectorAsset(id, symbolId, asset);
                    }
                    this._assets[id] = asset;
                };

                GFXChannelDeserializerContext.prototype._makeFrame = function (id) {
                    if (id === -1) {
                        return null;
                    }
                    var frame = null;
                    if (id & 134217728 /* Asset */) {
                        id &= ~134217728 /* Asset */;
                        frame = new Shape(this._assets[id]);
                        this._assets[id].addFrameReferrer(frame);
                    } else {
                        frame = this._frames[id];
                    }
                    release || assert(frame, "Frame ", frame, " of ", id, " has not been sent yet.");
                    return frame;
                };

                GFXChannelDeserializerContext.prototype._getAsset = function (id) {
                    return this._assets[id];
                };

                GFXChannelDeserializerContext.prototype._getBitmapAsset = function (id) {
                    return this._assets[id];
                };

                GFXChannelDeserializerContext.prototype._getTextAsset = function (id) {
                    return this._assets[id];
                };
                return GFXChannelDeserializerContext;
            })();
            GFX.GFXChannelDeserializerContext = GFXChannelDeserializerContext;

            var GFXChannelDeserializer = (function () {
                function GFXChannelDeserializer() {
                }
                GFXChannelDeserializer.prototype.read = function () {
                    var tag = 0;
                    var input = this.input;

                    var data = {
                        bytesAvailable: input.bytesAvailable,
                        updateGraphics: 0,
                        updateBitmapData: 0,
                        updateTextContent: 0,
                        updateFrame: 0,
                        updateStage: 0,
                        registerFont: 0,
                        drawToBitmap: 0
                    };
                    Shumway.GFX.enterTimeline("GFXChannelDeserializer.read", data);
                    while (input.bytesAvailable > 0) {
                        tag = input.readInt();
                        switch (tag) {
                            case 0 /* EOF */:
                                Shumway.GFX.leaveTimeline("GFXChannelDeserializer.read");
                                return;
                            case 101 /* UpdateGraphics */:
                                data.updateGraphics++;
                                this._readUpdateGraphics();
                                break;
                            case 102 /* UpdateBitmapData */:
                                data.updateBitmapData++;
                                this._readUpdateBitmapData();
                                break;
                            case 103 /* UpdateTextContent */:
                                data.updateTextContent++;
                                this._readUpdateTextContent();
                                break;
                            case 100 /* UpdateFrame */:
                                data.updateFrame++;
                                this._readUpdateFrame();
                                break;
                            case 104 /* UpdateStage */:
                                data.updateStage++;
                                this._readUpdateStage();
                                break;
                            case 200 /* RegisterFont */:
                                data.registerFont++;
                                this._readRegisterFont();
                                break;
                            case 201 /* DrawToBitmap */:
                                data.drawToBitmap++;
                                this._readDrawToBitmap();
                                break;
                            case 105 /* RequestBitmapData */:
                                data.drawToBitmap++;
                                this._readRequestBitmapData();
                                break;
                            default:
                                release || assert(false, 'Unknown MessageReader tag: ' + tag);
                                break;
                        }
                    }
                    Shumway.GFX.leaveTimeline("GFXChannelDeserializer.read");
                };

                GFXChannelDeserializer.prototype._readMatrix = function () {
                    var input = this.input;
                    return new Matrix(input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat() / 20, input.readFloat() / 20);
                };

                GFXChannelDeserializer.prototype._readRectangle = function () {
                    var input = this.input;
                    return new Rectangle(input.readInt() / 20, input.readInt() / 20, input.readInt() / 20, input.readInt() / 20);
                };

                GFXChannelDeserializer.prototype._readColorMatrix = function () {
                    var input = this.input;
                    var rm = 1, gm = 1, bm = 1, am = 1;
                    var ro = 0, go = 0, bo = 0, ao = 0;
                    switch (input.readInt()) {
                        case 0 /* Identity */:
                            break;
                        case 1 /* AlphaMultiplierOnly */:
                            am = input.readFloat();
                            break;
                        case 2 /* All */:
                            rm = input.readFloat();
                            gm = input.readFloat();
                            bm = input.readFloat();
                            am = input.readFloat();
                            ro = input.readInt();
                            go = input.readInt();
                            bo = input.readInt();
                            ao = input.readInt();
                            break;
                    }
                    return ColorMatrix.fromMultipliersAndOffsets(rm, gm, bm, am, ro, go, bo, ao);
                };

                GFXChannelDeserializer.prototype._popAsset = function () {
                    var assetId = this.input.readInt();
                    var asset = this.inputAssets[assetId];
                    this.inputAssets[assetId] = null;
                    return asset;
                };

                GFXChannelDeserializer.prototype._readUpdateGraphics = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var symbolId = input.readInt();
                    var asset = context._getAsset(id);
                    var bounds = this._readRectangle();
                    var pathData = ShapeData.FromPlainObject(this._popAsset());
                    var numTextures = input.readInt();
                    var textures = [];
                    for (var i = 0; i < numTextures; i++) {
                        var bitmapId = input.readInt();
                        textures.push(context._getBitmapAsset(bitmapId));
                    }
                    if (asset) {
                        asset.update(pathData, textures, bounds);
                    } else {
                        var renderable = new RenderableShape(id, pathData, textures, bounds);
                        for (var i = 0; i < textures.length; i++) {
                            textures[i].addRenderableReferrer(renderable);
                        }
                        context._registerAsset(id, symbolId, renderable);
                    }
                };

                GFXChannelDeserializer.prototype._readUpdateBitmapData = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var symbolId = input.readInt();
                    var asset = context._getBitmapAsset(id);
                    var bounds = this._readRectangle();
                    var type = input.readInt();
                    var dataBuffer = DataBuffer.FromPlainObject(this._popAsset());
                    if (!asset) {
                        asset = RenderableBitmap.FromDataBuffer(type, dataBuffer, bounds);
                        context._registerAsset(id, symbolId, asset);
                    } else {
                        asset.updateFromDataBuffer(type, dataBuffer);
                    }
                    if (this.output) {
                        // TODO: Write image data to output.
                    }
                };

                GFXChannelDeserializer.prototype._readUpdateTextContent = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var symbolId = input.readInt();
                    var asset = context._getTextAsset(id);
                    var bounds = this._readRectangle();
                    var matrix = this._readMatrix();
                    var backgroundColor = input.readInt();
                    var borderColor = input.readInt();
                    var autoSize = input.readInt();
                    var wordWrap = input.readBoolean();
                    var plainText = this._popAsset();
                    var textRunData = DataBuffer.FromPlainObject(this._popAsset());
                    var coords = null;
                    var numCoords = input.readInt();
                    if (numCoords) {
                        coords = new DataBuffer(numCoords * 4);
                        input.readBytes(coords, 0, numCoords * 4);
                    }
                    if (!asset) {
                        asset = new RenderableText(bounds);
                        asset.setContent(plainText, textRunData, matrix, coords);
                        asset.setStyle(backgroundColor, borderColor);
                        asset.reflow(autoSize, wordWrap);
                        context._registerAsset(id, symbolId, asset);
                    } else {
                        asset.setBounds(bounds);
                        asset.setContent(plainText, textRunData, matrix, coords);
                        asset.setStyle(backgroundColor, borderColor);
                        asset.reflow(autoSize, wordWrap);
                    }
                    if (this.output) {
                        var rect = asset.textRect;
                        this.output.writeInt(rect.w * 20);
                        this.output.writeInt(rect.h * 20);
                        this.output.writeInt(rect.x * 20);
                        var lines = asset.lines;
                        var numLines = lines.length;
                        this.output.writeInt(numLines);
                        for (var i = 0; i < numLines; i++) {
                            this._writeLineMetrics(lines[i]);
                        }
                    }
                };

                GFXChannelDeserializer.prototype._writeLineMetrics = function (line) {
                    release || assert(this.output);
                    this.output.writeInt(line.x);
                    this.output.writeInt(line.width);
                    this.output.writeInt(line.ascent);
                    this.output.writeInt(line.descent);
                    this.output.writeInt(line.leading);
                };

                GFXChannelDeserializer.prototype._readUpdateStage = function () {
                    var context = this.context;
                    var id = this.input.readInt();
                    if (!context._frames[id]) {
                        context._frames[id] = context.root;
                    }
                    var color = this.input.readInt();
                    var rectangle = this._readRectangle();
                    context.root.setBounds(rectangle);
                    context.root.color = Shumway.Color.FromARGB(color);
                };

                GFXChannelDeserializer.prototype._readUpdateFrame = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    writer && writer.writeLn("Receiving UpdateFrame: " + id);
                    var frame = context._frames[id];
                    if (!frame) {
                        frame = context._frames[id] = new FrameContainer();
                    }

                    var hasBits = input.readInt();
                    if (hasBits & 1 /* HasMatrix */) {
                        frame.matrix = this._readMatrix();
                    }
                    if (hasBits & 8 /* HasColorTransform */) {
                        frame.colorMatrix = this._readColorMatrix();
                    }
                    if (hasBits & 64 /* HasMask */) {
                        frame.mask = context._makeFrame(input.readInt());
                    }
                    if (hasBits & 128 /* HasClip */) {
                        frame.clip = input.readInt();
                    }
                    if (hasBits & 32 /* HasMiscellaneousProperties */) {
                        frame.blendMode = input.readInt();
                        frame._toggleFlags(16384 /* Visible */, input.readBoolean());
                        frame.pixelSnapping = input.readInt();
                        frame.smoothing = input.readInt();
                    }
                    if (hasBits & 4 /* HasChildren */) {
                        var count = input.readInt();
                        var container = frame;
                        container.clearChildren();
                        for (var i = 0; i < count; i++) {
                            var childId = input.readInt();
                            var child = context._makeFrame(childId);
                            release || assert(child, "Child ", childId, " of ", id, " has not been sent yet.");
                            container.addChild(child);
                        }
                    }
                };

                GFXChannelDeserializer.prototype._readRegisterFont = function () {
                    var input = this.input;
                    var fontId = input.readInt();
                    var bold = input.readBoolean();
                    var italic = input.readBoolean();
                    var data = this._popAsset();
                    var head = document.head;
                    head.insertBefore(document.createElement('style'), head.firstChild);
                    var style = document.styleSheets[0];
                    style.insertRule('@font-face{' + 'font-family:swffont' + fontId + ';' + 'src:url(data:font/opentype;base64,' + Shumway.StringUtilities.base64ArrayBuffer(data.buffer) + ')' + '}', style.cssRules.length);
                };

                GFXChannelDeserializer.prototype._readDrawToBitmap = function () {
                    var input = this.input;
                    var context = this.context;
                    var targetId = input.readInt();
                    var sourceId = input.readInt();
                    var hasBits = input.readInt();
                    var matrix;
                    var colorMatrix;
                    var clipRect;
                    if (hasBits & 1 /* HasMatrix */) {
                        matrix = this._readMatrix();
                    } else {
                        matrix = Matrix.createIdentity();
                    }
                    if (hasBits & 8 /* HasColorTransform */) {
                        colorMatrix = this._readColorMatrix();
                    }
                    if (hasBits & 16 /* HasClipRect */) {
                        clipRect = this._readRectangle();
                    }
                    var blendMode = input.readInt();
                    input.readBoolean(); // Smoothing
                    var target = context._getBitmapAsset(targetId);
                    var source = context._makeFrame(sourceId);
                    if (!target) {
                        context._registerAsset(targetId, -1, RenderableBitmap.FromFrame(source, matrix, colorMatrix, blendMode, clipRect));
                    } else {
                        target.drawFrame(source, matrix, colorMatrix, blendMode, clipRect);
                    }
                };

                GFXChannelDeserializer.prototype._readRequestBitmapData = function () {
                    var input = this.input;
                    var output = this.output;
                    var context = this.context;
                    var id = input.readInt();
                    var renderableBitmap = context._getBitmapAsset(id);
                    renderableBitmap.readImageData(output);
                };
                return GFXChannelDeserializer;
            })();
            GFX.GFXChannelDeserializer = GFXChannelDeserializer;
        })(Remoting.GFX || (Remoting.GFX = {}));
        var GFX = Remoting.GFX;
    })(Shumway.Remoting || (Shumway.Remoting = {}));
    var Remoting = Shumway.Remoting;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        var Point = Shumway.GFX.Geometry.Point;

        var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

        var EaselHost = (function () {
            function EaselHost(easel) {
                this._easel = easel;
                var frameContainer = easel.world;
                this._frameContainer = frameContainer;
                this._context = new Shumway.Remoting.GFX.GFXChannelDeserializerContext(this._frameContainer);

                this._addEventListeners();
            }
            EaselHost.prototype.onSendEventUpdates = function (update) {
                throw new Error('This method is abstract');
            };

            Object.defineProperty(EaselHost.prototype, "stage", {
                get: function () {
                    return this._easel.stage;
                },
                enumerable: true,
                configurable: true
            });

            EaselHost.prototype._mouseEventListener = function (event) {
                var position = this._easel.getMouseWorldPosition(event);
                var point = new Point(position.x, position.y);

                var buffer = new DataBuffer();
                var serializer = new Shumway.Remoting.GFX.GFXChannelSerializer();
                serializer.output = buffer;
                serializer.writeMouseEvent(event, point);
                this.onSendEventUpdates(buffer);
            };

            EaselHost.prototype._keyboardEventListener = function (event) {
                var buffer = new DataBuffer();
                var serializer = new Shumway.Remoting.GFX.GFXChannelSerializer();
                serializer.output = buffer;
                serializer.writeKeyboardEvent(event);
                this.onSendEventUpdates(buffer);
            };

            EaselHost.prototype._addEventListeners = function () {
                var mouseEventListener = this._mouseEventListener.bind(this);
                var keyboardEventListener = this._keyboardEventListener.bind(this);
                var mouseEvents = EaselHost._mouseEvents;
                for (var i = 0; i < mouseEvents.length; i++) {
                    window.addEventListener(mouseEvents[i], mouseEventListener);
                }
                var keyboardEvents = EaselHost._keyboardEvents;
                for (var i = 0; i < keyboardEvents.length; i++) {
                    window.addEventListener(keyboardEvents[i], keyboardEventListener);
                }
                this._addFocusEventListeners();
            };

            EaselHost.prototype._sendFocusEvent = function (type) {
                var buffer = new DataBuffer();
                var serializer = new Shumway.Remoting.GFX.GFXChannelSerializer();
                serializer.output = buffer;
                serializer.writeFocusEvent(type);
                this.onSendEventUpdates(buffer);
            };

            EaselHost.prototype._addFocusEventListeners = function () {
                var self = this;
                document.addEventListener('visibilitychange', function (event) {
                    self._sendFocusEvent(document.hidden ? 0 /* DocumentHidden */ : 1 /* DocumentVisible */);
                });
                window.addEventListener('focus', function (event) {
                    self._sendFocusEvent(3 /* WindowFocus */);
                });
                window.addEventListener('blur', function (event) {
                    self._sendFocusEvent(2 /* WindowBlur */);
                });
            };

            EaselHost.prototype.processUpdates = function (updates, assets, output) {
                if (typeof output === "undefined") { output = null; }
                var deserializer = new Shumway.Remoting.GFX.GFXChannelDeserializer();
                deserializer.input = updates;
                deserializer.inputAssets = assets;
                deserializer.output = output;
                deserializer.context = this._context;
                deserializer.read();
            };

            EaselHost.prototype.processExternalCommand = function (command) {
                if (command.action === 'isEnabled') {
                    command.result = false;
                    return;
                }
                throw new Error('This command is not supported');
            };

            EaselHost.prototype.processFrame = function () {
            };

            EaselHost.prototype.onExernalCallback = function (request) {
                throw new Error('This method is abstract');
            };

            EaselHost.prototype.sendExernalCallback = function (functionName, args) {
                var request = {
                    functionName: functionName,
                    args: args
                };
                this.onExernalCallback(request);
                if (request.error) {
                    throw new Error(request.error);
                }
                return request.result;
            };
            EaselHost._mouseEvents = Shumway.Remoting.MouseEventNames;
            EaselHost._keyboardEvents = Shumway.Remoting.KeyboardEventNames;
            return EaselHost;
        })();
        GFX.EaselHost = EaselHost;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (Window) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

            var CircularBuffer = Shumway.CircularBuffer;
            var TimelineBuffer = Shumway.Tools.Profiler.TimelineBuffer;

            var WindowEaselHost = (function (_super) {
                __extends(WindowEaselHost, _super);
                function WindowEaselHost(easel, playerWindow, window) {
                    _super.call(this, easel);
                    this._timelineRequests = Object.create(null);
                    this._playerWindow = playerWindow;
                    this._window = window;
                    this._window.addEventListener('message', function (e) {
                        this.onWindowMessage(e.data);
                    }.bind(this));
                    this._window.addEventListener('syncmessage', function (e) {
                        this.onWindowMessage(e.detail, false);
                    }.bind(this));
                }
                WindowEaselHost.prototype.onSendEventUpdates = function (updates) {
                    var bytes = updates.getBytes();
                    this._playerWindow.postMessage({
                        type: 'gfx',
                        updates: bytes
                    }, '*', [bytes.buffer]);
                };

                WindowEaselHost.prototype.onExernalCallback = function (request) {
                    var event = this._playerWindow.document.createEvent('CustomEvent');
                    event.initCustomEvent('syncmessage', false, false, {
                        type: 'externalCallback',
                        request: request
                    });
                    this._playerWindow.dispatchEvent(event);
                };

                WindowEaselHost.prototype.requestTimeline = function (type, cmd) {
                    return new Promise(function (resolve) {
                        this._timelineRequests[type] = resolve;
                        this._playerWindow.postMessage({
                            type: 'timeline',
                            cmd: cmd,
                            request: type
                        }, '*');
                    }.bind(this));
                };

                WindowEaselHost.prototype.onWindowMessage = function (data, async) {
                    if (typeof async === "undefined") { async = true; }
                    if (typeof data === 'object' && data !== null) {
                        if (data.type === 'player') {
                            var updates = DataBuffer.FromArrayBuffer(data.updates.buffer);
                            if (async) {
                                this.processUpdates(updates, data.assets);
                            } else {
                                var output = new DataBuffer();
                                this.processUpdates(updates, data.assets, output);
                                data.result = output.toPlainObject();
                            }
                        } else if (data.type === 'frame') {
                            this.processFrame();
                        } else if (data.type === 'external') {
                            this.processExternalCommand(data.request);
                        } else if (data.type === 'timelineResponse' && data.timeline) {
                            // Transform timeline into a Timeline object.
                            data.timeline.__proto__ = TimelineBuffer.prototype;
                            data.timeline._marks.__proto__ = CircularBuffer.prototype;
                            data.timeline._times.__proto__ = CircularBuffer.prototype;
                            this._timelineRequests[data.request](data.timeline);
                        }
                    }
                };
                return WindowEaselHost;
            })(GFX.EaselHost);
            Window.WindowEaselHost = WindowEaselHost;
        })(GFX.Window || (GFX.Window = {}));
        var Window = GFX.Window;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

var Shumway;
(function (Shumway) {
    (function (GFX) {
        (function (Test) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

            var TestEaselHost = (function (_super) {
                __extends(TestEaselHost, _super);
                function TestEaselHost(easel) {
                    _super.call(this, easel);

                    // TODO this is temporary worker to test postMessage tranfers
                    this._worker = Shumway.Player.Test.FakeSyncWorker.instance;
                    this._worker.addEventListener('message', this._onWorkerMessage.bind(this));
                    this._worker.addEventListener('syncmessage', this._onSyncWorkerMessage.bind(this));
                }
                TestEaselHost.prototype.onSendEventUpdates = function (updates) {
                    var bytes = updates.getBytes();
                    this._worker.postMessage({
                        type: 'gfx',
                        updates: bytes
                    }, [bytes.buffer]);
                };

                TestEaselHost.prototype.onExernalCallback = function (request) {
                    this._worker.postSyncMessage({
                        type: 'externalCallback',
                        request: request
                    });
                };

                TestEaselHost.prototype.requestTimeline = function (type, cmd) {
                    var buffer;
                    switch (type) {
                        case 'AVM2':
                            buffer = Shumway.AVM2.timelineBuffer;
                            break;
                        case 'Player':
                            buffer = Shumway.Player.timelineBuffer;
                            break;
                        case 'SWF':
                            buffer = Shumway.SWF.timelineBuffer;
                            break;
                    }
                    if (cmd === 'clear' && buffer) {
                        buffer.reset();
                    }
                    return Promise.resolve(buffer);
                };

                TestEaselHost.prototype._onWorkerMessage = function (e, async) {
                    if (typeof async === "undefined") { async = true; }
                    var data = e.data;
                    if (typeof data !== 'object' || data === null) {
                        return;
                    }
                    var type = data.type;
                    switch (type) {
                        case 'player':
                            var updates = DataBuffer.FromArrayBuffer(data.updates.buffer);
                            if (async) {
                                this.processUpdates(updates, data.assets);
                            } else {
                                var output = new DataBuffer();
                                this.processUpdates(updates, data.assets, output);
                                return output.toPlainObject();
                            }
                            break;
                        case 'frame':
                            this.processFrame();
                            break;
                        case 'external':
                            this.processExternalCommand(data.command);
                            break;
                    }
                };

                TestEaselHost.prototype._onSyncWorkerMessage = function (e) {
                    return this._onWorkerMessage(e, false);
                };
                return TestEaselHost;
            })(GFX.EaselHost);
            Test.TestEaselHost = TestEaselHost;
        })(GFX.Test || (GFX.Test = {}));
        var Test = GFX.Test;
    })(Shumway.GFX || (Shumway.GFX = {}));
    var GFX = Shumway.GFX;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
/// <reference path='../../build/ts/gfx-base.d.ts' />
/// <reference path='gl/glContext.ts'/>
/// <reference path='gl/core.ts'/>
/// <reference path='gl/surface.ts'/>
/// <reference path='gl/gl.ts'/>
/// <reference path='gl/brush.ts'/>
/// <reference path='2d/debug.ts'/>
/// <reference path='2d/surface.ts'/>
/// <reference path='2d/2d.ts'/>
/// <reference path='dom/dom.ts'/>
/// <reference path='easel.ts'/>
/// <reference path='debug/tree.ts'/>
/// <reference path='remotingGfx.ts' />
/// <reference path='easelHost.ts' />
/// <reference path='window/windowEaselHost.ts' />
/// <reference path='test/testEaselHost.ts' />
//# sourceMappingURL=gfx.js.map

console.timeEnd("Load GFX Dependencies");
// Manifest parser
console.time("Load Parser Dependencies");
console.timeEnd("Load Parser Dependencies");
console.time("Load SWF Parser");
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        SWF.timelineBuffer = new Shumway.Tools.Profiler.TimelineBuffer("Parser");

        function enterTimeline(name, data) {
            profile && SWF.timelineBuffer && SWF.timelineBuffer.enter(name, data);
        }
        SWF.enterTimeline = enterTimeline;

        function leaveTimeline(data) {
            profile && SWF.timelineBuffer && SWF.timelineBuffer.leave(null, data);
        }
        SWF.leaveTimeline = leaveTimeline;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var pow = Math.pow;
            var fromCharCode = String.fromCharCode;
            var slice = Array.prototype.slice;

            function readSi8($bytes, $stream) {
                return $stream.getInt8($stream.pos++);
            }
            Parser.readSi8 = readSi8;

            function readSi16($bytes, $stream) {
                return $stream.getInt16($stream.pos, $stream.pos += 2);
            }
            Parser.readSi16 = readSi16;

            function readSi32($bytes, $stream) {
                return $stream.getInt32($stream.pos, $stream.pos += 4);
            }
            Parser.readSi32 = readSi32;

            function readUi8($bytes, $stream) {
                return $bytes[$stream.pos++];
            }
            Parser.readUi8 = readUi8;

            function readUi16($bytes, $stream) {
                return $stream.getUint16($stream.pos, $stream.pos += 2);
            }
            Parser.readUi16 = readUi16;

            function readUi32($bytes, $stream) {
                return $stream.getUint32($stream.pos, $stream.pos += 4);
            }
            Parser.readUi32 = readUi32;

            function readFixed($bytes, $stream) {
                return $stream.getInt32($stream.pos, $stream.pos += 4) / 65536;
            }
            Parser.readFixed = readFixed;

            function readFixed8($bytes, $stream) {
                return $stream.getInt16($stream.pos, $stream.pos += 2) / 256;
            }
            Parser.readFixed8 = readFixed8;

            function readFloat16($bytes, $stream) {
                var ui16 = $stream.getUint16($stream.pos);
                $stream.pos += 2;
                var sign = ui16 >> 15 ? -1 : 1;
                var exponent = (ui16 & 0x7c00) >> 10;
                var fraction = ui16 & 0x03ff;
                if (!exponent)
                    return sign * pow(2, -14) * (fraction / 1024);
                if (exponent === 0x1f)
                    return fraction ? NaN : sign * Infinity;
                return sign * pow(2, exponent - 15) * (1 + (fraction / 1024));
            }
            Parser.readFloat16 = readFloat16;

            function readFloat($bytes, $stream) {
                return $stream.getFloat32($stream.pos, $stream.pos += 4);
            }
            Parser.readFloat = readFloat;

            function readDouble($bytes, $stream) {
                return $stream.getFloat64($stream.pos, $stream.pos += 8);
            }
            Parser.readDouble = readDouble;

            function readEncodedU32($bytes, $stream) {
                var val = $bytes[$stream.pos++];
                if (!(val & 0x080))
                    return val;
                val |= $bytes[$stream.pos++] << 7;
                if (!(val & 0x4000))
                    return val;
                val |= $bytes[$stream.pos++] << 14;
                if (!(val & 0x200000))
                    return val;
                val |= $bytes[$stream.pos++] << 21;
                if (!(val & 0x10000000))
                    return val;
                return val | ($bytes[$stream.pos++] << 28);
            }
            Parser.readEncodedU32 = readEncodedU32;

            function readBool($bytes, $stream) {
                return !!$bytes[$stream.pos++];
            }
            Parser.readBool = readBool;

            function align($bytes, $stream) {
                $stream.align();
            }
            Parser.align = align;

            function readSb($bytes, $stream, size) {
                return (readUb($bytes, $stream, size) << (32 - size)) >> (32 - size);
            }
            Parser.readSb = readSb;

            var masks = new Uint32Array(33);
            for (var i = 1, mask = 0; i <= 32; ++i) {
                masks[i] = mask = (mask << 1) | 1;
            }

            function readUb($bytes, $stream, size) {
                var buffer = $stream.bitBuffer;
                var bitlen = $stream.bitLength;
                while (size > bitlen) {
                    buffer = (buffer << 8) | $bytes[$stream.pos++];
                    bitlen += 8;
                }
                bitlen -= size;
                var val = (buffer >>> bitlen) & masks[size];
                $stream.bitBuffer = buffer;
                $stream.bitLength = bitlen;
                return val;
            }
            Parser.readUb = readUb;

            function readFb($bytes, $stream, size) {
                return readSb($bytes, $stream, size) / 65536;
            }
            Parser.readFb = readFb;

            function readString($bytes, $stream, length) {
                var codes;
                var pos = $stream.pos;
                if (length) {
                    codes = $bytes.subarray(pos, pos += length);
                } else {
                    length = 0;
                    for (var i = pos; $bytes[i]; i++) {
                        length++;
                    }
                    codes = $bytes.subarray(pos, pos += length);
                    pos++;
                }
                $stream.pos = pos;
                var str = Shumway.StringUtilities.utf8encode(codes);
                if (str.indexOf('\0') >= 0) {
                    str = str.split('\0').join('');
                }
                return str;
            }
            Parser.readString = readString;

            function readBinary($bytes, $stream, size, temporaryUsage) {
                if (!size) {
                    size = $stream.end - $stream.pos;
                }
                var subArray = $bytes.subarray($stream.pos, $stream.pos = ($stream.pos + size));
                if (temporaryUsage) {
                    return subArray;
                }
                var result = new Uint8Array(size);
                result.set(subArray);
                return result;
            }
            Parser.readBinary = readBinary;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            function defineShape($bytes, $stream, output, swfVersion, tagCode) {
                output || (output = {});
                output.id = Parser.readUi16($bytes, $stream);
                var lineBounds = output.lineBounds = {};
                bbox($bytes, $stream, lineBounds, swfVersion, tagCode);
                var isMorph = output.isMorph = tagCode === 46 || tagCode === 84;
                if (isMorph) {
                    var lineBoundsMorph = output.lineBoundsMorph = {};
                    bbox($bytes, $stream, lineBoundsMorph, swfVersion, tagCode);
                }
                var canHaveStrokes = output.canHaveStrokes = tagCode === 83 || tagCode === 84;
                if (canHaveStrokes) {
                    var fillBounds = output.fillBounds = {};
                    bbox($bytes, $stream, fillBounds, swfVersion, tagCode);
                    if (isMorph) {
                        var fillBoundsMorph = output.fillBoundsMorph = {};
                        bbox($bytes, $stream, fillBoundsMorph, swfVersion, tagCode);
                    }
                    output.flags = Parser.readUi8($bytes, $stream);
                }
                if (isMorph) {
                    output.offsetMorph = Parser.readUi32($bytes, $stream);
                    morphShapeWithStyle($bytes, $stream, output, swfVersion, tagCode, isMorph, canHaveStrokes);
                } else {
                    shapeWithStyle($bytes, $stream, output, swfVersion, tagCode, isMorph, canHaveStrokes);
                }
                return output;
            }

            function placeObject($bytes, $stream, $, swfVersion, tagCode) {
                var flags;
                $ || ($ = {});
                if (tagCode > 4 /* CODE_PLACE_OBJECT */) {
                    flags = $.flags = tagCode > 26 /* CODE_PLACE_OBJECT2 */ ? Parser.readUi16($bytes, $stream) : Parser.readUi8($bytes, $stream);
                    $.depth = Parser.readUi16($bytes, $stream);
                    if (flags & 2048 /* HasClassName */) {
                        $.className = Parser.readString($bytes, $stream, 0);
                    }
                    if (flags & 2 /* HasCharacter */) {
                        $.symbolId = Parser.readUi16($bytes, $stream);
                    }
                    if (flags & 4 /* HasMatrix */) {
                        var $0 = $.matrix = {};
                        matrix($bytes, $stream, $0, swfVersion, tagCode);
                    }
                    if (flags & 8 /* HasColorTransform */) {
                        var $1 = $.cxform = {};
                        cxform($bytes, $stream, $1, swfVersion, tagCode);
                    }
                    if (flags & 16 /* HasRatio */) {
                        $.ratio = Parser.readUi16($bytes, $stream);
                    }
                    if (flags & 32 /* HasName */) {
                        $.name = Parser.readString($bytes, $stream, 0);
                    }
                    if (flags & 64 /* HasClipDepth */) {
                        $.clipDepth = Parser.readUi16($bytes, $stream);
                    }
                    if (flags & 256 /* HasFilterList */) {
                        var count = Parser.readUi8($bytes, $stream);
                        var $2 = $.filters = [];
                        var $3 = count;
                        while ($3--) {
                            var $4 = {};
                            anyFilter($bytes, $stream, $4, swfVersion, tagCode);
                            $2.push($4);
                        }
                    }
                    if (flags & 512 /* HasBlendMode */) {
                        $.blendMode = Parser.readUi8($bytes, $stream);
                    }
                    if (flags & 1024 /* HasCacheAsBitmap */) {
                        $.bmpCache = Parser.readUi8($bytes, $stream);
                    }
                    if (flags & 128 /* HasClipActions */) {
                        var reserved = Parser.readUi16($bytes, $stream);
                        if (swfVersion >= 6) {
                            var allFlags = Parser.readUi32($bytes, $stream);
                        } else {
                            var allFlags = Parser.readUi16($bytes, $stream);
                        }
                        var $28 = $.events = [];
                        do {
                            var $29 = {};
                            var eoe = events($bytes, $stream, $29, swfVersion, tagCode);
                            $28.push($29);
                        } while(!eoe);
                    }
                    if (flags & 1024 /* OpaqueBackground */) {
                        $.backgroundColor = argb($bytes, $stream);
                    }
                    if (flags & 512 /* HasVisible */) {
                        $.visibility = Parser.readUi8($bytes, $stream);
                    }
                } else {
                    $.symbolId = Parser.readUi16($bytes, $stream);
                    $.depth = Parser.readUi16($bytes, $stream);
                    $.flags |= 4 /* HasMatrix */;
                    var $30 = $.matrix = {};
                    matrix($bytes, $stream, $30, swfVersion, tagCode);
                    if ($stream.remaining()) {
                        $.flags |= 8 /* HasColorTransform */;
                        var $31 = $.cxform = {};
                        cxform($bytes, $stream, $31, swfVersion, tagCode);
                    }
                }
                return $;
            }

            function removeObject($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                if (tagCode === 5) {
                    $.symbolId = Parser.readUi16($bytes, $stream);
                }
                $.depth = Parser.readUi16($bytes, $stream);
                return $;
            }

            function defineImage($bytes, $stream, $, swfVersion, tagCode) {
                var imgData;
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                if (tagCode > 21) {
                    var alphaDataOffset = Parser.readUi32($bytes, $stream);
                    if (tagCode === 90) {
                        $.deblock = Parser.readFixed8($bytes, $stream);
                    }
                    imgData = $.imgData = Parser.readBinary($bytes, $stream, alphaDataOffset, true);
                    $.alphaData = Parser.readBinary($bytes, $stream, 0, true);
                } else {
                    imgData = $.imgData = Parser.readBinary($bytes, $stream, 0, true);
                }
                switch (imgData[0] << 8 | imgData[1]) {
                    case 65496:
                    case 65497:
                        $.mimeType = "image/jpeg";
                        break;
                    case 35152:
                        $.mimeType = "image/png";
                        break;
                    case 18249:
                        $.mimeType = "image/gif";
                        break;
                    default:
                        $.mimeType = "application/octet-stream";
                }
                if (tagCode === 6) {
                    $.incomplete = 1;
                }
                return $;
            }

            function defineButton($bytes, $stream, $, swfVersion, tagCode) {
                var eob;
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                if (tagCode == 7) {
                    var $0 = $.characters = [];
                    do {
                        var $1 = {};
                        var temp = button($bytes, $stream, $1, swfVersion, tagCode);
                        eob = temp.eob;
                        $0.push($1);
                    } while(!eob);
                    $.actionsData = Parser.readBinary($bytes, $stream, 0, false);
                } else {
                    var trackFlags = Parser.readUi8($bytes, $stream);
                    $.trackAsMenu = trackFlags >> 7 & 1;
                    var actionOffset = Parser.readUi16($bytes, $stream);
                    var $28 = $.characters = [];
                    do {
                        var $29 = {};
                        var flags = Parser.readUi8($bytes, $stream);
                        var eob = $29.eob = !flags;
                        if (swfVersion >= 8) {
                            $29.flags = (flags >> 5 & 1 ? 512 /* HasBlendMode */ : 0) | (flags >> 4 & 1 ? 256 /* HasFilterList */ : 0);
                        } else {
                            $29.flags = 0;
                        }
                        $29.stateHitTest = flags >> 3 & 1;
                        $29.stateDown = flags >> 2 & 1;
                        $29.stateOver = flags >> 1 & 1;
                        $29.stateUp = flags & 1;
                        if (!eob) {
                            $29.symbolId = Parser.readUi16($bytes, $stream);
                            $29.depth = Parser.readUi16($bytes, $stream);
                            var $30 = $29.matrix = {};
                            matrix($bytes, $stream, $30, swfVersion, tagCode);
                            if (tagCode === 34) {
                                var $31 = $29.cxform = {};
                                cxform($bytes, $stream, $31, swfVersion, tagCode);
                            }
                            if ($29.flags & 256 /* HasFilterList */) {
                                var count = Parser.readUi8($bytes, $stream);
                                var $2 = $.filters = [];
                                var $3 = count;
                                while ($3--) {
                                    var $4 = {};
                                    anyFilter($bytes, $stream, $4, swfVersion, tagCode);
                                    $2.push($4);
                                }
                            }
                            if ($29.flags & 512 /* HasBlendMode */) {
                                $29.blendMode = Parser.readUi8($bytes, $stream);
                            }
                        }
                        $28.push($29);
                    } while(!eob);
                    if (!!actionOffset) {
                        var $56 = $.buttonActions = [];
                        do {
                            var $57 = {};
                            buttonCondAction($bytes, $stream, $57, swfVersion, tagCode);
                            $56.push($57);
                        } while($stream.remaining() > 0);
                    }
                }
                return $;
            }

            function defineJPEGTables($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = 0;
                $.imgData = Parser.readBinary($bytes, $stream, 0, false);
                $.mimeType = "application/octet-stream";
                return $;
            }

            function setBackgroundColor($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.color = rgb($bytes, $stream);
                return $;
            }

            function defineBinaryData($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var reserved = Parser.readUi32($bytes, $stream);
                $.data = Parser.readBinary($bytes, $stream, 0, false);
                return $;
            }

            function defineFont($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var firstOffset = Parser.readUi16($bytes, $stream);
                var glyphCount = $.glyphCount = firstOffset / 2;
                var restOffsets = [];
                var $0 = glyphCount - 1;
                while ($0--) {
                    restOffsets.push(Parser.readUi16($bytes, $stream));
                }
                $.offsets = [firstOffset].concat(restOffsets);
                var $1 = $.glyphs = [];
                var $2 = glyphCount;
                while ($2--) {
                    var $3 = {};
                    shape($bytes, $stream, $3, swfVersion, tagCode);
                    $1.push($3);
                }
                return $;
            }

            function defineLabel($bytes, $stream, $, swfVersion, tagCode) {
                var eot;
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var $0 = $.bbox = {};
                bbox($bytes, $stream, $0, swfVersion, tagCode);
                var $1 = $.matrix = {};
                matrix($bytes, $stream, $1, swfVersion, tagCode);
                var glyphBits = $.glyphBits = Parser.readUi8($bytes, $stream);
                var advanceBits = $.advanceBits = Parser.readUi8($bytes, $stream);
                var $2 = $.records = [];
                do {
                    var $3 = {};
                    var temp = textRecord($bytes, $stream, $3, swfVersion, tagCode, glyphBits, advanceBits);
                    eot = temp.eot;
                    $2.push($3);
                } while(!eot);
                return $;
            }

            function doAction($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                if (tagCode === 59) {
                    $.spriteId = Parser.readUi16($bytes, $stream);
                }
                $.actionsData = Parser.readBinary($bytes, $stream, 0, false);
                return $;
            }

            function defineSound($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var soundFlags = Parser.readUi8($bytes, $stream);
                $.soundFormat = soundFlags >> 4 & 15;
                $.soundRate = soundFlags >> 2 & 3;
                $.soundSize = soundFlags >> 1 & 1;
                $.soundType = soundFlags & 1;
                $.samplesCount = Parser.readUi32($bytes, $stream);
                $.soundData = Parser.readBinary($bytes, $stream, 0, false);
                return $;
            }

            function startSound($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                if (tagCode == 15) {
                    $.soundId = Parser.readUi16($bytes, $stream);
                }
                if (tagCode == 89) {
                    $.soundClassName = Parser.readString($bytes, $stream, 0);
                }
                var $0 = $.soundInfo = {};
                soundInfo($bytes, $stream, $0, swfVersion, tagCode);
                return $;
            }

            function soundStreamHead($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                var playbackFlags = Parser.readUi8($bytes, $stream);
                $.playbackRate = playbackFlags >> 2 & 3;
                $.playbackSize = playbackFlags >> 1 & 1;
                $.playbackType = playbackFlags & 1;
                var streamFlags = Parser.readUi8($bytes, $stream);
                var streamCompression = $.streamCompression = streamFlags >> 4 & 15;
                $.streamRate = streamFlags >> 2 & 3;
                $.streamSize = streamFlags >> 1 & 1;
                $.streamType = streamFlags & 1;
                $.samplesCount = Parser.readUi32($bytes, $stream);
                if (streamCompression == 2) {
                    $.latencySeek = Parser.readSi16($bytes, $stream);
                }
                return $;
            }

            function soundStreamBlock($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.data = Parser.readBinary($bytes, $stream, 0, false);
                return $;
            }

            function defineBitmap($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var format = $.format = Parser.readUi8($bytes, $stream);
                $.width = Parser.readUi16($bytes, $stream);
                $.height = Parser.readUi16($bytes, $stream);
                $.hasAlpha = tagCode === 36;
                if (format === 3) {
                    $.colorTableSize = Parser.readUi8($bytes, $stream);
                }
                $.bmpData = Parser.readBinary($bytes, $stream, 0, false);
                return $;
            }

            function defineText($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var $0 = $.bbox = {};
                bbox($bytes, $stream, $0, swfVersion, tagCode);
                var flags = Parser.readUi16($bytes, $stream);
                var hasText = $.hasText = flags >> 7 & 1;
                $.wordWrap = flags >> 6 & 1;
                $.multiline = flags >> 5 & 1;
                $.password = flags >> 4 & 1;
                $.readonly = flags >> 3 & 1;
                var hasColor = $.hasColor = flags >> 2 & 1;
                var hasMaxLength = $.hasMaxLength = flags >> 1 & 1;
                var hasFont = $.hasFont = flags & 1;
                var hasFontClass = $.hasFontClass = flags >> 15 & 1;
                $.autoSize = flags >> 14 & 1;
                var hasLayout = $.hasLayout = flags >> 13 & 1;
                $.noSelect = flags >> 12 & 1;
                $.border = flags >> 11 & 1;
                $.wasStatic = flags >> 10 & 1;
                $.html = flags >> 9 & 1;
                $.useOutlines = flags >> 8 & 1;
                if (hasFont) {
                    $.fontId = Parser.readUi16($bytes, $stream);
                }
                if (hasFontClass) {
                    $.fontClass = Parser.readString($bytes, $stream, 0);
                }
                if (hasFont) {
                    $.fontHeight = Parser.readUi16($bytes, $stream);
                }
                if (hasColor) {
                    $.color = rgba($bytes, $stream);
                }
                if (hasMaxLength) {
                    $.maxLength = Parser.readUi16($bytes, $stream);
                }
                if (hasLayout) {
                    $.align = Parser.readUi8($bytes, $stream);
                    $.leftMargin = Parser.readUi16($bytes, $stream);
                    $.rightMargin = Parser.readUi16($bytes, $stream);
                    $.indent = Parser.readSi16($bytes, $stream);
                    $.leading = Parser.readSi16($bytes, $stream);
                }
                $.variableName = Parser.readString($bytes, $stream, 0);
                if (hasText) {
                    $.initialText = Parser.readString($bytes, $stream, 0);
                }
                return $;
            }

            function frameLabel($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.name = Parser.readString($bytes, $stream, 0);
                return $;
            }

            function defineFont2($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var hasLayout = $.hasLayout = Parser.readUb($bytes, $stream, 1);
                var reserved;
                if (swfVersion > 5) {
                    $.shiftJis = Parser.readUb($bytes, $stream, 1);
                } else {
                    reserved = Parser.readUb($bytes, $stream, 1);
                }
                $.smallText = Parser.readUb($bytes, $stream, 1);
                $.ansi = Parser.readUb($bytes, $stream, 1);
                var wideOffset = $.wideOffset = Parser.readUb($bytes, $stream, 1);
                var wide = $.wide = Parser.readUb($bytes, $stream, 1);
                $.italic = Parser.readUb($bytes, $stream, 1);
                $.bold = Parser.readUb($bytes, $stream, 1);
                if (swfVersion > 5) {
                    $.language = Parser.readUi8($bytes, $stream);
                } else {
                    reserved = Parser.readUi8($bytes, $stream);
                    $.language = 0;
                }
                var nameLength = Parser.readUi8($bytes, $stream);
                $.name = Parser.readString($bytes, $stream, nameLength);
                if (tagCode === 75) {
                    $.resolution = 20;
                }
                var glyphCount = $.glyphCount = Parser.readUi16($bytes, $stream);
                var startpos = $stream.pos;
                if (wideOffset) {
                    var $0 = $.offsets = [];
                    var $1 = glyphCount;
                    while ($1--) {
                        $0.push(Parser.readUi32($bytes, $stream));
                    }
                    $.mapOffset = Parser.readUi32($bytes, $stream);
                } else {
                    var $2 = $.offsets = [];
                    var $3 = glyphCount;
                    while ($3--) {
                        $2.push(Parser.readUi16($bytes, $stream));
                    }
                    $.mapOffset = Parser.readUi16($bytes, $stream);
                }
                var $4 = $.glyphs = [];
                var $5 = glyphCount;
                while ($5--) {
                    var $6 = {};
                    var dist = $.offsets[glyphCount - $5] + startpos - $stream.pos;

                    // when just one byte difference between two offsets, just read that and insert a eos record
                    if (dist === 1) {
                        Parser.readUi8($bytes, $stream);
                        $4.push({ "records": [{ "type": 0, "eos": true, "hasNewStyles": 0, "hasLineStyle": 0, "hasFillStyle1": 0, "hasFillStyle0": 0, "move": 0 }] });
                        continue;
                    }
                    shape($bytes, $stream, $6, swfVersion, tagCode);
                    $4.push($6);
                }
                if (wide) {
                    var $47 = $.codes = [];
                    var $48 = glyphCount;
                    while ($48--) {
                        $47.push(Parser.readUi16($bytes, $stream));
                    }
                } else {
                    var $49 = $.codes = [];
                    var $50 = glyphCount;
                    while ($50--) {
                        $49.push(Parser.readUi8($bytes, $stream));
                    }
                }
                if (hasLayout) {
                    $.ascent = Parser.readUi16($bytes, $stream);
                    $.descent = Parser.readUi16($bytes, $stream);
                    $.leading = Parser.readSi16($bytes, $stream);
                    var $51 = $.advance = [];
                    var $52 = glyphCount;
                    while ($52--) {
                        $51.push(Parser.readSi16($bytes, $stream));
                    }
                    var $53 = $.bbox = [];
                    var $54 = glyphCount;
                    while ($54--) {
                        var $55 = {};
                        bbox($bytes, $stream, $55, swfVersion, tagCode);
                        $53.push($55);
                    }
                    var kerningCount = Parser.readUi16($bytes, $stream);
                    var $56 = $.kerning = [];
                    var $57 = kerningCount;
                    while ($57--) {
                        var $58 = {};
                        kerning($bytes, $stream, $58, swfVersion, tagCode, wide);
                        $56.push($58);
                    }
                }
                return $;
            }

            function defineFont4($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.id = Parser.readUi16($bytes, $stream);
                var reserved = Parser.readUb($bytes, $stream, 5);
                var hasFontData = $.hasFontData = Parser.readUb($bytes, $stream, 1);
                $.italic = Parser.readUb($bytes, $stream, 1);
                $.bold = Parser.readUb($bytes, $stream, 1);
                $.name = Parser.readString($bytes, $stream, 0);
                if (hasFontData) {
                    $.data = Parser.readBinary($bytes, $stream, 0, false);
                }
                return $;
            }

            function fileAttributes($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                var reserved = Parser.readUb($bytes, $stream, 1);
                $.useDirectBlit = Parser.readUb($bytes, $stream, 1);
                $.useGpu = Parser.readUb($bytes, $stream, 1);
                $.hasMetadata = Parser.readUb($bytes, $stream, 1);
                $.doAbc = Parser.readUb($bytes, $stream, 1);
                $.noCrossDomainCaching = Parser.readUb($bytes, $stream, 1);
                $.relativeUrls = Parser.readUb($bytes, $stream, 1);
                $.network = Parser.readUb($bytes, $stream, 1);
                var pad = Parser.readUb($bytes, $stream, 24);
                return $;
            }

            function doABC($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                if (tagCode === 82) {
                    $.flags = Parser.readUi32($bytes, $stream);
                } else {
                    $.flags = 0;
                }
                if (tagCode === 82) {
                    $.name = Parser.readString($bytes, $stream, 0);
                } else {
                    $.name = "";
                }
                $.data = Parser.readBinary($bytes, $stream, 0, false);
                return $;
            }

            function exportAssets($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                var exportsCount = Parser.readUi16($bytes, $stream);
                var $0 = $.exports = [];
                var $1 = exportsCount;
                while ($1--) {
                    var $2 = {};
                    $2.symbolId = Parser.readUi16($bytes, $stream);
                    $2.className = Parser.readString($bytes, $stream, 0);
                    $0.push($2);
                }
                return $;
            }

            function symbolClass($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                var symbolCount = Parser.readUi16($bytes, $stream);
                var $0 = $.exports = [];
                var $1 = symbolCount;
                while ($1--) {
                    var $2 = {};
                    $2.symbolId = Parser.readUi16($bytes, $stream);
                    $2.className = Parser.readString($bytes, $stream, 0);
                    $0.push($2);
                }
                return $;
            }

            function defineScalingGrid($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                $.symbolId = Parser.readUi16($bytes, $stream);
                var $0 = $.splitter = {};
                bbox($bytes, $stream, $0, swfVersion, tagCode);
                return $;
            }

            function defineScene($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                var sceneCount = Parser.readEncodedU32($bytes, $stream);
                var $0 = $.scenes = [];
                var $1 = sceneCount;
                while ($1--) {
                    var $2 = {};
                    $2.offset = Parser.readEncodedU32($bytes, $stream);
                    $2.name = Parser.readString($bytes, $stream, 0);
                    $0.push($2);
                }
                var labelCount = Parser.readEncodedU32($bytes, $stream);
                var $3 = $.labels = [];
                var $4 = labelCount;
                while ($4--) {
                    var $5 = {};
                    $5.frame = Parser.readEncodedU32($bytes, $stream);
                    $5.name = Parser.readString($bytes, $stream, 0);
                    $3.push($5);
                }
                return $;
            }

            function bbox($bytes, $stream, $, swfVersion, tagCode) {
                Parser.align($bytes, $stream);
                var bits = Parser.readUb($bytes, $stream, 5);
                var xMin = Parser.readSb($bytes, $stream, bits);
                var xMax = Parser.readSb($bytes, $stream, bits);
                var yMin = Parser.readSb($bytes, $stream, bits);
                var yMax = Parser.readSb($bytes, $stream, bits);
                $.xMin = xMin;
                $.xMax = xMax;
                $.yMin = yMin;
                $.yMax = yMax;
                Parser.align($bytes, $stream);
            }

            function rgb($bytes, $stream) {
                return ((Parser.readUi8($bytes, $stream) << 24) | (Parser.readUi8($bytes, $stream) << 16) | (Parser.readUi8($bytes, $stream) << 8) | 0xff) >>> 0;
            }

            function rgba($bytes, $stream) {
                return (Parser.readUi8($bytes, $stream) << 24) | (Parser.readUi8($bytes, $stream) << 16) | (Parser.readUi8($bytes, $stream) << 8) | Parser.readUi8($bytes, $stream);
            }

            function argb($bytes, $stream) {
                return Parser.readUi8($bytes, $stream) | (Parser.readUi8($bytes, $stream) << 24) | (Parser.readUi8($bytes, $stream) << 16) | (Parser.readUi8($bytes, $stream) << 8);
            }

            function fillSolid($bytes, $stream, $, swfVersion, tagCode, isMorph) {
                if (tagCode > 22 || isMorph) {
                    $.color = rgba($bytes, $stream);
                } else {
                    $.color = rgb($bytes, $stream);
                }
                if (isMorph) {
                    $.colorMorph = rgba($bytes, $stream);
                }
            }

            function matrix($bytes, $stream, $, swfVersion, tagCode) {
                Parser.align($bytes, $stream);
                var hasScale = Parser.readUb($bytes, $stream, 1);
                if (hasScale) {
                    var bits = Parser.readUb($bytes, $stream, 5);
                    $.a = Parser.readFb($bytes, $stream, bits);
                    $.d = Parser.readFb($bytes, $stream, bits);
                } else {
                    $.a = 1;
                    $.d = 1;
                }
                var hasRotate = Parser.readUb($bytes, $stream, 1);
                if (hasRotate) {
                    var bits = Parser.readUb($bytes, $stream, 5);
                    $.b = Parser.readFb($bytes, $stream, bits);
                    $.c = Parser.readFb($bytes, $stream, bits);
                } else {
                    $.b = 0;
                    $.c = 0;
                }
                var bits = Parser.readUb($bytes, $stream, 5);
                var e = Parser.readSb($bytes, $stream, bits);
                var f = Parser.readSb($bytes, $stream, bits);
                $.tx = e;
                $.ty = f;
                Parser.align($bytes, $stream);
            }

            function cxform($bytes, $stream, $, swfVersion, tagCode) {
                Parser.align($bytes, $stream);
                var hasOffsets = Parser.readUb($bytes, $stream, 1);
                var hasMultipliers = Parser.readUb($bytes, $stream, 1);
                var bits = Parser.readUb($bytes, $stream, 4);
                if (hasMultipliers) {
                    $.redMultiplier = Parser.readSb($bytes, $stream, bits);
                    $.greenMultiplier = Parser.readSb($bytes, $stream, bits);
                    $.blueMultiplier = Parser.readSb($bytes, $stream, bits);
                    if (tagCode > 4) {
                        $.alphaMultiplier = Parser.readSb($bytes, $stream, bits);
                    } else {
                        $.alphaMultiplier = 256;
                    }
                } else {
                    $.redMultiplier = 256;
                    $.greenMultiplier = 256;
                    $.blueMultiplier = 256;
                    $.alphaMultiplier = 256;
                }
                if (hasOffsets) {
                    $.redOffset = Parser.readSb($bytes, $stream, bits);
                    $.greenOffset = Parser.readSb($bytes, $stream, bits);
                    $.blueOffset = Parser.readSb($bytes, $stream, bits);
                    if (tagCode > 4) {
                        $.alphaOffset = Parser.readSb($bytes, $stream, bits);
                    } else {
                        $.alphaOffset = 0;
                    }
                } else {
                    $.redOffset = 0;
                    $.greenOffset = 0;
                    $.blueOffset = 0;
                    $.alphaOffset = 0;
                }
                Parser.align($bytes, $stream);
            }

            function fillGradient($bytes, $stream, $, swfVersion, tagCode, isMorph, type) {
                var $128 = $.matrix = {};
                matrix($bytes, $stream, $128, swfVersion, tagCode);
                if (isMorph) {
                    var $129 = $.matrixMorph = {};
                    matrix($bytes, $stream, $129, swfVersion, tagCode);
                }
                gradient($bytes, $stream, $, swfVersion, tagCode, isMorph, type);
            }

            function gradient($bytes, $stream, $, swfVersion, tagCode, isMorph, type) {
                if (tagCode === 83) {
                    $.spreadMode = Parser.readUb($bytes, $stream, 2);
                    $.interpolationMode = Parser.readUb($bytes, $stream, 2);
                } else {
                    var pad = Parser.readUb($bytes, $stream, 4);
                }
                var count = $.count = Parser.readUb($bytes, $stream, 4);
                var $130 = $.records = [];
                var $131 = count;
                while ($131--) {
                    var $132 = {};
                    gradientRecord($bytes, $stream, $132, swfVersion, tagCode, isMorph);
                    $130.push($132);
                }
                if (type === 19) {
                    $.focalPoint = Parser.readSi16($bytes, $stream);
                    if (isMorph) {
                        $.focalPointMorph = Parser.readSi16($bytes, $stream);
                    }
                }
            }

            function gradientRecord($bytes, $stream, $, swfVersion, tagCode, isMorph) {
                $.ratio = Parser.readUi8($bytes, $stream);
                if (tagCode > 22) {
                    $.color = rgba($bytes, $stream);
                } else {
                    $.color = rgb($bytes, $stream);
                }
                if (isMorph) {
                    $.ratioMorph = Parser.readUi8($bytes, $stream);
                    $.colorMorph = rgba($bytes, $stream);
                }
            }

            function morphShapeWithStyle($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes) {
                var eos, bits, temp;
                temp = styles($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes);
                var lineBits = temp.lineBits;
                var fillBits = temp.fillBits;
                var $160 = $.records = [];
                do {
                    var $161 = {};
                    temp = shapeRecord($bytes, $stream, $161, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes, bits);
                    eos = temp.eos;
                    var flags = temp.flags;
                    var type = temp.type;
                    var fillBits = temp.fillBits;
                    var lineBits = temp.lineBits;
                    bits = temp.bits;
                    $160.push($161);
                } while(!eos);
                temp = styleBits($bytes, $stream, $, swfVersion, tagCode);
                var fillBits = temp.fillBits;
                var lineBits = temp.lineBits;
                var $162 = $.recordsMorph = [];
                do {
                    var $163 = {};
                    temp = shapeRecord($bytes, $stream, $163, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes, bits);
                    eos = temp.eos;
                    var flags = temp.flags;
                    var type = temp.type;
                    var fillBits = temp.fillBits;
                    var lineBits = temp.lineBits;
                    bits = temp.bits;
                    $162.push($163);
                } while(!eos);
            }

            function shapeWithStyle($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes) {
                var eos, bits, temp;
                temp = styles($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes);
                var fillBits = temp.fillBits;
                var lineBits = temp.lineBits;
                var $160 = $.records = [];
                do {
                    var $161 = {};
                    temp = shapeRecord($bytes, $stream, $161, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes, bits);
                    eos = temp.eos;
                    var flags = temp.flags;
                    var type = temp.type;
                    var fillBits = temp.fillBits;
                    var lineBits = temp.lineBits;
                    bits = temp.bits;
                    $160.push($161);
                } while(!eos);
            }

            function shapeRecord($bytes, $stream, $, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes, bits) {
                var eos, temp;
                var type = $.type = Parser.readUb($bytes, $stream, 1);
                var flags = Parser.readUb($bytes, $stream, 5);
                eos = $.eos = !(type || flags);
                if (type) {
                    temp = shapeRecordEdge($bytes, $stream, $, swfVersion, tagCode, flags, bits);
                    bits = temp.bits;
                } else {
                    temp = shapeRecordSetup($bytes, $stream, $, swfVersion, tagCode, flags, isMorph, fillBits, lineBits, hasStrokes, bits);
                    var fillBits = temp.fillBits;
                    var lineBits = temp.lineBits;
                    bits = temp.bits;
                }
                return {
                    type: type,
                    flags: flags,
                    eos: eos,
                    fillBits: fillBits,
                    lineBits: lineBits,
                    bits: bits
                };
            }

            function shapeRecordEdge($bytes, $stream, $, swfVersion, tagCode, flags, bits) {
                var isStraight = 0, tmp = 0, bits = 0, isGeneral = 0, isVertical = 0;
                isStraight = $.isStraight = flags >> 4;
                tmp = flags & 0x0f;
                bits = tmp + 2;
                if (isStraight) {
                    isGeneral = $.isGeneral = Parser.readUb($bytes, $stream, 1);
                    if (isGeneral) {
                        $.deltaX = Parser.readSb($bytes, $stream, bits);
                        $.deltaY = Parser.readSb($bytes, $stream, bits);
                    } else {
                        isVertical = $.isVertical = Parser.readUb($bytes, $stream, 1);
                        if (isVertical) {
                            $.deltaY = Parser.readSb($bytes, $stream, bits);
                        } else {
                            $.deltaX = Parser.readSb($bytes, $stream, bits);
                        }
                    }
                } else {
                    $.controlDeltaX = Parser.readSb($bytes, $stream, bits);
                    $.controlDeltaY = Parser.readSb($bytes, $stream, bits);
                    $.anchorDeltaX = Parser.readSb($bytes, $stream, bits);
                    $.anchorDeltaY = Parser.readSb($bytes, $stream, bits);
                }
                return { bits: bits };
            }

            function shapeRecordSetup($bytes, $stream, $, swfVersion, tagCode, flags, isMorph, fillBits, lineBits, hasStrokes, bits) {
                var hasNewStyles = 0, hasLineStyle = 0, hasFillStyle1 = 0;
                var hasFillStyle0 = 0, move = 0;
                if (tagCode > 2) {
                    hasNewStyles = $.hasNewStyles = flags >> 4;
                } else {
                    hasNewStyles = $.hasNewStyles = 0;
                }
                hasLineStyle = $.hasLineStyle = flags >> 3 & 1;
                hasFillStyle1 = $.hasFillStyle1 = flags >> 2 & 1;
                hasFillStyle0 = $.hasFillStyle0 = flags >> 1 & 1;
                move = $.move = flags & 1;
                if (move) {
                    bits = Parser.readUb($bytes, $stream, 5);
                    $.moveX = Parser.readSb($bytes, $stream, bits);
                    $.moveY = Parser.readSb($bytes, $stream, bits);
                }
                if (hasFillStyle0) {
                    $.fillStyle0 = Parser.readUb($bytes, $stream, fillBits);
                }
                if (hasFillStyle1) {
                    $.fillStyle1 = Parser.readUb($bytes, $stream, fillBits);
                }
                if (hasLineStyle) {
                    $.lineStyle = Parser.readUb($bytes, $stream, lineBits);
                }
                if (hasNewStyles) {
                    var temp = styles($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes);
                    lineBits = temp.lineBits;
                    fillBits = temp.fillBits;
                }
                return {
                    lineBits: lineBits,
                    fillBits: fillBits,
                    bits: bits
                };
            }

            function styles($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes) {
                fillStyleArray($bytes, $stream, $, swfVersion, tagCode, isMorph);
                lineStyleArray($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes);
                var temp = styleBits($bytes, $stream, $, swfVersion, tagCode);
                var fillBits = temp.fillBits;
                var lineBits = temp.lineBits;
                return { fillBits: fillBits, lineBits: lineBits };
            }

            function fillStyleArray($bytes, $stream, $, swfVersion, tagCode, isMorph) {
                var count;
                var tmp = Parser.readUi8($bytes, $stream);
                if (tagCode > 2 && tmp === 255) {
                    count = Parser.readUi16($bytes, $stream);
                } else {
                    count = tmp;
                }
                var $4 = $.fillStyles = [];
                var $5 = count;
                while ($5--) {
                    var $6 = {};
                    fillStyle($bytes, $stream, $6, swfVersion, tagCode, isMorph);
                    $4.push($6);
                }
            }

            function lineStyleArray($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes) {
                var count;
                var tmp = Parser.readUi8($bytes, $stream);
                if (tagCode > 2 && tmp === 255) {
                    count = Parser.readUi16($bytes, $stream);
                } else {
                    count = tmp;
                }
                var $138 = $.lineStyles = [];
                var $139 = count;
                while ($139--) {
                    var $140 = {};
                    lineStyle($bytes, $stream, $140, swfVersion, tagCode, isMorph, hasStrokes);
                    $138.push($140);
                }
            }

            function styleBits($bytes, $stream, $, swfVersion, tagCode) {
                Parser.align($bytes, $stream);
                var fillBits = Parser.readUb($bytes, $stream, 4);
                var lineBits = Parser.readUb($bytes, $stream, 4);
                return {
                    fillBits: fillBits,
                    lineBits: lineBits
                };
            }

            function fillStyle($bytes, $stream, $, swfVersion, tagCode, isMorph) {
                var type = $.type = Parser.readUi8($bytes, $stream);
                switch (type) {
                    case 0:
                        fillSolid($bytes, $stream, $, swfVersion, tagCode, isMorph);
                        break;
                    case 16:
                    case 18:
                    case 19:
                        fillGradient($bytes, $stream, $, swfVersion, tagCode, isMorph, type);
                        break;
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                        fillBitmap($bytes, $stream, $, swfVersion, tagCode, isMorph, type);
                        break;
                    default:
                }
            }

            function lineStyle($bytes, $stream, $, swfVersion, tagCode, isMorph, hasStrokes) {
                $.width = Parser.readUi16($bytes, $stream);
                if (isMorph) {
                    $.widthMorph = Parser.readUi16($bytes, $stream);
                }
                if (hasStrokes) {
                    Parser.align($bytes, $stream);
                    $.startCapsStyle = Parser.readUb($bytes, $stream, 2);
                    var jointStyle = $.jointStyle = Parser.readUb($bytes, $stream, 2);
                    var hasFill = $.hasFill = Parser.readUb($bytes, $stream, 1);
                    $.noHscale = Parser.readUb($bytes, $stream, 1);
                    $.noVscale = Parser.readUb($bytes, $stream, 1);
                    $.pixelHinting = Parser.readUb($bytes, $stream, 1);
                    var reserved = Parser.readUb($bytes, $stream, 5);
                    $.noClose = Parser.readUb($bytes, $stream, 1);
                    $.endCapsStyle = Parser.readUb($bytes, $stream, 2);
                    if (jointStyle === 2) {
                        $.miterLimitFactor = Parser.readFixed8($bytes, $stream);
                    }
                    if (hasFill) {
                        var $141 = $.fillStyle = {};
                        fillStyle($bytes, $stream, $141, swfVersion, tagCode, isMorph);
                    } else {
                        $.color = rgba($bytes, $stream);
                        if (isMorph) {
                            $.colorMorph = rgba($bytes, $stream);
                        }
                    }
                } else {
                    if (tagCode > 22) {
                        $.color = rgba($bytes, $stream);
                    } else {
                        $.color = rgb($bytes, $stream);
                    }
                    if (isMorph) {
                        $.colorMorph = rgba($bytes, $stream);
                    }
                }
            }

            function fillBitmap($bytes, $stream, $, swfVersion, tagCode, isMorph, type) {
                $.bitmapId = Parser.readUi16($bytes, $stream);
                var $18 = $.matrix = {};
                matrix($bytes, $stream, $18, swfVersion, tagCode);
                if (isMorph) {
                    var $19 = $.matrixMorph = {};
                    matrix($bytes, $stream, $19, swfVersion, tagCode);
                }
                $.condition = type === 64 || type === 67;
            }

            function filterGlow($bytes, $stream, $, swfVersion, tagCode, type) {
                var count;
                if (type === 4 || type === 7) {
                    count = Parser.readUi8($bytes, $stream);
                } else {
                    count = 1;
                }
                var $5 = $.colors = [];
                var $6 = count;
                while ($6--) {
                    $5.push(rgba($bytes, $stream));
                }
                if (type === 3) {
                    $.hightlightColor = rgba($bytes, $stream);
                }
                if (type === 4 || type === 7) {
                    var $9 = $.ratios = [];
                    var $10 = count;
                    while ($10--) {
                        $9.push(Parser.readUi8($bytes, $stream));
                    }
                }
                $.blurX = Parser.readFixed($bytes, $stream);
                $.blurY = Parser.readFixed($bytes, $stream);
                if (type !== 2) {
                    $.angle = Parser.readFixed($bytes, $stream);
                    $.distance = Parser.readFixed($bytes, $stream);
                }
                $.strength = Parser.readFixed8($bytes, $stream);
                $.inner = Parser.readUb($bytes, $stream, 1);
                $.knockout = Parser.readUb($bytes, $stream, 1);
                $.compositeSource = Parser.readUb($bytes, $stream, 1);
                if (type === 3 || type === 4 || type === 7) {
                    $.onTop = Parser.readUb($bytes, $stream, 1);
                    $.quality = Parser.readUb($bytes, $stream, 4);
                } else {
                    $.quality = Parser.readUb($bytes, $stream, 5);
                }
            }

            function filterBlur($bytes, $stream, $, swfVersion, tagCode) {
                $.blurX = Parser.readFixed($bytes, $stream);
                $.blurY = Parser.readFixed($bytes, $stream);
                $.quality = Parser.readUb($bytes, $stream, 5);
                var reserved = Parser.readUb($bytes, $stream, 3);
            }

            function filterConvolution($bytes, $stream, $, swfVersion, tagCode) {
                var matrixX = $.matrixX = Parser.readUi8($bytes, $stream);
                var matrixY = $.matrixY = Parser.readUi8($bytes, $stream);
                $.divisor = Parser.readFloat($bytes, $stream);
                $.bias = Parser.readFloat($bytes, $stream);
                var $17 = $.matrix = [];
                var $18 = matrixX * matrixY;
                while ($18--) {
                    $17.push(Parser.readFloat($bytes, $stream));
                }
                $.color = rgba($bytes, $stream);
                var reserved = Parser.readUb($bytes, $stream, 6);
                $.clamp = Parser.readUb($bytes, $stream, 1);
                $.preserveAlpha = Parser.readUb($bytes, $stream, 1);
            }

            function filterColorMatrix($bytes, $stream, $, swfVersion, tagCode) {
                var $20 = $.matrix = [];
                var $21 = 20;
                while ($21--) {
                    $20.push(Parser.readFloat($bytes, $stream));
                }
            }

            function anyFilter($bytes, $stream, $, swfVersion, tagCode) {
                var type = $.type = Parser.readUi8($bytes, $stream);
                switch (type) {
                    case 0:
                    case 2:
                    case 3:
                    case 4:
                    case 7:
                        filterGlow($bytes, $stream, $, swfVersion, tagCode, type);
                        break;
                    case 1:
                        filterBlur($bytes, $stream, $, swfVersion, tagCode);
                        break;
                    case 5:
                        filterConvolution($bytes, $stream, $, swfVersion, tagCode);
                        break;
                    case 6:
                        filterColorMatrix($bytes, $stream, $, swfVersion, tagCode);
                        break;
                    default:
                }
            }

            function events($bytes, $stream, $, swfVersion, tagCode) {
                var flags = swfVersion >= 6 ? Parser.readUi32($bytes, $stream) : Parser.readUi16($bytes, $stream);
                var eoe = $.eoe = !flags;
                var keyPress = 0;
                $.onKeyUp = flags >> 7 & 1;
                $.onKeyDown = flags >> 6 & 1;
                $.onMouseUp = flags >> 5 & 1;
                $.onMouseDown = flags >> 4 & 1;
                $.onMouseMove = flags >> 3 & 1;
                $.onUnload = flags >> 2 & 1;
                $.onEnterFrame = flags >> 1 & 1;
                $.onLoad = flags & 1;
                if (swfVersion >= 6) {
                    $.onDragOver = flags >> 15 & 1;
                    $.onRollOut = flags >> 14 & 1;
                    $.onRollOver = flags >> 13 & 1;
                    $.onReleaseOutside = flags >> 12 & 1;
                    $.onRelease = flags >> 11 & 1;
                    $.onPress = flags >> 10 & 1;
                    $.onInitialize = flags >> 9 & 1;
                    $.onData = flags >> 8 & 1;
                    if (swfVersion >= 7) {
                        $.onConstruct = flags >> 18 & 1;
                    } else {
                        $.onConstruct = 0;
                    }
                    keyPress = $.keyPress = flags >> 17 & 1;
                    $.onDragOut = flags >> 16 & 1;
                }
                if (!eoe) {
                    var length = $.length = Parser.readUi32($bytes, $stream);
                    if (keyPress) {
                        $.keyCode = Parser.readUi8($bytes, $stream);
                    }
                    $.actionsData = Parser.readBinary($bytes, $stream, length - +keyPress, false);
                }
                return eoe;
            }

            function kerning($bytes, $stream, $, swfVersion, tagCode, wide) {
                if (wide) {
                    $.code1 = Parser.readUi16($bytes, $stream);
                    $.code2 = Parser.readUi16($bytes, $stream);
                } else {
                    $.code1 = Parser.readUi8($bytes, $stream);
                    $.code2 = Parser.readUi8($bytes, $stream);
                }
                $.adjustment = Parser.readUi16($bytes, $stream);
            }

            function textEntry($bytes, $stream, $, swfVersion, tagCode, glyphBits, advanceBits) {
                $.glyphIndex = Parser.readUb($bytes, $stream, glyphBits);
                $.advance = Parser.readSb($bytes, $stream, advanceBits);
            }

            function textRecordSetup($bytes, $stream, $, swfVersion, tagCode, flags) {
                var hasFont = $.hasFont = flags >> 3 & 1;
                var hasColor = $.hasColor = flags >> 2 & 1;
                var hasMoveY = $.hasMoveY = flags >> 1 & 1;
                var hasMoveX = $.hasMoveX = flags & 1;
                if (hasFont) {
                    $.fontId = Parser.readUi16($bytes, $stream);
                }
                if (hasColor) {
                    if (tagCode === 33) {
                        $.color = rgba($bytes, $stream);
                    } else {
                        $.color = rgb($bytes, $stream);
                    }
                }
                if (hasMoveX) {
                    $.moveX = Parser.readSi16($bytes, $stream);
                }
                if (hasMoveY) {
                    $.moveY = Parser.readSi16($bytes, $stream);
                }
                if (hasFont) {
                    $.fontHeight = Parser.readUi16($bytes, $stream);
                }
            }

            function textRecord($bytes, $stream, $, swfVersion, tagCode, glyphBits, advanceBits) {
                var glyphCount;
                Parser.align($bytes, $stream);
                var flags = Parser.readUb($bytes, $stream, 8);
                var eot = $.eot = !flags;
                textRecordSetup($bytes, $stream, $, swfVersion, tagCode, flags);
                if (!eot) {
                    var tmp = Parser.readUi8($bytes, $stream);
                    if (swfVersion > 6) {
                        glyphCount = $.glyphCount = tmp;
                    } else {
                        glyphCount = $.glyphCount = tmp; // & 0x7f;
                    }
                    var $6 = $.entries = [];
                    var $7 = glyphCount;
                    while ($7--) {
                        var $8 = {};
                        textEntry($bytes, $stream, $8, swfVersion, tagCode, glyphBits, advanceBits);
                        $6.push($8);
                    }
                }
                return { eot: eot };
            }

            function soundEnvelope($bytes, $stream, $, swfVersion, tagCode) {
                $.pos44 = Parser.readUi32($bytes, $stream);
                $.volumeLeft = Parser.readUi16($bytes, $stream);
                $.volumeRight = Parser.readUi16($bytes, $stream);
            }

            function soundInfo($bytes, $stream, $, swfVersion, tagCode) {
                var reserved = Parser.readUb($bytes, $stream, 2);
                $.stop = Parser.readUb($bytes, $stream, 1);
                $.noMultiple = Parser.readUb($bytes, $stream, 1);
                var hasEnvelope = $.hasEnvelope = Parser.readUb($bytes, $stream, 1);
                var hasLoops = $.hasLoops = Parser.readUb($bytes, $stream, 1);
                var hasOutPoint = $.hasOutPoint = Parser.readUb($bytes, $stream, 1);
                var hasInPoint = $.hasInPoint = Parser.readUb($bytes, $stream, 1);
                if (hasInPoint) {
                    $.inPoint = Parser.readUi32($bytes, $stream);
                }
                if (hasOutPoint) {
                    $.outPoint = Parser.readUi32($bytes, $stream);
                }
                if (hasLoops) {
                    $.loopCount = Parser.readUi16($bytes, $stream);
                }
                if (hasEnvelope) {
                    var envelopeCount = $.envelopeCount = Parser.readUi8($bytes, $stream);
                    var $1 = $.envelopes = [];
                    var $2 = envelopeCount;
                    while ($2--) {
                        var $3 = {};
                        soundEnvelope($bytes, $stream, $3, swfVersion, tagCode);
                        $1.push($3);
                    }
                }
            }

            function button($bytes, $stream, $, swfVersion, tagCode) {
                var flags = Parser.readUi8($bytes, $stream);
                var eob = $.eob = !flags;
                if (swfVersion >= 8) {
                    $.flags = (flags >> 5 & 1 ? 512 /* HasBlendMode */ : 0) | (flags >> 4 & 1 ? 256 /* HasFilterList */ : 0);
                } else {
                    $.flags = 0;
                }
                $.stateHitTest = flags >> 3 & 1;
                $.stateDown = flags >> 2 & 1;
                $.stateOver = flags >> 1 & 1;
                $.stateUp = flags & 1;
                if (!eob) {
                    $.symbolId = Parser.readUi16($bytes, $stream);
                    $.depth = Parser.readUi16($bytes, $stream);
                    var $2 = $.matrix = {};
                    matrix($bytes, $stream, $2, swfVersion, tagCode);
                    if (tagCode === 34 /* CODE_DEFINE_BUTTON2 */) {
                        var $3 = $.cxform = {};
                        cxform($bytes, $stream, $3, swfVersion, tagCode);
                    }
                    if ($.flags & 256 /* HasFilterList */) {
                        $.filterCount = Parser.readUi8($bytes, $stream);
                        var $4 = $.filters = {};
                        anyFilter($bytes, $stream, $4, swfVersion, tagCode);
                    }
                    if ($.flags & 512 /* HasBlendMode */) {
                        $.blendMode = Parser.readUi8($bytes, $stream);
                    }
                }
                return { eob: eob };
            }

            function buttonCondAction($bytes, $stream, $, swfVersion, tagCode) {
                var tagSize = Parser.readUi16($bytes, $stream);
                var conditions = Parser.readUi16($bytes, $stream);

                // The 7 upper bits hold a key code the button should respond to.
                $.keyCode = (conditions & 0xfe00) >> 9;

                // The lower 9 bits hold state transition flags. See the enum in AS2Button for details.
                $.stateTransitionFlags = conditions & 0x1ff;

                // If no tagSize is given, pass `0` to readBinary.
                $.actionsData = Parser.readBinary($bytes, $stream, (tagSize || 4) - 4, false);
            }

            function shape($bytes, $stream, $, swfVersion, tagCode) {
                var eos, bits, temp;
                temp = styleBits($bytes, $stream, $, swfVersion, tagCode);
                var fillBits = temp.fillBits;
                var lineBits = temp.lineBits;
                var $4 = $.records = [];
                do {
                    var $5 = {};
                    var isMorph = false;
                    var hasStrokes = false;
                    temp = shapeRecord($bytes, $stream, $5, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes, bits);
                    eos = temp.eos;
                    var fillBits = temp.fillBits;
                    var lineBits = temp.lineBits;
                    bits = bits;
                    $4.push($5);
                } while(!eos);
            }

            Parser.tagHandler = {
                /* End */ /* End */ 0: undefined,
                /* ShowFrame */ /* ShowFrame */ 1: undefined,
                /* DefineShape */ /* DefineShape */ 2: defineShape,
                /* PlaceObject */ /* PlaceObject */ 4: placeObject,
                /* RemoveObject */ /* RemoveObject */ 5: removeObject,
                /* DefineBits */ /* DefineBits */ 6: defineImage,
                /* DefineButton */ /* DefineButton */ 7: defineButton,
                /* JPEGTables */ /* JPEGTables */ 8: defineJPEGTables,
                /* SetBackgroundColor */ /* SetBackgroundColor */ 9: setBackgroundColor,
                /* DefineFont */ /* DefineFont */ 10: defineFont,
                /* DefineText */ /* DefineText */ 11: defineLabel,
                /* DoAction */ /* DoAction */ 12: doAction,
                /* DefineFontInfo */ /* DefineFontInfo */ 13: undefined,
                /* DefineSound */ /* DefineSound */ 14: defineSound,
                /* StartSound */ /* StartSound */ 15: startSound,
                /* DefineButtonSound */ /* DefineButtonSound */ 17: undefined,
                /* SoundStreamHead */ /* SoundStreamHead */ 18: soundStreamHead,
                /* SoundStreamBlock */ /* SoundStreamBlock */ 19: soundStreamBlock,
                /* DefineBitsLossless */ /* DefineBitsLossless */ 20: defineBitmap,
                /* DefineBitsJPEG2 */ /* DefineBitsJPEG2 */ 21: defineImage,
                /* DefineShape2 */ /* DefineShape2 */ 22: defineShape,
                /* DefineButtonCxform */ /* DefineButtonCxform */ 23: undefined,
                /* Protect */ /* Protect */ 24: undefined,
                /* PlaceObject2 */ /* PlaceObject2 */ 26: placeObject,
                /* RemoveObject2 */ /* RemoveObject2 */ 28: removeObject,
                /* DefineShape3 */ /* DefineShape3 */ 32: defineShape,
                /* DefineText2 */ /* DefineText2 */ 33: defineLabel,
                /* DefineButton2 */ /* DefineButton2 */ 34: defineButton,
                /* DefineBitsJPEG3 */ /* DefineBitsJPEG3 */ 35: defineImage,
                /* DefineBitsLossless2 */ /* DefineBitsLossless2 */ 36: defineBitmap,
                /* DefineEditText */ /* DefineEditText */ 37: defineText,
                /* DefineSprite */ /* DefineSprite */ 39: undefined,
                /* FrameLabel */ /* FrameLabel */ 43: frameLabel,
                /* SoundStreamHead2 */ /* SoundStreamHead2 */ 45: soundStreamHead,
                /* DefineMorphShape */ /* DefineMorphShape */ 46: defineShape,
                /* DefineFont2 */ /* DefineFont2 */ 48: defineFont2,
                /* ExportAssets */ /* ExportAssets */ 56: exportAssets,
                /* ImportAssets */ /* ImportAssets */ 57: undefined,
                /* EnableDebugger */ /* EnableDebugger */ 58: undefined,
                /* DoInitAction */ /* DoInitAction */ 59: doAction,
                /* DefineVideoStream */ /* DefineVideoStream */ 60: undefined,
                /* VideoFrame */ /* VideoFrame */ 61: undefined,
                /* DefineFontInfo2 */ /* DefineFontInfo2 */ 62: undefined,
                /* EnableDebugger2 */ /* EnableDebugger2 */ 64: undefined,
                /* ScriptLimits */ /* ScriptLimits */ 65: undefined,
                /* SetTabIndex */ /* SetTabIndex */ 66: undefined,
                /* FileAttributes */ /* FileAttributes */ 69: fileAttributes,
                /* PlaceObject3 */ /* PlaceObject3 */ 70: placeObject,
                /* ImportAssets2 */ /* ImportAssets2 */ 71: undefined,
                /* DoABC (undoc) */ /* DoABC (undoc) */ 72: doABC,
                /* DefineFontAlignZones */ /* DefineFontAlignZones */ 73: undefined,
                /* CSMTextSettings */ /* CSMTextSettings */ 74: undefined,
                /* DefineFont3 */ /* DefineFont3 */ 75: defineFont2,
                /* SymbolClass */ /* SymbolClass */ 76: symbolClass,
                /* Metadata */ /* Metadata */ 77: undefined,
                /* DefineScalingGrid */ /* DefineScalingGrid */ 78: defineScalingGrid,
                /* DoABC */ /* DoABC */ 82: doABC,
                /* DefineShape4 */ /* DefineShape4 */ 83: defineShape,
                /* DefineMorphShape2 */ /* DefineMorphShape2 */ 84: defineShape,
                /* DefineSceneAndFrameLabelData */ /* DefineSceneAndFrameLabelData */ 86: defineScene,
                /* DefineBinaryData */ /* DefineBinaryData */ 87: defineBinaryData,
                /* DefineFontName */ /* DefineFontName */ 88: undefined,
                /* StartSound2 */ /* StartSound2 */ 89: startSound,
                /* DefineBitsJPEG4 */ /* DefineBitsJPEG4 */ 90: defineImage,
                /* DefineFont4 */ /* DefineFont4 */ 91: defineFont4
            };

            function readHeader($bytes, $stream, $, swfVersion, tagCode) {
                $ || ($ = {});
                var $0 = $.bbox = {};
                Parser.align($bytes, $stream);
                var bits = Parser.readUb($bytes, $stream, 5);
                var xMin = Parser.readSb($bytes, $stream, bits);
                var xMax = Parser.readSb($bytes, $stream, bits);
                var yMin = Parser.readSb($bytes, $stream, bits);
                var yMax = Parser.readSb($bytes, $stream, bits);
                $0.xMin = xMin;
                $0.xMax = xMax;
                $0.yMin = yMin;
                $0.yMax = yMax;
                Parser.align($bytes, $stream);
                var frameRateFraction = Parser.readUi8($bytes, $stream);
                $.frameRate = Parser.readUi8($bytes, $stream) + frameRateFraction / 256;
                $.frameCount = Parser.readUi16($bytes, $stream);
                return $;
            }
            Parser.readHeader = readHeader;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            function readTags(context, stream, swfVersion, final, onprogress, onexception) {
                var tags = context.tags;
                var bytes = stream.bytes;
                var lastSuccessfulPosition;

                var tag = null;
                if (context._readTag) {
                    tag = context._readTag;
                    context._readTag = null;
                }

                try  {
                    while (stream.pos < stream.end) {
                        // this loop can be interrupted at any moment by StreamNoDataError
                        // exception, trying to recover data/position below when thrown
                        lastSuccessfulPosition = stream.pos;

                        stream.ensure(2);
                        var tagCodeAndLength = Parser.readUi16(bytes, stream);
                        if (!tagCodeAndLength) {
                            // end of tags
                            final = true;
                            break;
                        }

                        var tagCode = tagCodeAndLength >> 6;
                        var length = tagCodeAndLength & 0x3f;
                        if (length === 0x3f) {
                            stream.ensure(4);
                            length = Parser.readUi32(bytes, stream);
                        }

                        if (tag) {
                            if (tagCode === 1 && tag.code === 1) {
                                // counting ShowFrame
                                tag.repeat++;
                                stream.pos += length;
                                continue;
                            }
                            tags.push(tag);
                            if (onprogress && tag.id !== undefined) {
                                context.bytesLoaded = (context.bytesTotal * stream.pos / stream.end) | 0;
                                onprogress(context);
                            }
                            tag = null;
                        }

                        stream.ensure(length);
                        var substream = stream.substream(stream.pos, stream.pos += length);
                        var subbytes = substream.bytes;
                        var nextTag = { code: tagCode };

                        if (tagCode === 39 /* CODE_DEFINE_SPRITE */) {
                            nextTag.type = 'sprite';
                            nextTag.id = Parser.readUi16(subbytes, substream);
                            nextTag.frameCount = Parser.readUi16(subbytes, substream);
                            nextTag.tags = [];
                            readTags(nextTag, substream, swfVersion, true, null, null);
                        } else if (tagCode === 1) {
                            nextTag.repeat = 1;
                        } else {
                            var handler = Parser.tagHandler[tagCode];
                            if (handler) {
                                handler(subbytes, substream, nextTag, swfVersion, tagCode);
                            }
                        }

                        tag = nextTag;
                    }
                    if ((tag && final) || (stream.pos >= stream.end)) {
                        if (tag) {
                            tag.finalTag = true; // note: 'eot' is reserved by handlers
                            tags.push(tag);
                        }
                        if (onprogress) {
                            context.bytesLoaded = context.bytesTotal;
                            onprogress(context);
                        }
                    } else {
                        context._readTag = tag;
                    }
                } catch (e) {
                    if (e !== SWF.StreamNoDataError) {
                        onexception && onexception(e);
                        throw e;
                    }

                    // recovering the stream state
                    stream.pos = lastSuccessfulPosition;
                    context._readTag = tag;
                }
            }

            var HeadTailBuffer = (function () {
                function HeadTailBuffer(defaultSize) {
                    if (typeof defaultSize === "undefined") { defaultSize = 16; }
                    this._bufferSize = defaultSize;
                    this._buffer = new Uint8Array(this._bufferSize);
                    this._pos = 0;
                }
                HeadTailBuffer.prototype.push = function (data, need) {
                    var bufferLengthNeed = this._pos + data.length;
                    if (this._bufferSize < bufferLengthNeed) {
                        var newBufferSize = this._bufferSize;
                        while (newBufferSize < bufferLengthNeed) {
                            newBufferSize <<= 1;
                        }
                        var newBuffer = new Uint8Array(newBufferSize);
                        if (this._bufferSize > 0) {
                            newBuffer.set(this._buffer);
                        }
                        this._buffer = newBuffer;
                        this._bufferSize = newBufferSize;
                    }
                    this._buffer.set(data, this._pos);
                    this._pos += data.length;
                    if (need) {
                        return this._pos >= need;
                    }
                };

                HeadTailBuffer.prototype.getHead = function (size) {
                    return this._buffer.subarray(0, size);
                };

                HeadTailBuffer.prototype.getTail = function (offset) {
                    return this._buffer.subarray(offset, this._pos);
                };

                HeadTailBuffer.prototype.removeHead = function (size) {
                    var tail = this.getTail(size);
                    this._buffer = new Uint8Array(this._bufferSize);
                    this._buffer.set(tail);
                    this._pos = tail.length;
                };

                Object.defineProperty(HeadTailBuffer.prototype, "arrayBuffer", {
                    get: function () {
                        return this._buffer.buffer;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(HeadTailBuffer.prototype, "length", {
                    get: function () {
                        return this._pos;
                    },
                    enumerable: true,
                    configurable: true
                });

                HeadTailBuffer.prototype.getBytes = function () {
                    return this._buffer.subarray(0, this._pos);
                };

                HeadTailBuffer.prototype.createStream = function () {
                    return new SWF.Stream(this.arrayBuffer, 0, this.length);
                };
                return HeadTailBuffer;
            })();

            var CompressedPipe = (function () {
                function CompressedPipe(target, length) {
                    this._target = target;
                    this._length = length;
                    this._initialize = true;
                    this._buffer = new HeadTailBuffer(8096);
                    this._state = {
                        bitBuffer: 0, bitLength: 0, compression: {
                            header: null, distanceTable: null, literalTable: null,
                            sym: null, len: null, sym2: null } };
                    this._output = {
                        data: new Uint8Array(length),
                        available: 0,
                        completed: false
                    };
                }
                CompressedPipe.prototype.push = function (data, progressInfo) {
                    var buffer = this._buffer;
                    if (this._initialize) {
                        if (!buffer.push(data, 2)) {
                            return;
                        }
                        var headerBytes = buffer.getHead(2);
                        SWF.verifyDeflateHeader(headerBytes);
                        buffer.removeHead(2);
                        this._initialize = false;
                    } else {
                        buffer.push(data);
                    }
                    var stream = buffer.createStream();
                    stream.bitBuffer = this._state.bitBuffer;
                    stream.bitLength = this._state.bitLength;
                    var output = this._output;
                    var lastAvailable = output.available;
                    try  {
                        do {
                            SWF.inflateBlock(stream, output, this._state.compression);
                        } while(stream.pos < buffer.length && !output.completed);
                    } catch (e) {
                        this._state.bitBuffer = stream.bitBuffer;
                        this._state.bitLength = stream.bitLength;
                        if (e !== SWF.InflateNoDataError) {
                            throw e;
                        }
                    }
                    this._state.bitBuffer = stream.bitBuffer;
                    this._state.bitLength = stream.bitLength;
                    buffer.removeHead(stream.pos);

                    // push data downstream
                    this._target.push(output.data.subarray(lastAvailable, output.available), progressInfo);
                };

                CompressedPipe.prototype.close = function () {
                };
                return CompressedPipe;
            })();

            var BodyParser = (function () {
                function BodyParser(swfVersion, length, options) {
                    this.swf = {
                        swfVersion: swfVersion,
                        parseTime: 0,
                        bytesLoaded: undefined,
                        bytesTotal: undefined,
                        fileAttributes: undefined,
                        tags: undefined
                    };
                    this._buffer = new HeadTailBuffer(32768);
                    this._initialize = true;
                    this._totalRead = 0;
                    this._length = length;
                    this._options = options;
                }
                BodyParser.prototype.push = function (data, progressInfo) {
                    if (data.length === 0) {
                        return;
                    }

                    var swf = this.swf;
                    var swfVersion = swf.swfVersion;
                    var buffer = this._buffer;
                    var options = this._options;
                    var stream;

                    var finalBlock = false;
                    if (progressInfo) {
                        swf.bytesLoaded = progressInfo.bytesLoaded;
                        swf.bytesTotal = progressInfo.bytesTotal;
                        finalBlock = progressInfo.bytesLoaded >= progressInfo.bytesTotal;
                    }

                    if (this._initialize) {
                        var PREFETCH_SIZE = 17 + 4 + 6;
                        if (!buffer.push(data, PREFETCH_SIZE))
                            return;

                        stream = buffer.createStream();
                        var bytes = stream.bytes;
                        Parser.readHeader(bytes, stream, swf, null, null);

                        // reading FileAttributes tag, this tag shall be first in the file
                        var nextTagHeader = Parser.readUi16(bytes, stream);
                        var FILE_ATTRIBUTES_LENGTH = 4;
                        if (nextTagHeader == ((69 /* CODE_FILE_ATTRIBUTES */ << 6) | FILE_ATTRIBUTES_LENGTH)) {
                            stream.ensure(FILE_ATTRIBUTES_LENGTH);
                            var substream = stream.substream(stream.pos, stream.pos += FILE_ATTRIBUTES_LENGTH);
                            var handler = Parser.tagHandler[69 /* CODE_FILE_ATTRIBUTES */];
                            var fileAttributesTag = { code: 69 /* CODE_FILE_ATTRIBUTES */ };
                            handler(substream.bytes, substream, fileAttributesTag, swfVersion, 69 /* CODE_FILE_ATTRIBUTES */);
                            swf.fileAttributes = fileAttributesTag;
                        } else {
                            stream.pos -= 2; // FileAttributes tag was not found -- re-winding
                            swf.fileAttributes = {}; // using empty object here, defaults all attributes to false
                        }

                        if (options.onstart)
                            options.onstart(swf);

                        swf.tags = [];

                        this._initialize = false;
                    } else {
                        buffer.push(data);
                        stream = buffer.createStream();
                    }

                    var readStartTime = performance.now();
                    readTags(swf, stream, swfVersion, finalBlock, options.onprogress, options.onexception);
                    swf.parseTime += performance.now() - readStartTime;

                    var read = stream.pos;
                    buffer.removeHead(read);
                    this._totalRead += read;

                    if (options.oncomplete && swf.tags[swf.tags.length - 1].finalTag) {
                        options.oncomplete(swf);
                    }
                };

                BodyParser.prototype.close = function () {
                };
                return BodyParser;
            })();

            function parseAsync(options) {
                var buffer = new HeadTailBuffer();
                var target = null;

                var pipe = {
                    push: function (data, progressInfo) {
                        if (target !== null) {
                            return target.push(data, progressInfo);
                        }
                        if (!buffer.push(data, 8)) {
                            return null;
                        }
                        var bytes = buffer.getHead(8);
                        var magic1 = bytes[0];
                        var magic2 = bytes[1];
                        var magic3 = bytes[2];

                        // check for SWF
                        if ((magic1 === 70 || magic1 === 67) && magic2 === 87 && magic3 === 83) {
                            var swfVersion = bytes[3];
                            var compressed = magic1 === 67;
                            parseSWF(compressed, swfVersion, progressInfo);
                            buffer = null;
                            return;
                        }

                        var isImage = false;
                        var imageType;

                        // check for JPG
                        if (magic1 === 0xff && magic2 === 0xd8 && magic3 === 0xff) {
                            isImage = true;
                            imageType = 'image/jpeg';
                        } else if (magic1 === 0x89 && magic2 === 0x50 && magic3 === 0x4e) {
                            isImage = true;
                            imageType = 'image/png';
                        }

                        if (isImage) {
                            parseImage(data, progressInfo.bytesTotal, imageType);
                        }
                        buffer = null;
                    },
                    close: function () {
                        if (buffer) {
                            // buffer was closed: none or few bytes were received
                            var symbol = {
                                command: 'empty',
                                data: buffer.getBytes()
                            };
                            options.oncomplete && options.oncomplete(symbol);
                        }
                        if (this.target !== undefined && this.target.close) {
                            this.target.close();
                        }
                    }
                };

                function parseSWF(compressed, swfVersion, progressInfo) {
                    var stream = buffer.createStream();
                    stream.pos += 4;
                    var fileLength = Parser.readUi32(null, stream);
                    var bodyLength = fileLength - 8;

                    target = new BodyParser(swfVersion, bodyLength, options);
                    if (compressed) {
                        target = new CompressedPipe(target, bodyLength);
                    }
                    target.push(buffer.getTail(8), progressInfo);
                }

                function parseImage(data, bytesTotal, type) {
                    var buffer = new Uint8Array(bytesTotal);
                    buffer.set(data);
                    var bufferPos = data.length;

                    target = {
                        push: function (data) {
                            buffer.set(data, bufferPos);
                            bufferPos += data.length;
                        },
                        close: function () {
                            var props = {};
                            var chunks;
                            if (type == 'image/jpeg') {
                                chunks = Parser.parseJpegChunks(props, buffer);
                            } else {
                                chunks = [buffer];
                            }
                            var symbol = {
                                type: 'image',
                                props: props,
                                data: new Blob(chunks, { type: type })
                            };
                            options.oncomplete && options.oncomplete(symbol);
                        }
                    };
                }

                return pipe;
            }
            Parser.parseAsync = parseAsync;

            function parse(buffer, options) {
                if (typeof options === "undefined") { options = {}; }
                var pipe = parseAsync(options);
                var bytes = new Uint8Array(buffer);
                var progressInfo = { bytesLoaded: bytes.length, bytesTotal: bytes.length };
                pipe.push(bytes, progressInfo);
                pipe.close();
            }
            Parser.parse = parse;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var roundToMultipleOfFour = Shumway.IntegerUtilities.roundToMultipleOfFour;

            (function (BitmapFormat) {
                /**
                * 8-bit color mapped image.
                */
                BitmapFormat[BitmapFormat["FORMAT_COLORMAPPED"] = 3] = "FORMAT_COLORMAPPED";

                /**
                * 15-bit RGB image.
                */
                BitmapFormat[BitmapFormat["FORMAT_15BPP"] = 4] = "FORMAT_15BPP";

                /**
                * 24-bit RGB image, however stored as 4 byte value 0x00RRGGBB.
                */
                BitmapFormat[BitmapFormat["FORMAT_24BPP"] = 5] = "FORMAT_24BPP";
            })(Parser.BitmapFormat || (Parser.BitmapFormat = {}));
            var BitmapFormat = Parser.BitmapFormat;

            /** @const */ var FACTOR_5BBP = 255 / 31;

            /*
            * Returns a Uint8Array of ARGB values. The source image is color mapped meaning
            * that the buffer is first prefixed with a color table:
            *
            * +--------------|--------------------------------------------------+
            * | Color Table  |  Image Data (byte indices into the color table)  |
            * +--------------|--------------------------------------------------+
            *
            * Color Table entries are either in RGB or RGBA format.
            *
            * There are two variations of these file formats, with or without alpha.
            *
            * Row pixels always start at 32 bit alinged offsets, the color table as
            * well as the end of each row may be padded so that the next row of pixels
            * is aligned.
            */
            function parseColorMapped(tag) {
                var width = tag.width, height = tag.height;
                var hasAlpha = tag.hasAlpha;

                var padding = roundToMultipleOfFour(width) - width;
                var colorTableLength = tag.colorTableSize + 1;
                var colorTableEntrySize = hasAlpha ? 4 : 3;
                var colorTableSize = roundToMultipleOfFour(colorTableLength * colorTableEntrySize);

                var dataSize = colorTableSize + ((width + padding) * height);
                var stream = SWF.createInflatedStream(tag.bmpData, dataSize);
                var bytes = stream.bytes;

                var view = new Uint32Array(width * height);

                // TODO: Figure out why this fails.
                // Make sure we've deflated enough bytes.
                // stream.ensure(dataSize);
                var p = colorTableSize, i = 0, offset = 0;
                if (hasAlpha) {
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            offset = bytes[p++] << 2;
                            var a = bytes[offset + 3];
                            var r = bytes[offset + 0];
                            var g = bytes[offset + 1];
                            var b = bytes[offset + 2];
                            view[i++] = b << 24 | g << 16 | r << 8 | a;
                        }
                        p += padding;
                    }
                } else {
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            offset = bytes[p++] * colorTableEntrySize;
                            var a = 0xff;
                            var r = bytes[offset + 0];
                            var g = bytes[offset + 1];
                            var b = bytes[offset + 2];
                            view[i++] = b << 24 | g << 16 | r << 8 | a;
                        }
                        p += padding;
                    }
                }
                release || assert(p === dataSize, "We should be at the end of the data buffer now.");
                release || assert(i === width * height, "Should have filled the entire image.");
                return new Uint8Array(view.buffer);
            }

            /**
            * Returns a Uint8Array of ARGB values. The data is already stored in premultiplied ARGB
            * so there's not much to do unless there's no alpha in which case we expand it here.
            */
            function parse24BPP(tag) {
                var width = tag.width, height = tag.height;
                var hasAlpha = tag.hasAlpha;

                // Even without alpha, 24BPP is stored as 4 bytes, probably for alignment reasons.
                var dataSize = height * width * 4;
                var stream = SWF.createInflatedStream(tag.bmpData, dataSize);

                // Make sure we've deflated enough bytes.
                stream.ensure(dataSize);
                var bytes = stream.bytes;
                if (hasAlpha) {
                    return bytes;
                }
                var view = new Uint32Array(width * height);
                var length = width * height, p = 0;

                for (var i = 0; i < length; i++) {
                    p++; // Reserved, always zero.
                    var r = bytes[p++];
                    var g = bytes[p++];
                    var b = bytes[p++];
                    view[i] = b << 24 | g << 16 | r << 8 | 0xff;
                }
                release || assert(p === dataSize, "We should be at the end of the data buffer now.");
                return new Uint8Array(view.buffer);
            }

            function parse15BPP(tag) {
                Shumway.Debug.notImplemented("parse15BPP");

                /*
                case FORMAT_15BPP:
                var colorType = 0x02;
                var bytesPerLine = ((width * 2) + 3) & ~3;
                var stream = createInflatedStream(bmpData, bytesPerLine * height);
                var pos = 0;
                
                for (var y = 0, i = 0; y < height; ++y) {
                stream.ensure(bytesPerLine);
                for (var x = 0; x < width; ++x, i += 4) {
                var word = stream.getUint16(pos);
                pos += 2;
                // Extracting RGB color components and changing values range
                // from 0..31 to 0..255.
                data[i] = 0 | (FACTOR_5BBP * ((word >> 10) & 0x1f));
                data[i + 1] = 0 | (FACTOR_5BBP * ((word >> 5) & 0x1f));
                data[i + 2] = 0 | (FACTOR_5BBP * (word & 0x1f));
                data[i + 3] = 255;
                }
                pos = stream.pos += bytesPerLine;
                }
                break;
                */
                return null;
            }

            function defineBitmap(tag) {
                SWF.enterTimeline("defineBitmap");
                var bmpData = tag.bmpData;
                var data;
                var type = 0 /* None */;
                switch (tag.format) {
                    case 3 /* FORMAT_COLORMAPPED */:
                        data = parseColorMapped(tag);
                        type = 1 /* PremultipliedAlphaARGB */;
                        break;
                    case 5 /* FORMAT_24BPP */:
                        data = parse24BPP(tag);
                        type = 1 /* PremultipliedAlphaARGB */;
                        break;
                    case 4 /* FORMAT_15BPP */:
                        data = parse15BPP(tag);
                        type = 1 /* PremultipliedAlphaARGB */;
                        break;
                    default:
                        release || assertUnreachable('invalid bitmap format');
                }
                SWF.leaveTimeline();
                return {
                    type: 'image',
                    id: tag.id,
                    width: tag.width,
                    height: tag.height,
                    mimeType: 'application/octet-stream',
                    data: data,
                    dataType: type
                };
            }
            Parser.defineBitmap = defineBitmap;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var assert = Shumway.Debug.assert;

            function defineButton(tag, dictionary) {
                var characters = tag.characters;
                var states = {
                    up: [],
                    over: [],
                    down: [],
                    hitTest: []
                };
                var i = 0, character;
                while ((character = characters[i++])) {
                    if (character.eob)
                        break;
                    var characterItem = dictionary[character.symbolId];
                    release || assert(characterItem, 'undefined character', 'button');
                    var cmd = {
                        symbolId: characterItem.id,
                        depth: character.depth,
                        flags: character.matrix ? 4 /* HasMatrix */ : 0,
                        matrix: character.matrix
                    };
                    if (character.stateUp)
                        states.up.push(cmd);
                    if (character.stateOver)
                        states.over.push(cmd);
                    if (character.stateDown)
                        states.down.push(cmd);
                    if (character.stateHitTest)
                        states.hitTest.push(cmd);
                }
                var button = {
                    type: 'button',
                    id: tag.id,
                    buttonActions: tag.buttonActions,
                    states: states
                };
                return button;
            }
            Parser.defineButton = defineButton;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var pow = Math.pow;
            var min = Math.min;
            var max = Math.max;
            var logE = Math.log;
            var fromCharCode = String.fromCharCode;

            var nextFontId = 1;

            function maxPower2(num) {
                var maxPower = 0;
                var val = num;
                while (val >= 2) {
                    val /= 2;
                    ++maxPower;
                }
                return pow(2, maxPower);
            }
            function toString16(val) {
                return fromCharCode((val >> 8) & 0xff, val & 0xff);
            }
            function toString32(val) {
                return toString16(val >> 16) + toString16(val);
            }

            function defineFont(tag, dictionary) {
                var uniqueName = 'swf-font-' + tag.id;
                var fontName = tag.name || uniqueName;

                var font = {
                    type: 'font',
                    id: tag.id,
                    name: fontName,
                    bold: tag.bold === 1,
                    italic: tag.italic === 1,
                    codes: null,
                    metrics: null,
                    data: tag.data
                };

                var glyphs = tag.glyphs;
                var glyphCount = glyphs ? tag.glyphCount = glyphs.length : 0;

                if (!glyphCount) {
                    return font;
                }

                var tables = {};
                var codes = [];
                var glyphIndex = {};
                var ranges = [];

                var originalCode;
                var generateAdvancement = !('advance' in tag);
                var correction = 0;
                var isFont2 = (tag.code === 48);
                var isFont3 = (tag.code === 75);

                if (generateAdvancement) {
                    tag.advance = [];
                }

                var maxCode = Math.max.apply(null, tag.codes) || 35;

                if (tag.codes) {
                    for (var i = 0; i < tag.codes.length; i++) {
                        var code = tag.codes[i];
                        if (code < 32) {
                            maxCode++;
                            if (maxCode == 8232) {
                                maxCode = 8240;
                            }
                            code = maxCode;
                        }
                        codes.push(code);
                        glyphIndex[code] = i;
                    }

                    originalCode = codes.concat();

                    codes.sort(function (a, b) {
                        return a - b;
                    });
                    var i = 0;
                    var code;
                    var indices;
                    while ((code = codes[i++]) !== undefined) {
                        var start = code;
                        var end = start;
                        indices = [i - 1];
                        while (((code = codes[i]) !== undefined) && end + 1 === code) {
                            ++end;
                            indices.push(i);
                            ++i;
                        }
                        ranges.push([start, end, indices]);
                    }
                } else {
                    indices = [];
                    var UAC_OFFSET = 0xe000;
                    for (var i = 0; i < glyphCount; i++) {
                        code = UAC_OFFSET + i;
                        codes.push(code);
                        glyphIndex[code] = i;
                        indices.push(i);
                    }
                    ranges.push([UAC_OFFSET, UAC_OFFSET + glyphCount - 1, indices]);
                    originalCode = codes.concat();
                }

                var resolution = tag.resolution || 1;
                if (isFont2 && !tag.hasLayout) {
                    // some DefineFont2 without layout using DefineFont3 resolution, why?
                    resolution = 20;
                }
                var ascent = Math.ceil(tag.ascent / resolution) || 1024;
                var descent = -Math.ceil(tag.descent / resolution) || 0;
                var leading = (tag.leading / resolution) || 0;
                tables['OS/2'] = '';

                var startCount = '';
                var endCount = '';
                var idDelta = '';
                var idRangeOffset = '';
                var i = 0;
                var range;
                while ((range = ranges[i++])) {
                    var start = range[0];
                    var end = range[1];
                    var code = range[2][0];
                    startCount += toString16(start);
                    endCount += toString16(end);
                    idDelta += toString16(((code - start) + 1) & 0xffff);
                    idRangeOffset += toString16(0);
                }
                endCount += '\xff\xff';
                startCount += '\xff\xff';
                idDelta += '\x00\x01';
                idRangeOffset += '\x00\x00';
                var segCount = ranges.length + 1;
                var searchRange = maxPower2(segCount) * 2;
                var rangeShift = (2 * segCount) - searchRange;
                var format314 = '\x00\x00' + toString16(segCount * 2) + toString16(searchRange) + toString16(logE(segCount) / logE(2)) + toString16(rangeShift) + endCount + '\x00\x00' + startCount + idDelta + idRangeOffset;
                tables['cmap'] = '\x00\x00' + '\x00\x01' + '\x00\x03' + '\x00\x01' + '\x00\x00\x00\x0c' + '\x00\x04' + toString16(format314.length + 4) + format314;

                var glyf = '\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x31\x00';
                var loca = '\x00\x00';
                var offset = 16;
                var maxPoints = 0;
                var xMins = [];
                var xMaxs = [];
                var yMins = [];
                var yMaxs = [];
                var maxContours = 0;
                var i = 0;
                var code;
                var rawData = {};
                while ((code = codes[i++]) !== undefined) {
                    var glyph = glyphs[glyphIndex[code]];
                    var records = glyph.records;
                    var x = 0;
                    var y = 0;

                    var myFlags = '';
                    var myEndpts = '';
                    var endPoint = 0;
                    var segments = [];
                    var segmentIndex = -1;

                    for (var j = 0; j < records.length; j++) {
                        record = records[j];
                        if (record.type) {
                            if (segmentIndex < 0) {
                                segmentIndex = 0;
                                segments[segmentIndex] = { data: [], commands: [], xMin: 0, xMax: 0, yMin: 0, yMax: 0 };
                            }
                            if (record.isStraight) {
                                segments[segmentIndex].commands.push(2);
                                var dx = (record.deltaX || 0) / resolution;
                                var dy = -(record.deltaY || 0) / resolution;
                                x += dx;
                                y += dy;
                                segments[segmentIndex].data.push(x, y);
                            } else {
                                segments[segmentIndex].commands.push(3);
                                var cx = record.controlDeltaX / resolution;
                                var cy = -record.controlDeltaY / resolution;
                                x += cx;
                                y += cy;
                                segments[segmentIndex].data.push(x, y);
                                var dx = record.anchorDeltaX / resolution;
                                var dy = -record.anchorDeltaY / resolution;
                                x += dx;
                                y += dy;
                                segments[segmentIndex].data.push(x, y);
                            }
                        } else {
                            if (record.eos) {
                                break;
                            }
                            if (record.move) {
                                segmentIndex++;
                                segments[segmentIndex] = { data: [], commands: [], xMin: 0, xMax: 0, yMin: 0, yMax: 0 };
                                segments[segmentIndex].commands.push(1);
                                var moveX = record.moveX / resolution;
                                var moveY = -record.moveY / resolution;
                                var dx = moveX - x;
                                var dy = moveY - y;
                                x = moveX;
                                y = moveY;
                                segments[segmentIndex].data.push(x, y);
                            }
                        }

                        if (segmentIndex > -1) {
                            if (segments[segmentIndex].xMin > x) {
                                segments[segmentIndex].xMin = x;
                            }
                            if (segments[segmentIndex].yMin > y) {
                                segments[segmentIndex].yMin = y;
                            }
                            if (segments[segmentIndex].xMax < x) {
                                segments[segmentIndex].xMax = x;
                            }
                            if (segments[segmentIndex].yMax < y) {
                                segments[segmentIndex].yMax = y;
                            }
                        }
                    }

                    if (!isFont3) {
                        segments.sort(function (a, b) {
                            return (b.xMax - b.xMin) * (b.yMax - b.yMin) - (a.xMax - a.xMin) * (a.yMax - a.yMin);
                        });
                    }

                    rawData[code] = segments;
                }

                i = 0;
                while ((code = codes[i++]) !== undefined) {
                    var glyph = glyphs[glyphIndex[code]];
                    var records = glyph.records;
                    segments = rawData[code];
                    var numberOfContours = 1;
                    var endPoint = 0;
                    var endPtsOfContours = '';
                    var flags = '';
                    var xCoordinates = '';
                    var yCoordinates = '';
                    var x = 0;
                    var y = 0;
                    var xMin = 0;
                    var xMax = -1024;
                    var yMin = 0;
                    var yMax = -1024;

                    var myFlags = '';
                    var myEndpts = '';
                    var endPoint = 0;
                    var segmentIndex = -1;

                    var data = [];
                    var commands = [];

                    for (j = 0; j < segments.length; j++) {
                        data = data.concat(segments[j].data);
                        commands = commands.concat(segments[j].commands);
                    }

                    x = 0;
                    y = 0;
                    var nx = 0;
                    var ny = 0;
                    var myXCoordinates = '';
                    var myYCoordinates = '';
                    var dataIndex = 0;
                    var endPoint = 0;
                    var numberOfContours = 1;
                    var myEndpts = '';
                    for (j = 0; j < commands.length; j++) {
                        var command = commands[j];
                        if (command === 1) {
                            if (endPoint) {
                                ++numberOfContours;
                                myEndpts += toString16(endPoint - 1);
                            }
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var dx = nx - x;
                            var dy = ny - y;
                            myFlags += '\x01';
                            myXCoordinates += toString16(dx);
                            myYCoordinates += toString16(dy);
                            x = nx;
                            y = ny;
                        } else if (command === 2) {
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var dx = nx - x;
                            var dy = ny - y;
                            myFlags += '\x01';
                            myXCoordinates += toString16(dx);
                            myYCoordinates += toString16(dy);
                            x = nx;
                            y = ny;
                        } else if (command === 3) {
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var cx = nx - x;
                            var cy = ny - y;
                            myFlags += '\x00';
                            myXCoordinates += toString16(cx);
                            myYCoordinates += toString16(cy);
                            x = nx;
                            y = ny;
                            endPoint++;

                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var cx = nx - x;
                            var cy = ny - y;
                            myFlags += '\x01';
                            myXCoordinates += toString16(cx);
                            myYCoordinates += toString16(cy);
                            x = nx;
                            y = ny;
                        }
                        endPoint++;
                        if (endPoint > maxPoints) {
                            maxPoints = endPoint;
                        }
                        if (xMin > x) {
                            xMin = x;
                        }
                        if (yMin > y) {
                            yMin = y;
                        }
                        if (xMax < x) {
                            xMax = x;
                        }
                        if (yMax < y) {
                            yMax = y;
                        }
                    }
                    myEndpts += toString16((endPoint || 1) - 1);

                    endPtsOfContours = myEndpts;
                    xCoordinates = myXCoordinates;
                    yCoordinates = myYCoordinates;
                    flags = myFlags;

                    if (!j) {
                        xMin = xMax = yMin = yMax = 0;
                        flags += '\x31';
                    }
                    var entry = toString16(numberOfContours) + toString16(xMin) + toString16(yMin) + toString16(xMax) + toString16(yMax) + endPtsOfContours + '\x00\x00' + flags + xCoordinates + yCoordinates;
                    if (entry.length & 1) {
                        entry += '\x00';
                    }
                    glyf += entry;
                    loca += toString16(offset / 2);
                    offset += entry.length;
                    xMins.push(xMin);
                    xMaxs.push(xMax);
                    yMins.push(yMin);
                    yMaxs.push(yMax);
                    if (numberOfContours > maxContours) {
                        maxContours = numberOfContours;
                    }
                    if (endPoint > maxPoints) {
                        maxPoints = endPoint;
                    }
                    if (generateAdvancement) {
                        tag.advance.push((xMax - xMin) * resolution * 1.3);
                    }
                }
                loca += toString16(offset / 2);
                tables['glyf'] = glyf;

                if (!isFont3) {
                    var minYmin = Math.min.apply(null, yMins);
                    if (minYmin < 0) {
                        descent = descent || minYmin;
                    }
                }

                tables['OS/2'] = '\x00\x01' + '\x00\x00' + toString16(tag.bold ? 700 : 400) + '\x00\x05' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + 'ALF ' + toString16((tag.italic ? 0x01 : 0) | (tag.bold ? 0x20 : 0)) + toString16(codes[0]) + toString16(codes[codes.length - 1]) + toString16(ascent) + toString16(descent) + toString16(leading) + toString16(ascent) + toString16(-descent) + '\x00\x00\x00\x00' + '\x00\x00\x00\x00';

                tables['head'] = '\x00\x01\x00\x00' + '\x00\x01\x00\x00' + '\x00\x00\x00\x00' + '\x5f\x0f\x3c\xf5' + '\x00\x0b' + '\x04\x00' + '\x00\x00\x00\x00' + toString32(Date.now()) + '\x00\x00\x00\x00' + toString32(Date.now()) + toString16(min.apply(null, xMins)) + toString16(min.apply(null, yMins)) + toString16(max.apply(null, xMaxs)) + toString16(max.apply(null, yMaxs)) + toString16((tag.italic ? 2 : 0) | (tag.bold ? 1 : 0)) + '\x00\x08' + '\x00\x02' + '\x00\x00' + '\x00\x00';

                var advance = tag.advance;
                tables['hhea'] = '\x00\x01\x00\x00' + toString16(ascent) + toString16(descent) + toString16(leading) + toString16(advance ? max.apply(null, advance) : 1024) + '\x00\x00' + '\x00\x00' + '\x03\xb8' + '\x00\x01' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + toString16(glyphCount + 1);

                var hmtx = '\x00\x00\x00\x00';
                for (var i = 0; i < glyphCount; ++i) {
                    hmtx += toString16(advance ? (advance[i] / resolution) : 1024) + '\x00\x00';
                }
                tables['hmtx'] = hmtx;

                if (tag.kerning) {
                    var kerning = tag.kerning;
                    var nPairs = kerning.length;
                    var searchRange = maxPower2(nPairs) * 2;
                    var kern = '\x00\x00' + '\x00\x01' + '\x00\x00' + toString16(14 + (nPairs * 6)) + '\x00\x01' + toString16(nPairs) + toString16(searchRange) + toString16(logE(nPairs) / logE(2)) + toString16((2 * nPairs) - searchRange);
                    var i = 0;
                    var record;
                    while ((record = kerning[i++])) {
                        kern += toString16(glyphIndex[record.code1]) + toString16(glyphIndex[record.code2]) + toString16(record.adjustment);
                    }
                    tables['kern'] = kern;
                }

                tables['loca'] = loca;

                tables['maxp'] = '\x00\x01\x00\x00' + toString16(glyphCount + 1) + toString16(maxPoints) + toString16(maxContours) + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00';

                var psName = fontName.replace(/ /g, '');
                var strings = [
                    tag.copyright || 'Original licence',
                    fontName,
                    'Unknown',
                    uniqueName,
                    fontName,
                    '1.0',
                    psName,
                    'Unknown',
                    'Unknown',
                    'Unknown'
                ];
                var count = strings.length;
                var name = '\x00\x00' + toString16(count) + toString16((count * 12) + 6);
                var offset = 0;
                var i = 0;
                var str;
                while ((str = strings[i++])) {
                    name += '\x00\x01' + '\x00\x00' + '\x00\x00' + toString16(i - 1) + toString16(str.length) + toString16(offset);
                    offset += str.length;
                }
                tables['name'] = name + strings.join('');

                tables['post'] = '\x00\x03\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00';

                var names = Object.keys(tables);
                var numTables = names.length;
                var header = '\x00\x01\x00\x00' + toString16(numTables) + '\x00\x80' + '\x00\x03' + '\x00\x20';
                var dataString = '';
                var offset = (numTables * 16) + header.length;
                var i = 0;
                while ((name = names[i++])) {
                    var table = tables[name];
                    var length = table.length;
                    header += name + '\x00\x00\x00\x00' + toString32(offset) + toString32(length);
                    while (length & 3) {
                        table += '\x00';
                        ++length;
                    }
                    dataString += table;
                    while (offset & 3) {
                        ++offset;
                    }
                    offset += length;
                }
                var otf = header + dataString;
                var unitPerEm = 1024;
                var metrics = {
                    ascent: ascent / unitPerEm,
                    descent: -descent / unitPerEm,
                    leading: leading / unitPerEm
                };

                // TODO: use a buffer to generate font data
                var dataBuffer = new Uint8Array(otf.length);
                for (var i = 0; i < otf.length; i++) {
                    dataBuffer[i] = otf.charCodeAt(i) & 0xff;
                }

                font.codes = originalCode;
                font.metrics = metrics;
                font.data = dataBuffer;

                return font;
            }
            Parser.defineFont = defineFont;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var assert = Shumway.Debug.assert;

            /**
            * Reads the next two bytes at the specified position.
            */
            function readUint16(bytes, position) {
                return (bytes[position] << 8) | bytes[position + 1];
            }

            /**
            * Parses JPEG chunks and reads image width and height information. JPEG data
            * is SWFs is encoded in chunks and is not directly decodable by the JPEG
            * parser.
            */
            function parseJpegChunks(image, bytes) {
                var i = 0;
                var n = bytes.length;
                var chunks = [];
                var code;
                do {
                    var begin = i;
                    while (i < n && bytes[i] !== 0xff) {
                        ++i;
                    }
                    while (i < n && bytes[i] === 0xff) {
                        ++i;
                    }
                    code = bytes[i++];
                    if (code === 0xda) {
                        i = n;
                    } else if (code === 0xd9) {
                        i += 2;
                        continue;
                    } else if (code < 0xd0 || code > 0xd8) {
                        var length = readUint16(bytes, i);
                        if (code >= 0xc0 && code <= 0xc3) {
                            image.height = readUint16(bytes, i + 3);
                            image.width = readUint16(bytes, i + 5);
                        }
                        i += length;
                    }
                    chunks.push(bytes.subarray(begin, i));
                } while(i < n);
                release || assert(image.width && image.height, 'bad image', 'jpeg');
                return chunks;
            }
            Parser.parseJpegChunks = parseJpegChunks;

            /**
            * Joins all the chunks in a larger byte array.
            */
            function joinChunks(chunks) {
                var length = 0;
                for (var i = 0; i < chunks.length; i++) {
                    length += chunks[i].length;
                }
                var bytes = new Uint8Array(length);
                var offset = 0;
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    bytes.set(chunk, offset);
                    offset += chunk.length;
                }
                return bytes;
            }

            function defineImage(tag, dictionary) {
                SWF.enterTimeline("defineImage");
                var image = {
                    type: 'image',
                    id: tag.id,
                    mimeType: tag.mimeType
                };
                var imgData = tag.imgData;
                var chunks;

                if (tag.mimeType === 'image/jpeg') {
                    var alphaData = tag.alphaData;
                    if (alphaData) {
                        var jpegImage = new Shumway.JPEG.JpegImage();
                        jpegImage.parse(joinChunks(parseJpegChunks(image, imgData)));
                        release || assert(image.width === jpegImage.width);
                        release || assert(image.height === jpegImage.height);
                        var width = image.width;
                        var height = image.height;
                        var length = width * height;
                        var alphaMaskBytes = SWF.createInflatedStream(alphaData, length).bytes;
                        var data = image.data = new Uint8ClampedArray(length * 4);
                        jpegImage.copyToImageData(image);
                        for (var i = 0, k = 3; i < length; i++, k += 4) {
                            data[k] = alphaMaskBytes[i];
                        }
                        image.mimeType = 'application/octet-stream';
                        image.dataType = 3 /* StraightAlphaRGBA */;
                    } else {
                        chunks = parseJpegChunks(image, imgData);

                        if (tag.incomplete) {
                            var tables = dictionary[0];
                            release || assert(tables, 'missing tables', 'jpeg');
                            var header = tables.data;
                            if (header && header.size) {
                                chunks[0] = chunks[0].subarray(2);
                                chunks.unshift(header.slice(0, header.size - 2));
                            }
                        }
                        image.data = joinChunks(chunks);
                    }
                } else {
                    image.data = imgData;
                }
                SWF.leaveTimeline();
                return image;
            }
            Parser.defineImage = defineImage;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var assert = Shumway.Debug.assert;

            function defineLabel(tag, dictionary) {
                var records = tag.records;
                var bbox = tag.bbox;
                var htmlText = '';
                var coords = [];
                var dependencies = [];
                var size = 12;
                var face = 'Times Roman';
                var color = 0;
                var x = 0;
                var y = 0;
                var i = 0;
                var record;
                var codes;
                var font;
                var fontAttributes;
                while ((record = records[i++])) {
                    if (record.eot) {
                        break;
                    }
                    if (record.hasFont) {
                        font = dictionary[record.fontId];
                        release || assert(font, 'undefined font', 'label');
                        codes = font.codes;
                        dependencies.push(font.id);
                        size = record.fontHeight / 20;
                        face = 'swffont' + font.id;
                    }
                    if (record.hasColor) {
                        color = record.color >>> 8;
                    }
                    if (record.hasMoveX) {
                        x = record.moveX;
                        if (x < bbox.xMin) {
                            bbox.xMin = x;
                        }
                    }
                    if (record.hasMoveY) {
                        y = record.moveY;
                        if (y < bbox.yMin) {
                            bbox.yMin = y;
                        }
                    }
                    var text = '';
                    var entries = record.entries;
                    var j = 0;
                    var entry;
                    while ((entry = entries[j++])) {
                        var code = codes[entry.glyphIndex];
                        release || assert(code, 'undefined glyph ', 'label');
                        text += String.fromCharCode(code);
                        coords.push(x, y);
                        x += entry.advance;
                    }
                    htmlText += '<font size="' + size + '" face="' + face + '"' + ' color="#' + ('000000' + color.toString(16)).slice(-6) + '">' + text.replace(/[<>&]/g, function (s) {
                        return s === '<' ? '&lt;' : (s === '>' ? '&gt;' : '&amp;');
                    }) + '</font>';
                }
                var label = {
                    type: 'text',
                    id: tag.id,
                    fillBounds: bbox,
                    matrix: tag.matrix,
                    tag: {
                        hasText: true,
                        initialText: htmlText,
                        html: true,
                        readonly: true
                    },
                    coords: coords,
                    static: true,
                    require: null
                };
                if (dependencies.length) {
                    label.require = dependencies;
                }
                return label;
            }
            Parser.defineLabel = defineLabel;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var PathCommand = Shumway.PathCommand;
            var GradientType = Shumway.GradientType;

            var Bounds = Shumway.Bounds;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var ShapeData = Shumway.ShapeData;
            var clamp = Shumway.NumberUtilities.clamp;
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var push = Array.prototype.push;

            var FillType;
            (function (FillType) {
                FillType[FillType["Solid"] = 0] = "Solid";
                FillType[FillType["LinearGradient"] = 0x10] = "LinearGradient";
                FillType[FillType["RadialGradient"] = 0x12] = "RadialGradient";
                FillType[FillType["FocalRadialGradient"] = 0x13] = "FocalRadialGradient";
                FillType[FillType["RepeatingBitmap"] = 0x40] = "RepeatingBitmap";
                FillType[FillType["ClippedBitmap"] = 0x41] = "ClippedBitmap";
                FillType[FillType["NonsmoothedRepeatingBitmap"] = 0x42] = "NonsmoothedRepeatingBitmap";
                FillType[FillType["NonsmoothedClippedBitmap"] = 0x43] = "NonsmoothedClippedBitmap";
            })(FillType || (FillType = {}));

            /*
            * Applies the current segment to the paths of all styles specified in the last
            * style-change record.
            *
            * For fill0, we have to apply commands and their data in reverse order, to turn
            * left fills into right ones.
            *
            * If we have more than one style, we only recorded commands for the first one
            * and have to duplicate them for the other styles. The order is: fill1, line,
            * fill0. (That means we only ever recorded into fill0 if that's the only style.)
            */
            function applySegmentToStyles(segment, styles, linePaths, fillPaths) {
                if (!segment) {
                    return;
                }
                var path;
                if (styles.fill0) {
                    path = fillPaths[styles.fill0 - 1];

                    // If fill0 is the only style, we have pushed the segment to its stack. In
                    // that case, just mark it as reversed and move on.
                    if (!(styles.fill1 || styles.line)) {
                        segment.isReversed = true;
                        return;
                    } else {
                        path.addSegment(segment.toReversed());
                    }
                }
                if (styles.line && styles.fill1) {
                    path = linePaths[styles.line - 1];
                    path.addSegment(segment.clone());
                }
            }

            /*
            * Converts records from the space-optimized format they're stored in to a
            * format that's more amenable to fast rendering.
            *
            * See http://blogs.msdn.com/b/mswanson/archive/2006/02/27/539749.aspx and
            * http://wahlers.com.br/claus/blog/hacking-swf-1-shapes-in-flash/ for details.
            */
            function convertRecordsToShapeData(records, fillPaths, linePaths, dictionary, dependencies, recordsMorph) {
                var isMorph = recordsMorph !== null;
                var styles = { fill0: 0, fill1: 0, line: 0 };
                var segment = null;

                // Fill- and line styles can be added by style change records in the middle of
                // a shape records list. This also causes the previous paths to be treated as
                // a group, so the lines don't get moved on top of any following fills.
                // To support this, we just append all current fill and line paths to a list
                // when new styles are introduced.
                var allPaths;

                // If no style is set for a segment of a path, a 1px transparent line is used.
                var defaultPath;

                //TODO: remove the `- 1` once we stop even parsing the EOS record
                var numRecords = records.length - 1;
                var x = 0;
                var y = 0;
                var morphX = 0;
                var morphY = 0;
                var path;
                for (var i = 0, j = 0; i < numRecords; i++) {
                    var record = records[i];
                    var morphRecord;
                    if (isMorph) {
                        morphRecord = recordsMorph[j++];
                    }

                    // type 0 is a StyleChange record
                    if (record.type === 0) {
                        //TODO: make the `has*` fields bitflags
                        if (segment) {
                            applySegmentToStyles(segment, styles, linePaths, fillPaths);
                        }

                        if (record.hasNewStyles) {
                            if (!allPaths) {
                                allPaths = [];
                            }
                            push.apply(allPaths, fillPaths);
                            fillPaths = createPathsList(record.fillStyles, false, dictionary, dependencies);
                            push.apply(allPaths, linePaths);
                            linePaths = createPathsList(record.lineStyles, true, dictionary, dependencies);
                            if (defaultPath) {
                                allPaths.push(defaultPath);
                                defaultPath = null;
                            }
                            styles = { fill0: 0, fill1: 0, line: 0 };
                        }

                        if (record.hasFillStyle0) {
                            styles.fill0 = record.fillStyle0;
                        }
                        if (record.hasFillStyle1) {
                            styles.fill1 = record.fillStyle1;
                        }
                        if (record.hasLineStyle) {
                            styles.line = record.lineStyle;
                        }
                        if (styles.fill1) {
                            path = fillPaths[styles.fill1 - 1];
                        } else if (styles.line) {
                            path = linePaths[styles.line - 1];
                        } else if (styles.fill0) {
                            path = fillPaths[styles.fill0 - 1];
                        }

                        if (record.move) {
                            x = record.moveX | 0;
                            y = record.moveY | 0;
                            // When morphed, StyleChangeRecords/MoveTo might not have a
                            // corresponding record in the start or end shape --
                            // processing morphRecord below before converting type 1 records.
                        }

                        // Very first record can be just fill/line-style definition record.
                        if (path) {
                            segment = PathSegment.FromDefaults(isMorph);
                            path.addSegment(segment);

                            // Move or not, we want this path segment to start where the last one
                            // left off. Even if the last one belonged to a different style.
                            // "Huh," you say? Yup.
                            if (!isMorph) {
                                segment.moveTo(x, y);
                            } else {
                                if (morphRecord.type === 0) {
                                    morphX = morphRecord.moveX | 0;
                                    morphY = morphRecord.moveY | 0;
                                } else {
                                    morphX = x;
                                    morphY = y;

                                    // Not all moveTos are reflected in morph data.
                                    // In that case, decrease morph data index.
                                    j--;
                                }
                                segment.morphMoveTo(x, y, morphX, morphY);
                            }
                        }
                    } else {
                        release || assert(record.type === 1);
                        if (!segment) {
                            if (!defaultPath) {
                                var style = { color: { red: 0, green: 0, blue: 0, alpha: 0 }, width: 20 };
                                defaultPath = new SegmentedPath(null, processStyle(style, true, dictionary, dependencies));
                            }
                            segment = PathSegment.FromDefaults(isMorph);
                            defaultPath.addSegment(segment);
                            if (!isMorph) {
                                segment.moveTo(x, y);
                            } else {
                                segment.morphMoveTo(x, y, morphX, morphY);
                            }
                        }
                        if (isMorph) {
                            while (morphRecord && morphRecord.type === 0) {
                                morphRecord = recordsMorph[j++];
                            }

                            // The EndEdges list might be shorter than the StartEdges list. Reuse
                            // start edges as end edges in that case.
                            if (!morphRecord) {
                                morphRecord = record;
                            }
                        }

                        if (record.isStraight && (!isMorph || morphRecord.isStraight)) {
                            x += record.deltaX | 0;
                            y += record.deltaY | 0;
                            if (!isMorph) {
                                segment.lineTo(x, y);
                            } else {
                                morphX += morphRecord.deltaX | 0;
                                morphY += morphRecord.deltaY | 0;
                                segment.morphLineTo(x, y, morphX, morphY);
                            }
                        } else {
                            var cx, cy;
                            var deltaX, deltaY;
                            if (!record.isStraight) {
                                cx = x + record.controlDeltaX | 0;
                                cy = y + record.controlDeltaY | 0;
                                x = cx + record.anchorDeltaX | 0;
                                y = cy + record.anchorDeltaY | 0;
                            } else {
                                deltaX = record.deltaX | 0;
                                deltaY = record.deltaY | 0;
                                cx = x + (deltaX >> 1);
                                cy = y + (deltaY >> 1);
                                x += deltaX;
                                y += deltaY;
                            }
                            segment.curveTo(cx, cy, x, y);
                            if (!isMorph) {
                            } else {
                                if (!morphRecord.isStraight) {
                                    var morphCX = morphX + morphRecord.controlDeltaX | 0;
                                    var morphCY = morphY + morphRecord.controlDeltaY | 0;
                                    morphX = morphCX + morphRecord.anchorDeltaX | 0;
                                    morphY = morphCY + morphRecord.anchorDeltaY | 0;
                                } else {
                                    deltaX = morphRecord.deltaX | 0;
                                    deltaY = morphRecord.deltaY | 0;
                                    var morphCX = morphX + (deltaX >> 1);
                                    var morphCY = morphY + (deltaY >> 1);
                                    morphX += deltaX;
                                    morphY += deltaY;
                                }
                                segment.morphCurveTo(cx, cy, x, y, morphCX, morphCY, morphX, morphY);
                            }
                        }
                    }
                }
                applySegmentToStyles(segment, styles, linePaths, fillPaths);

                // All current paths get appended to the allPaths list at the end. First fill,
                // then line paths.
                if (allPaths) {
                    push.apply(allPaths, fillPaths);
                } else {
                    allPaths = fillPaths;
                }
                push.apply(allPaths, linePaths);
                if (defaultPath) {
                    allPaths.push(defaultPath);
                }

                var shape = new ShapeData();
                if (isMorph) {
                    shape.morphCoordinates = new Int32Array(shape.coordinates.length);
                }
                for (i = 0; i < allPaths.length; i++) {
                    allPaths[i].serialize(shape);
                }
                return shape;
            }

            var IDENTITY_MATRIX = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
            function processStyle(style, isLineStyle, dictionary, dependencies) {
                if (isLineStyle) {
                    style.miterLimit = (style.miterLimitFactor || 1.5) * 2;
                    if (!style.color && style.hasFill) {
                        var fillStyle = processStyle(style.fillStyle, false, dictionary, dependencies);
                        style.type = fillStyle.type;
                        style.transform = fillStyle.transform;
                        style.records = fillStyle.records;
                        style.colors = fillStyle.colors;
                        style.ratios = fillStyle.ratios;
                        style.focalPoint = fillStyle.focalPoint;
                        style.bitmapId = fillStyle.bitmapId;
                        style.bitmapIndex = fillStyle.bitmapIndex;
                        style.repeat = fillStyle.repeat;
                        style.fillStyle = null;
                        return style;
                    } else {
                        style.type = 0 /* Solid */;
                    }
                }
                if (style.type === undefined || style.type === 0 /* Solid */) {
                    return style;
                }
                var scale;
                switch (style.type) {
                    case 16 /* LinearGradient */:
                    case 18 /* RadialGradient */:
                    case 19 /* FocalRadialGradient */:
                        var records = style.records;
                        var colors = style.colors = [];
                        var ratios = style.ratios = [];
                        for (var i = 0; i < records.length; i++) {
                            var record = records[i];
                            colors.push(record.color);
                            ratios.push(record.ratio);
                        }
                        scale = 819.2;
                        break;
                    case 64 /* RepeatingBitmap */:
                    case 65 /* ClippedBitmap */:
                    case 66 /* NonsmoothedRepeatingBitmap */:
                    case 67 /* NonsmoothedClippedBitmap */:
                        style.smooth = style.type !== 66 /* NonsmoothedRepeatingBitmap */ && style.type !== 67 /* NonsmoothedClippedBitmap */;
                        style.repeat = style.type !== 65 /* ClippedBitmap */ && style.type !== 67 /* NonsmoothedClippedBitmap */;
                        if (dictionary[style.bitmapId]) {
                            style.bitmapIndex = dependencies.length;
                            dependencies.push(style.bitmapId);
                            scale = 0.05;
                        } else {
                            style.bitmapIndex = -1;
                        }
                        break;
                    default:
                        release || assertUnreachable('shape parser encountered invalid fill style');
                }
                if (!style.matrix) {
                    style.transform = IDENTITY_MATRIX;
                    return style;
                }
                var matrix = style.matrix;
                style.transform = {
                    a: (matrix.a * scale),
                    b: (matrix.b * scale),
                    c: (matrix.c * scale),
                    d: (matrix.d * scale),
                    tx: matrix.tx / 20,
                    ty: matrix.ty / 20
                };

                // null data that's unused from here on out
                style.matrix = null;
                return style;
            }

            /*
            * Paths are stored in 2-dimensional arrays. Each of the inner arrays contains
            * all the paths for a certain fill or line style.
            */
            function createPathsList(styles, isLineStyle, dictionary, dependencies) {
                var paths = [];
                for (var i = 0; i < styles.length; i++) {
                    var style = processStyle(styles[i], isLineStyle, dictionary, dependencies);
                    if (!isLineStyle) {
                        paths[i] = new SegmentedPath(style, null);
                    } else {
                        paths[i] = new SegmentedPath(null, style);
                    }
                }
                return paths;
            }

            function defineShape(tag, dictionary) {
                var dependencies = [];
                var fillPaths = createPathsList(tag.fillStyles, false, dictionary, dependencies);
                var linePaths = createPathsList(tag.lineStyles, true, dictionary, dependencies);
                var shape = convertRecordsToShapeData(tag.records, fillPaths, linePaths, dictionary, dependencies, tag.recordsMorph || null);

                if (tag.lineBoundsMorph) {
                    var lineBounds = tag.lineBounds = Bounds.FromUntyped(tag.lineBounds);
                    var lineBoundsMorph = tag.lineBoundsMorph;
                    lineBounds.extendByPoint(lineBoundsMorph.xMin, lineBoundsMorph.yMin);
                    lineBounds.extendByPoint(lineBoundsMorph.xMax, lineBoundsMorph.yMax);
                    var fillBoundsMorph = tag.fillBoundsMorph;
                    if (fillBoundsMorph) {
                        var fillBounds = tag.fillBounds = tag.fillBounds ? Bounds.FromUntyped(tag.fillBounds) : null;
                        fillBounds.extendByPoint(fillBoundsMorph.xMin, fillBoundsMorph.yMin);
                        fillBounds.extendByPoint(fillBoundsMorph.xMax, fillBoundsMorph.yMax);
                    }
                }
                return {
                    type: tag.isMorph ? 'morphshape' : 'shape',
                    id: tag.id,
                    fillBounds: tag.fillBounds,
                    lineBounds: tag.lineBounds,
                    morphFillBounds: tag.fillBoundsMorph || null,
                    morphLineBounds: tag.lineBoundsMorph || null,
                    hasFills: fillPaths.length > 0,
                    hasLines: linePaths.length > 0,
                    shape: shape.toPlainObject(),
                    transferables: shape.buffers,
                    require: dependencies.length ? dependencies : null
                };
            }
            Parser.defineShape = defineShape;

            var PathSegment = (function () {
                function PathSegment(commands, data, morphData, prev, next, isReversed) {
                    this.commands = commands;
                    this.data = data;
                    this.morphData = morphData;
                    this.prev = prev;
                    this.next = next;
                    this.isReversed = isReversed;
                    this.id = PathSegment._counter++;
                }
                PathSegment.FromDefaults = function (isMorph) {
                    var commands = new DataBuffer();
                    var data = new DataBuffer();
                    commands.endian = data.endian = 'auto';
                    var morphData = null;
                    if (isMorph) {
                        morphData = new DataBuffer();
                        morphData.endian = 'auto';
                    }
                    return new PathSegment(commands, data, morphData, null, null, false);
                };

                PathSegment.prototype.moveTo = function (x, y) {
                    this.commands.writeUnsignedByte(9 /* MoveTo */);
                    this.data.writeInt(x);
                    this.data.writeInt(y);
                };

                PathSegment.prototype.morphMoveTo = function (x, y, mx, my) {
                    this.moveTo(x, y);
                    this.morphData.writeInt(mx);
                    this.morphData.writeInt(my);
                };

                PathSegment.prototype.lineTo = function (x, y) {
                    this.commands.writeUnsignedByte(10 /* LineTo */);
                    this.data.writeInt(x);
                    this.data.writeInt(y);
                };

                PathSegment.prototype.morphLineTo = function (x, y, mx, my) {
                    this.lineTo(x, y);
                    this.morphData.writeInt(mx);
                    this.morphData.writeInt(my);
                };

                PathSegment.prototype.curveTo = function (cpx, cpy, x, y) {
                    this.commands.writeUnsignedByte(11 /* CurveTo */);
                    this.data.writeInt(cpx);
                    this.data.writeInt(cpy);
                    this.data.writeInt(x);
                    this.data.writeInt(y);
                };

                PathSegment.prototype.morphCurveTo = function (cpx, cpy, x, y, mcpx, mcpy, mx, my) {
                    this.curveTo(cpx, cpy, x, y);
                    this.morphData.writeInt(mcpx);
                    this.morphData.writeInt(mcpy);
                    this.morphData.writeInt(mx);
                    this.morphData.writeInt(my);
                };

                /**
                * Returns a shallow copy of the segment with the "isReversed" flag set.
                * Reversed segments play themselves back in reverse when they're merged into the final
                * non-segmented path.
                * Note: Don't modify the original, or the reversed copy, after this operation!
                */
                PathSegment.prototype.toReversed = function () {
                    release || assert(!this.isReversed);
                    return new PathSegment(this.commands, this.data, this.morphData, null, null, true);
                };

                PathSegment.prototype.clone = function () {
                    return new PathSegment(this.commands, this.data, this.morphData, null, null, this.isReversed);
                };

                PathSegment.prototype.storeStartAndEnd = function () {
                    var data = this.data.ints;
                    var endPoint1 = data[0] + ',' + data[1];
                    var endPoint2Offset = (this.data.length >> 2) - 2;
                    var endPoint2 = data[endPoint2Offset] + ',' + data[endPoint2Offset + 1];
                    if (!this.isReversed) {
                        this.startPoint = endPoint1;
                        this.endPoint = endPoint2;
                    } else {
                        this.startPoint = endPoint2;
                        this.endPoint = endPoint1;
                    }
                };

                PathSegment.prototype.connectsTo = function (other) {
                    release || assert(other !== this);
                    release || assert(this.endPoint);
                    release || assert(other.startPoint);
                    return this.endPoint === other.startPoint;
                };

                PathSegment.prototype.serialize = function (shape, lastPosition) {
                    if (this.isReversed) {
                        this._serializeReversed(shape, lastPosition);
                        return;
                    }
                    var commands = this.commands.bytes;

                    // Note: this *must* use `this.data.length`, because buffers will have padding.
                    var dataLength = this.data.length >> 2;
                    var morphData = this.morphData ? this.morphData.ints : null;
                    var data = this.data.ints;
                    release || assert(commands[0] === 9 /* MoveTo */);

                    // If the segment's first moveTo goes to the current coordinates, we have to skip it.
                    var offset = 0;
                    if (data[0] === lastPosition.x && data[1] === lastPosition.y) {
                        offset++;
                    }
                    var commandsCount = this.commands.length;
                    var dataPosition = offset * 2;
                    for (var i = offset; i < commandsCount; i++) {
                        dataPosition = this._writeCommand(commands[i], dataPosition, data, morphData, shape);
                    }
                    release || assert(dataPosition === dataLength);
                    lastPosition.x = data[dataLength - 2];
                    lastPosition.y = data[dataLength - 1];
                };
                PathSegment.prototype._serializeReversed = function (shape, lastPosition) {
                    // For reversing the fill0 segments, we rely on the fact that each segment
                    // starts with a moveTo. We first write a new moveTo with the final drawing command's
                    // target coordinates (if we don't skip it, see below). For each of the following
                    // commands, we take the coordinates of the command originally *preceding*
                    // it as the new target coordinates. The final coordinates we target will be
                    // the ones from the original first moveTo.
                    // Note: these *must* use `this.{data,commands}.length`, because buffers will have padding.
                    var commandsCount = this.commands.length;
                    var dataPosition = (this.data.length >> 2) - 2;
                    var commands = this.commands.bytes;
                    release || assert(commands[0] === 9 /* MoveTo */);
                    var data = this.data.ints;
                    var morphData = this.morphData ? this.morphData.ints : null;

                    // Only write the first moveTo if it doesn't go to the current coordinates.
                    if (data[dataPosition] !== lastPosition.x || data[dataPosition + 1] !== lastPosition.y) {
                        this._writeCommand(9 /* MoveTo */, dataPosition, data, morphData, shape);
                    }
                    if (commandsCount === 1) {
                        lastPosition.x = data[0];
                        lastPosition.y = data[1];
                        return;
                    }
                    for (var i = commandsCount; i-- > 1;) {
                        dataPosition -= 2;
                        var command = commands[i];
                        shape.writeCommandAndCoordinates(command, data[dataPosition], data[dataPosition + 1]);
                        if (morphData) {
                            shape.writeMorphCoordinates(morphData[dataPosition], morphData[dataPosition + 1]);
                        }
                        if (command === 11 /* CurveTo */) {
                            dataPosition -= 2;
                            shape.writeCoordinates(data[dataPosition], data[dataPosition + 1]);
                            if (morphData) {
                                shape.writeMorphCoordinates(morphData[dataPosition], morphData[dataPosition + 1]);
                            }
                        } else {
                        }
                    }
                    release || assert(dataPosition === 0);
                    lastPosition.x = data[0];
                    lastPosition.y = data[1];
                };
                PathSegment.prototype._writeCommand = function (command, position, data, morphData, shape) {
                    shape.writeCommandAndCoordinates(command, data[position++], data[position++]);
                    if (morphData) {
                        shape.writeMorphCoordinates(morphData[position - 2], morphData[position - 1]);
                    }
                    if (command === 11 /* CurveTo */) {
                        shape.writeCoordinates(data[position++], data[position++]);
                        if (morphData) {
                            shape.writeMorphCoordinates(morphData[position - 2], morphData[position - 1]);
                        }
                    }
                    return position;
                };
                PathSegment._counter = 0;
                return PathSegment;
            })();

            var SegmentedPath = (function () {
                function SegmentedPath(fillStyle, lineStyle) {
                    this.fillStyle = fillStyle;
                    this.lineStyle = lineStyle;
                    this._head = null;
                }
                SegmentedPath.prototype.addSegment = function (segment) {
                    release || assert(segment);
                    release || assert(segment.next === null);
                    release || assert(segment.prev === null);
                    var currentHead = this._head;
                    if (currentHead) {
                        release || assert(segment !== currentHead);
                        currentHead.next = segment;
                        segment.prev = currentHead;
                    }
                    this._head = segment;
                };

                // Does *not* reset the segment's prev and next pointers!
                SegmentedPath.prototype.removeSegment = function (segment) {
                    if (segment.prev) {
                        segment.prev.next = segment.next;
                    }
                    if (segment.next) {
                        segment.next.prev = segment.prev;
                    }
                };

                SegmentedPath.prototype.insertSegment = function (segment, next) {
                    var prev = next.prev;
                    segment.prev = prev;
                    segment.next = next;
                    if (prev) {
                        prev.next = segment;
                    }
                    next.prev = segment;
                };

                SegmentedPath.prototype.head = function () {
                    return this._head;
                };

                SegmentedPath.prototype.serialize = function (shape) {
                    var segment = this.head();
                    if (!segment) {
                        // Path is empty.
                        return;
                    }

                    while (segment) {
                        segment.storeStartAndEnd();
                        segment = segment.prev;
                    }

                    var start = this.head();
                    var end = start;

                    var finalRoot = null;
                    var finalHead = null;

                    // Path segments for one style can appear in arbitrary order in the tag's list
                    // of edge records.
                    // Before we linearize them, we have to identify all pairs of segments where
                    // one ends at a coordinate the other starts at.
                    // The following loop does that, by creating ever-growing runs of matching
                    // segments. If no more segments are found that match the current run (either
                    // at the beginning, or at the end), the current run is complete, and a new
                    // one is started. Rinse, repeat, until no solitary segments remain.
                    var current = start.prev;
                    while (start) {
                        while (current) {
                            if (current.connectsTo(start)) {
                                if (current.next !== start) {
                                    this.removeSegment(current);
                                    this.insertSegment(current, start);
                                }
                                start = current;
                                current = start.prev;
                                continue;
                            }
                            if (end.connectsTo(current)) {
                                this.removeSegment(current);
                                end.next = current;
                                current = current.prev;
                                end.next.prev = end;
                                end.next.next = null;
                                end = end.next;
                                continue;
                            }
                            current = current.prev;
                        }

                        // This run of segments is finished. Store and forget it (for this loop).
                        current = start.prev;
                        if (!finalRoot) {
                            finalRoot = start;
                            finalHead = end;
                        } else {
                            finalHead.next = start;
                            start.prev = finalHead;
                            finalHead = end;
                            finalHead.next = null;
                        }
                        if (!current) {
                            break;
                        }
                        start = end = current;
                        current = start.prev;
                    }

                    if (this.fillStyle) {
                        var style = this.fillStyle;
                        switch (style.type) {
                            case 0 /* Solid */:
                                shape.beginFill(style.color);
                                break;
                            case 16 /* LinearGradient */:
                            case 18 /* RadialGradient */:
                            case 19 /* FocalRadialGradient */:
                                var gradientType = style.type === 16 /* LinearGradient */ ? 16 /* Linear */ : 18 /* Radial */;
                                shape.beginGradient(2 /* BeginGradientFill */, style.colors, style.ratios, gradientType, style.transform, style.spreadMethod, style.interpolationMode, style.focalPoint | 0);
                                break;
                            case 65 /* ClippedBitmap */:
                            case 64 /* RepeatingBitmap */:
                            case 67 /* NonsmoothedClippedBitmap */:
                            case 66 /* NonsmoothedRepeatingBitmap */:
                                release || assert(style.bitmapIndex > -1);
                                shape.beginBitmap(3 /* BeginBitmapFill */, style.bitmapIndex, style.transform, style.repeat, style.smooth);
                                break;
                            default:
                                release || assertUnreachable('Invalid fill style type: ' + style.type);
                        }
                    } else {
                        var style = this.lineStyle;
                        release || assert(style);
                        switch (style.type) {
                            case 0 /* Solid */:
                                writeLineStyle(style, shape);
                                break;
                            case 16 /* LinearGradient */:
                            case 18 /* RadialGradient */:
                            case 19 /* FocalRadialGradient */:
                                var gradientType = style.type === 16 /* LinearGradient */ ? 16 /* Linear */ : 18 /* Radial */;
                                writeLineStyle(style, shape);
                                shape.beginGradient(6 /* LineStyleGradient */, style.colors, style.ratios, gradientType, style.transform, style.spreadMethod, style.interpolationMode, style.focalPoint | 0);
                                break;
                            case 65 /* ClippedBitmap */:
                            case 64 /* RepeatingBitmap */:
                            case 67 /* NonsmoothedClippedBitmap */:
                            case 66 /* NonsmoothedRepeatingBitmap */:
                                release || assert(style.bitmapIndex > -1);
                                writeLineStyle(style, shape);
                                shape.beginBitmap(7 /* LineStyleBitmap */, style.bitmapIndex, style.transform, style.repeat, style.smooth);
                                break;
                            default:
                                console.error('Line style type not yet supported: ' + style.type);
                        }
                    }

                    var lastPosition = { x: 0, y: 0 };
                    current = finalRoot;
                    while (current) {
                        current.serialize(shape, lastPosition);
                        current = current.next;
                    }
                    if (this.fillStyle) {
                        shape.endFill();
                    } else {
                        shape.endLine();
                    }
                    return shape;
                };
                return SegmentedPath;
            })();

            function writeLineStyle(style, shape) {
                // No scaling == 0, normal == 1, vertical only == 2, horizontal only == 3.
                var scaleMode = style.noHscale ? (style.noVscale ? 0 : 2) : style.noVscale ? 3 : 1;

                // TODO: Figure out how to handle startCapsStyle
                var thickness = clamp(style.width, 0, 0xff * 20) | 0;
                shape.lineStyle(thickness, style.color, style.pixelHinting, scaleMode, style.endCapsStyle, style.jointStyle, style.miterLimit);
            }
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            var SOUND_SIZE_8_BIT = 0;
            var SOUND_SIZE_16_BIT = 1;
            var SOUND_TYPE_MONO = 0;
            var SOUND_TYPE_STEREO = 1;

            var SOUND_FORMAT_PCM_BE = 0;
            var SOUND_FORMAT_ADPCM = 1;
            var SOUND_FORMAT_MP3 = 2;
            var SOUND_FORMAT_PCM_LE = 3;
            var SOUND_FORMAT_NELLYMOSER_16 = 4;
            var SOUND_FORMAT_NELLYMOSER_8 = 5;
            var SOUND_FORMAT_NELLYMOSER = 6;
            var SOUND_FORMAT_SPEEX = 11;

            var SOUND_RATES = [5512, 11250, 22500, 44100];

            var WaveHeader = new Uint8Array([
                0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00,
                0x57, 0x41, 0x56, 0x45, 0x66, 0x6D, 0x74, 0x20, 0x10, 0x00, 0x00, 0x00,
                0x01, 0x00, 0x02, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x10, 0xB1, 0x02, 0x00,
                0x04, 0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00]);

            function packageWave(data, sampleRate, channels, size, swapBytes) {
                var sizeInBytes = size >> 3;
                var sizePerSecond = channels * sampleRate * sizeInBytes;
                var sizePerSample = channels * sizeInBytes;
                var dataLength = data.length + (data.length & 1);
                var buffer = new ArrayBuffer(WaveHeader.length + dataLength);
                var bytes = new Uint8Array(buffer);
                bytes.set(WaveHeader);
                if (swapBytes) {
                    for (var i = 0, j = WaveHeader.length; i < data.length; i += 2, j += 2) {
                        bytes[j] = data[i + 1];
                        bytes[j + 1] = data[i];
                    }
                } else {
                    bytes.set(data, WaveHeader.length);
                }
                var view = new DataView(buffer);
                view.setUint32(4, dataLength + 36, true);
                view.setUint16(22, channels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sizePerSecond, true);
                view.setUint16(32, sizePerSample, true);
                view.setUint16(34, size, true);
                view.setUint32(40, dataLength, true);
                return {
                    data: bytes,
                    mimeType: 'audio/wav'
                };
            }

            function defineSound(tag, dictionary) {
                var channels = tag.soundType == SOUND_TYPE_STEREO ? 2 : 1;
                var samplesCount = tag.samplesCount;
                var sampleRate = SOUND_RATES[tag.soundRate];

                var data = tag.soundData;
                var pcm, packaged;
                switch (tag.soundFormat) {
                    case SOUND_FORMAT_PCM_BE:
                        pcm = new Float32Array(samplesCount * channels);
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                                pcm[i] = ((data[j] << 24) | (data[j + 1] << 16)) / 2147483648;
                            packaged = packageWave(data, sampleRate, channels, 16, true);
                        } else {
                            for (var i = 0; i < pcm.length; i++)
                                pcm[i] = (data[i] - 128) / 128;
                            packaged = packageWave(data, sampleRate, channels, 8, false);
                        }
                        break;
                    case SOUND_FORMAT_PCM_LE:
                        pcm = new Float32Array(samplesCount * channels);
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                                pcm[i] = ((data[j + 1] << 24) | (data[j] << 16)) / 2147483648;
                            packaged = packageWave(data, sampleRate, channels, 16, false);
                        } else {
                            for (var i = 0; i < pcm.length; i++)
                                pcm[i] = (data[i] - 128) / 128;
                            packaged = packageWave(data, sampleRate, channels, 8, false);
                        }
                        break;
                    case SOUND_FORMAT_MP3:
                        packaged = {
                            data: new Uint8Array(data.subarray(2)),
                            mimeType: 'audio/mpeg'
                        };
                        break;
                    case SOUND_FORMAT_ADPCM:
                        var pcm16 = new Int16Array(samplesCount * channels);
                        decodeACPCMSoundData(data, pcm16, channels);
                        pcm = new Float32Array(samplesCount * channels);
                        for (var i = 0; i < pcm.length; i++)
                            pcm[i] = pcm16[i] / 32768;
                        packaged = packageWave(new Uint8Array(pcm16.buffer), sampleRate, channels, 16, !(new Uint8Array(new Uint16Array([1]).buffer))[0]);
                        break;
                    default:
                        throw new Error('Unsupported audio format: ' + tag.soundFormat);
                }

                var sound = {
                    type: 'sound',
                    id: tag.id,
                    sampleRate: sampleRate,
                    channels: channels,
                    pcm: pcm,
                    packaged: undefined
                };
                if (packaged) {
                    sound.packaged = packaged;
                }
                return sound;
            }
            Parser.defineSound = defineSound;

            var ACPCMIndexTables = [
                [-1, 2],
                [-1, -1, 2, 4],
                [-1, -1, -1, -1, 2, 4, 6, 8],
                [-1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 4, 6, 8, 10, 13, 16]
            ];

            var ACPCMStepSizeTable = [
                7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
                50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230,
                253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,
                1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327,
                3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487,
                12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
            ];

            function decodeACPCMSoundData(data, pcm16, channels) {
                function readBits(n) {
                    while (dataBufferLength < n) {
                        dataBuffer = (dataBuffer << 8) | data[dataPosition++];
                        dataBufferLength += 8;
                    }
                    dataBufferLength -= n;
                    return (dataBuffer >>> dataBufferLength) & ((1 << n) - 1);
                }
                var dataPosition = 0;
                var dataBuffer = 0;
                var dataBufferLength = 0;

                var pcmPosition = 0;
                var codeSize = readBits(2);
                var indexTable = ACPCMIndexTables[codeSize];
                while (pcmPosition < pcm16.length) {
                    var x = pcm16[pcmPosition++] = (readBits(16) << 16) >> 16, x2;
                    var stepIndex = readBits(6), stepIndex2;
                    if (channels > 1) {
                        x2 = pcm16[pcmPosition++] = (readBits(16) << 16) >> 16;
                        stepIndex2 = readBits(6);
                    }
                    var signMask = 1 << (codeSize + 1);
                    for (var i = 0; i < 4095; i++) {
                        var nibble = readBits(codeSize + 2);
                        var step = ACPCMStepSizeTable[stepIndex];
                        var sum = 0;
                        for (var currentBit = signMask >> 1; currentBit; currentBit >>= 1, step >>= 1) {
                            if (nibble & currentBit)
                                sum += step;
                        }
                        x += (nibble & signMask ? -1 : 1) * (sum + step);
                        pcm16[pcmPosition++] = (x = (x < -32768 ? -32768 : x > 32767 ? 32767 : x));
                        stepIndex += indexTable[nibble & ~signMask];
                        stepIndex = stepIndex < 0 ? 0 : stepIndex > 88 ? 88 : stepIndex;
                        if (channels > 1) {
                            nibble = readBits(codeSize + 2);
                            step = ACPCMStepSizeTable[stepIndex2];
                            sum = 0;
                            for (var currentBit = signMask >> 1; currentBit; currentBit >>= 1, step >>= 1) {
                                if (nibble & currentBit)
                                    sum += step;
                            }
                            x2 += (nibble & signMask ? -1 : 1) * (sum + step);
                            pcm16[pcmPosition++] = (x2 = (x2 < -32768 ? -32768 : x2 > 32767 ? 32767 : x2));
                            stepIndex2 += indexTable[nibble & ~signMask];
                            stepIndex2 = stepIndex2 < 0 ? 0 : stepIndex2 > 88 ? 88 : stepIndex2;
                        }
                    }
                }
            }

            var nextSoundStreamId = 0;

            var SwfSoundStream = (function () {
                function SwfSoundStream(samplesCount, sampleRate, channels) {
                    this.streamId = (nextSoundStreamId++);
                    this.samplesCount = samplesCount;
                    this.sampleRate = sampleRate;
                    this.channels = channels;
                    this.format = null;
                    this.currentSample = 0;
                }
                Object.defineProperty(SwfSoundStream.prototype, "info", {
                    get: function () {
                        return {
                            samplesCount: this.samplesCount,
                            sampleRate: this.sampleRate,
                            channels: this.channels,
                            format: this.format,
                            streamId: this.streamId
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                return SwfSoundStream;
            })();
            Parser.SwfSoundStream = SwfSoundStream;

            function SwfSoundStream_decode_PCM(data) {
                var pcm = new Float32Array(data.length);
                for (var i = 0; i < pcm.length; i++)
                    pcm[i] = (data[i] - 128) / 128;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }

            function SwfSoundStream_decode_PCM_be(data) {
                var pcm = new Float32Array(data.length / 2);
                for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                    pcm[i] = ((data[j] << 24) | (data[j + 1] << 16)) / 2147483648;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }

            function SwfSoundStream_decode_PCM_le(data) {
                var pcm = new Float32Array(data.length / 2);
                for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                    pcm[i] = ((data[j + 1] << 24) | (data[j] << 16)) / 2147483648;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }

            function SwfSoundStream_decode_MP3(data) {
                var samplesCount = (data[1] << 8) | data[0];
                var seek = (data[3] << 8) | data[2];
                this.currentSample += samplesCount;
                return {
                    streamId: this.streamId,
                    samplesCount: samplesCount,
                    data: new Uint8Array(data.subarray(4)),
                    seek: seek
                };
            }

            function createSoundStream(tag) {
                var channels = tag.streamType == SOUND_TYPE_STEREO ? 2 : 1;
                var samplesCount = tag.samplesCount;
                var sampleRate = SOUND_RATES[tag.streamRate];
                var stream = new SwfSoundStream(samplesCount, sampleRate, channels);

                switch (tag.streamCompression) {
                    case SOUND_FORMAT_PCM_BE:
                        stream.format = 'wave';
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            stream.decode = SwfSoundStream_decode_PCM_be;
                        } else {
                            stream.decode = SwfSoundStream_decode_PCM;
                        }
                        break;
                    case SOUND_FORMAT_PCM_LE:
                        stream.format = 'wave';
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            stream.decode = SwfSoundStream_decode_PCM_le;
                        } else {
                            stream.decode = SwfSoundStream_decode_PCM;
                        }
                        break;
                    case SOUND_FORMAT_MP3:
                        stream.format = 'mp3';
                        stream.decode = SwfSoundStream_decode_MP3;
                        break;
                    default:
                        throw new Error('Unsupported audio format: ' + tag.soundFormat);
                }

                return stream;
            }
            Parser.createSoundStream = createSoundStream;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        /// <reference path='references.ts'/>
        (function (Parser) {
            function defineText(tag, dictionary) {
                var dependencies = [];
                var bold = false;
                var italic = false;
                if (tag.hasFont) {
                    var font = dictionary[tag.fontId];
                    if (font) {
                        dependencies.push(font.id);
                        bold = font.bold;
                        italic = font.italic;
                    } else {
                        Shumway.Debug.warning("Font is not defined.");
                    }
                }

                var props = {
                    type: 'text',
                    id: tag.id,
                    fillBounds: tag.bbox,
                    variableName: tag.variableName,
                    tag: tag,
                    bold: bold,
                    italic: italic,
                    require: undefined
                };
                if (dependencies.length) {
                    props.require = dependencies;
                }
                return props;
            }
            Parser.defineText = defineText;
        })(SWF.Parser || (SWF.Parser = {}));
        var Parser = SWF.Parser;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
///<reference path='../references.ts' />
///<reference path='templates.ts' />
///<reference path='handlers.ts' />
///<reference path='parser.ts' />
///<reference path='bitmap.ts' />
///<reference path='button.ts' />
///<reference path='font.ts' />
///<reference path='image.ts' />
///<reference path='label.ts' />
///<reference path='shape.ts' />
///<reference path='sound.ts' />
///<reference path='text.ts' />
/* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    /*
    This code was forked from https://github.com/notmasteryet/jpgjs. The original
    version was created by github user notmasteryet
    
    - The JPEG specification can be found in the ITU CCITT Recommendation T.81
    (www.w3.org/Graphics/JPEG/itu-t81.pdf)
    - The JFIF specification can be found in the JPEG File Interchange Format
    (www.w3.org/Graphics/JPEG/jfif3.pdf)
    - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
    in PostScript Level 2, Technical Note #5116
    (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)
    */
    (function (JPEG) {
        var dctZigZag = new Int32Array([
            0,
            1, 8,
            16, 9, 2,
            3, 10, 17, 24,
            32, 25, 18, 11, 4,
            5, 12, 19, 26, 33, 40,
            48, 41, 34, 27, 20, 13, 6,
            7, 14, 21, 28, 35, 42, 49, 56,
            57, 50, 43, 36, 29, 22, 15,
            23, 30, 37, 44, 51, 58,
            59, 52, 45, 38, 31,
            39, 46, 53, 60,
            61, 54, 47,
            55, 62,
            63
        ]);

        var dctCos1 = 4017;
        var dctSin1 = 799;
        var dctCos3 = 3406;
        var dctSin3 = 2276;
        var dctCos6 = 1567;
        var dctSin6 = 3784;
        var dctSqrt2 = 5793;
        var dctSqrt1d2 = 2896;

        function constructor() {
        }

        function buildHuffmanTable(codeLengths, values) {
            var k = 0, code = [], i, j, length = 16;
            while (length > 0 && !codeLengths[length - 1]) {
                length--;
            }
            code.push({ children: [], index: 0 });
            var p = code[0], q;
            for (i = 0; i < length; i++) {
                for (j = 0; j < codeLengths[i]; j++) {
                    p = code.pop();
                    p.children[p.index] = values[k];
                    while (p.index > 0) {
                        p = code.pop();
                    }
                    p.index++;
                    code.push(p);
                    while (code.length <= i) {
                        code.push(q = { children: [], index: 0 });
                        p.children[p.index] = q.children;
                        p = q;
                    }
                    k++;
                }
                if (i + 1 < length) {
                    // p here points to last code
                    code.push(q = { children: [], index: 0 });
                    p.children[p.index] = q.children;
                    p = q;
                }
            }
            return code[0].children;
        }

        function getBlockBufferOffset(component, row, col) {
            return 64 * ((component.blocksPerLine + 1) * row + col);
        }

        function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
            var precision = frame.precision;
            var samplesPerLine = frame.samplesPerLine;
            var scanLines = frame.scanLines;
            var mcusPerLine = frame.mcusPerLine;
            var progressive = frame.progressive;
            var maxH = frame.maxH, maxV = frame.maxV;

            var startOffset = offset, bitsData = 0, bitsCount = 0;

            function readBit() {
                if (bitsCount > 0) {
                    bitsCount--;
                    return (bitsData >> bitsCount) & 1;
                }
                bitsData = data[offset++];
                if (bitsData == 0xFF) {
                    var nextByte = data[offset++];
                    if (nextByte) {
                        throw 'unexpected marker: ' + ((bitsData << 8) | nextByte).toString(16);
                    }
                    // unstuff 0
                }
                bitsCount = 7;
                return bitsData >>> 7;
            }

            function decodeHuffman(tree) {
                var node = tree;
                var bit;
                while ((bit = readBit()) !== null) {
                    node = node[bit];
                    if (typeof node === 'number') {
                        return node;
                    }
                    if (typeof node !== 'object') {
                        throw 'invalid huffman sequence';
                    }
                }
                return null;
            }

            function receive(length) {
                var n = 0;
                while (length > 0) {
                    var bit = readBit();
                    if (bit === null) {
                        return;
                    }
                    n = (n << 1) | bit;
                    length--;
                }
                return n;
            }

            function receiveAndExtend(length) {
                if (length === 1) {
                    return readBit() === 1 ? 1 : -1;
                }
                var n = receive(length);
                if (n >= 1 << (length - 1)) {
                    return n;
                }
                return n + (-1 << length) + 1;
            }

            function decodeBaseline(component, offset) {
                var t = decodeHuffman(component.huffmanTableDC);
                var diff = t === 0 ? 0 : receiveAndExtend(t);
                component.blockData[offset] = (component.pred += diff);
                var k = 1;
                while (k < 64) {
                    var rs = decodeHuffman(component.huffmanTableAC);
                    var s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                        if (r < 15) {
                            break;
                        }
                        k += 16;
                        continue;
                    }
                    k += r;
                    var z = dctZigZag[k];
                    component.blockData[offset + z] = receiveAndExtend(s);
                    k++;
                }
            }

            function decodeDCFirst(component, offset) {
                var t = decodeHuffman(component.huffmanTableDC);
                var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
                component.blockData[offset] = (component.pred += diff);
            }

            function decodeDCSuccessive(component, offset) {
                component.blockData[offset] |= readBit() << successive;
            }

            var eobrun = 0;
            function decodeACFirst(component, offset) {
                if (eobrun > 0) {
                    eobrun--;
                    return;
                }
                var k = spectralStart, e = spectralEnd;
                while (k <= e) {
                    var rs = decodeHuffman(component.huffmanTableAC);
                    var s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                        if (r < 15) {
                            eobrun = receive(r) + (1 << r) - 1;
                            break;
                        }
                        k += 16;
                        continue;
                    }
                    k += r;
                    var z = dctZigZag[k];
                    component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
                    k++;
                }
            }

            var successiveACState = 0, successiveACNextValue;
            function decodeACSuccessive(component, offset) {
                var k = spectralStart;
                var e = spectralEnd;
                var r = 0;
                var s;
                var rs;
                while (k <= e) {
                    var z = dctZigZag[k];
                    switch (successiveACState) {
                        case 0:
                            rs = decodeHuffman(component.huffmanTableAC);
                            s = rs & 15;
                            r = rs >> 4;
                            if (s === 0) {
                                if (r < 15) {
                                    eobrun = receive(r) + (1 << r);
                                    successiveACState = 4;
                                } else {
                                    r = 16;
                                    successiveACState = 1;
                                }
                            } else {
                                if (s !== 1) {
                                    throw 'invalid ACn encoding';
                                }
                                successiveACNextValue = receiveAndExtend(s);
                                successiveACState = r ? 2 : 3;
                            }
                            continue;
                        case 1:
                        case 2:
                            if (component.blockData[offset + z]) {
                                component.blockData[offset + z] += (readBit() << successive);
                            } else {
                                r--;
                                if (r === 0) {
                                    successiveACState = successiveACState == 2 ? 3 : 0;
                                }
                            }
                            break;
                        case 3:
                            if (component.blockData[offset + z]) {
                                component.blockData[offset + z] += (readBit() << successive);
                            } else {
                                component.blockData[offset + z] = successiveACNextValue << successive;
                                successiveACState = 0;
                            }
                            break;
                        case 4:
                            if (component.blockData[offset + z]) {
                                component.blockData[offset + z] += (readBit() << successive);
                            }
                            break;
                    }
                    k++;
                }
                if (successiveACState === 4) {
                    eobrun--;
                    if (eobrun === 0) {
                        successiveACState = 0;
                    }
                }
            }

            function decodeMcu(component, decode, mcu, row, col) {
                var mcuRow = (mcu / mcusPerLine) | 0;
                var mcuCol = mcu % mcusPerLine;
                var blockRow = mcuRow * component.v + row;
                var blockCol = mcuCol * component.h + col;
                var offset = getBlockBufferOffset(component, blockRow, blockCol);
                decode(component, offset);
            }

            function decodeBlock(component, decode, mcu) {
                var blockRow = (mcu / component.blocksPerLine) | 0;
                var blockCol = mcu % component.blocksPerLine;
                var offset = getBlockBufferOffset(component, blockRow, blockCol);
                decode(component, offset);
            }

            var componentsLength = components.length;
            var component, i, j, k, n;
            var decodeFn;
            if (progressive) {
                if (spectralStart === 0) {
                    decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                } else {
                    decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                }
            } else {
                decodeFn = decodeBaseline;
            }

            var mcu = 0, marker;
            var mcuExpected;
            if (componentsLength == 1) {
                mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
            } else {
                mcuExpected = mcusPerLine * frame.mcusPerColumn;
            }
            if (!resetInterval) {
                resetInterval = mcuExpected;
            }

            var h, v;
            while (mcu < mcuExpected) {
                for (i = 0; i < componentsLength; i++) {
                    components[i].pred = 0;
                }
                eobrun = 0;

                if (componentsLength == 1) {
                    component = components[0];
                    for (n = 0; n < resetInterval; n++) {
                        decodeBlock(component, decodeFn, mcu);
                        mcu++;
                    }
                } else {
                    for (n = 0; n < resetInterval; n++) {
                        for (i = 0; i < componentsLength; i++) {
                            component = components[i];
                            h = component.h;
                            v = component.v;
                            for (j = 0; j < v; j++) {
                                for (k = 0; k < h; k++) {
                                    decodeMcu(component, decodeFn, mcu, j, k);
                                }
                            }
                        }
                        mcu++;
                    }
                }

                // find marker
                bitsCount = 0;
                marker = (data[offset] << 8) | data[offset + 1];
                if (marker <= 0xFF00) {
                    throw 'marker was not found';
                }

                if (marker >= 0xFFD0 && marker <= 0xFFD7) {
                    offset += 2;
                } else {
                    break;
                }
            }

            return offset - startOffset;
        }

        // A port of poppler's IDCT method which in turn is taken from:
        //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
        //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',
        //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
        //   988-991.
        function quantizeAndInverse(component, blockBufferOffset, p) {
            var qt = component.quantizationTable;
            var v0, v1, v2, v3, v4, v5, v6, v7, t;
            var i;

            for (i = 0; i < 64; i++) {
                p[i] = component.blockData[blockBufferOffset + i] * qt[i];
            }

            for (i = 0; i < 8; ++i) {
                var row = 8 * i;

                // check for all-zero AC coefficients
                if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 && p[7 + row] === 0) {
                    t = (dctSqrt2 * p[0 + row] + 512) >> 10;
                    p[0 + row] = t;
                    p[1 + row] = t;
                    p[2 + row] = t;
                    p[3 + row] = t;
                    p[4 + row] = t;
                    p[5 + row] = t;
                    p[6 + row] = t;
                    p[7 + row] = t;
                    continue;
                }

                // stage 4
                v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
                v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
                v2 = p[2 + row];
                v3 = p[6 + row];
                v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
                v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
                v5 = p[3 + row] << 4;
                v6 = p[5 + row] << 4;

                // stage 3
                t = (v0 - v1 + 1) >> 1;
                v0 = (v0 + v1 + 1) >> 1;
                v1 = t;
                t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
                v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
                v3 = t;
                t = (v4 - v6 + 1) >> 1;
                v4 = (v4 + v6 + 1) >> 1;
                v6 = t;
                t = (v7 + v5 + 1) >> 1;
                v5 = (v7 - v5 + 1) >> 1;
                v7 = t;

                // stage 2
                t = (v0 - v3 + 1) >> 1;
                v0 = (v0 + v3 + 1) >> 1;
                v3 = t;
                t = (v1 - v2 + 1) >> 1;
                v1 = (v1 + v2 + 1) >> 1;
                v2 = t;
                t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
                v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
                v7 = t;
                t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
                v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
                v6 = t;

                // stage 1
                p[0 + row] = v0 + v7;
                p[7 + row] = v0 - v7;
                p[1 + row] = v1 + v6;
                p[6 + row] = v1 - v6;
                p[2 + row] = v2 + v5;
                p[5 + row] = v2 - v5;
                p[3 + row] = v3 + v4;
                p[4 + row] = v3 - v4;
            }

            for (i = 0; i < 8; ++i) {
                var col = i;

                // check for all-zero AC coefficients
                if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 && p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 && p[7 * 8 + col] === 0) {
                    t = (dctSqrt2 * p[i + 0] + 8192) >> 14;
                    p[0 * 8 + col] = t;
                    p[1 * 8 + col] = t;
                    p[2 * 8 + col] = t;
                    p[3 * 8 + col] = t;
                    p[4 * 8 + col] = t;
                    p[5 * 8 + col] = t;
                    p[6 * 8 + col] = t;
                    p[7 * 8 + col] = t;
                    continue;
                }

                // stage 4
                v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;
                v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;
                v2 = p[2 * 8 + col];
                v3 = p[6 * 8 + col];
                v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;
                v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;
                v5 = p[3 * 8 + col];
                v6 = p[5 * 8 + col];

                // stage 3
                t = (v0 - v1 + 1) >> 1;
                v0 = (v0 + v1 + 1) >> 1;
                v1 = t;
                t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
                v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
                v3 = t;
                t = (v4 - v6 + 1) >> 1;
                v4 = (v4 + v6 + 1) >> 1;
                v6 = t;
                t = (v7 + v5 + 1) >> 1;
                v5 = (v7 - v5 + 1) >> 1;
                v7 = t;

                // stage 2
                t = (v0 - v3 + 1) >> 1;
                v0 = (v0 + v3 + 1) >> 1;
                v3 = t;
                t = (v1 - v2 + 1) >> 1;
                v1 = (v1 + v2 + 1) >> 1;
                v2 = t;
                t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
                v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
                v7 = t;
                t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
                v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
                v6 = t;

                // stage 1
                p[0 * 8 + col] = v0 + v7;
                p[7 * 8 + col] = v0 - v7;
                p[1 * 8 + col] = v1 + v6;
                p[6 * 8 + col] = v1 - v6;
                p[2 * 8 + col] = v2 + v5;
                p[5 * 8 + col] = v2 - v5;
                p[3 * 8 + col] = v3 + v4;
                p[4 * 8 + col] = v3 - v4;
            }

            for (i = 0; i < 64; ++i) {
                var index = blockBufferOffset + i;
                var q = p[i];
                q = (q <= -2056) ? 0 : (q >= 2024) ? 255 : (q + 2056) >> 4;
                component.blockData[index] = q;
            }
        }

        function buildComponentData(frame, component) {
            var lines = [];
            var blocksPerLine = component.blocksPerLine;
            var blocksPerColumn = component.blocksPerColumn;
            var samplesPerLine = blocksPerLine << 3;
            var computationBuffer = new Int32Array(64);

            var i, j, ll = 0;
            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                    var offset = getBlockBufferOffset(component, blockRow, blockCol);
                    quantizeAndInverse(component, offset, computationBuffer);
                }
            }
            return component.blockData;
        }

        function clamp0to255(a) {
            return a <= 0 ? 0 : a >= 255 ? 255 : a;
        }

        var JpegImage = (function () {
            function JpegImage() {
            }
            JpegImage.prototype.parse = function (data) {
                function readUint16() {
                    var value = (data[offset] << 8) | data[offset + 1];
                    offset += 2;
                    return value;
                }

                function readDataBlock() {
                    var length = readUint16();
                    var array = data.subarray(offset, offset + length - 2);
                    offset += array.length;
                    return array;
                }

                function prepareComponents(frame) {
                    var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
                    var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
                    for (var i = 0; i < frame.components.length; i++) {
                        component = frame.components[i];
                        var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
                        var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
                        var blocksPerLineForMcu = mcusPerLine * component.h;
                        var blocksPerColumnForMcu = mcusPerColumn * component.v;

                        var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                        component.blockData = new Int16Array(blocksBufferSize);
                        component.blocksPerLine = blocksPerLine;
                        component.blocksPerColumn = blocksPerColumn;
                    }
                    frame.mcusPerLine = mcusPerLine;
                    frame.mcusPerColumn = mcusPerColumn;
                }

                var offset = 0, length = data.length;
                var jfif = null;
                var adobe = null;
                var pixels = null;
                var frame, resetInterval;
                var quantizationTables = [];
                var huffmanTablesAC = [], huffmanTablesDC = [];
                var fileMarker = readUint16();
                if (fileMarker != 0xFFD8) {
                    throw 'SOI not found';
                }

                fileMarker = readUint16();
                while (fileMarker != 0xFFD9) {
                    var i, j, l;
                    switch (fileMarker) {
                        case 0xFFE0:
                        case 0xFFE1:
                        case 0xFFE2:
                        case 0xFFE3:
                        case 0xFFE4:
                        case 0xFFE5:
                        case 0xFFE6:
                        case 0xFFE7:
                        case 0xFFE8:
                        case 0xFFE9:
                        case 0xFFEA:
                        case 0xFFEB:
                        case 0xFFEC:
                        case 0xFFED:
                        case 0xFFEE:
                        case 0xFFEF:
                        case 0xFFFE:
                            var appData = readDataBlock();

                            if (fileMarker === 0xFFE0) {
                                if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
                                    jfif = {
                                        version: { major: appData[5], minor: appData[6] },
                                        densityUnits: appData[7],
                                        xDensity: (appData[8] << 8) | appData[9],
                                        yDensity: (appData[10] << 8) | appData[11],
                                        thumbWidth: appData[12],
                                        thumbHeight: appData[13],
                                        thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                                    };
                                }
                            }

                            // TODO APP1 - Exif
                            if (fileMarker === 0xFFEE) {
                                if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) {
                                    adobe = {
                                        version: appData[6],
                                        flags0: (appData[7] << 8) | appData[8],
                                        flags1: (appData[9] << 8) | appData[10],
                                        transformCode: appData[11]
                                    };
                                }
                            }
                            break;

                        case 0xFFDB:
                            var quantizationTablesLength = readUint16();
                            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                            var z;
                            while (offset < quantizationTablesEnd) {
                                var quantizationTableSpec = data[offset++];
                                var tableData = new Int32Array(64);
                                if ((quantizationTableSpec >> 4) === 0) {
                                    for (j = 0; j < 64; j++) {
                                        z = dctZigZag[j];
                                        tableData[z] = data[offset++];
                                    }
                                } else if ((quantizationTableSpec >> 4) === 1) {
                                    for (j = 0; j < 64; j++) {
                                        z = dctZigZag[j];
                                        tableData[z] = readUint16();
                                    }
                                } else {
                                    throw 'DQT: invalid table spec';
                                }
                                quantizationTables[quantizationTableSpec & 15] = tableData;
                            }
                            break;

                        case 0xFFC0:
                        case 0xFFC1:
                        case 0xFFC2:
                            if (frame) {
                                throw 'Only single frame JPEGs supported';
                            }
                            readUint16(); // skip data length
                            frame = {};
                            frame.extended = (fileMarker === 0xFFC1);
                            frame.progressive = (fileMarker === 0xFFC2);
                            frame.precision = data[offset++];
                            frame.scanLines = readUint16();
                            frame.samplesPerLine = readUint16();
                            frame.components = [];
                            frame.componentIds = {};
                            var componentsCount = data[offset++], componentId;
                            var maxH = 0, maxV = 0;
                            for (i = 0; i < componentsCount; i++) {
                                componentId = data[offset];
                                var h = data[offset + 1] >> 4;
                                var v = data[offset + 1] & 15;
                                if (maxH < h) {
                                    maxH = h;
                                }
                                if (maxV < v) {
                                    maxV = v;
                                }
                                var qId = data[offset + 2];
                                l = frame.components.push({
                                    h: h,
                                    v: v,
                                    quantizationTable: quantizationTables[qId]
                                });
                                frame.componentIds[componentId] = l - 1;
                                offset += 3;
                            }
                            frame.maxH = maxH;
                            frame.maxV = maxV;
                            prepareComponents(frame);
                            break;

                        case 0xFFC4:
                            var huffmanLength = readUint16();
                            for (i = 2; i < huffmanLength;) {
                                var huffmanTableSpec = data[offset++];
                                var codeLengths = new Uint8Array(16);
                                var codeLengthSum = 0;
                                for (j = 0; j < 16; j++, offset++) {
                                    codeLengthSum += (codeLengths[j] = data[offset]);
                                }
                                var huffmanValues = new Uint8Array(codeLengthSum);
                                for (j = 0; j < codeLengthSum; j++, offset++) {
                                    huffmanValues[j] = data[offset];
                                }
                                i += 17 + codeLengthSum;

                                ((huffmanTableSpec >> 4) === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                            }
                            break;

                        case 0xFFDD:
                            readUint16(); // skip data length
                            resetInterval = readUint16();
                            break;

                        case 0xFFDA:
                            var scanLength = readUint16();
                            var selectorsCount = data[offset++];
                            var components = [], component;
                            for (i = 0; i < selectorsCount; i++) {
                                var componentIndex = frame.componentIds[data[offset++]];
                                component = frame.components[componentIndex];
                                var tableSpec = data[offset++];
                                component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                                component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                                components.push(component);
                            }
                            var spectralStart = data[offset++];
                            var spectralEnd = data[offset++];
                            var successiveApproximation = data[offset++];
                            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
                            offset += processed;
                            break;
                        default:
                            if (data[offset - 3] == 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
                                // could be incorrect encoding -- last 0xFF byte of the previous
                                // block was eaten by the encoder
                                offset -= 3;
                                break;
                            }
                            throw 'unknown JPEG marker ' + fileMarker.toString(16);
                    }
                    fileMarker = readUint16();
                }

                this.width = frame.samplesPerLine;
                this.height = frame.scanLines;
                this.jfif = jfif;
                this.adobe = adobe;
                this.components = [];
                for (i = 0; i < frame.components.length; i++) {
                    component = frame.components[i];
                    this.components.push({
                        output: buildComponentData(frame, component),
                        scaleX: component.h / frame.maxH,
                        scaleY: component.v / frame.maxV,
                        blocksPerLine: component.blocksPerLine,
                        blocksPerColumn: component.blocksPerColumn
                    });
                }
                this.numComponents = this.components.length;
            };

            JpegImage.prototype._getLinearizedBlockData = function (width, height) {
                var scaleX = this.width / width, scaleY = this.height / height;

                var component, componentScaleX, componentScaleY, blocksPerScanline;
                var x, y, i, j, k;
                var index;
                var offset = 0;
                var output;
                var numComponents = this.components.length;
                var dataLength = width * height * numComponents;
                var data = new Uint8Array(dataLength);
                var xScaleBlockOffset = new Uint32Array(width);
                var mask3LSB = 0xfffffff8;

                for (i = 0; i < numComponents; i++) {
                    component = this.components[i];
                    componentScaleX = component.scaleX * scaleX;
                    componentScaleY = component.scaleY * scaleY;
                    offset = i;
                    output = component.output;
                    blocksPerScanline = (component.blocksPerLine + 1) << 3;

                    for (x = 0; x < width; x++) {
                        j = 0 | (x * componentScaleX);
                        xScaleBlockOffset[x] = ((j & mask3LSB) << 3) | (j & 7);
                    }

                    for (y = 0; y < height; y++) {
                        j = 0 | (y * componentScaleY);
                        index = blocksPerScanline * (j & mask3LSB) | ((j & 7) << 3);
                        for (x = 0; x < width; x++) {
                            data[offset] = output[index + xScaleBlockOffset[x]];
                            offset += numComponents;
                        }
                    }
                }

                // decodeTransform will contains pairs of multiplier (-256..256) and
                // additive
                var transform = this.decodeTransform;
                if (transform) {
                    for (i = 0; i < dataLength;) {
                        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
                            data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];
                        }
                    }
                }
                return data;
            };

            JpegImage.prototype._isColorConversionNeeded = function () {
                if (this.adobe && this.adobe.transformCode) {
                    // The adobe transform marker overrides any previous setting
                    return true;
                } else if (this.numComponents == 3) {
                    return true;
                } else {
                    return false;
                }
            };

            JpegImage.prototype._convertYccToRgb = function (data) {
                var Y, Cb, Cr;
                for (var i = 0, length = data.length; i < length; i += 3) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = clamp0to255(Y - 179.456 + 1.402 * Cr);
                    data[i + 1] = clamp0to255(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
                    data[i + 2] = clamp0to255(Y - 226.816 + 1.772 * Cb);
                }
                return data;
            };

            JpegImage.prototype._convertYcckToRgb = function (data) {
                var Y, Cb, Cr, k, CbCb, CbCr, CbY, Cbk, CrCr, Crk, CrY, YY, Yk, kk;
                var offset = 0;
                for (var i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    k = data[i + 3];

                    CbCb = Cb * Cb;
                    CbCr = Cb * Cr;
                    CbY = Cb * Y;
                    Cbk = Cb * k;
                    CrCr = Cr * Cr;
                    Crk = Cr * k;
                    CrY = Cr * Y;
                    YY = Y * Y;
                    Yk = Y * k;
                    kk = k * k;

                    var r = -122.67195406894 - 6.60635669420364e-5 * CbCb + 0.000437130475926232 * CbCr - 5.4080610064599e-5 * CbY + 0.00048449797120281 * Cbk - 0.154362151871126 * Cb - 0.000957964378445773 * CrCr + 0.000817076911346625 * CrY - 0.00477271405408747 * Crk + 1.53380253221734 * Cr + 0.000961250184130688 * YY - 0.00266257332283933 * Yk + 0.48357088451265 * Y - 0.000336197177618394 * kk + 0.484791561490776 * k;

                    var g = 107.268039397724 + 2.19927104525741e-5 * CbCb - 0.000640992018297945 * CbCr + 0.000659397001245577 * CbY + 0.000426105652938837 * Cbk - 0.176491792462875 * Cb - 0.000778269941513683 * CrCr + 0.00130872261408275 * CrY + 0.000770482631801132 * Crk - 0.151051492775562 * Cr + 0.00126935368114843 * YY - 0.00265090189010898 * Yk + 0.25802910206845 * Y - 0.000318913117588328 * kk - 0.213742400323665 * k;

                    var b = -20.810012546947 - 0.000570115196973677 * CbCb - 2.63409051004589e-5 * CbCr + 0.0020741088115012 * CbY - 0.00288260236853442 * Cbk + 0.814272968359295 * Cb - 1.53496057440975e-5 * CrCr - 0.000132689043961446 * CrY + 0.000560833691242812 * Crk - 0.195152027534049 * Cr + 0.00174418132927582 * YY - 0.00255243321439347 * Yk + 0.116935020465145 * Y - 0.000343531996510555 * kk + 0.24165260232407 * k;

                    data[offset++] = clamp0to255(r);
                    data[offset++] = clamp0to255(g);
                    data[offset++] = clamp0to255(b);
                }
                return data;
            };

            JpegImage.prototype._convertYcckToCmyk = function (data) {
                var Y, Cb, Cr;
                for (var i = 0, length = data.length; i < length; i += 4) {
                    Y = data[i];
                    Cb = data[i + 1];
                    Cr = data[i + 2];
                    data[i] = clamp0to255(434.456 - Y - 1.402 * Cr);
                    data[i + 1] = clamp0to255(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
                    data[i + 2] = clamp0to255(481.816 - Y - 1.772 * Cb);
                    // K in data[i + 3] is unchanged
                }
                return data;
            };

            JpegImage.prototype._convertCmykToRgb = function (data) {
                var c, m, y, k;
                var offset = 0;
                var min = -255 * 255 * 255;
                var scale = 1 / 255 / 255;
                for (var i = 0, length = data.length; i < length; i += 4) {
                    c = data[i];
                    m = data[i + 1];
                    y = data[i + 2];
                    k = data[i + 3];

                    var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k - 72734.4411664936) + m * (1.7149763477362134 * m - 5.6096736904047315 * y - 17.873870861415444 * k - 1401.7366389350734) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 4465.541406466231) - k * (21.86122147463605 * k + 48317.86113160301);
                    var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k - 20220.756542821975) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 48691.05921601825) + y * (4.444339102852739 * y + 9.8632861493405 * k - 6341.191035517494) - k * (20.737325471181034 * k + 47890.15695978492);
                    var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k - 3616.812083916688) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 28620.90484698408) + y * (0.03296041114873217 * y + 115.60384449646641 * k - 49363.43385999684) - k * (22.33816807309886 * k + 45932.16563550634);

                    data[offset++] = r >= 0 ? 255 : r <= min ? 0 : 255 + r * scale | 0;
                    data[offset++] = g >= 0 ? 255 : g <= min ? 0 : 255 + g * scale | 0;
                    data[offset++] = b >= 0 ? 255 : b <= min ? 0 : 255 + b * scale | 0;
                }
                return data;
            };

            JpegImage.prototype.getData = function (width, height, forceRGBoutput) {
                if (this.numComponents > 4) {
                    throw 'Unsupported color mode';
                }

                // type of data: Uint8Array(width * height * numComponents)
                var data = this._getLinearizedBlockData(width, height);

                if (this.numComponents === 3) {
                    return this._convertYccToRgb(data);
                } else if (this.numComponents === 4) {
                    if (this._isColorConversionNeeded()) {
                        if (forceRGBoutput) {
                            return this._convertYcckToRgb(data);
                        } else {
                            return this._convertYcckToCmyk(data);
                        }
                    } else {
                        return this._convertCmykToRgb(data);
                    }
                }
                return data;
            };

            JpegImage.prototype.copyToImageData = function (imageData) {
                var width = imageData.width, height = imageData.height;
                var imageDataBytes = width * height * 4;
                var imageDataArray = imageData.data;
                var data = this.getData(width, height, true);
                var i = 0, j = 0;
                var Y, K, C, M, R, G, B;
                switch (this.components.length) {
                    case 1:
                        while (j < imageDataBytes) {
                            Y = data[i++];

                            imageDataArray[j++] = Y;
                            imageDataArray[j++] = Y;
                            imageDataArray[j++] = Y;
                            imageDataArray[j++] = 255;
                        }
                        break;
                    case 3:
                        while (j < imageDataBytes) {
                            R = data[i++];
                            G = data[i++];
                            B = data[i++];

                            imageDataArray[j++] = R;
                            imageDataArray[j++] = G;
                            imageDataArray[j++] = B;
                            imageDataArray[j++] = 255;
                        }
                        break;
                    case 4:
                        while (j < imageDataBytes) {
                            C = data[i++];
                            M = data[i++];
                            Y = data[i++];
                            K = data[i++];

                            R = 255 - clamp0to255(C * (1 - K / 255) + K);
                            G = 255 - clamp0to255(M * (1 - K / 255) + K);
                            B = 255 - clamp0to255(Y * (1 - K / 255) + K);

                            imageDataArray[j++] = R;
                            imageDataArray[j++] = G;
                            imageDataArray[j++] = B;
                            imageDataArray[j++] = 255;
                        }
                        break;
                    default:
                        throw 'Unsupported color mode';
                }
            };
            return JpegImage;
        })();
        JPEG.JpegImage = JpegImage;
    })(Shumway.JPEG || (Shumway.JPEG = {}));
    var JPEG = Shumway.JPEG;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    /// <reference path='references.ts'/>
    (function (SWF) {
        SWF.StreamNoDataError = {};

        function Stream_align() {
            this.bitBuffer = this.bitLength = 0;
        }

        function Stream_ensure(size) {
            if (this.pos + size > this.end) {
                throw SWF.StreamNoDataError;
            }
        }

        function Stream_remaining() {
            return this.end - this.pos;
        }

        function Stream_substream(begin, end) {
            var stream = new Stream(this.bytes);
            stream.pos = begin;
            stream.end = end;
            return stream;
        }

        function Stream_push(data) {
            var bytes = this.bytes;
            var newBytesLength = this.end + data.length;
            if (newBytesLength > bytes.length) {
                throw 'stream buffer overfow';
            }
            bytes.set(data, this.end);
            this.end = newBytesLength;
        }

        var Stream = (function () {
            function Stream(buffer, offset, length, maxLength) {
                if (offset === undefined)
                    offset = 0;
                if (buffer.buffer instanceof ArrayBuffer) {
                    offset += buffer.byteOffset;
                    buffer = buffer.buffer;
                }
                if (length === undefined)
                    length = buffer.byteLength - offset;
                if (maxLength === undefined)
                    maxLength = length;

                var bytes = new Uint8Array(buffer, offset, maxLength);
                var stream = (new DataView(buffer, offset, maxLength));

                stream.bytes = bytes;
                stream.pos = 0;
                stream.end = length;
                stream.bitBuffer = 0;
                stream.bitLength = 0;

                stream.align = Stream_align;
                stream.ensure = Stream_ensure;
                stream.remaining = Stream_remaining;
                stream.substream = Stream_substream;
                stream.push = Stream_push;
                return stream;
            }
            return Stream;
        })();
        SWF.Stream = Stream;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    /// <reference path='references.ts'/>
    (function (SWF) {
        var assert = Shumway.Debug.assert;
        var assertUnreachable = Shumway.Debug.assertUnreachable;

        SWF.InflateNoDataError = {};

        var codeLengthOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

        var distanceCodes = [];
        var distanceExtraBits = [];
        for (var i = 0, j = 0, code = 1; i < 30; ++i) {
            distanceCodes[i] = code;
            code += 1 << (distanceExtraBits[i] = ~~((j += (i > 2 ? 1 : 0)) / 2));
        }

        var bitLengths = [];
        for (var i = 0; i < 32; ++i) {
            bitLengths[i] = 5;
        }
        var fixedDistanceTable = makeHuffmanTable(bitLengths);

        var lengthCodes = [];
        var lengthExtraBits = [];
        for (var i = 0, j = 0, code = 3; i < 29; ++i) {
            lengthCodes[i] = code - (i == 28 ? 1 : 0);
            code += 1 << (lengthExtraBits[i] = ~~(((j += (i > 4 ? 1 : 0)) / 4) % 6));
        }
        for (var i = 0; i < 288; ++i) {
            bitLengths[i] = i < 144 || i > 279 ? 8 : (i < 256 ? 9 : 7);
        }
        var fixedLiteralTable = makeHuffmanTable(bitLengths);

        function makeHuffmanTable(bitLengths) {
            var maxBits = Math.max.apply(null, bitLengths);
            var numLengths = bitLengths.length;
            var size = 1 << maxBits;
            var codes = new Uint32Array(size);
            for (var code = 0, len = 1, skip = 2; len <= maxBits; code <<= 1, ++len, skip <<= 1) {
                for (var val = 0; val < numLengths; ++val) {
                    if (bitLengths[val] === len) {
                        var lsb = 0;
                        for (var i = 0; i < len; ++i)
                            lsb = (lsb * 2) + ((code >> i) & 1);
                        for (var i = lsb; i < size; i += skip)
                            codes[i] = (len << 16) | val;
                        ++code;
                    }
                }
            }
            return { codes: codes, maxBits: maxBits };
        }

        function verifyDeflateHeader(bytes) {
            var header = (bytes[0] << 8) | bytes[1];
            release || assert((header & 0x0f00) === 0x0800, 'unknown compression method', 'inflate');
            release || assert((header % 31) === 0, 'bad FCHECK', 'inflate');
            release || assert(!(header & 0x20), 'FDICT bit set', 'inflate');
        }
        SWF.verifyDeflateHeader = verifyDeflateHeader;

        function createInflatedStream(bytes, outputLength) {
            verifyDeflateHeader(bytes);
            var stream = new SWF.Stream(bytes, 2);
            var output = {
                data: new Uint8Array(outputLength),
                available: 0,
                completed: false
            };
            var state = {
                header: null, distanceTable: null,
                literalTable: null, sym: null, len: null, sym2: null };
            do {
                inflateBlock(stream, output, state);
            } while(!output.completed && stream.pos < stream.end);
            return new SWF.Stream(output.data, 0, output.available);
        }
        SWF.createInflatedStream = createInflatedStream;

        function inflateBlock(stream, output, state) {
            var header = state.header !== null ? state.header : (state.header = readBits(stream.bytes, stream, 3));
            switch (header >> 1) {
                case 0:
                    stream.align();
                    var pos = stream.pos;
                    if (stream.end - pos < 4) {
                        throw SWF.InflateNoDataError;
                    }
                    var len = stream.getUint16(pos, true);
                    var nlen = stream.getUint16(pos + 2, true);
                    release || assert((~nlen & 0xffff) === len, 'bad uncompressed block length', 'inflate');
                    if (stream.end - pos < 4 + len) {
                        throw SWF.InflateNoDataError;
                    }
                    var begin = pos + 4;
                    var end = stream.pos = begin + len;
                    var sbytes = stream.bytes, dbytes = output.data;
                    dbytes.set(sbytes.subarray(begin, end), output.available);
                    output.available += len;
                    break;
                case 1:
                    inflate(stream, output, fixedLiteralTable, fixedDistanceTable, state);
                    break;
                case 2:
                    var distanceTable, literalTable;
                    if (state.distanceTable !== null) {
                        distanceTable = state.distanceTable;
                        literalTable = state.literalTable;
                    } else {
                        var sbytes = stream.bytes;
                        var savedBufferPos = stream.pos;
                        var savedBitBuffer = stream.bitBuffer;
                        var savedBitLength = stream.bitLength;
                        var bitLengths = [];
                        var numLiteralCodes, numDistanceCodes;
                        try  {
                            numLiteralCodes = readBits(sbytes, stream, 5) + 257;
                            numDistanceCodes = readBits(sbytes, stream, 5) + 1;
                            var numCodes = numLiteralCodes + numDistanceCodes;
                            var numLengthCodes = readBits(sbytes, stream, 4) + 4;
                            for (var i = 0; i < 19; ++i)
                                bitLengths[codeLengthOrder[i]] = i < numLengthCodes ? readBits(sbytes, stream, 3) : 0;
                            var codeLengthTable = makeHuffmanTable(bitLengths);
                            bitLengths = [];
                            var i = 0;
                            var prev = 0;
                            while (i < numCodes) {
                                var j = 1;
                                var sym = readCode(sbytes, stream, codeLengthTable);
                                switch (sym) {
                                    case 16:
                                        j = readBits(sbytes, stream, 2) + 3;
                                        sym = prev;
                                        break;
                                    case 17:
                                        j = readBits(sbytes, stream, 3) + 3;
                                        sym = 0;
                                        break;
                                    case 18:
                                        j = readBits(sbytes, stream, 7) + 11;
                                        sym = 0;
                                        break;
                                    default:
                                        prev = sym;
                                }
                                while (j--)
                                    bitLengths[i++] = sym;
                            }
                        } catch (e) {
                            stream.pos = savedBufferPos;
                            stream.bitBuffer = savedBitBuffer;
                            stream.bitLength = savedBitLength;
                            throw e;
                        }
                        distanceTable = state.distanceTable = makeHuffmanTable(bitLengths.splice(numLiteralCodes, numDistanceCodes));
                        literalTable = state.literalTable = makeHuffmanTable(bitLengths);
                    }
                    inflate(stream, output, literalTable, distanceTable, state);
                    state.distanceTable = null;
                    state.literalTable = null;
                    break;
                default:
                    release || assertUnreachable('inflate encountered unknown block type');
            }
            state.header = null;
            output.completed = !!(header & 1);
        }
        SWF.inflateBlock = inflateBlock;

        function readBits(bytes, stream, size) {
            var bitBuffer = stream.bitBuffer;
            var bitLength = stream.bitLength;
            if (size > bitLength) {
                var pos = stream.pos;
                var end = stream.end;
                do {
                    if (pos >= end) {
                        stream.pos = pos;
                        stream.bitBuffer = bitBuffer;
                        stream.bitLength = bitLength;
                        throw SWF.InflateNoDataError;
                    }
                    bitBuffer |= bytes[pos++] << bitLength;
                    bitLength += 8;
                } while(size > bitLength);
                stream.pos = pos;
            }
            stream.bitBuffer = bitBuffer >>> size;
            stream.bitLength = bitLength - size;
            return bitBuffer & ((1 << size) - 1);
        }

        function inflate(stream, output, literalTable, distanceTable, state) {
            var pos = output.available;
            var dbytes = output.data;
            var sbytes = stream.bytes;
            var sym = state.sym !== null ? state.sym : readCode(sbytes, stream, literalTable);
            while (sym !== 256) {
                if (sym < 256) {
                    dbytes[pos++] = sym;
                } else {
                    state.sym = sym;
                    sym -= 257;
                    var len = state.len !== null ? state.len : (state.len = lengthCodes[sym] + readBits(sbytes, stream, lengthExtraBits[sym]));
                    var sym2 = state.sym2 !== null ? state.sym2 : (state.sym2 = readCode(sbytes, stream, distanceTable));
                    var distance = distanceCodes[sym2] + readBits(sbytes, stream, distanceExtraBits[sym2]);
                    var i = pos - distance;
                    while (len--)
                        dbytes[pos++] = dbytes[i++];
                    state.sym2 = null;
                    state.len = null;
                    state.sym = null;
                }
                output.available = pos;
                sym = readCode(sbytes, stream, literalTable);
            }
        }

        function readCode(bytes, stream, codeTable) {
            var bitBuffer = stream.bitBuffer;
            var bitLength = stream.bitLength;
            var maxBits = codeTable.maxBits;
            if (maxBits > bitLength) {
                var pos = stream.pos;
                var end = stream.end;
                do {
                    if (pos >= end) {
                        stream.pos = pos;
                        stream.bitBuffer = bitBuffer;
                        stream.bitLength = bitLength;
                        throw SWF.InflateNoDataError;
                    }
                    bitBuffer |= bytes[pos++] << bitLength;
                    bitLength += 8;
                } while(maxBits > bitLength);
                stream.pos = pos;
            }
            var code = codeTable.codes[bitBuffer & ((1 << maxBits) - 1)];
            var len = code >> 16;
            release || assert(len, 'bad encoding', 'inflate');
            stream.bitBuffer = bitBuffer >>> len;
            stream.bitLength = bitLength - len;
            return code & 0xffff;
        }
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (SWF) {
        var SwfTag = Shumway.SWF.Parser.SwfTag;
        var createSoundStream = Shumway.SWF.Parser.createSoundStream;

        function defineSymbol(swfTag, symbols) {
            var symbol;

            switch (swfTag.code) {
                case 6 /* CODE_DEFINE_BITS */:
                case 21 /* CODE_DEFINE_BITS_JPEG2 */:
                case 35 /* CODE_DEFINE_BITS_JPEG3 */:
                case 90 /* CODE_DEFINE_BITS_JPEG4 */:
                case 8 /* CODE_JPEG_TABLES */:
                    symbol = Shumway.SWF.Parser.defineImage(swfTag, symbols);
                    break;
                case 20 /* CODE_DEFINE_BITS_LOSSLESS */:
                case 36 /* CODE_DEFINE_BITS_LOSSLESS2 */:
                    symbol = Shumway.SWF.Parser.defineBitmap(swfTag);
                    break;
                case 7 /* CODE_DEFINE_BUTTON */:
                case 34 /* CODE_DEFINE_BUTTON2 */:
                    symbol = Shumway.SWF.Parser.defineButton(swfTag, symbols);
                    break;
                case 37 /* CODE_DEFINE_EDIT_TEXT */:
                    symbol = Shumway.SWF.Parser.defineText(swfTag, symbols);
                    break;
                case 10 /* CODE_DEFINE_FONT */:
                case 48 /* CODE_DEFINE_FONT2 */:
                case 75 /* CODE_DEFINE_FONT3 */:
                case 91 /* CODE_DEFINE_FONT4 */:
                    symbol = Shumway.SWF.Parser.defineFont(swfTag, symbols);
                    break;
                case 46 /* CODE_DEFINE_MORPH_SHAPE */:
                case 84 /* CODE_DEFINE_MORPH_SHAPE2 */:
                case 2 /* CODE_DEFINE_SHAPE */:
                case 22 /* CODE_DEFINE_SHAPE2 */:
                case 32 /* CODE_DEFINE_SHAPE3 */:
                case 83 /* CODE_DEFINE_SHAPE4 */:
                    symbol = Shumway.SWF.Parser.defineShape(swfTag, symbols);
                    break;
                case 14 /* CODE_DEFINE_SOUND */:
                    symbol = Shumway.SWF.Parser.defineSound(swfTag, symbols);
                    break;
                case 87 /* CODE_DEFINE_BINARY_DATA */:
                    symbol = {
                        type: 'binary',
                        id: swfTag.id,
                        // TODO: make transferable
                        data: swfTag.data
                    };
                    break;
                case 39 /* CODE_DEFINE_SPRITE */:
                    var commands = [];
                    var frame = { type: 'frame' };
                    var frames = [];
                    var tags = swfTag.tags;
                    var frameScripts = null;
                    var frameIndex = 0;
                    var soundStream = null;
                    for (var i = 0, n = tags.length; i < n; i++) {
                        var tag = tags[i];
                        switch (tag.code) {
                            case 12 /* CODE_DO_ACTION */:
                                if (!frameScripts)
                                    frameScripts = [];
                                frameScripts.push(frameIndex);
                                frameScripts.push(tag.actionsData);
                                break;

                            case 15 /* CODE_START_SOUND */:
                                var startSounds = frame.startSounds || (frame.startSounds = []);
                                startSounds.push(tag);
                                break;
                            case 18 /* CODE_SOUND_STREAM_HEAD */:
                                try  {
                                    // TODO: make transferable
                                    soundStream = createSoundStream(tag);
                                    frame.soundStream = soundStream.info;
                                } catch (e) {
                                    // ignoring if sound stream codec is not supported
                                    // console.error('ERROR: ' + e.message);
                                }
                                break;
                            case 19 /* CODE_SOUND_STREAM_BLOCK */:
                                if (soundStream) {
                                    frame.soundStreamBlock = soundStream.decode(tag.data);
                                }
                                break;
                            case 43 /* CODE_FRAME_LABEL */:
                                frame.labelName = tag.name;
                                break;
                            case 4 /* CODE_PLACE_OBJECT */:
                            case 26 /* CODE_PLACE_OBJECT2 */:
                            case 70 /* CODE_PLACE_OBJECT3 */:
                                commands.push(tag);
                                break;
                            case 5 /* CODE_REMOVE_OBJECT */:
                            case 28 /* CODE_REMOVE_OBJECT2 */:
                                commands.push(tag);
                                break;
                            case 1 /* CODE_SHOW_FRAME */:
                                frameIndex += tag.repeat;
                                frame.repeat = tag.repeat;
                                frame.commands = commands;
                                frames.push(frame);
                                commands = [];
                                frame = { type: 'frame' };
                                break;
                        }
                    }
                    symbol = {
                        type: 'sprite',
                        id: swfTag.id,
                        frameCount: swfTag.frameCount,
                        frames: frames,
                        frameScripts: frameScripts
                    };
                    break;
                case 11 /* CODE_DEFINE_TEXT */:
                case 33 /* CODE_DEFINE_TEXT2 */:
                    symbol = Shumway.SWF.Parser.defineLabel(swfTag, symbols);
                    break;
            }

            if (!symbol) {
                return { command: 'error', message: 'unknown symbol type: ' + swfTag.code };
            }

            symbol.isSymbol = true;
            symbols[swfTag.id] = symbol;
            return symbol;
        }

        function createParsingContext(commitData) {
            var commands = [];
            var symbols = {};
            var frame = { type: 'frame' };
            var tagsProcessed = 0;
            var soundStream = null;
            var bytesLoaded = 0;

            return {
                onstart: function (result) {
                    commitData({ command: 'init', result: result });
                },
                onprogress: function (result) {
                    if (result.bytesLoaded - bytesLoaded >= 65536) {
                        while (bytesLoaded < result.bytesLoaded) {
                            if (bytesLoaded) {
                                commitData({
                                    command: 'progress', result: {
                                        bytesLoaded: bytesLoaded,
                                        bytesTotal: result.bytesTotal
                                    } });
                            }
                            bytesLoaded += 65536;
                        }
                    }

                    var tags = result.tags;
                    for (var n = tags.length; tagsProcessed < n; tagsProcessed++) {
                        var tag = tags[tagsProcessed];
                        if ('id' in tag) {
                            var symbol = defineSymbol(tag, symbols);
                            commitData(symbol, symbol.transferables);
                            continue;
                        }

                        switch (tag.code) {
                            case 86 /* CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA */:
                                frame.sceneData = tag;
                                break;
                            case 78 /* CODE_DEFINE_SCALING_GRID */:
                                var symbolUpdate = {
                                    isSymbol: true,
                                    id: tag.symbolId,
                                    updates: {
                                        scale9Grid: tag.splitter
                                    }
                                };
                                commitData(symbolUpdate);
                                break;
                            case 82 /* CODE_DO_ABC */:
                            case 72 /* CODE_DO_ABC_ */:
                                commitData({
                                    type: 'abc',
                                    flags: tag.flags,
                                    name: tag.name,
                                    data: tag.data
                                });
                                break;
                            case 12 /* CODE_DO_ACTION */:
                                var actionBlocks = frame.actionBlocks;
                                if (actionBlocks)
                                    actionBlocks.push(tag.actionsData);
                                else
                                    frame.actionBlocks = [tag.actionsData];
                                break;
                            case 59 /* CODE_DO_INIT_ACTION */:
                                var initActionBlocks = frame.initActionBlocks || (frame.initActionBlocks = []);
                                initActionBlocks.push({ spriteId: tag.spriteId, actionsData: tag.actionsData });
                                break;
                            case 15 /* CODE_START_SOUND */:
                                var startSounds = frame.startSounds;
                                if (!startSounds)
                                    frame.startSounds = startSounds = [];
                                startSounds.push(tag);
                                break;
                            case 18 /* CODE_SOUND_STREAM_HEAD */:
                                try  {
                                    // TODO: make transferable
                                    soundStream = createSoundStream(tag);
                                    frame.soundStream = soundStream.info;
                                } catch (e) {
                                    // ignoring if sound stream codec is not supported
                                    // console.error('ERROR: ' + e.message);
                                }
                                break;
                            case 19 /* CODE_SOUND_STREAM_BLOCK */:
                                if (soundStream) {
                                    frame.soundStreamBlock = soundStream.decode(tag.data);
                                }
                                break;
                            case 56 /* CODE_EXPORT_ASSETS */:
                                var exports = frame.exports;
                                if (exports)
                                    frame.exports = exports.concat(tag.exports);
                                else
                                    frame.exports = tag.exports.slice(0);
                                break;
                            case 76 /* CODE_SYMBOL_CLASS */:
                                var symbolClasses = frame.symbolClasses;
                                if (symbolClasses)
                                    frame.symbolClasses = symbolClasses.concat(tag.exports);
                                else
                                    frame.symbolClasses = tag.exports.slice(0);
                                break;
                            case 43 /* CODE_FRAME_LABEL */:
                                frame.labelName = tag.name;
                                break;
                            case 4 /* CODE_PLACE_OBJECT */:
                            case 26 /* CODE_PLACE_OBJECT2 */:
                            case 70 /* CODE_PLACE_OBJECT3 */:
                                commands.push(tag);
                                break;
                            case 5 /* CODE_REMOVE_OBJECT */:
                            case 28 /* CODE_REMOVE_OBJECT2 */:
                                commands.push(tag);
                                break;
                            case 9 /* CODE_SET_BACKGROUND_COLOR */:
                                frame.bgcolor = tag.color;
                                break;
                            case 1 /* CODE_SHOW_FRAME */:
                                frame.repeat = tag.repeat;
                                frame.commands = commands;
                                frame.complete = !!tag.finalTag;
                                commitData(frame);
                                commands = [];
                                frame = { type: 'frame' };
                                break;
                        }
                    }

                    if (result.bytesLoaded === result.bytesTotal) {
                        commitData({
                            command: 'progress', result: {
                                bytesLoaded: result.bytesLoaded,
                                bytesTotal: result.bytesTotal
                            } });
                    }
                },
                oncomplete: function (result) {
                    commitData(result);

                    var stats;
                    if (typeof result.swfVersion === 'number') {
                        // Extracting stats from the context object
                        var bbox = result.bbox;
                        stats = {
                            topic: 'parseInfo',
                            parseTime: result.parseTime,
                            bytesTotal: result.bytesTotal,
                            swfVersion: result.swfVersion,
                            frameRate: result.frameRate,
                            width: (bbox.xMax - bbox.xMin) / 20,
                            height: (bbox.yMax - bbox.yMin) / 20,
                            isAvm2: !!result.fileAttributes.doAbc
                        };
                    }

                    commitData({ command: 'complete', stats: stats });
                },
                onexception: function (e) {
                    commitData({ type: 'exception', message: e.message, stack: e.stack });
                }
            };
        }

        function parseBytes(bytes, commitData) {
            Shumway.SWF.Parser.parse(bytes, createParsingContext(commitData));
        }

        var ResourceLoader = (function () {
            function ResourceLoader(scope, isWorker) {
                this._subscription = null;

                var self = this;
                if (!isWorker) {
                    this._messenger = {
                        postMessage: function (data) {
                            self.onmessage({ data: data });
                        }
                    };
                } else {
                    this._messenger = scope;
                    scope.onmessage = function (event) {
                        self.listener(event.data);
                    };
                }
            }
            ResourceLoader.prototype.terminate = function () {
                this._messenger = null;
                this.listener = null;
            };

            ResourceLoader.prototype.onmessage = function (event) {
                this.listener(event.data);
            };

            ResourceLoader.prototype.postMessage = function (data) {
                this.listener && this.listener(data);
            };

            ResourceLoader.prototype.listener = function (data) {
                if (this._subscription) {
                    this._subscription.callback(data.data, data.progress);
                } else if (data === 'pipe:') {
                    // progressive data loading is requested, replacing onmessage handler
                    // for the following messages
                    this._subscription = {
                        subscribe: function (callback) {
                            this.callback = callback;
                        }
                    };
                    this.parseLoadedData(this._messenger, this._subscription);
                } else {
                    this.parseLoadedData(this._messenger, data);
                }
            };

            ResourceLoader.prototype.parseLoadedData = function (loader, request) {
                function commitData(data, transferables) {
                    try  {
                        loader.postMessage(data, transferables);
                    } catch (ex) {
                        // Attempting to fix IE10/IE11 transferables by retrying without
                        // Transferables.
                        if (ex != 'DataCloneError') {
                            throw ex;
                        }
                        loader.postMessage(data);
                    }
                }

                if (request instanceof ArrayBuffer) {
                    parseBytes(request, commitData);
                } else if ('subscribe' in request) {
                    var pipe = Shumway.SWF.Parser.parseAsync(createParsingContext(commitData));
                    request.subscribe(function (data, progress) {
                        if (data) {
                            pipe.push(data, progress);
                        } else {
                            pipe.close();
                        }
                    });
                } else if (typeof FileReaderSync !== 'undefined') {
                    var readerSync = new FileReaderSync();
                    var buffer = readerSync.readAsArrayBuffer(request);
                    parseBytes(buffer, commitData);
                } else {
                    var reader = new FileReader();
                    reader.onload = function () {
                        parseBytes(this.result, commitData);
                    };
                    reader.readAsArrayBuffer(request);
                }
            };
            return ResourceLoader;
        })();
        SWF.ResourceLoader = ResourceLoader;
    })(Shumway.SWF || (Shumway.SWF = {}));
    var SWF = Shumway.SWF;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
///<reference path='module.ts'/>
///<reference path='parser/references.ts' />
///<reference path='jpeg.ts' />
///<reference path='stream.ts' />
///<reference path='inflate.ts' />
///<reference path='resourceLoader.ts' />
//# sourceMappingURL=swf.js.map

console.timeEnd("Load SWF Parser");
// Manifest player
console.time("Load Player Dependencies");
console.time("Load Shared Dependencies");
console.timeEnd("Load Shared Dependencies");
console.time("Load AVM2 Dependencies");
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        AVM2.timelineBuffer = new Shumway.Tools.Profiler.TimelineBuffer("AVM2");
        AVM2.counter = new Shumway.Metrics.Counter(!release);

        function countTimeline(name, value) {
            if (typeof value === "undefined") { value = 1; }
            AVM2.timelineBuffer && AVM2.timelineBuffer.count(name, value);
        }
        AVM2.countTimeline = countTimeline;

        function enterTimeline(name, data) {
            profile && AVM2.timelineBuffer && AVM2.timelineBuffer.enter(name, data);
        }
        AVM2.enterTimeline = enterTimeline;

        function leaveTimeline(data) {
            profile && AVM2.timelineBuffer && AVM2.timelineBuffer.leave(null, data);
        }
        AVM2.leaveTimeline = leaveTimeline;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        AVM2.Errors = {
            /**
            * AVM2 Error Codes
            */
            //  OutOfMemoryError                     : {code: 1000, message: "The system is out of memory."},
            //  NotImplementedError                  : {code: 1001, message: "The method %1 is not implemented."},
            //  InvalidPrecisionError                : {code: 1002, message: "Number.toPrecision has a range of 1 to 21. Number.toFixed and Number.toExponential have a range of 0 to 20. Specified value is not within expected range."},
            //  InvalidRadixError                    : {code: 1003, message: "The radix argument must be between 2 and 36; got %1."},
            //  InvokeOnIncompatibleObjectError      : {code: 1004, message: "Method %1 was invoked on an incompatible object."},
            //  ArrayIndexNotIntegerError            : {code: 1005, message: "Array index is not a positive integer (%1)."},
            CallOfNonFunctionError: { code: 1006, message: "%1 is not a function." },
            //  ConstructOfNonFunctionError          : {code: 1007, message: "Instantiation attempted on a non-constructor."},
            //  AmbiguousBindingError                : {code: 1008, message: "%1 is ambiguous; Found more than one matching binding."},
            ConvertNullToObjectError: { code: 1009, message: "Cannot access a property or method of a null object reference." },
            ConvertUndefinedToObjectError: { code: 1010, message: "A term is undefined and has no properties." },
            //  IllegalOpcodeError                   : {code: 1011, message: "Method %1 contained illegal opcode %2 at offset %3."},
            //  LastInstExceedsCodeSizeError         : {code: 1012, message: "The last instruction exceeded code size."},
            //  FindVarWithNoScopeError              : {code: 1013, message: "Cannot call OP_findproperty when scopeDepth is 0."},
            ClassNotFoundError: { code: 1014, message: "Class %1 could not be found." },
            //  IllegalSetDxns                       : {code: 1015, message: "Method %1 cannot set default xml namespace"},
            //  DescendentsError                     : {code: 1016, message: "Descendants operator (..) not supported on type %1."},
            //  ScopeStackOverflowError              : {code: 1017, message: "Scope stack overflow occurred."},
            //  ScopeStackUnderflowError             : {code: 1018, message: "Scope stack underflow occurred."},
            //  GetScopeObjectBoundsError            : {code: 1019, message: "Getscopeobject %1 is out of bounds."},
            //  CannotFallOffMethodError             : {code: 1020, message: "Code cannot fall off the end of a method."},
            //  InvalidBranchTargetError             : {code: 1021, message: "At least one branch target was not on a valid instruction in the method."},
            //  IllegalVoidError                     : {code: 1022, message: "Type void may only be used as a function return type."},
            //  StackOverflowError                   : {code: 1023, message: "Stack overflow occurred."},
            //  StackUnderflowError                  : {code: 1024, message: "Stack underflow occurred."},
            //  InvalidRegisterError                 : {code: 1025, message: "An invalid register %1 was accessed."},
            //  SlotExceedsCountError                : {code: 1026, message: "Slot %1 exceeds slotCount=%2 of %3."},
            //  MethodInfoExceedsCountError          : {code: 1027, message: "Method_info %1 exceeds method_count=%2."},
            //  DispIdExceedsCountError              : {code: 1028, message: "Disp_id %1 exceeds max_disp_id=%2 of %3."},
            //  DispIdUndefinedError                 : {code: 1029, message: "Disp_id %1 is undefined on %2."},
            //  StackDepthUnbalancedError            : {code: 1030, message: "Stack depth is unbalanced. %1 != %2."},
            //  ScopeDepthUnbalancedError            : {code: 1031, message: "Scope depth is unbalanced. %1 != %2."},
            //  CpoolIndexRangeError                 : {code: 1032, message: "Cpool index %1 is out of range %2."},
            //  CpoolEntryWrongTypeError             : {code: 1033, message: "Cpool entry %1 is wrong type."},
            CheckTypeFailedError: { code: 1034, message: "Type Coercion failed: cannot convert %1 to %2." },
            //  IllegalSuperCallError                : {code: 1035, message: "Illegal super expression found in method %1."},
            //  CannotAssignToMethodError            : {code: 1037, message: "Cannot assign to a method %1 on %2."},
            //  RedefinedError                       : {code: 1038, message: "%1 is already defined."},
            //  CannotVerifyUntilReferencedError     : {code: 1039, message: "Cannot verify method until it is referenced."},
            //  CantUseInstanceofOnNonObjectError    : {code: 1040, message: "The right-hand side of instanceof must be a class or function."},
            //  IsTypeMustBeClassError               : {code: 1041, message: "The right-hand side of operator must be a class."},
            //  InvalidMagicError                    : {code: 1042, message: "Not an ABC file.  major_version=%1 minor_version=%2."},
            //  InvalidCodeLengthError               : {code: 1043, message: "Invalid code_length=%1."},
            //  InvalidMethodInfoFlagsError          : {code: 1044, message: "MethodInfo-%1 unsupported flags=%2."},
            //  UnsupportedTraitsKindError           : {code: 1045, message: "Unsupported traits kind=%1."},
            //  MethodInfoOrderError                 : {code: 1046, message: "MethodInfo-%1 referenced before definition."},
            //  MissingEntryPointError               : {code: 1047, message: "No entry point was found."},
            //  PrototypeTypeError                   : {code: 1049, message: "Prototype objects must be vanilla Objects."},
            //  ConvertToPrimitiveError              : {code: 1050, message: "Cannot convert %1 to primitive."},
            //  IllegalEarlyBindingError             : {code: 1051, message: "Illegal early binding access to %1."},
            //  InvalidURIError                      : {code: 1052, message: "Invalid URI passed to %1 function."},
            //  IllegalOverrideError                 : {code: 1053, message: "Illegal override of %1 in %2."},
            //  IllegalExceptionHandlerError         : {code: 1054, message: "Illegal range or target offsets in exception handler."},
            //  WriteSealedError                     : {code: 1056, message: "Cannot create property %1 on %2."},
            //  IllegalSlotError                     : {code: 1057, message: "%1 can only contain methods."},
            //  IllegalOperandTypeError              : {code: 1058, message: "Illegal operand type: %1 must be %2."},
            //  ClassInfoOrderError                  : {code: 1059, message: "ClassInfo-%1 is referenced before definition."},
            //  ClassInfoExceedsCountError           : {code: 1060, message: "ClassInfo %1 exceeds class_count=%2."},
            //  NumberOutOfRangeError                : {code: 1061, message: "The value %1 cannot be converted to %2 without losing precision."},
            WrongArgumentCountError: { code: 1063, message: "Argument count mismatch on %1. Expected %2, got %3." },
            //  CannotCallMethodAsConstructor        : {code: 1064, message: "Cannot call method %1 as constructor."},
            //  UndefinedVarError                    : {code: 1065, message: "Variable %1 is not defined."},
            //  FunctionConstructorError             : {code: 1066, message: "The form function('function body') is not supported."},
            //  IllegalNativeMethodBodyError         : {code: 1067, message: "Native method %1 has illegal method body."},
            //  CannotMergeTypesError                : {code: 1068, message: "%1 and %2 cannot be reconciled."},
            //  ReadSealedError                      : {code: 1069, message: "Property %1 not found on %2 and there is no default value."},
            //  CallNotFoundError                    : {code: 1070, message: "Method %1 not found on %2"},
            //  AlreadyBoundError                    : {code: 1071, message: "Function %1 has already been bound to %2."},
            //  ZeroDispIdError                      : {code: 1072, message: "Disp_id 0 is illegal."},
            //  DuplicateDispIdError                 : {code: 1073, message: "Non-override method %1 replaced because of duplicate disp_id %2."},
            //  ConstWriteError                      : {code: 1074, message: "Illegal write to read-only property %1 on %2."},
            //  MathNotFunctionError                 : {code: 1075, message: "Math is not a function."},
            //  MathNotConstructorError              : {code: 1076, message: "Math is not a constructor."},
            //  WriteOnlyError                       : {code: 1077, message: "Illegal read of write-only property %1 on %2."},
            //  IllegalOpMultinameError              : {code: 1078, message: "Illegal opcode/multiname combination: %1<%2>."},
            //  IllegalNativeMethodError             : {code: 1079, message: "Native methods are not allowed in loaded code."},
            //  IllegalNamespaceError                : {code: 1080, message: "Illegal value for namespace."},
            //  ReadSealedErrorNs                    : {code: 1081, message: "Property %1 not found on %2 and there is no default value."},
            //  NoDefaultNamespaceError              : {code: 1082, message: "No default namespace has been set."},
            //  XMLPrefixNotBound                    : {code: 1083, message: "The prefix \"%1\" for element \"%2\" is not bound."},
            //  XMLBadQName                          : {code: 1084, message: "Element or attribute (\"%1\") does not match QName production: QName::=(NCName':')?NCName."},
            //  XMLUnterminatedElementTag            : {code: 1085, message: "The element type \"%1\" must be terminated by the matching end-tag \"</%2>\"."},
            //  XMLOnlyWorksWithOneItemLists         : {code: 1086, message: "The %1 method only works on lists containing one item."},
            //  XMLAssignmentToIndexedXMLNotAllowed  : {code: 1087, message: "Assignment to indexed XML is not allowed."},
            XMLMarkupMustBeWellFormed: { code: 1088, message: "The markup in the document following the root element must be well-formed." },
            //  XMLAssigmentOneItemLists             : {code: 1089, message: "Assignment to lists with more than one item is not supported."},
            //  XMLMalformedElement                  : {code: 1090, message: "XML parser failure: element is malformed."},
            //  XMLUnterminatedCData                 : {code: 1091, message: "XML parser failure: Unterminated CDATA section."},
            //  XMLUnterminatedXMLDecl               : {code: 1092, message: "XML parser failure: Unterminated XML declaration."},
            //  XMLUnterminatedDocTypeDecl           : {code: 1093, message: "XML parser failure: Unterminated DOCTYPE declaration."},
            //  XMLUnterminatedComment               : {code: 1094, message: "XML parser failure: Unterminated comment."},
            //  XMLUnterminatedAttribute             : {code: 1095, message: "XML parser failure: Unterminated attribute."},
            //  XMLUnterminatedElement               : {code: 1096, message: "XML parser failure: Unterminated element."},
            //  XMLUnterminatedProcessingInstruction : {code: 1097, message: "XML parser failure: Unterminated processing instruction."},
            //  XMLNamespaceWithPrefixAndNoURI       : {code: 1098, message: "Illegal prefix %1 for no namespace."},
            //  RegExpFlagsArgumentError             : {code: 1100, message: "Cannot supply flags when constructing one RegExp from another."},
            //  NoScopeError                         : {code: 1101, message: "Cannot verify method %1 with unknown scope."},
            //  IllegalDefaultValue                  : {code: 1102, message: "Illegal default value for type %1."},
            //  CannotExtendFinalClass               : {code: 1103, message: "Class %1 cannot extend final base class."},
            //  XMLDuplicateAttribute                : {code: 1104, message: "Attribute \"%1\" was already specified for element \"%2\"."},
            //  CorruptABCError                      : {code: 1107, message: "The ABC data is corrupt, attempt to read out of bounds."},
            //  InvalidBaseClassError                : {code: 1108, message: "The OP_newclass opcode was used with the incorrect base class."},
            //  DanglingFunctionError                : {code: 1109, message: "Attempt to directly call unbound function %1 from method %2."},
            //  CannotExtendError                    : {code: 1110, message: "%1 cannot extend %2."},
            //  CannotImplementError                 : {code: 1111, message: "%1 cannot implement %2."},
            //  CoerceArgumentCountError             : {code: 1112, message: "Argument count mismatch on class coercion.  Expected 1, got %1."},
            //  InvalidNewActivationError            : {code: 1113, message: "OP_newactivation used in method without NEED_ACTIVATION flag."},
            //  NoGlobalScopeError                   : {code: 1114, message: "OP_getglobalslot or OP_setglobalslot used with no global scope."},
            //  NotConstructorError                  : {code: 1115, message: "%1 is not a constructor."},
            //  ApplyError                           : {code: 1116, message: "second argument to Function.prototype.apply must be an array."},
            //  XMLInvalidName                       : {code: 1117, message: "Invalid XML name: %1."},
            //  XMLIllegalCyclicalLoop               : {code: 1118, message: "Illegal cyclical loop between nodes."},
            //  DeleteTypeError                      : {code: 1119, message: "Delete operator is not supported with operand of type %1."},
            //  DeleteSealedError                    : {code: 1120, message: "Cannot delete property %1 on %2."},
            //  DuplicateMethodBodyError             : {code: 1121, message: "Method %1 has a duplicate method body."},
            //  IllegalInterfaceMethodBodyError      : {code: 1122, message: "Interface method %1 has illegal method body."},
            //  FilterError                          : {code: 1123, message: "Filter operator not supported on type %1."},
            //  InvalidHasNextError                  : {code: 1124, message: "OP_hasnext2 requires object and index to be distinct registers."},
            OutOfRangeError: { code: 1125, message: "The index %1 is out of range %2." },
            VectorFixedError: { code: 1126, message: "Cannot change the length of a fixed Vector." },
            //  TypeAppOfNonParamType                : {code: 1127, message: "Type application attempted on a non-parameterized type."},
            //  WrongTypeArgCountError               : {code: 1128, message: "Incorrect number of type parameters for %1. Expected %2, got %3."},
            //  JSONCyclicStructure                  : {code: 1129, message: "Cyclic structure cannot be converted to JSON string."},
            //  JSONInvalidReplacer                  : {code: 1131, message: "Replacer argument to JSON stringifier must be an array or a two parameter function."},
            //  JSONInvalidParseInput                : {code: 1132, message: "Invalid JSON parse input."},
            //  FileOpenError                        : {code: 1500, message: "Error occurred opening file %1."},
            //  FileWriteError                       : {code: 1501, message: "Error occurred writing to file %1."},
            //  ScriptTimeoutError                   : {code: 1502, message: "A script has executed for longer than the default timeout period of 15 seconds."},
            //  ScriptTerminatedError                : {code: 1503, message: "A script failed to exit after 30 seconds and was terminated."},
            //  EndOfFileError                       : {code: 1504, message: "End of file."},
            //  StringIndexOutOfBoundsError          : {code: 1505, message: "The string index %1 is out of bounds; must be in range %2 to %3."},
            InvalidRangeError: { code: 1506, message: "The specified range is invalid." },
            NullArgumentError: { code: 1507, message: "Argument %1 cannot be null." },
            InvalidArgumentError: { code: 1508, message: "The value specified for argument %1 is invalid." },
            //  ArrayFilterNonNullObjectError        : {code: 1510, message: "When the callback argument is a method of a class, the optional this argument must be null."},
            InvalidParamError: { code: 2004, message: "One of the parameters is invalid." },
            ParamRangeError: { code: 2006, message: "The supplied index is out of bounds." },
            NullPointerError: { code: 2007, message: "Parameter %1 must be non-null." },
            InvalidEnumError: { code: 2008, message: "Parameter %1 must be one of the accepted values." },
            //  CantInstantiateError                 : {code: 2012, message: "%1 class cannot be instantiated."},
            InvalidBitmapData: { code: 2015, message: "Invalid BitmapData." },
            //  EOFError                             : {code: 2030, message: "End of file was encountered."},
            CompressedDataError: { code: 2058, message: "There was an error decompressing the data." },
            //  EmptyStringError                     : {code: 2085, message: "Parameter %1 must be non-empty string."},
            //  ProxyGetPropertyError                : {code: 2088, message: "The Proxy class does not implement getProperty. It must be overridden by a subclass."},
            //  ProxySetPropertyError                : {code: 2089, message: "The Proxy class does not implement setProperty. It must be overridden by a subclass."},
            //  ProxyCallPropertyError               : {code: 2090, message: "The Proxy class does not implement callProperty. It must be overridden by a subclass."},
            //  ProxyHasPropertyError                : {code: 2091, message: "The Proxy class does not implement hasProperty. It must be overridden by a subclass."},
            //  ProxyDeletePropertyError             : {code: 2092, message: "The Proxy class does not implement deleteProperty. It must be overridden by a subclass."},
            //  ProxyGetDescendantsError             : {code: 2093, message: "The Proxy class does not implement getDescendants. It must be overridden by a subclass."},
            //  ProxyNextNameIndexError              : {code: 2105, message: "The Proxy class does not implement nextNameIndex. It must be overridden by a subclass."},
            //  ProxyNextNameError                   : {code: 2106, message: "The Proxy class does not implement nextName. It must be overridden by a subclass."},
            //  ProxyNextValueError                  : {code: 2107, message: "The Proxy class does not implement nextValue. It must be overridden by a subclass."},
            //  InvalidArrayLengthError              : {code: 2108, message: "The value %1 is not a valid Array length."},
            //  ReadExternalNotImplementedError      : {code: 2173, message: "Unable to read object in stream.  The class %1 does not implement flash.utils.IExternalizable but is aliased to an externalizable class."},
            /**
            * Player Error Codes
            */
            //  NoSecurityContextError                                    : { code: 2000, message: "No active security context."},
            TooFewArgumentsError: { code: 2001, message: "Too few arguments were specified; got %1, %2 expected." },
            //  InvalidSocketError                                        : { code: 2002, message: "Operation attempted on invalid socket."},
            //  InvalidSocketPortError                                    : { code: 2003, message: "Invalid socket port number specified."},
            //  ParamTypeError                                            : { code: 2005, message: "Parameter %1 is of the incorrect type. Should be type %2."},
            //  HasStyleSheetError                                        : { code: 2009, message: "This method cannot be used on a text field with a style sheet."},
            //  SocketLocalFileSecurityError                              : { code: 2010, message: "Local-with-filesystem SWF files are not permitted to use sockets."},
            SocketConnectError: { code: 2011, message: "Socket connection failed to %1:%2." },
            //  AuthoringOnlyFeatureError                                 : { code: 2013, message: "Feature can only be used in Flash Authoring."},
            //  FeatureNotAvailableError                                  : { code: 2014, message: "Feature is not available at this time."},
            //  InvalidBitmapDataError                                    : { code: 2015, message: "Invalid BitmapData."},
            //  SystemExitSecurityError                                   : { code: 2017, message: "Only trusted local files may cause the Flash Player to exit."},
            //  SystemExitUnsupportedError                                : { code: 2018, message: "System.exit is only available in the standalone Flash Player."},
            //  InvalidDepthError                                         : { code: 2019, message: "Depth specified is invalid."},
            //  MovieClipSwapError                                        : { code: 2020, message: "MovieClips objects with different parents cannot be swapped."},
            //  ObjectCreationError                                       : { code: 2021, message: "Object creation failed."},
            //  NotDisplayObjectError                                     : { code: 2022, message: "Class %1 must inherit from DisplayObject to link to a symbol."},
            //  NotSpriteError                                            : { code: 2023, message: "Class %1 must inherit from Sprite to link to the root."},
            CantAddSelfError: { code: 2024, message: "An object cannot be added as a child of itself." },
            NotAChildError: { code: 2025, message: "The supplied DisplayObject must be a child of the caller." },
            //  NavigateURLError                                          : { code: 2026, message: "An error occurred navigating to the URL %1."},
            //  MustBeNonNegativeError                                    : { code: 2027, message: "Parameter %1 must be a non-negative number; got %2."},
            //  LocalSecurityError                                        : { code: 2028, message: "Local-with-filesystem SWF file %1 cannot access Internet URL %2."},
            //  InvalidStreamError                                        : { code: 2029, message: "This URLStream object does not have a stream opened."},
            //  SocketError                                               : { code: 2031, message: "Socket Error."},
            //  StreamError                                               : { code: 2032, message: "Stream Error."},
            //  KeyGenerationError                                        : { code: 2033, message: "Key Generation Failed."},
            //  InvalidKeyError                                           : { code: 2034, message: "An invalid digest was supplied."},
            //  URLNotFoundError                                          : { code: 2035, message: "URL Not Found."},
            //  LoadNeverCompletedError                                   : { code: 2036, message: "Load Never Completed."},
            //  InvalidCallError                                          : { code: 2037, message: "Functions called in incorrect sequence, or earlier call was unsuccessful."},
            //  FileIOError                                               : { code: 2038, message: "File I/O Error."},
            //  RemoteURLError                                            : { code: 2039, message: "Invalid remote URL protocol. The remote URL protocol must be HTTP or HTTPS."},
            //  BrowseInProgressError                                     : { code: 2041, message: "Only one file browsing session may be performed at a time."},
            //  DigestNotSupportedError                                   : { code: 2042, message: "The digest property is not supported by this load operation."},
            //  UnhandledError                                            : { code: 2044, message: "Unhandled %1:."},
            //  FileVerificationError                                     : { code: 2046, message: "The loaded file did not have a valid signature."},
            //  DisplayListSecurityError                                  : { code: 2047, message: "Security sandbox violation: %1: %2 cannot access %3."},
            //  DownloadSecurityError                                     : { code: 2048, message: "Security sandbox violation: %1 cannot load data from %2."},
            //  UploadSecurityError                                       : { code: 2049, message: "Security sandbox violation: %1 cannot upload data to %2."},
            //  OutboundScriptingSecurityError                            : { code: 2051, message: "Security sandbox violation: %1 cannot evaluate scripting URLs within %2 (allowScriptAccess is %3). Attempted URL was %4."},
            //  AllowDomainArgumentError                                  : { code: 2052, message: "Only String arguments are permitted for allowDomain and allowInsecureDomain."},
            //  IntervalSecurityError                                     : { code: 2053, message: "Security sandbox violation: %1 cannot clear an interval timer set by %2."},
            //  ExactSettingsError                                        : { code: 2054, message: "The value of Security.exactSettings cannot be changed after it has been used."},
            //  PrintJobStartError                                        : { code: 2055, message: "The print job could not be started."},
            //  PrintJobSendError                                         : { code: 2056, message: "The print job could not be sent to the printer."},
            //  PrintJobAddPageError                                      : { code: 2057, message: "The page could not be added to the print job."},
            //  ExternalCallbackSecurityError                             : { code: 2059, message: "Security sandbox violation: %1 cannot overwrite an ExternalInterface callback added by %2."},
            //  ExternalInterfaceSecurityError                            : { code: 2060, message: "Security sandbox violation: ExternalInterface caller %1 cannot access %2."},
            //  ExternalInterfaceNoCallbackError                          : { code: 2061, message: "No ExternalInterface callback %1 registered."},
            //  NoCloneMethodError                                        : { code: 2062, message: "Children of Event must override clone() {return new MyEventClass (...);}."},
            //  IMEError                                                  : { code: 2063, message: "Error attempting to execute IME command."},
            //  FocusNotSetError                                          : { code: 2065, message: "The focus cannot be set for this target."},
            //  DelayRangeError                                           : { code: 2066, message: "The Timer delay specified is out of range."},
            ExternalInterfaceNotAvailableError: { code: 2067, message: "The ExternalInterface is not available in this container. ExternalInterface requires Internet Explorer ActiveX, Firefox, Mozilla 1.7.5 and greater, or other browsers that support NPRuntime." },
            //  InvalidSoundError                                         : { code: 2068, message: "Invalid sound."},
            //  InvalidLoaderMethodError                                  : { code: 2069, message: "The Loader class does not implement this method."},
            //  StageOwnerSecurityError                                   : { code: 2070, message: "Security sandbox violation: caller %1 cannot access Stage owned by %2."},
            InvalidStageMethodError: { code: 2071, message: "The Stage class does not implement this property or method." },
            //  ProductManagerDiskError                                   : { code: 2073, message: "There was a problem saving the application to disk."},
            //  ProductManagerStageError                                  : { code: 2074, message: "The stage is too small to fit the download ui."},
            //  ProductManagerVerifyError                                 : { code: 2075, message: "The downloaded file is invalid."},
            //  FilterFailedError                                         : { code: 2077, message: "This filter operation cannot be performed with the specified input parameters."},
            //  TimelineObjectNameSealedError                             : { code: 2078, message: "The name property of a Timeline-placed object cannot be modified."},
            //  BitmapNotAssociatedWithBitsCharError                      : { code: 2079, message: "Classes derived from Bitmap can only be associated with defineBits characters (bitmaps)."},
            //  AlreadyConnectedError                                     : { code: 2082, message: "Connect failed because the object is already connected."},
            //  CloseNotConnectedError                                    : { code: 2083, message: "Close failed because the object is not connected."},
            //  ArgumentSizeError                                         : { code: 2084, message: "The AMF encoding of the arguments cannot exceed 40K."},
            //  FileReferenceProhibitedError                              : { code: 2086, message: "A setting in the mms.cfg file prohibits this FileReference request."},
            //  DownloadFileNameProhibitedError                           : { code: 2087, message: "The FileReference.download() file name contains prohibited characters."},
            //  EventDispatchRecursionError                               : { code: 2094, message: "Event dispatch recursion overflow."},
            //  AsyncError                                                : { code: 2095, message: "%1 was unable to invoke callback %2."},
            //  DisallowedHTTPHeaderError                                 : { code: 2096, message: "The HTTP request header %1 cannot be set via ActionScript."},
            //  FileFilterError                                           : { code: 2097, message: "The FileFilter Array is not in the correct format."},
            //  LoadingObjectNotSWFError                                  : { code: 2098, message: "The loading object is not a .swf file, you cannot request SWF properties from it."},
            //  LoadingObjectNotInitializedError                          : { code: 2099, message: "The loading object is not sufficiently loaded to provide this information."},
            //  EmptyByteArrayError                                       : { code: 2100, message: "The ByteArray parameter in Loader.loadBytes() must have length greater than 0."},
            //  DecodeParamError                                          : { code: 2101, message: "The String passed to URLVariables.decode() must be a URL-encoded query string containing name/value pairs."},
            //  NotAnXMLChildError                                        : { code: 2102, message: "The before XMLNode parameter must be a child of the caller."},
            //  XMLRecursionError                                         : { code: 2103, message: "XML recursion failure: new child would create infinite loop."},
            SceneNotFoundError: { code: 2108, message: "Scene %1 was not found." },
            FrameLabelNotFoundError: { code: 2109, message: "Frame label %1 not found in scene %2." },
            //  DisableAVM1LoadingError                                   : { code: 2110, message: "The value of Security.disableAVM1Loading cannot be set unless the caller can access the stage and is in an ActionScript 3.0 SWF file."},
            //  AVM1LoadingError                                          : { code: 2111, message: "Security.disableAVM1Loading is true so the current load of the ActionScript 1.0/2.0 SWF file has been blocked."},
            //  ApplicationDomainSecurityError                            : { code: 2112, message: "Provided parameter LoaderContext.ApplicationDomain is from a disallowed domain."},
            //  SecurityDomainSecurityError                               : { code: 2113, message: "Provided parameter LoaderContext.SecurityDomain is from a disallowed domain."},
            //  NonNullPointerError                                       : { code: 2114, message: "Parameter %1 must be null."},
            //  TrueParamError                                            : { code: 2115, message: "Parameter %1 must be false."},
            //  FalseParamError                                           : { code: 2116, message: "Parameter %1 must be true."},
            //  InvalidLoaderInfoMethodError                              : { code: 2118, message: "The LoaderInfo class does not implement this method."},
            //  LoaderInfoAppDomainSecurityError                          : { code: 2119, message: "Security sandbox violation: caller %1 cannot access LoaderInfo.applicationDomain owned by %2."},
            //  SecuritySwfNotAllowedError                                : { code: 2121, message: "Security sandbox violation: %1: %2 cannot access %3. This may be worked around by calling Security.allowDomain."},
            //  SecurityNonSwfIncompletePolicyFilesError                  : { code: 2122, message: "Security sandbox violation: %1: %2 cannot access %3. A policy file is required, but the checkPolicyFile flag was not set when this media was loaded."},
            //  SecurityNonSwfNotAllowedError                             : { code: 2123, message: "Security sandbox violation: %1: %2 cannot access %3. No policy files granted access."},
            //  UnknownFileTypeError                                      : { code: 2124, message: "Loaded file is an unknown type."},
            //  SecurityCrossVMNotAllowedError                            : { code: 2125, message: "Security sandbox violation: %1 cannot use Runtime Shared Library %2 because crossing the boundary between ActionScript 3.0 and ActionScript 1.0/2.0 objects is not allowed."},
            //  NotConnectedError                                         : { code: 2126, message: "NetConnection object must be connected."},
            //  FileRefBadPostDataTypeError                               : { code: 2127, message: "FileReference POST data cannot be type ByteArray."},
            //  NetConnectionConnectError                                 : { code: 2129, message: "Connection to %1 failed."},
            //  SharedObjectFlushFailedError                              : { code: 2130, message: "Unable to flush SharedObject."},
            //  DefinitionNotFoundError                                   : { code: 2131, message: "Definition %1 cannot be found."},
            //  NetConnectionInvalidConnectFromNetStatusEventError        : { code: 2132, message: "NetConnection.connect cannot be called from a netStatus event handler."},
            //  CallbackNotRegisteredError                                : { code: 2133, message: "Callback %1 is not registered."},
            //  SharedObjectCreateError                                   : { code: 2134, message: "Cannot create SharedObject."},
            //  InvalidSWFError                                           : { code: 2136, message: "The SWF file %1 contains invalid data."},
            //  NavigationSecurityError                                   : { code: 2137, message: "Security sandbox violation: %1 cannot navigate window %2 within %3 (allowScriptAccess is %4). Attempted URL was %5."},
            //  NonParsableRichTextXMLError                               : { code: 2138, message: "Rich text XML could not be parsed."},
            //  SharedObjectConnectError                                  : { code: 2139, message: "SharedObject could not connect."},
            //  LocalSecurityLoadingError                                 : { code: 2140, message: "Security sandbox violation: %1 cannot load %2. Local-with-filesystem and local-with-networking SWF files cannot load each other."},
            //  MultiplePrintJobsError                                    : { code: 2141, message: "Only one PrintJob may be in use at a time."},
            //  LocalImportSecurityError                                  : { code: 2142, message: "Security sandbox violation: local SWF files cannot use the LoaderContext.securityDomain property. %1 was attempting to load %2."},
            //  AccOverrideRole                                           : { code: 2143, message: "AccessibilityImplementation.get_accRole() must be overridden from its default."},
            //  AccOverrideState                                          : { code: 2144, message: "AccessibilityImplementation.get_accState() must be overridden from its default."},
            //  URLRequestHeaderInvalidLengthError                        : { code: 2145, message: "Cumulative length of requestHeaders must be less than 8192 characters."},
            //  AllowNetworkingSecurityError                              : { code: 2146, message: "Security sandbox violation: %1 cannot call %2 because the HTML/container parameter allowNetworking has the value %3."},
            //  ForbiddenProtocolError                                    : { code: 2147, message: "Forbidden protocol in URL %1."},
            //  RemoteToLocalSecurityError                                : { code: 2148, message: "SWF file %1 cannot access local resource %2. Only local-with-filesystem and trusted local SWF files may access local resources."},
            //  FsCommandSecurityError                                    : { code: 2149, message: "Security sandbox violation: %1 cannot make fscommand calls to %2 (allowScriptAccess is %3)."},
            CantAddParentError: { code: 2150, message: "An object cannot be added as a child to one of it's children (or children's children, etc.)." }
        };

        function getErrorMessage(index) {
            if (!Shumway.AVM2.Runtime.debuggerMode.value) {
                return "Error #" + index;
            }
            for (var k in AVM2.Errors) {
                if (AVM2.Errors[k].code == index) {
                    return "Error #" + index + ": " + AVM2.Errors[k].message;
                }
            }
            return "Error #" + index + ": (unknown)";
        }
        AVM2.getErrorMessage = getErrorMessage;

        function formatErrorMessage(error) {
            var args = [];
            for (var _i = 0; _i < (arguments.length - 1); _i++) {
                args[_i] = arguments[_i + 1];
            }
            var message = error.message;
            Array.prototype.slice.call(arguments, 1).forEach(function (x, i) {
                message = message.replace("%" + (i + 1), x);
            });
            return "Error #" + error.code + ": " + message;
        }
        AVM2.formatErrorMessage = formatErrorMessage;

        function translateErrorMessage(error) {
            if (error.type) {
                switch (error.type) {
                    case "undefined_method":
                        return formatErrorMessage(AVM2.Errors.CallOfNonFunctionError, "value");
                    default:
                        throw Shumway.Debug.notImplemented(error.type);
                }
            } else {
                if (error.message.indexOf("is not a function") >= 0) {
                    return formatErrorMessage(AVM2.Errors.CallOfNonFunctionError, "value");
                }
                return error.message;
            }
        }
        AVM2.translateErrorMessage = translateErrorMessage;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

var Errors = Shumway.AVM2.Errors;
var getErrorMessage = Shumway.AVM2.getErrorMessage;
var formatErrorMessage = Shumway.AVM2.formatErrorMessage;
var translateErrorMessage = Shumway.AVM2.translateErrorMessage;
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (ABC) {
            var textDecoder = null;
            if (typeof TextDecoder !== "undefined") {
                textDecoder = new TextDecoder();
            }

            var AbcStream = (function () {
                function AbcStream(bytes) {
                    this._bytes = bytes;
                    this._view = new DataView(bytes.buffer, bytes.byteOffset);
                    this._position = 0;
                }
                AbcStream._getResultBuffer = function (length) {
                    if (!AbcStream._resultBuffer || AbcStream._resultBuffer.length < length) {
                        AbcStream._resultBuffer = new Int32Array(length * 2);
                    }
                    return AbcStream._resultBuffer;
                };

                Object.defineProperty(AbcStream.prototype, "position", {
                    get: function () {
                        return this._position;
                    },
                    enumerable: true,
                    configurable: true
                });

                AbcStream.prototype.remaining = function () {
                    return this._bytes.length - this._position;
                };

                AbcStream.prototype.seek = function (position) {
                    this._position = position;
                };

                AbcStream.prototype.readU8 = function () {
                    return this._bytes[this._position++];
                };

                AbcStream.prototype.readU8s = function (count) {
                    var b = new Uint8Array(count);
                    b.set(this._bytes.subarray(this._position, this._position + count), 0);
                    this._position += count;
                    return b;
                };

                AbcStream.prototype.readS8 = function () {
                    return this._bytes[this._position++] << 24 >> 24;
                };

                AbcStream.prototype.readU32 = function () {
                    return this.readS32() >>> 0;
                };

                AbcStream.prototype.readU30 = function () {
                    var result = this.readU32();
                    if (result & 0xc0000000) {
                        // TODO: Spec says this is a corrupt ABC file, but it seems that some content
                        // has this, e.g. 1000-0.abc
                        // error("Corrupt ABC File");
                        return result;
                    }
                    return result;
                };

                AbcStream.prototype.readU30Unsafe = function () {
                    return this.readU32();
                };

                AbcStream.prototype.readS16 = function () {
                    return (this.readU30Unsafe() << 16) >> 16;
                };

                /**
                * Read a variable-length encoded 32-bit signed integer. The value may use one to five bytes (little endian),
                * each contributing 7 bits. The most significant bit of each byte indicates that the next byte is part of
                * the value. The spec indicates that the most significant bit of the last byte to be read is sign extended
                * but this turns out not to be the case in the real implementation, for instance 0x7f should technically be
                * -1, but instead it's 127. Moreover, what happens to the remaining 4 high bits of the fifth byte that is
                * read? Who knows, here we'll just stay true to the Tamarin implementation.
                */
                AbcStream.prototype.readS32 = function () {
                    var result = this.readU8();
                    if (result & 0x80) {
                        result = result & 0x7f | this.readU8() << 7;
                        if (result & 0x4000) {
                            result = result & 0x3fff | this.readU8() << 14;
                            if (result & 0x200000) {
                                result = result & 0x1fffff | this.readU8() << 21;
                                if (result & 0x10000000) {
                                    result = result & 0x0fffffff | this.readU8() << 28;
                                    result = result & 0xffffffff;
                                }
                            }
                        }
                    }
                    return result;
                };

                AbcStream.prototype.readWord = function () {
                    var result = this._view.getUint32(this._position, true);
                    this._position += 4;
                    return result;
                };

                AbcStream.prototype.readS24 = function () {
                    var u = this.readU8() | (this.readU8() << 8) | (this.readU8() << 16);
                    return (u << 8) >> 8;
                };

                AbcStream.prototype.readDouble = function () {
                    var result = this._view.getFloat64(this._position, true);
                    this._position += 8;
                    return result;
                };

                AbcStream.prototype.readUTFString = function (length) {
                    /**
                    * Use the TextDecoder API whenever available.
                    * http://encoding.spec.whatwg.org/#concept-encoding-get
                    */
                    if (textDecoder) {
                        var position = this._position;
                        this._position += length;
                        return textDecoder.decode(this._bytes.subarray(position, position + length));
                    }

                    var pos = this._position;
                    var end = pos + length;
                    var bytes = this._bytes;
                    var i = 0;
                    var result = AbcStream._getResultBuffer(length * 2);
                    while (pos < end) {
                        var c = bytes[pos++];
                        if (c <= 0x7f) {
                            result[i++] = c;
                        } else if (c >= 0xc0) {
                            var code = 0;
                            if (c < 0xe0) {
                                code = ((c & 0x1f) << 6) | (bytes[pos++] & 0x3f);
                            } else if (c < 0xf0) {
                                code = ((c & 0x0f) << 12) | ((bytes[pos++] & 0x3f) << 6) | (bytes[pos++] & 0x3f);
                            } else {
                                // turned into two characters in JS as surrogate pair
                                code = (((c & 0x07) << 18) | ((bytes[pos++] & 0x3f) << 12) | ((bytes[pos++] & 0x3f) << 6) | (bytes[pos++] & 0x3f)) - 0x10000;

                                // High surrogate
                                result[i++] = ((code & 0xffc00) >>> 10) + 0xd800;

                                // Low surrogate
                                code = (code & 0x3ff) + 0xdc00;
                            }
                            result[i++] = code;
                        }
                    }
                    this._position = pos;
                    return Shumway.StringUtilities.fromCharCodeArray(result.subarray(0, i));
                };
                AbcStream._resultBuffer = new Int32Array(256);
                return AbcStream;
            })();
            ABC.AbcStream = AbcStream;
        })(AVM2.ABC || (AVM2.ABC = {}));
        var ABC = AVM2.ABC;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (ABC) {
            var isString = Shumway.isString;

            var isNumeric = Shumway.isNumeric;
            var isObject = Shumway.isObject;
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;

            var Parameter = (function () {
                function Parameter(name, type, value, optional) {
                    if (typeof optional === "undefined") { optional = false; }
                    this.name = name;
                    this.type = type;
                    this.value = value;
                    this.optional = optional;
                    // ...
                }
                return Parameter;
            })();
            ABC.Parameter = Parameter;

            var Trait = (function () {
                function Trait(abc, stream, holder) {
                    var constantPool = abc.constantPool;
                    var methods = abc.methods;
                    var classes = abc.classes;
                    var metadata = abc.metadata;

                    this.holder = holder;
                    this.name = constantPool.multinames[stream.readU30()];
                    var tag = stream.readU8();

                    this.kind = tag & 0x0F;
                    this.attributes = (tag >> 4) & 0x0F;
                    release || assert(Multiname.isQName(this.name), "Name must be a QName: " + this.name + ", kind: " + this.kind);

                    switch (this.kind) {
                        case 0 /* Slot */:
                        case 6 /* Const */:
                            this.slotId = stream.readU30();
                            this.typeName = constantPool.multinames[stream.readU30()];
                            var valueIndex = stream.readU30();
                            this.value = undefined;
                            if (valueIndex !== 0) {
                                this.hasDefaultValue = true;
                                this.value = constantPool.getValue(stream.readU8(), valueIndex);
                            }
                            break;
                        case 1 /* Method */:
                        case 3 /* Setter */:
                        case 2 /* Getter */:
                            this.dispId = stream.readU30();
                            this.methodInfo = methods[stream.readU30()];
                            this.methodInfo.name = this.name;

                            // make sure that the holder was not already set
                            AbcFile.attachHolder(this.methodInfo, this.holder);
                            this.methodInfo.abc = abc;
                            break;
                        case 4 /* Class */:
                            this.slotId = stream.readU30();
                            release || assert(classes, "Classes should be passed down here, I'm guessing whenever classes are being parsed.");
                            this.classInfo = classes[stream.readU30()];
                            break;
                        case 5 /* Function */:
                            // TRAIT.Function is a leftover. it's not supported at all in
                            // Tamarin/Flash and will cause a verify error.
                            release || assert(false, "Function encountered in the wild, should not happen");
                            break;
                    }

                    if (this.attributes & 4 /* Metadata */) {
                        var traitMetadata;
                        for (var i = 0, j = stream.readU30(); i < j; i++) {
                            var md = metadata[stream.readU30()];
                            if (md.name === "__go_to_definition_help" || md.name === "__go_to_ctor_definition_help") {
                                continue;
                            }
                            if (!traitMetadata) {
                                traitMetadata = {};
                            }
                            traitMetadata[md.name] = md;
                        }
                        if (traitMetadata) {
                            // FIXME: we should probably only set Class metadata on the classInfo.
                            if (this.isClass()) {
                                this.classInfo.metadata = traitMetadata;
                            }
                            this.metadata = traitMetadata;
                        }
                    }
                }
                Trait.prototype.isSlot = function () {
                    return this.kind === 0 /* Slot */;
                };

                Trait.prototype.isConst = function () {
                    return this.kind === 6 /* Const */;
                };

                Trait.prototype.isMethod = function () {
                    return this.kind === 1 /* Method */;
                };

                Trait.prototype.isClass = function () {
                    return this.kind === 4 /* Class */;
                };

                Trait.prototype.isGetter = function () {
                    return this.kind === 2 /* Getter */;
                };

                Trait.prototype.isSetter = function () {
                    return this.kind === 3 /* Setter */;
                };

                Trait.prototype.isAccessor = function () {
                    return this.isGetter() || this.isSetter();
                };

                Trait.prototype.isMethodOrAccessor = function () {
                    return this.isMethod() || this.isGetter() || this.isSetter();
                };

                Trait.prototype.isProtected = function () {
                    release || assert(Multiname.isQName(this.name));
                    return this.name.namespaces[0].isProtected();
                };

                Trait.prototype.kindName = function () {
                    switch (this.kind) {
                        case 0 /* Slot */:
                            return "Slot";
                        case 6 /* Const */:
                            return "Const";
                        case 1 /* Method */:
                            return "Method";
                        case 3 /* Setter */:
                            return "Setter";
                        case 2 /* Getter */:
                            return "Getter";
                        case 4 /* Class */:
                            return "Class";
                        case 5 /* Function */:
                            return "Function";
                    }
                    Shumway.Debug.unexpected();
                };

                Trait.prototype.isOverride = function () {
                    return this.attributes & 2 /* Override */;
                };

                Trait.prototype.isFinal = function () {
                    return this.attributes & 1 /* Final */;
                };

                Trait.prototype.toString = function () {
                    var str = Shumway.IntegerUtilities.getFlags(this.attributes, "final|override|metadata".split("|"));
                    if (str) {
                        str += " ";
                    }
                    str += Multiname.getQualifiedName(this.name);
                    switch (this.kind) {
                        case 0 /* Slot */:
                        case 6 /* Const */:
                            return str + ", typeName: " + this.typeName + ", slotId: " + this.slotId + ", value: " + this.value;
                        case 1 /* Method */:
                        case 3 /* Setter */:
                        case 2 /* Getter */:
                            return str + ", " + this.kindName() + ": " + this.methodInfo.name;
                        case 4 /* Class */:
                            return str + ", slotId: " + this.slotId + ", class: " + this.classInfo;
                        case 5 /* Function */:
                            break;
                    }
                };

                Trait.parseTraits = function (abc, stream, holder) {
                    var count = stream.readU30();
                    var traits = [];
                    for (var i = 0; i < count; i++) {
                        traits.push(new Trait(abc, stream, holder));
                    }
                    return traits;
                };
                return Trait;
            })();
            ABC.Trait = Trait;

            var Info = (function () {
                function Info(abc, index, hash) {
                    this.abc = abc;
                    this.index = index;
                    this.hash = abc.hash & 65535 /* AbcMask */ | hash | (index << 19 /* IndexOffset */);
                }
                return Info;
            })();
            ABC.Info = Info;

            var MethodInfo = (function (_super) {
                __extends(MethodInfo, _super);
                function MethodInfo(abc, index, stream) {
                    _super.call(this, abc, index, 131072 /* MethodInfo */);
                    var constantPool = abc.constantPool;
                    var parameterCount = stream.readU30();
                    this.returnType = constantPool.multinames[stream.readU30()];
                    this.parameters = [];
                    for (var i = 0; i < parameterCount; i++) {
                        this.parameters.push(new Parameter(undefined, constantPool.multinames[stream.readU30()], undefined));
                    }

                    this.debugName = constantPool.strings[stream.readU30()];
                    this.flags = stream.readU8();

                    var optionalCount = 0;
                    if (this.flags & 8 /* HasOptional */) {
                        optionalCount = stream.readU30();
                        release || assert(parameterCount >= optionalCount);
                        for (var i = parameterCount - optionalCount; i < parameterCount; i++) {
                            var valueIndex = stream.readU30();
                            this.parameters[i].value = constantPool.getValue(stream.readU8(), valueIndex);
                            this.parameters[i].optional = true;
                        }
                    }

                    if (this.flags & 128 /* HasParamNames */) {
                        for (var i = 0; i < parameterCount; i++) {
                            // NOTE: We can't get the parameter name as described in the spec because
                            // some SWFs have invalid parameter names. Tamarin doesn't parse parameter
                            // names correctly, so we must follow that same behaviour.
                            if (MethodInfo.parseParameterNames) {
                                this.parameters[i].name = constantPool.strings[stream.readU30()];
                            } else {
                                stream.readU30();
                                this.parameters[i].name = MethodInfo._getParameterName(i);
                            }
                        }
                    } else {
                        for (var i = 0; i < parameterCount; i++) {
                            this.parameters[i].name = MethodInfo._getParameterName(i);
                        }
                    }
                }
                MethodInfo._getParameterName = function (i) {
                    if (i < 26) {
                        return String.fromCharCode("A".charCodeAt(0) + i);
                    }
                    return "P" + (i - 26);
                };

                MethodInfo.prototype.toString = function () {
                    var flags = Shumway.IntegerUtilities.getFlags(this.flags, "NEED_ARGUMENTS|NEED_ACTIVATION|NEED_REST|HAS_OPTIONAL|||SET_DXN|HAS_PARAM_NAMES".split("|"));
                    return (flags ? flags + " " : "") + this.name;
                };
                MethodInfo.prototype.hasOptional = function () {
                    return !!(this.flags & 8 /* HasOptional */);
                };
                MethodInfo.prototype.needsActivation = function () {
                    return !!(this.flags & 2 /* Activation */);
                };
                MethodInfo.prototype.needsRest = function () {
                    return !!(this.flags & 4 /* Needrest */);
                };
                MethodInfo.prototype.needsArguments = function () {
                    return !!(this.flags & 1 /* Arguments */);
                };
                MethodInfo.prototype.isNative = function () {
                    return !!(this.flags & 32 /* Native */);
                };
                MethodInfo.prototype.isClassMember = function () {
                    return this.holder instanceof ClassInfo;
                };
                MethodInfo.prototype.isInstanceMember = function () {
                    return this.holder instanceof InstanceInfo;
                };
                MethodInfo.prototype.isScriptMember = function () {
                    return this.holder instanceof ScriptInfo;
                };
                MethodInfo.prototype.hasSetsDxns = function () {
                    return !!(this.flags & 64 /* Setsdxns */);
                };

                MethodInfo.parseException = function (abc, stream) {
                    var multinames = abc.constantPool.multinames;

                    var ex = {
                        start: stream.readU30(),
                        end: stream.readU30(),
                        target: stream.readU30(),
                        typeName: multinames[stream.readU30()],
                        varName: multinames[stream.readU30()]
                    };
                    release || assert(!ex.typeName || !ex.typeName.isRuntime());
                    release || assert(!ex.varName || ex.varName.isQName());
                    return ex;
                };

                MethodInfo.parseBody = function (abc, stream) {
                    var constantPool = abc.constantPool;
                    var methods = abc.methods;

                    var index = stream.readU30();
                    var mi = methods[index];
                    mi.index = index;
                    mi.hasBody = true;
                    release || assert(!mi.isNative());
                    mi.maxStack = stream.readU30();
                    mi.localCount = stream.readU30();
                    mi.initScopeDepth = stream.readU30();
                    mi.maxScopeDepth = stream.readU30();
                    mi.code = stream.readU8s(stream.readU30());

                    var exceptions = [];
                    var exceptionCount = stream.readU30();
                    for (var i = 0; i < exceptionCount; ++i) {
                        exceptions.push(MethodInfo.parseException(abc, stream));
                    }
                    mi.exceptions = exceptions;
                    mi.traits = Trait.parseTraits(abc, stream, mi);
                };

                MethodInfo.prototype.hasExceptions = function () {
                    return this.exceptions.length > 0;
                };
                MethodInfo.parseParameterNames = false;
                return MethodInfo;
            })(Info);
            ABC.MethodInfo = MethodInfo;

            var InstanceInfo = (function (_super) {
                __extends(InstanceInfo, _super);
                function InstanceInfo(abc, index, stream) {
                    _super.call(this, abc, index, 65536 /* InstanceInfo */);
                    this.runtimeId = InstanceInfo.nextID++;
                    var constantPool = abc.constantPool;
                    var methods = abc.methods;

                    this.name = constantPool.multinames[stream.readU30()];
                    release || assert(Multiname.isQName(this.name));
                    this.superName = constantPool.multinames[stream.readU30()];
                    this.flags = stream.readU8();
                    this.protectedNs = undefined;
                    if (this.flags & 8 /* ClassProtectedNs */) {
                        this.protectedNs = constantPool.namespaces[stream.readU30()];
                    }
                    var interfaceCount = stream.readU30();
                    this.interfaces = [];
                    for (var i = 0; i < interfaceCount; i++) {
                        this.interfaces[i] = constantPool.multinames[stream.readU30()];
                    }
                    this.init = methods[stream.readU30()];
                    this.init.isInstanceInitializer = true;
                    this.init.name = this.name;
                    AbcFile.attachHolder(this.init, this);
                    this.traits = Trait.parseTraits(abc, stream, this);
                }
                InstanceInfo.prototype.toString = function () {
                    var flags = Shumway.IntegerUtilities.getFlags(this.flags & 8, "sealed|final|interface|protected".split("|"));
                    var str = (flags ? flags + " " : "") + this.name;
                    if (this.superName) {
                        str += " extends " + this.superName;
                    }
                    return str;
                };
                InstanceInfo.prototype.isFinal = function () {
                    return !!(this.flags & 2 /* ClassFinal */);
                };
                InstanceInfo.prototype.isSealed = function () {
                    return !!(this.flags & 1 /* ClassSealed */);
                };
                InstanceInfo.prototype.isInterface = function () {
                    return !!(this.flags & 4 /* ClassInterface */);
                };
                InstanceInfo.nextID = 1;
                return InstanceInfo;
            })(Info);
            ABC.InstanceInfo = InstanceInfo;

            /**
            * Defines various constants to deal with unique encodings of ABC constants.
            */
            (function (Hashes) {
                Hashes[Hashes["AbcMask"] = 0x0000FFFF] = "AbcMask";
                Hashes[Hashes["KindMask"] = 0x00070000] = "KindMask";
                Hashes[Hashes["ClassInfo"] = 0x00000000] = "ClassInfo";
                Hashes[Hashes["InstanceInfo"] = 0x00010000] = "InstanceInfo";
                Hashes[Hashes["MethodInfo"] = 0x00020000] = "MethodInfo";
                Hashes[Hashes["ScriptInfo"] = 0x00030000] = "ScriptInfo";
                Hashes[Hashes["NamespaceSet"] = 0x00040000] = "NamespaceSet";
                Hashes[Hashes["IndexOffset"] = 19] = "IndexOffset";
            })(ABC.Hashes || (ABC.Hashes = {}));
            var Hashes = ABC.Hashes;

            var ClassInfo = (function (_super) {
                __extends(ClassInfo, _super);
                function ClassInfo(abc, index, stream) {
                    _super.call(this, abc, index, 0 /* ClassInfo */);
                    this.runtimeId = ClassInfo.nextID++;
                    this.init = abc.methods[stream.readU30()];
                    this.init.isClassInitializer = true;
                    AbcFile.attachHolder(this.init, this);
                    this.traits = Trait.parseTraits(abc, stream, this);
                    this.instanceInfo = abc.instances[index];
                    this.instanceInfo.classInfo = this;
                    this.defaultValue = ClassInfo._getDefaultValue(this.instanceInfo.name);
                }
                ClassInfo._getDefaultValue = function (qn) {
                    if (Multiname.getQualifiedName(qn) === Multiname.Int || Multiname.getQualifiedName(qn) === Multiname.Uint) {
                        return 0;
                    } else if (Multiname.getQualifiedName(qn) === Multiname.Number) {
                        return NaN;
                    } else if (Multiname.getQualifiedName(qn) === Multiname.Boolean) {
                        return false;
                    } else {
                        return null;
                    }
                };

                ClassInfo.prototype.toString = function () {
                    return this.instanceInfo.name.toString();
                };
                ClassInfo.nextID = 1;
                return ClassInfo;
            })(Info);
            ABC.ClassInfo = ClassInfo;

            var ScriptInfo = (function (_super) {
                __extends(ScriptInfo, _super);
                function ScriptInfo(abc, index, stream) {
                    _super.call(this, abc, index, 196608 /* ScriptInfo */);
                    this.runtimeId = ClassInfo.nextID++;
                    this.name = abc.name + "$script" + index;
                    this.init = abc.methods[stream.readU30()];
                    this.init.isScriptInitializer = true;
                    AbcFile.attachHolder(this.init, this);
                    this.traits = Trait.parseTraits(abc, stream, this);
                    // this.traits.verified = true;
                }
                Object.defineProperty(ScriptInfo.prototype, "entryPoint", {
                    get: function () {
                        return this.init;
                    },
                    enumerable: true,
                    configurable: true
                });
                ScriptInfo.prototype.toString = function () {
                    return this.name;
                };
                ScriptInfo.nextID = 1;
                return ScriptInfo;
            })(Info);
            ABC.ScriptInfo = ScriptInfo;

            var AbcFile = (function () {
                function AbcFile(bytes, name, hash) {
                    if (typeof hash === "undefined") { hash = 0; }
                    AVM2.enterTimeline("Parse ABC");
                    this.name = name;
                    this.env = {};

                    var computedHash;
                    if (!hash || !release) {
                        // Compute hash if one was not supplied or if we're in debug mode so we can do a sanity check.
                        AVM2.enterTimeline("Adler");
                        computedHash = Shumway.HashUtilities.hashBytesTo32BitsAdler(bytes, 0, bytes.length);
                        AVM2.leaveTimeline();
                    }
                    if (hash) {
                        this.hash = hash;

                        // Sanity check.
                        release || assert(hash === computedHash);
                    } else {
                        this.hash = computedHash;
                    }
                    var n, i;
                    var stream = new ABC.AbcStream(bytes);
                    AbcFile._checkMagic(stream);
                    AVM2.enterTimeline("Parse constantPool");
                    this.constantPool = new ConstantPool(stream, this);
                    AVM2.leaveTimeline();

                    // Method Infos
                    AVM2.enterTimeline("Parse Method Infos");
                    this.methods = [];
                    n = stream.readU30();
                    for (i = 0; i < n; ++i) {
                        this.methods.push(new MethodInfo(this, i, stream));
                    }
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Parse MetaData Infos");

                    // MetaData Infos
                    this.metadata = [];
                    n = stream.readU30();
                    for (i = 0; i < n; ++i) {
                        this.metadata.push(new MetaDataInfo(this, stream));
                    }
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Parse Instance Infos");

                    // Instance Infos
                    this.instances = [];
                    n = stream.readU30();
                    for (i = 0; i < n; ++i) {
                        this.instances.push(new InstanceInfo(this, i, stream));
                    }
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Parse Class Infos");

                    // Class Infos
                    this.classes = [];
                    for (i = 0; i < n; ++i) {
                        this.classes.push(new ClassInfo(this, i, stream));
                    }
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Parse Script Infos");

                    // Script Infos
                    this.scripts = [];
                    n = stream.readU30();
                    for (i = 0; i < n; ++i) {
                        this.scripts.push(new ScriptInfo(this, i, stream));
                    }
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Parse Method Body Info");

                    // Method body info just live inside methods
                    n = stream.readU30();
                    for (i = 0; i < n; ++i) {
                        MethodInfo.parseBody(this, stream);
                    }
                    AVM2.leaveTimeline();
                    AVM2.leaveTimeline();
                }
                AbcFile._checkMagic = function (stream) {
                    var magic = stream.readWord();
                    var flashPlayerBrannan = 46 << 16 | 15;
                    if (magic < flashPlayerBrannan) {
                        throw new Error("Invalid ABC File (magic = " + Number(magic).toString(16) + ")");
                    }
                };

                Object.defineProperty(AbcFile.prototype, "lastScript", {
                    get: function () {
                        release || assert(this.scripts.length > 0);
                        return this.scripts[this.scripts.length - 1];
                    },
                    enumerable: true,
                    configurable: true
                });

                AbcFile.attachHolder = function (mi, holder) {
                    release || assert(!mi.holder);
                    mi.holder = holder;
                };

                AbcFile.prototype.toString = function () {
                    return this.name;
                };

                AbcFile.prototype.getConstant = function (hash) {
                    release || assert((this.hash & 65535 /* AbcMask */) === (hash & 65535 /* AbcMask */));
                    var index = hash >> 19 /* IndexOffset */;
                    switch (hash & 458752 /* KindMask */) {
                        case 0 /* ClassInfo */:
                            return this.classes[index];
                        case 65536 /* InstanceInfo */:
                            return this.instances[index];
                        case 131072 /* MethodInfo */:
                            return this.methods[index];
                        case 196608 /* ScriptInfo */:
                            return this.scripts[index];
                        case 262144 /* NamespaceSet */:
                            return this.constantPool.namespaceSets[index];
                        default:
                            notImplemented("Kind");
                    }
                };
                return AbcFile;
            })();
            ABC.AbcFile = AbcFile;

            var Namespace = (function () {
                /**
                * Private namespaces need unique URIs |uniqueURIHash|, for such cases we compute a hash value
                * based on the ABC's hash. We could have easily given them a unique runtimeId but this wouldn't
                * have worked for AOT compilation.
                */
                function Namespace(kind, uri, prefix, uniqueURIHash) {
                    if (typeof uri === "undefined") { uri = ""; }
                    if (uri === undefined) {
                        uri = "";
                    }
                    this.kind = kind;
                    this.uri = uri;
                    this.prefix = prefix;
                    this.qualifiedName = undefined;
                    this._buildNamespace(uniqueURIHash);
                }
                Namespace.prototype._buildNamespace = function (uniqueURIHash) {
                    if (this.kind === 22 /* PackageNamespace */) {
                        this.kind = 8 /* Namespace */;
                    }
                    if (this.isPublic() && this.uri) {
                        /* Strip the api version mark for now. */
                        var n = this.uri.length - 1;
                        var mark = this.uri.charCodeAt(n);
                        if (mark > Namespace._MIN_API_MARK) {
                            release || assert(false, "What's this code for?");
                            this.uri = this.uri.substring(0, n - 1);
                        }
                    } else if (this.isUnique()) {
                        release || assert(uniqueURIHash !== undefined);
                        this.uri = "private " + uniqueURIHash;
                    }
                    if (this.kind === 26 /* StaticProtectedNs */) {
                        // FIXME: We need to deal with static protected namespaces the same way as
                        // for instance protected namespaces. For now, let's just reset the URI so
                        // that name resolution works out.
                        this.uri = "*";
                    }
                    this.qualifiedName = Namespace._qualifyNamespace(this.kind, this.uri, this.prefix ? this.prefix : "");
                };

                Namespace._hashNamespace = function (kind, uri, prefix) {
                    var data = new Int32Array(1 + uri.length + prefix.length);
                    var j = 0;
                    data[j++] = kind;
                    var index = Namespace._knownURIs.indexOf(uri);
                    if (index >= 0) {
                        return kind << 2 | index;
                    } else {
                        for (var i = 0; i < uri.length; i++) {
                            data[j++] = uri.charCodeAt(i);
                        }
                    }
                    for (var i = 0; i < prefix.length; i++) {
                        data[j++] = prefix.charCodeAt(i);
                    }
                    return Shumway.HashUtilities.hashBytesTo32BitsMD5(data, 0, j);
                };

                /**
                * Mangles a namespace URI to a more sensible name. The process is reversible
                * using lookup tables.
                */
                Namespace._qualifyNamespace = function (kind, uri, prefix) {
                    var key = kind + uri;
                    var mangledNamespace = Namespace._mangledNamespaceCache[key];
                    if (mangledNamespace) {
                        return mangledNamespace;
                    }
                    mangledNamespace = Shumway.StringUtilities.variableLengthEncodeInt32(Namespace._hashNamespace(kind, uri, prefix));
                    Namespace._mangledNamespaceMap[mangledNamespace] = {
                        kind: kind, uri: uri, prefix: prefix
                    };
                    Namespace._mangledNamespaceCache[key] = mangledNamespace;
                    return mangledNamespace;
                };

                Namespace.fromQualifiedName = function (qn) {
                    var length = Shumway.StringUtilities.fromEncoding(qn[0]);
                    var mangledNamespace = qn.substring(0, length + 1);
                    var ns = Namespace._mangledNamespaceMap[mangledNamespace];
                    return new Namespace(ns.kind, ns.uri, ns.prefix);
                };

                Namespace.kindFromString = function (str) {
                    for (var kind in Namespace._kinds) {
                        if (Namespace._kinds[kind] === str) {
                            return kind;
                        }
                    }
                    release || assert(false, "Cannot find kind " + str);
                    return NaN;
                };

                Namespace.createNamespace = function (uri, prefix) {
                    if (typeof prefix === "undefined") { prefix = undefined; }
                    return new Namespace(8 /* Namespace */, uri, prefix);
                };

                Namespace.parse = function (constantPool, stream, hash) {
                    var kind = stream.readU8();
                    var uri = constantPool.strings[stream.readU30()];
                    return new Namespace(kind, uri, undefined, hash);
                };

                Namespace.prototype.isPublic = function () {
                    return this.kind === 8 /* Namespace */ || this.kind === 22 /* PackageNamespace */;
                };

                Namespace.prototype.isProtected = function () {
                    return this.kind === 24 /* ProtectedNamespace */ || this.kind === 26 /* StaticProtectedNs */;
                };

                Namespace.prototype.isPrivate = function () {
                    return this.kind === 5 /* PrivateNs */;
                };

                Namespace.prototype.isPackageInternal = function () {
                    return this.kind === 23 /* PackageInternalNs */;
                };

                Namespace.prototype.isUnique = function () {
                    return this.kind === 5 /* PrivateNs */ && !this.uri;
                };

                Namespace.prototype.isDynamic = function () {
                    return this.isPublic() && !this.uri;
                };

                Namespace.prototype.getURI = function () {
                    return this.uri;
                };

                Namespace.prototype.toString = function () {
                    return Namespace._kinds[this.kind] + (this.uri ? " " + this.uri : "");
                };

                Namespace.prototype.clone = function () {
                    var ns = Object.create(Namespace.prototype);
                    ns.kind = this.kind;
                    ns.uri = this.uri;
                    ns.prefix = this.prefix;
                    ns.qualifiedName = this.qualifiedName;
                    return ns;
                };

                Namespace.prototype.isEqualTo = function (other) {
                    return this.qualifiedName === other.qualifiedName;
                };

                Namespace.prototype.inNamespaceSet = function (set) {
                    for (var i = 0; i < set.length; i++) {
                        if (set[i].qualifiedName === this.qualifiedName) {
                            return true;
                        }
                    }
                    return false;
                };

                Namespace.prototype.getAccessModifier = function () {
                    return Namespace._kinds[this.kind];
                };

                Namespace.prototype.getQualifiedName = function () {
                    return this.qualifiedName;
                };

                /**
                * Creates a set of namespaces from one or more comma delimited simple names, for example:
                * flash.display
                * private flash.display
                * [flash.display, private flash.display]
                */
                Namespace.fromSimpleName = function (simpleName) {
                    if (simpleName in Namespace._simpleNameCache) {
                        return Namespace._simpleNameCache[simpleName];
                    }
                    var namespaceNames;
                    if (simpleName.indexOf("[") === 0) {
                        release || assert(simpleName[simpleName.length - 1] === "]");
                        namespaceNames = simpleName.substring(1, simpleName.length - 1).split(",");
                    } else {
                        namespaceNames = [simpleName];
                    }
                    return Namespace._simpleNameCache[simpleName] = namespaceNames.map(function (name) {
                        name = name.trim();
                        var kindName, uri;
                        if (name.indexOf(" ") > 0) {
                            kindName = name.substring(0, name.indexOf(" ")).trim();
                            uri = name.substring(name.indexOf(" ") + 1).trim();
                        } else {
                            var kinds = Namespace._kinds;
                            if (name === kinds[8 /* Namespace */] || name === kinds[23 /* PackageInternalNs */] || name === kinds[5 /* PrivateNs */] || name === kinds[24 /* ProtectedNamespace */] || name === kinds[25 /* ExplicitNamespace */] || name === kinds[26 /* StaticProtectedNs */]) {
                                kindName = name;
                                uri = "";
                            } else {
                                kindName = Namespace._publicPrefix;
                                uri = name;
                            }
                        }
                        return new Namespace(Namespace.kindFromString(kindName), uri);
                    });
                };
                Namespace._publicPrefix = "public";

                Namespace._kinds = (function () {
                    var map = Shumway.ObjectUtilities.createMap();
                    map[8 /* Namespace */] = Namespace._publicPrefix;
                    map[23 /* PackageInternalNs */] = "packageInternal";
                    map[5 /* PrivateNs */] = "private";
                    map[24 /* ProtectedNamespace */] = "protected";
                    map[25 /* ExplicitNamespace */] = "explicit";
                    map[26 /* StaticProtectedNs */] = "staticProtected";
                    return map;
                })();

                Namespace._MIN_API_MARK = 0xe294;
                Namespace._MAX_API_MARK = 0xf8ff;

                Namespace._knownURIs = [
                    ""
                ];

                Namespace._mangledNamespaceCache = Shumway.ObjectUtilities.createMap();
                Namespace._mangledNamespaceMap = Shumway.ObjectUtilities.createMap();

                Namespace.PUBLIC = new Namespace(8 /* Namespace */);
                Namespace.PROTECTED = new Namespace(24 /* ProtectedNamespace */);
                Namespace.PROXY = new Namespace(8 /* Namespace */, "http://www.adobe.com/2006/actionscript/flash/proxy");
                Namespace.VECTOR = new Namespace(8 /* Namespace */, "__AS3__.vec");
                Namespace.VECTOR_PACKAGE = new Namespace(23 /* PackageInternalNs */, "__AS3__.vec");
                Namespace.BUILTIN = new Namespace(5 /* PrivateNs */, "builtin.as$0");

                Namespace._simpleNameCache = Shumway.ObjectUtilities.createMap();
                return Namespace;
            })();
            ABC.Namespace = Namespace;

            // TOTAL HACK ALERT !!!
            Namespace.prototype = Object.create(Namespace.prototype);

            /**
            * Section 2.3 and 4.4.3
            *
            * Multinames are (namespace set, name) pairs that are resolved to QNames (qualified names) at runtime. The terminology
            * in general is very confusing so we follow some naming conventions to simplify things. First of all, in ActionScript 3
            * there are 10 types of multinames. Half of them end in an "A" are used to represent the names of XML attributes. Those
            * prefixed with "RT" are "runtime" multinames which means they get their namespace from the runtime execution stack.
            * Multinames suffixed with "L" are called "late" which means they get their name from the runtime execution stack.
            *
            *  QName - A QName (qualified name) is the simplest form of multiname, it has one name and one namespace.
            *  E.g. ns::n
            *
            *  RTQName - A QName whose namespace part is resolved at runtime.
            *  E.g. [x]::n
            *
            *  RTQNameL - An RTQName whose name part is resolved at runtime.
            *  E.g. [x]::[y]
            *
            *  Multiname - A multiname with a namespace set.
            *  E.g. {ns0, ns1, ns2, ...}::n
            *
            *  MultinameL - A multiname with a namespace set whose name part is resolved at runtime.
            *  E.g. {ns0, ns1, ns2, ...}::[y]
            *
            * Multinames are used very frequently so it's important that we optimize their use. In Shumway, QNames are
            * represented as either: Multiname objects, strings or numbers, depending on the information they need to carry.
            * Typically, most named QNames will be strings while numeric QNames will be treated as numbers. All other Multiname
            * types will be represented as Multiname objects.
            *
            * Please use the following conventions when dealing with multinames:
            *
            * In the AS3 bytecode specification the word "name" usually refers to multinames. We use the same property name in
            * Shumway thus leading to code such as |instanceInfo.name.name| which is quite ugly. If possible, avoid using the
            * word "name" to refer to multinames, instead use "mn" or "multiname" and use the word "name" to refer to the
            * name part of a Multiname.
            *
            * Multiname: multiname, mn
            * QName: qualifiedName, qn
            * Namespace: namespace, ns
            *
            * Because a qualified name can be either a Multiname object, a string, a number, or even a Number object use the static
            * Multiname methods to query multinames. For instance, use |Multiname.isRuntimeMultiname(mn)| instead of
            * |mn.isRuntimeMultiname()| since the latter will fail if |mn| is not a Multiname object.
            */
            /**
            * Name Mangling
            *
            * All Shumway QNames are mangled using the following format:
            *
            * "$" (Variable Length Mangled Namespace) Name
            *
            * Namespaces are hashed to 32 bit integers and are converted to a base64 variable length string
            * encoding that can still be parsed as a valid JS identifier. We can encode 32 bits hashes with
            * six sets of 6 bits. This leaves us with 4 unused bits that can be used to encode the length
            * of the string.
            *
            */
            var Multiname = (function () {
                function Multiname(namespaces, name, flags) {
                    if (typeof flags === "undefined") { flags = 0; }
                    if (name !== undefined) {
                        release || assert(name === null || isString(name), "Multiname name must be a string. " + name);
                        // release || assert (!isNumeric(name), "Multiname name must not be numeric: " + name);
                    }
                    this.runtimeId = Multiname._nextID++;
                    this.namespaces = namespaces;
                    this.name = name;
                    this.flags = flags;
                }
                Multiname.parse = function (constantPool, stream, multinames, typeNamePatches, multinameIndex) {
                    var index = 0;
                    var kind = stream.readU8();
                    var name, namespaces = [], flags = 0;
                    switch (kind) {
                        case 7 /* QName */:
                        case 13 /* QNameA */:
                            index = stream.readU30();
                            if (index) {
                                namespaces = [constantPool.namespaces[index]];
                            } else {
                                flags &= ~Multiname.RUNTIME_NAME; // any name
                            }
                            index = stream.readU30();
                            if (index) {
                                name = constantPool.strings[index];
                            }
                            break;
                        case 15 /* RTQName */:
                        case 16 /* RTQNameA */:
                            index = stream.readU30();
                            if (index) {
                                name = constantPool.strings[index];
                            } else {
                                flags &= ~Multiname.RUNTIME_NAME;
                            }
                            flags |= Multiname.RUNTIME_NAMESPACE;
                            break;
                        case 17 /* RTQNameL */:
                        case 18 /* RTQNameLA */:
                            flags |= Multiname.RUNTIME_NAMESPACE;
                            flags |= Multiname.RUNTIME_NAME;
                            break;
                        case 9 /* Multiname */:
                        case 14 /* MultinameA */:
                            index = stream.readU30();
                            if (index) {
                                name = constantPool.strings[index];
                            } else {
                                flags &= ~Multiname.RUNTIME_NAME;
                            }
                            index = stream.readU30();
                            release || assert(index !== 0);
                            namespaces = constantPool.namespaceSets[index];
                            break;
                        case 27 /* MultinameL */:
                        case 28 /* MultinameLA */:
                            flags |= Multiname.RUNTIME_NAME;
                            index = stream.readU30();
                            release || assert(index !== 0);
                            namespaces = constantPool.namespaceSets[index];
                            break;

                        case 29 /* TypeName */:
                            var factoryTypeIndex = stream.readU32();
                            var typeParameterCount = stream.readU32();
                            release || assert(typeParameterCount === 1); // This is probably the number of type parameters.
                            var typeParameterIndex = stream.readU32();
                            var mn = undefined;

                            // If both |factoryTypeIndex| and |typeParameterIndex| are parsed then we can construct the type.
                            if (multinames[factoryTypeIndex] && multinames[typeParameterIndex]) {
                                mn = new Multiname(multinames[factoryTypeIndex].namespaces, multinames[factoryTypeIndex].name, flags);
                                mn.typeParameter = multinames[typeParameterIndex];
                            } else {
                                // Otherwise we have to patch it later since they are foward referenced.
                                typeNamePatches.push({
                                    index: multinameIndex,
                                    factoryTypeIndex: factoryTypeIndex,
                                    typeParameterIndex: typeParameterIndex,
                                    flags: flags
                                });
                            }
                            return mn;
                        default:
                            Shumway.Debug.unexpected();
                            break;
                    }
                    switch (kind) {
                        case 13 /* QNameA */:
                        case 16 /* RTQNameA */:
                        case 18 /* RTQNameLA */:
                        case 14 /* MultinameA */:
                        case 28 /* MultinameLA */:
                            flags |= Multiname.ATTRIBUTE;
                            break;
                    }

                    return new Multiname(namespaces, name, flags);
                };

                /**
                * Tests if the specified value is a valid Multiname.
                */
                Multiname.isMultiname = function (mn) {
                    return typeof mn === "number" || typeof mn === "string" || mn instanceof Multiname || mn instanceof Number;
                };

                Multiname.needsResolution = function (mn) {
                    return mn instanceof Multiname && mn.namespaces.length > 1;
                };

                /**
                * Tests if the specified value is a valid qualified name.
                */
                Multiname.isQName = function (mn) {
                    if (mn instanceof Multiname) {
                        return mn.namespaces && mn.namespaces.length === 1;
                    }
                    return true;
                };

                /**
                * Tests if the specified multiname has a runtime name.
                */
                Multiname.isRuntimeName = function (mn) {
                    return mn instanceof Multiname && mn.isRuntimeName();
                };

                /**
                * Tests if the specified multiname has a runtime namespace.
                */
                Multiname.isRuntimeNamespace = function (mn) {
                    return mn instanceof Multiname && mn.isRuntimeNamespace();
                };

                /**
                * Tests if the specified multiname has a runtime name or namespace.
                */
                Multiname.isRuntime = function (mn) {
                    return mn instanceof Multiname && mn.isRuntimeName() || mn.isRuntimeNamespace();
                };

                /**
                * Gets the qualified name for this multiname, this is either the identity or
                * a mangled Multiname object.
                */
                Multiname.getQualifiedName = function (mn) {
                    release || assert(Multiname.isQName(mn));
                    if (mn instanceof Multiname) {
                        if (mn.qualifiedName !== undefined) {
                            return mn.qualifiedName;
                        }
                        var name = String(mn.name);
                        if (isNumeric(name) && mn.namespaces[0].isPublic()) {
                            // release || assert (mn.namespaces[0].isPublic());
                            return mn.qualifiedName = name;
                        }
                        mn = mn.qualifiedName = Multiname.qualifyName(mn.namespaces[0], name);
                    }
                    return mn;
                };

                Multiname.qualifyName = function (namespace, name) {
                    return "$" + namespace.qualifiedName + name;
                };

                Multiname.stripPublicQualifier = function (qn) {
                    var publicQualifier = "$" + Namespace.PUBLIC.qualifiedName;
                    var index = qn.indexOf(publicQualifier);
                    if (index !== 0) {
                        return undefined;
                    }
                    return qn.substring(publicQualifier.length);
                };

                /**
                * Creates a Multiname from a mangled qualified name. The format should be of
                * the form "$"(mangledNamespace)(name).
                */
                Multiname.fromQualifiedName = function (qn) {
                    if (qn instanceof Multiname) {
                        return qn;
                    }
                    if (isNumeric(qn)) {
                        return new Multiname([Namespace.PUBLIC], qn);
                    }
                    if (qn[0] !== "$") {
                        return;
                    }
                    var ns = Namespace.fromQualifiedName(qn.substring(1));
                    return new Multiname([ns], qn.substring(1 + ns.qualifiedName.length));
                };

                Multiname.getNameFromPublicQualifiedName = function (qn) {
                    var mn = Multiname.fromQualifiedName(qn);
                    release || assert(mn.getNamespace().isPublic());
                    return mn.name;
                };

                /**
                * Same as |getQualifiedName| but it also includes the type parameter if
                * it has one.
                */
                Multiname.getFullQualifiedName = function (mn) {
                    var qn = Multiname.getQualifiedName(mn);
                    if (mn instanceof Multiname && mn.typeParameter) {
                        qn += "$" + Multiname.getFullQualifiedName(mn.typeParameter);
                    }
                    return qn;
                };

                Multiname.getPublicQualifiedName = function (name) {
                    if (isNumeric(name)) {
                        return Shumway.toNumber(name);
                    } else if (name !== null && isObject(name)) {
                        return name;
                    }

                    // release || assert (isString(name) || isNullOrUndefined(name));
                    return Multiname.qualifyName(Namespace.PUBLIC, name);
                };

                Multiname.isPublicQualifiedName = function (qn) {
                    return typeof qn === "number" || isNumeric(qn) || qn.indexOf(Namespace.PUBLIC.qualifiedName) === 1;
                };

                Multiname.getAccessModifier = function (mn) {
                    release || assert(Multiname.isQName(mn));
                    if (typeof mn === "number" || typeof mn === "string" || mn instanceof Number) {
                        return "public";
                    }
                    release || assert(mn instanceof Multiname);
                    return mn.namespaces[0].getAccessModifier();
                };

                Multiname.isNumeric = function (mn) {
                    if (typeof mn === "number") {
                        return true;
                    } else if (typeof mn === "string") {
                        return isNumeric(mn);
                    }

                    return !isNaN(parseInt(Multiname.getName(mn), 10));
                };

                Multiname.getName = function (mn) {
                    release || assert(mn instanceof Multiname);
                    release || assert(!mn.isRuntimeName());
                    return mn.getName();
                };

                Multiname.isAnyName = function (mn) {
                    return typeof mn === "object" && !mn.isRuntimeName() && !mn.name;
                };

                /**
                * Creates a multiname from a simple name qualified with one ore more namespaces, for example:
                * flash.display.Graphics
                * private flash.display.Graphics
                * [private flash.display, private flash, public].Graphics
                */
                Multiname.fromSimpleName = function (simpleName) {
                    release || assert(simpleName);
                    if (simpleName in Multiname._simpleNameCache) {
                        return Multiname._simpleNameCache[simpleName];
                    }

                    var nameIndex, namespaceIndex, name, namespace;
                    nameIndex = simpleName.lastIndexOf(".");
                    if (nameIndex <= 0) {
                        nameIndex = simpleName.lastIndexOf(" ");
                    }

                    if (nameIndex > 0 && nameIndex < simpleName.length - 1) {
                        name = simpleName.substring(nameIndex + 1).trim();
                        namespace = simpleName.substring(0, nameIndex).trim();
                    } else {
                        name = simpleName;
                        namespace = "";
                    }
                    return Multiname._simpleNameCache[simpleName] = new Multiname(Namespace.fromSimpleName(namespace), name);
                };

                Multiname.prototype.getQName = function (index) {
                    release || assert(index >= 0 && index < this.namespaces.length);
                    if (!this._qualifiedNameCache) {
                        this._qualifiedNameCache = Shumway.ObjectUtilities.createArrayMap();
                    }
                    var name = this._qualifiedNameCache[index];
                    if (!name) {
                        name = this._qualifiedNameCache[index] = new Multiname([this.namespaces[index]], this.name, this.flags);
                    }
                    return name;
                };

                Multiname.prototype.hasQName = function (qn) {
                    release || assert(qn instanceof Multiname);
                    if (this.name !== qn.name) {
                        return false;
                    }
                    for (var i = 0; i < this.namespaces.length; i++) {
                        if (this.namespaces[i].isEqualTo(qn.namespaces[0])) {
                            return true;
                        }
                    }
                    return false;
                };

                Multiname.prototype.isAttribute = function () {
                    return this.flags & Multiname.ATTRIBUTE;
                };

                Multiname.prototype.isAnyName = function () {
                    return Multiname.isAnyName(this);
                };

                Multiname.prototype.isAnyNamespace = function () {
                    // x.* has the same meaning as x.*::*, so look for the former case and give
                    // it the same meaning of the latter.
                    return !this.isRuntimeNamespace() && (this.namespaces.length === 0 || (this.isAnyName() && this.namespaces.length !== 1));
                };

                Multiname.prototype.isRuntimeName = function () {
                    return !!(this.flags & Multiname.RUNTIME_NAME);
                };

                Multiname.prototype.isRuntimeNamespace = function () {
                    return !!(this.flags & Multiname.RUNTIME_NAMESPACE);
                };

                Multiname.prototype.isRuntime = function () {
                    return !!(this.flags & (Multiname.RUNTIME_NAME | Multiname.RUNTIME_NAMESPACE));
                };

                Multiname.prototype.isQName = function () {
                    return this.namespaces.length === 1 && !this.isAnyName();
                };

                Multiname.prototype.hasTypeParameter = function () {
                    return !!this.typeParameter;
                };

                Multiname.prototype.getName = function () {
                    return this.name;
                };

                Multiname.prototype.getOriginalName = function () {
                    release || assert(this.isQName());
                    var name = this.namespaces[0].uri;
                    if (name) {
                        name += ".";
                    }
                    return name + this.name;
                };

                Multiname.prototype.getNamespace = function () {
                    release || assert(!this.isRuntimeNamespace());
                    release || assert(this.namespaces.length === 1);
                    return this.namespaces[0];
                };

                Multiname.prototype.nameToString = function () {
                    if (this.isAnyName()) {
                        return "*";
                    } else {
                        var name = this.getName();
                        return this.isRuntimeName() ? "[]" : name;
                    }
                };

                Multiname.prototype.hasObjectName = function () {
                    return typeof this.name === "object";
                };

                Multiname.prototype.toString = function () {
                    var str = this.isAttribute() ? "@" : "";
                    if (this.isAnyNamespace()) {
                        str += "*::" + this.nameToString();
                    } else if (this.isRuntimeNamespace()) {
                        str += "[]::" + this.nameToString();
                    } else if (this.namespaces.length === 1 && this.isQName()) {
                        str += this.namespaces[0].toString() + "::";
                        str += this.nameToString();
                    } else {
                        str += "{";
                        for (var i = 0, count = this.namespaces.length; i < count; i++) {
                            str += this.namespaces[i].toString();
                            if (i + 1 < count) {
                                str += ",";
                            }
                        }
                        str += "}::" + this.nameToString();
                    }

                    if (this.hasTypeParameter()) {
                        str += "<" + this.typeParameter.toString() + ">";
                    }
                    return str;
                };
                Multiname.ATTRIBUTE = 0x01;
                Multiname.RUNTIME_NAMESPACE = 0x02;
                Multiname.RUNTIME_NAME = 0x04;
                Multiname._nextID = 0;

                Multiname._simpleNameCache = Shumway.ObjectUtilities.createMap();

                Multiname.Int = Multiname.getPublicQualifiedName("int");
                Multiname.Uint = Multiname.getPublicQualifiedName("uint");
                Multiname.Class = Multiname.getPublicQualifiedName("Class");
                Multiname.Array = Multiname.getPublicQualifiedName("Array");
                Multiname.Object = Multiname.getPublicQualifiedName("Object");
                Multiname.String = Multiname.getPublicQualifiedName("String");
                Multiname.Number = Multiname.getPublicQualifiedName("Number");
                Multiname.Boolean = Multiname.getPublicQualifiedName("Boolean");
                Multiname.Function = Multiname.getPublicQualifiedName("Function");
                Multiname.XML = Multiname.getPublicQualifiedName("XML");
                Multiname.XMLList = Multiname.getPublicQualifiedName("XMLList");

                Multiname.TO_STRING = Multiname.getPublicQualifiedName("toString");
                Multiname.VALUE_OF = Multiname.getPublicQualifiedName("valueOf");
                Multiname.TEMPORARY = new Multiname([], "");
                return Multiname;
            })();
            ABC.Multiname = Multiname;

            var MetaDataInfo = (function () {
                function MetaDataInfo(abc, stream) {
                    var strings = abc.constantPool.strings;
                    var name = this.name = strings[stream.readU30()];
                    var itemCount = stream.readU30();
                    var keys = [];
                    var items = [];

                    for (var i = 0; i < itemCount; i++) {
                        keys[i] = strings[stream.readU30()];
                    }

                    for (var i = 0; i < itemCount; i++) {
                        var key = keys[i];
                        items[i] = { key: key, value: strings[stream.readU30()] };

                        // for the 'native' tag, store all properties directly on the tag's
                        // object, too. There's not going to be any duplicates.
                        if (key && name === "native") {
                            release || assert(!this.hasOwnProperty(key));
                            this[key] = items[i].value;
                        }
                    }

                    this.value = items;
                }
                MetaDataInfo.prototype.toString = function () {
                    return "[" + this.name + "]";
                };
                return MetaDataInfo;
            })();
            ABC.MetaDataInfo = MetaDataInfo;

            (function (CONSTANT) {
                CONSTANT[CONSTANT["Undefined"] = 0x00] = "Undefined";
                CONSTANT[CONSTANT["Utf8"] = 0x01] = "Utf8";
                CONSTANT[CONSTANT["Float"] = 0x02] = "Float";
                CONSTANT[CONSTANT["Int"] = 0x03] = "Int";
                CONSTANT[CONSTANT["UInt"] = 0x04] = "UInt";
                CONSTANT[CONSTANT["PrivateNs"] = 0x05] = "PrivateNs";
                CONSTANT[CONSTANT["Double"] = 0x06] = "Double";
                CONSTANT[CONSTANT["QName"] = 0x07] = "QName";
                CONSTANT[CONSTANT["Namespace"] = 0x08] = "Namespace";
                CONSTANT[CONSTANT["Multiname"] = 0x09] = "Multiname";
                CONSTANT[CONSTANT["False"] = 0x0A] = "False";
                CONSTANT[CONSTANT["True"] = 0x0B] = "True";
                CONSTANT[CONSTANT["Null"] = 0x0C] = "Null";
                CONSTANT[CONSTANT["QNameA"] = 0x0D] = "QNameA";
                CONSTANT[CONSTANT["MultinameA"] = 0x0E] = "MultinameA";
                CONSTANT[CONSTANT["RTQName"] = 0x0F] = "RTQName";
                CONSTANT[CONSTANT["RTQNameA"] = 0x10] = "RTQNameA";
                CONSTANT[CONSTANT["RTQNameL"] = 0x11] = "RTQNameL";
                CONSTANT[CONSTANT["RTQNameLA"] = 0x12] = "RTQNameLA";
                CONSTANT[CONSTANT["NameL"] = 0x13] = "NameL";
                CONSTANT[CONSTANT["NameLA"] = 0x14] = "NameLA";
                CONSTANT[CONSTANT["NamespaceSet"] = 0x15] = "NamespaceSet";
                CONSTANT[CONSTANT["PackageNamespace"] = 0x16] = "PackageNamespace";
                CONSTANT[CONSTANT["PackageInternalNs"] = 0x17] = "PackageInternalNs";
                CONSTANT[CONSTANT["ProtectedNamespace"] = 0x18] = "ProtectedNamespace";
                CONSTANT[CONSTANT["ExplicitNamespace"] = 0x19] = "ExplicitNamespace";
                CONSTANT[CONSTANT["StaticProtectedNs"] = 0x1A] = "StaticProtectedNs";
                CONSTANT[CONSTANT["MultinameL"] = 0x1B] = "MultinameL";
                CONSTANT[CONSTANT["MultinameLA"] = 0x1C] = "MultinameLA";
                CONSTANT[CONSTANT["TypeName"] = 0x1D] = "TypeName";

                CONSTANT[CONSTANT["ClassSealed"] = 0x01] = "ClassSealed";
                CONSTANT[CONSTANT["ClassFinal"] = 0x02] = "ClassFinal";
                CONSTANT[CONSTANT["ClassInterface"] = 0x04] = "ClassInterface";
                CONSTANT[CONSTANT["ClassProtectedNs"] = 0x08] = "ClassProtectedNs";
            })(ABC.CONSTANT || (ABC.CONSTANT = {}));
            var CONSTANT = ABC.CONSTANT;

            (function (METHOD) {
                METHOD[METHOD["Arguments"] = 0x1] = "Arguments";
                METHOD[METHOD["Activation"] = 0x2] = "Activation";
                METHOD[METHOD["Needrest"] = 0x4] = "Needrest";
                METHOD[METHOD["HasOptional"] = 0x8] = "HasOptional";
                METHOD[METHOD["IgnoreRest"] = 0x10] = "IgnoreRest";
                METHOD[METHOD["Native"] = 0x20] = "Native";
                METHOD[METHOD["Setsdxns"] = 0x40] = "Setsdxns";
                METHOD[METHOD["HasParamNames"] = 0x80] = "HasParamNames";
            })(ABC.METHOD || (ABC.METHOD = {}));
            var METHOD = ABC.METHOD;

            (function (TRAIT) {
                TRAIT[TRAIT["Slot"] = 0] = "Slot";
                TRAIT[TRAIT["Method"] = 1] = "Method";
                TRAIT[TRAIT["Getter"] = 2] = "Getter";
                TRAIT[TRAIT["Setter"] = 3] = "Setter";
                TRAIT[TRAIT["Class"] = 4] = "Class";
                TRAIT[TRAIT["Function"] = 5] = "Function";
                TRAIT[TRAIT["Const"] = 6] = "Const";
            })(ABC.TRAIT || (ABC.TRAIT = {}));
            var TRAIT = ABC.TRAIT;

            (function (ATTR) {
                ATTR[ATTR["Final"] = 0x01] = "Final";
                ATTR[ATTR["Override"] = 0x02] = "Override";
                ATTR[ATTR["Metadata"] = 0x04] = "Metadata";
            })(ABC.ATTR || (ABC.ATTR = {}));
            var ATTR = ABC.ATTR;

            (function (SORT) {
                SORT[SORT["CASEINSENSITIVE"] = 0x01] = "CASEINSENSITIVE";
                SORT[SORT["DESCENDING"] = 0x02] = "DESCENDING";
                SORT[SORT["UNIQUESORT"] = 0x04] = "UNIQUESORT";
                SORT[SORT["RETURNINDEXEDARRAY"] = 0x08] = "RETURNINDEXEDARRAY";
                SORT[SORT["NUMERIC"] = 0x10] = "NUMERIC";
            })(ABC.SORT || (ABC.SORT = {}));
            var SORT = ABC.SORT;

            var ConstantPool = (function () {
                function ConstantPool(stream, abc) {
                    var n;

                    // Parse Integers
                    var ints = [0];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        ints.push(stream.readS32());
                    }

                    // Parse Unsigned Integers
                    var uints = [0];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        uints.push(stream.readU32());
                    }

                    // Parse Doubles
                    var doubles = [NaN];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        doubles.push(stream.readDouble());
                    }
                    AVM2.enterTimeline("Parse Strings");

                    // Parse Strings
                    var strings = [""];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        strings.push(stream.readUTFString(stream.readU30()));
                    }
                    AVM2.leaveTimeline();

                    this.ints = ints;
                    this.uints = uints;
                    this.doubles = doubles;
                    this.strings = strings;

                    AVM2.enterTimeline("Parse Namespaces");

                    // Namespaces
                    var namespaces = [undefined];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        namespaces.push(Namespace.parse(this, stream, abc.hash + i));
                    }
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Parse Namespace Sets");

                    // Namespace Sets
                    var namespaceSets = [undefined];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        var count = stream.readU30();
                        var namespaceSet = [];
                        namespaceSet.runtimeId = ConstantPool._nextNamespaceSetID++;
                        namespaceSet.hash = abc.hash & 65535 /* AbcMask */ | 262144 /* NamespaceSet */ | (i << 19 /* IndexOffset */);
                        for (var j = 0; j < count; ++j) {
                            namespaceSet.push(namespaces[stream.readU30()]);
                        }
                        namespaceSets.push(namespaceSet);
                    }
                    AVM2.leaveTimeline();

                    this.namespaces = namespaces;
                    this.namespaceSets = namespaceSets;

                    AVM2.enterTimeline("Parse Multinames");

                    // Multinames
                    var multinames = [undefined];
                    var typeNamePatches = [];
                    n = stream.readU30();
                    for (var i = 1; i < n; ++i) {
                        multinames.push(Multiname.parse(this, stream, multinames, typeNamePatches, i));
                    }
                    for (var i = 0; i < typeNamePatches.length; i++) {
                        var patch = typeNamePatches[i];
                        var factoryType = multinames[patch.factoryTypeIndex];
                        var typeParameter = multinames[patch.typeParameterIndex];
                        release || assert(factoryType && typeParameter);
                        var mn = new Multiname(factoryType.namespaces, factoryType.name, patch.flags);
                        mn.typeParameter = typeParameter;
                        multinames[patch.index] = mn;
                    }
                    AVM2.leaveTimeline();

                    this.multinames = multinames;
                }
                ConstantPool.prototype.getValue = function (kind, index) {
                    switch (kind) {
                        case 3 /* Int */:
                            return this.ints[index];
                        case 4 /* UInt */:
                            return this.uints[index];
                        case 6 /* Double */:
                            return this.doubles[index];
                        case 1 /* Utf8 */:
                            return this.strings[index];
                        case 11 /* True */:
                            return true;
                        case 10 /* False */:
                            return false;
                        case 12 /* Null */:
                            return null;
                        case 0 /* Undefined */:
                            return undefined;
                        case 8 /* Namespace */:
                        case 23 /* PackageInternalNs */:
                            return this.namespaces[index];
                        case 7 /* QName */:
                        case 14 /* MultinameA */:
                        case 15 /* RTQName */:
                        case 16 /* RTQNameA */:
                        case 17 /* RTQNameL */:
                        case 18 /* RTQNameLA */:
                        case 19 /* NameL */:
                        case 20 /* NameLA */:
                            return this.multinames[index];
                        case 2 /* Float */:
                            Shumway.Debug.warning("TODO: CONSTANT.Float may be deprecated?");
                            break;
                        default:
                            release || assert(false, "Not Implemented Kind " + kind);
                    }
                };
                ConstantPool._nextNamespaceSetID = 1;
                return ConstantPool;
            })();
            ABC.ConstantPool = ConstantPool;
        })(AVM2.ABC || (AVM2.ABC = {}));
        var ABC = AVM2.ABC;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /*
        * Copyright 2013 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *     http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (ABC) {
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;

            var filter = new Shumway.Options.Option("f", "filter", "string", "SpciMsmNtu", "[S]ource, constant[p]ool, [c]lasses, [i]nstances, [M]etadata, [s]cripts, [m]ethods, multi[N]ames, S[t]atistics, [u]tf");

            function traceArray(writer, name, array, abc) {
                if (typeof abc === "undefined") { abc = null; }
                if (array.length === 0) {
                    return;
                }
                writer.enter(name + " {");
                array.forEach(function (a, idx) {
                    a.trace(writer, abc);
                });
                writer.leave("}");
            }

            ABC.AbcFile.prototype.trace = function trace(writer) {
                if (filter.value.indexOf("p") >= 0) {
                    this.constantPool.trace(writer);
                }
                if (filter.value.indexOf("N") >= 0) {
                    traceMultinamesOnly(this.constantPool, writer);
                }
                if (filter.value.indexOf("c") >= 0) {
                    traceArray(writer, "classes", this.classes);
                }
                if (filter.value.indexOf("i") >= 0) {
                    traceArray(writer, "instances", this.instances);
                }
                if (filter.value.indexOf("M") >= 0) {
                    traceArray(writer, "metadata", this.metadata);
                }
                if (filter.value.indexOf("s") >= 0) {
                    traceArray(writer, "scripts", this.scripts);
                }
                if (filter.value.indexOf("m") >= 0) {
                    traceArray(writer, "methods", this.methods, this);
                }
                if (filter.value.indexOf("S") >= 0) {
                    traceSource(writer, this);
                }
                if (filter.value.indexOf("t") >= 0) {
                    traceStatistics(writer, this);
                }
            };

            ABC.ConstantPool.prototype.trace = function (writer) {
                writer.enter("constantPool {");
                for (var key in this) {
                    /* Special-case namespaces to print out full names. */
                    if (key === "namespaces") {
                        writer.enter("namespaces {");
                        this.namespaces.forEach(function (ns, i) {
                            writer.writeLn(("" + i).padRight(' ', 3) + (ns ? ns.toString() : "*"));
                        });
                        writer.leave("}");
                    } else if (this[key] instanceof Array) {
                        writer.enter(key + " " + this[key].length + " {");
                        writer.writeArray(this[key]);
                        writer.leave("}");
                    }
                }
                writer.leave("}");
            };

            function traceMultinamesOnly(constantPool, writer) {
                writer.writeArray(constantPool.multinames, null, true);
            }

            ABC.ClassInfo.prototype.trace = function (writer) {
                writer.enter("class " + this + " {");
                traceArray(writer, "traits", this.traits);
                writer.leave("}");
            };

            ABC.MetaDataInfo.prototype.trace = function (writer) {
                writer.enter(this + " {");
                this.value.forEach(function (item) {
                    writer.writeLn((item.key ? item.key + ": " : "") + "\"" + item.value + "\"");
                });
                writer.leave("}");
            };

            ABC.InstanceInfo.prototype.trace = function (writer) {
                writer.enter("instance " + this + " {");
                traceArray(writer, "traits", this.traits);
                writer.leave("}");
            };

            ABC.ScriptInfo.prototype.trace = function (writer) {
                writer.enter("script " + this + " {");
                traceArray(writer, "traits", this.traits);
                writer.leave("}");
            };

            ABC.Trait.prototype.trace = function (writer) {
                if (this.metadata) {
                    for (var key in this.metadata) {
                        if (this.metadata.hasOwnProperty(key)) {
                            this.metadata[key].trace(writer);
                        }
                    }
                }
                writer.writeLn(this);
            };

            function traceAbc(writer, abc) {
                abc.trace(writer);
            }

            function traceOperand(operand, abc, code) {
                var value = 0;
                switch (operand.size) {
                    case "s08":
                        value = code.readS8();
                        break;
                    case "u08":
                        value = code.readU8();
                        break;
                    case "s16":
                        value = code.readS16();
                        break;
                    case "s24":
                        value = code.readS24();
                        break;
                    case "u30":
                        value = code.readU30();
                        break;
                    case "u32":
                        value = code.readU32();
                        break;
                    default:
                        release || assert(false);
                        break;
                }
                var description = "";
                switch (operand.type) {
                    case "":
                        break;
                    case "I":
                        description = abc.constantPool.ints[value];
                        break;
                    case "U":
                        description = abc.constantPool.uints[value];
                        break;
                    case "D":
                        description = abc.constantPool.doubles[value];
                        break;
                    case "S":
                        description = abc.constantPool.strings[value];
                        break;
                    case "N":
                        description = abc.constantPool.namespaces[value];
                        break;
                    case "CI":
                        description = abc.classes[value];
                        break;
                    case "M":
                        return abc.constantPool.multinames[value];
                    default:
                        description = "?";
                        break;
                }
                return operand.name + ":" + value + (description === "" ? "" : " (" + description + ")");
            }

            function traceOperands(opcode, abc, code, rewind) {
                if (typeof rewind === "undefined") { rewind = false; }
                var old = code.position;
                var str = "";
                if (opcode.operands === null) {
                    str = "null";
                } else {
                    opcode.operands.forEach(function (op, i) {
                        str += traceOperand(op, abc, code);
                        if (i < opcode.operands.length - 1) {
                            str += ", ";
                        }
                    });
                }
                if (rewind) {
                    code.seek(old);
                }
                return str;
            }

            ABC.MethodInfo.prototype.trace = function trace(writer) {
                var abc = this.abc;
                writer.enter("method" + (this.name ? " " + this.name : "") + " {");
                writer.writeLn("flags: " + Shumway.IntegerUtilities.getFlags(this.flags, "NEED_ARGUMENTS|NEED_ACTIVATION|NEED_REST|HAS_OPTIONAL||NATIVE|SET_DXN|HAS_PARAM_NAMES".split("|")));
                writer.writeLn("parameters: " + this.parameters.map(function (x) {
                    return (x.type ? ABC.Multiname.getQualifiedName(x.type) + "::" : "") + x.name;
                }));

                if (!this.code) {
                    writer.leave("}");
                    return;
                }

                var code = new ABC.AbcStream(this.code);

                traceArray(writer, "traits", this.traits);

                writer.enter("code {");
                while (code.remaining() > 0) {
                    var bc = code.readU8();
                    var opcode = Shumway.AVM2.opcodeTable[bc];
                    var str, defaultOffset, offset, count;
                    str = ("" + code.position).padRight(' ', 6);
                    switch (bc) {
                        case 27 /* lookupswitch */:
                            str += opcode.name + ": defaultOffset: " + code.readS24();
                            var caseCount = code.readU30();
                            str += ", caseCount: " + caseCount;
                            for (var i = 0; i < caseCount + 1; i++) {
                                str += " offset: " + code.readS24();
                            }
                            writer.writeLn(str);
                            break;
                        default:
                            if (opcode) {
                                str += opcode.name.padRight(' ', 20);
                                if (!opcode.operands) {
                                    release || assert(false, "Opcode: " + opcode.name + " has undefined operands.");
                                } else {
                                    if (opcode.operands.length > 0) {
                                        str += traceOperands(opcode, abc, code);
                                    }
                                    writer.writeLn(str);
                                }
                            } else {
                                release || assert(false, "Opcode: " + bc + " is not implemented.");
                            }
                            break;
                    }
                }
                writer.leave("}");
                writer.leave("}");
            };

            var SourceTracer = (function () {
                function literal(value) {
                    if (value === undefined) {
                        return "undefined";
                    } else if (value === null) {
                        return "null";
                    } else if (typeof (value) === "string") {
                        return "\"" + value + "\"";
                    } else {
                        return String(value);
                    }
                }

                function getSignature(mi, excludeTypesAndDefaultValues) {
                    if (typeof excludeTypesAndDefaultValues === "undefined") { excludeTypesAndDefaultValues = false; }
                    return mi.parameters.map(function (x) {
                        var str = x.name;
                        if (!excludeTypesAndDefaultValues) {
                            if (x.type) {
                                str += ":" + x.type.getName();
                            }
                            if (x.value !== undefined) {
                                str += " = " + literal(x.value);
                            }
                        }
                        return str;
                    }).join(", ");
                }

                function SourceTracer(writer) {
                    this.writer = writer;
                }

                SourceTracer.prototype = {
                    traceTraits: function traceTraits(traits, isStatic, inInterfaceNamespace) {
                        var writer = this.writer;
                        var tracer = this;

                        traits.forEach(function (trait) {
                            var str;
                            var accessModifier = ABC.Multiname.getAccessModifier(trait.name);
                            var namespaceName = trait.name.namespaces[0].uri;
                            if (namespaceName) {
                                if (namespaceName === "http://adobe.com/AS3/2006/builtin") {
                                    namespaceName = "AS3";
                                }
                                if (accessModifier === "public") {
                                    str = inInterfaceNamespace === namespaceName ? "" : namespaceName;
                                } else {
                                    str = accessModifier;
                                }
                            } else {
                                str = accessModifier;
                            }
                            if (isStatic) {
                                str += " static";
                            }
                            if (trait.isSlot() || trait.isConst()) {
                                tracer.traceMetadata(trait.metadata);
                                if (trait.isConst()) {
                                    str += " const";
                                } else {
                                    str += " var";
                                }
                                str += " " + trait.name.getName();
                                if (trait.typeName) {
                                    str += ":" + trait.typeName.getName();
                                }
                                if (trait.value) {
                                    str += " = " + literal(trait.value);
                                }
                                writer.writeLn(str + ";");
                            } else if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                                tracer.traceMetadata(trait.metadata);
                                var mi = trait.methodInfo;
                                if (trait.attributes & 2 /* Override */) {
                                    str += " override";
                                }
                                if (mi.isNative()) {
                                    str += " native";
                                }
                                str += " function";
                                str += trait.isGetter() ? " get" : (trait.isSetter() ? " set" : "");
                                str += " " + trait.name.getName();
                                str += "(" + getSignature(mi) + ")";
                                str += mi.returnType ? ":" + mi.returnType.getName() : "";

                                if (true) {
                                    var className;
                                    var prefix = "";
                                    if (trait.holder instanceof ABC.ClassInfo) {
                                        className = trait.holder.instanceInfo.name;
                                        if (className.namespaces[0].uri) {
                                            prefix += className.namespaces[0].uri + "::";
                                        }
                                        prefix += className.getName();
                                        prefix += "$/";
                                    } else if (trait.holder instanceof ABC.InstanceInfo) {
                                        className = trait.holder.name;
                                        if (className.namespaces[0].uri) {
                                            prefix += className.namespaces[0].uri + "::";
                                        }
                                        prefix += className.getName();
                                        prefix += "/";
                                    } else {
                                        prefix = "global/";
                                    }
                                    var getSet = trait.isGetter() ? "get " : (trait.isSetter() ? "set " : "");
                                    if (!mi.isNative()) {
                                        // print("XXX: " + prefix + getSet + trait.name.getName() + " ()");
                                    }
                                }

                                if (mi.isNative()) {
                                    writer.writeLn(str + ";");
                                } else {
                                    if (inInterfaceNamespace) {
                                        writer.writeLn(str + ";");
                                    } else {
                                        writer.writeLn(str + " { notImplemented(\"" + trait.name.getName() + "\"); }");
                                    }
                                }
                            } else if (trait.isClass()) {
                                var className = trait.classInfo.instanceInfo.name;
                                writer.enter("package " + className.namespaces[0].uri + " {\n");
                                tracer.traceMetadata(trait.metadata);
                                tracer.traceClass(trait.classInfo);
                                writer.leave("\n}");
                                tracer.traceClassStub(trait);
                            } else {
                                notImplemented(trait);
                            }
                        });
                    },
                    traceClassStub2: function traceClassStub(trait) {
                        var writer = this.writer;

                        var ci = trait.classInfo;
                        var ii = ci.instanceInfo;
                        var name = ii.name.getName();
                        var native = trait.metadata ? trait.metadata.native : null;
                        if (!native) {
                            return false;
                        }

                        writer.writeLn("Cut and paste the following into `native.js' and edit accordingly");
                        writer.writeLn("8< --------------------------------------------------------------");
                        writer.enter("natives." + native.cls + " = function " + native.cls + "(runtime, scope, instanceConstructor, baseClass) {");
                        writer.writeLn("var c = new Class(\"" + name + "\", instanceConstructor, ApplicationDomain.passthroughCallable(instanceConstructor));");
                        writer.writeLn("c.extend(baseClass);\n");

                        function traceTraits(traits, isStatic) {
                            if (typeof isStatic === "undefined") { isStatic = false; }
                            var nativeMethodTraits = [];

                            traits.forEach(function (trait, i) {
                                if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                                    if (trait.methodInfo.isNative()) {
                                        nativeMethodTraits.push(trait);
                                    }
                                }
                            });

                            nativeMethodTraits.forEach(function (trait, i) {
                                var mi = trait.methodInfo;
                                var traitName = trait.name.getName();
                                writer.writeLn("// " + traitName + " :: " + (mi.parameters.length ? getSignature(mi) : "void") + " -> " + (mi.returnType ? mi.returnType.getName() : "any"));
                                var prop;
                                if (trait.isGetter()) {
                                    prop = "\"get " + traitName + "\"";
                                } else if (trait.isSetter()) {
                                    prop = "\"set " + traitName + "\"";
                                } else {
                                    prop = traitName;
                                }

                                writer.enter(prop + ": function " + traitName + "(" + getSignature(mi, true) + ") {");
                                writer.writeLn("  notImplemented(\"" + name + "." + traitName + "\");");
                                writer.leave("}" + (i === nativeMethodTraits.length - 1 ? "" : ",\n"));
                            });
                        }

                        writer.enter("c.nativeStatics = {");
                        traceTraits(ci.traits, true);
                        writer.leave("};\n");
                        writer.enter("c.nativeMethods = {");
                        traceTraits(ii.traits);
                        writer.leave("};\n");

                        writer.writeLn("return c;");
                        writer.leave("};");
                        writer.writeLn("-------------------------------------------------------------- >8");

                        return true;
                    },
                    traceClassStub: function traceClassStub(trait) {
                        var writer = this.writer;

                        var ci = trait.classInfo;
                        var ii = ci.instanceInfo;
                        var className = ii.name.getName();
                        var native = trait.metadata ? trait.metadata.native : null;

                        writer.writeLn("Cut and paste the following glue and edit accordingly.");
                        writer.writeLn("Class " + ii);
                        writer.writeLn("8< --------------------------------------------------------------");

                        var uri = ii.name.namespaces[0].uri;

                        writer.enter("var " + className + "Definition = (function () {");
                        function maxTraitNameLength(traits) {
                            var length = 0;
                            traits.forEach(function (t) {
                                length = Math.max(t.name.name.length, length);
                            });
                            return length;
                        }

                        function quote(s) {
                            return '\'' + s + '\'';
                        }

                        function filterTraits(traits, isNative) {
                            function isMethod(x) {
                                return x.isMethod() || x.isGetter() || x.isSetter();
                            }
                            return {
                                properties: traits.filter(function (trait) {
                                    return !isNative && !isMethod(trait);
                                }),
                                methods: traits.filter(function (trait) {
                                    return isMethod(trait) && (isNative === trait.methodInfo.isNative());
                                })
                            };
                        }

                        function writeTraits(traits, isNative, isStatic) {
                            if (typeof isStatic === "undefined") { isStatic = false; }
                            traits = filterTraits(traits, isNative);

                            // var methods = traits.methods;
                            var methods = [];
                            var gettersAndSetters = Shumway.ObjectUtilities.createEmptyObject();

                            traits.methods.forEach(function (trait, i) {
                                var traitName = trait.name.getName();
                                if (trait.isGetter() || trait.isSetter()) {
                                    if (!gettersAndSetters[traitName]) {
                                        gettersAndSetters[traitName] = [];
                                    }
                                    gettersAndSetters[traitName].push(trait);
                                } else {
                                    methods.push(trait);
                                }
                            });

                            function writeTrait(trait, writeComma) {
                                var mi = trait.methodInfo;
                                var traitName = trait.name.getName();
                                var signature = "// (" + (mi.parameters.length ? getSignature(mi) : "void") + ") -> " + (mi.returnType ? mi.returnType.getName() : "any");
                                var propertyName = traitName;
                                if (trait.isGetter()) {
                                    propertyName = "get";
                                } else if (trait.isSetter()) {
                                    propertyName = "set";
                                }
                                writer.enter(propertyName + ": function " + traitName + "(" + getSignature(mi, true) + ") { " + signature);
                                writer.writeLn("notImplemented(\"" + className + "." + traitName + "\");");
                                if (!isStatic) {
                                    if (trait.isGetter()) {
                                        writer.writeLn("return this._" + traitName + ";");
                                    } else if (trait.isSetter()) {
                                        writer.writeLn("this._" + traitName + " = " + mi.parameters[0].name + ";");
                                    }
                                }
                                writer.leave("}" + (writeComma ? "," : ""));
                            }

                            for (var i = 0; i < methods.length; i++) {
                                writeTrait(methods[i], i < methods.length - 1);
                            }

                            var keyValues = Shumway.ObjectUtilities.toKeyValueArray(gettersAndSetters);
                            for (var j = 0; j < keyValues.length; j++) {
                                writer.enter(keyValues[j][0] + ": {");
                                var list = keyValues[j][1];
                                for (var i = 0; i < list.length; i++) {
                                    writeTrait(list[i], i < list.length - 1);
                                }
                                writer.leave("}" + (j < keyValues.length - 1 ? "," : ""));
                            }

                            traits.properties.forEach(function (trait, i) {
                                var traitName = trait.name.getName();
                                var last = i === traits.properties.length - 1;

                                // writer.writeLn("// " + (trait.typeName ? trait.typeName + " " : "") + traitName + ": " + quote(Multiname.getQualifiedName(trait.name)) + (last ? "" : ","));
                                if (trait.name.getNamespace().isPublic()) {
                                    writer.writeLn(traitName + ": " + quote("public " + trait.name.name) + (last ? "" : ","));
                                }
                            });
                        }

                        writer.enter("return {");
                        writer.writeLn("// (" + getSignature(ii.init, false) + ")");
                        writer.writeLn("__class__: \"" + uri + "." + className + "\",");
                        writer.enter("initialize: function () {");
                        writer.leave("},");
                        writer.enter("__glue__: {");
                        writer.enter("native: {");
                        writer.enter("static: {");
                        writeTraits(ci.traits, true, true);
                        writer.leave("},");
                        writer.enter("instance: {");
                        writeTraits(ii.traits, true);
                        writer.leave("}");
                        writer.leave("},");
                        writer.enter("script: {");
                        writer.writeLn("instance: Glue.ALL");
                        writer.leave("}");
                        writer.leave("}");
                        writer.leave("};");

                        writer.leave("}).call(this);");
                        writer.writeLn("-------------------------------------------------------------- >8");

                        return true;
                    },
                    traceClass: function traceClass(ci) {
                        var writer = this.writer;

                        var ii = ci.instanceInfo;
                        var name = ii.name;
                        var str = ABC.Multiname.getAccessModifier(name);
                        if (ii.isFinal()) {
                            str += " final";
                        }
                        if (!ii.isSealed()) {
                            str += " dynamic";
                        }
                        str += ii.isInterface() ? " interface " : " class ";
                        str += name.getName();
                        if (ii.superName && ii.superName.getName() !== "Object") {
                            str += " extends " + ii.superName.getName();
                        }
                        if (ii.interfaces.length) {
                            str += " implements " + ii.interfaces.map(function (x) {
                                return x.getName();
                            }).join(", ");
                        }
                        writer.enter(str + " {");
                        if (!ii.isInterface()) {
                            writer.writeLn("public function " + name.getName() + "(" + getSignature(ii.init) + ") {}");
                        }
                        var interfaceNamespace;
                        if (ii.isInterface()) {
                            interfaceNamespace = name.namespaces[0].uri + ":" + name.name;
                        }
                        this.traceTraits(ci.traits, true, interfaceNamespace);
                        this.traceTraits(ii.traits, false, interfaceNamespace);
                        writer.leave("}");
                    },
                    traceMetadata: function traceMetadata(metadata) {
                        var writer = this.writer;

                        for (var key in metadata) {
                            if (metadata.hasOwnProperty(key)) {
                                if (key.indexOf("__") === 0) {
                                    continue;
                                }
                                writer.writeLn("[" + key + "(" + metadata[key].value.map(function (m) {
                                    var str = m.key ? m.key + "=" : "";
                                    return str + "\"" + m.value + "\"";
                                }).join(", ") + ")]");
                            }
                        }
                    }
                };

                return SourceTracer;
            })();

            function traceSource(writer, abc) {
                var tracer = new SourceTracer(writer);
                abc.scripts.forEach(function (script) {
                    tracer.traceTraits(script.traits);
                });
            }

            function traceStatistics(writer, abc) {
                /**
                * Keep track of classes / methods / properties defined in this ABC file. This is very
                * conservative, we only look at names and ignore all namespaces. Members that do not
                * appear in this ABC file are assumed to be in the library.
                */
                var libraryClassCounter = new Shumway.Metrics.Counter(true);
                var librarySuperClassCounter = new Shumway.Metrics.Counter(true);
                var libraryMethodCounter = new Shumway.Metrics.Counter(true);
                var libraryProperties = new Shumway.Metrics.Counter(true);

                var definedClasses = {};
                var definedMethods = {};
                var definedProperties = {};

                abc.classes.forEach(function (x) {
                    var className = x.instanceInfo.name.name;
                    definedClasses[className] = true;
                });

                abc.scripts.forEach(function (s) {
                    s.traits.forEach(function (t) {
                        if (t.isClass()) {
                            var superClassName = t.classInfo.instanceInfo.superName ? t.classInfo.instanceInfo.superName.name : "?";
                            if (!(superClassName in definedClasses)) {
                                librarySuperClassCounter.count(superClassName);
                            }
                            t.classInfo.traits.forEach(function (st) {
                                if (st.isMethod()) {
                                    definedMethods[st.name.name] = true;
                                } else {
                                    definedProperties[st.name.name] = true;
                                }
                            });
                            t.classInfo.instanceInfo.traits.forEach(function (it) {
                                if (it.isMethod() && !(it.attributes & 2 /* Override */)) {
                                    definedMethods[it.name.name] = true;
                                } else {
                                    definedProperties[it.name.name] = true;
                                }
                            });
                        }
                    });
                });

                var opCounter = new Shumway.Metrics.Counter(true);

                abc.methods.forEach(function (m) {
                    if (!m.code) {
                        return;
                    }

                    function readOperand(operand) {
                        var value = 0;
                        switch (operand.size) {
                            case "s08":
                                value = code.readS8();
                                break;
                            case "u08":
                                value = code.readU8();
                                break;
                            case "s16":
                                value = code.readS16();
                                break;
                            case "s24":
                                value = code.readS24();
                                break;
                            case "u30":
                                value = code.readU30();
                                break;
                            case "u32":
                                value = code.readU32();
                                break;
                            default:
                                release || assert(false);
                                break;
                        }
                        var description = "";
                        switch (operand.type) {
                            case "":
                                break;
                            case "I":
                                description = abc.constantPool.ints[value];
                                break;
                            case "U":
                                description = abc.constantPool.uints[value];
                                break;
                            case "D":
                                description = abc.constantPool.doubles[value];
                                break;
                            case "S":
                                description = abc.constantPool.strings[value];
                                break;
                            case "N":
                                description = abc.constantPool.namespaces[value];
                                break;
                            case "CI":
                                description = abc.classes[value];
                                break;
                            case "M":
                                description = abc.constantPool.multinames[value];
                                break;
                            default:
                                description = "?";
                                break;
                        }
                        return description;
                    }

                    var code = new ABC.AbcStream(m.code);
                    while (code.remaining() > 0) {
                        var bc = code.readU8();
                        var op = Shumway.AVM2.opcodeTable[bc];
                        var operands = null;
                        if (op) {
                            opCounter.count(op.name);
                            if (op.operands) {
                                operands = op.operands.map(readOperand);
                            }
                            switch (bc) {
                                case 65 /* call */:
                                case 67 /* callmethod */:
                                    continue;
                                case 70 /* callproperty */:
                                case 76 /* callproplex */:
                                case 79 /* callpropvoid */:
                                case 68 /* callstatic */:
                                case 69 /* callsuper */:
                                case 78 /* callsupervoid */:
                                    if (operands[0] && !(operands[0].name in definedMethods)) {
                                        libraryMethodCounter.count(operands[0].name);
                                    }
                                    break;
                                case 74 /* constructprop */:
                                    if (operands[0] && !(operands[0].name in definedClasses)) {
                                        libraryClassCounter.count(operands[0].name);
                                    }
                                    break;
                                case 102 /* getproperty */:
                                case 97 /* setproperty */:
                                    if (operands[0] && !(operands[0].name in definedProperties)) {
                                        libraryProperties.count(operands[0].name);
                                    }
                                    break;
                            }
                        }
                    }
                });
                writer.writeLn(JSON.stringify({
                    definedClasses: definedClasses,
                    definedMethods: definedMethods,
                    definedProperties: definedProperties,
                    libraryClasses: libraryClassCounter.counts,
                    librarySuperClasses: librarySuperClassCounter.counts,
                    libraryMethods: libraryMethodCounter.counts,
                    libraryProperties: libraryProperties.counts,
                    operations: opCounter.counts
                }, null, 2));
            }
        })(AVM2.ABC || (AVM2.ABC = {}));
        var ABC = AVM2.ABC;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        var assert = Shumway.Debug.assert;
        var unexpected = Shumway.Debug.unexpected;

        var AbcStream = Shumway.AVM2.ABC.AbcStream;

        var top = Shumway.ArrayUtilities.top;
        var peek = Shumway.ArrayUtilities.peek;

        (function (OP) {
            OP[OP["bkpt"] = 0x01] = "bkpt";
            OP[OP["nop"] = 0x02] = "nop";
            OP[OP["throw"] = 0x03] = "throw";
            OP[OP["getsuper"] = 0x04] = "getsuper";
            OP[OP["setsuper"] = 0x05] = "setsuper";
            OP[OP["dxns"] = 0x06] = "dxns";
            OP[OP["dxnslate"] = 0x07] = "dxnslate";
            OP[OP["kill"] = 0x08] = "kill";
            OP[OP["label"] = 0x09] = "label";
            OP[OP["lf32x4"] = 0x0A] = "lf32x4";
            OP[OP["sf32x4"] = 0x0B] = "sf32x4";
            OP[OP["ifnlt"] = 0x0C] = "ifnlt";
            OP[OP["ifnle"] = 0x0D] = "ifnle";
            OP[OP["ifngt"] = 0x0E] = "ifngt";
            OP[OP["ifnge"] = 0x0F] = "ifnge";
            OP[OP["jump"] = 0x10] = "jump";
            OP[OP["iftrue"] = 0x11] = "iftrue";
            OP[OP["iffalse"] = 0x12] = "iffalse";
            OP[OP["ifeq"] = 0x13] = "ifeq";
            OP[OP["ifne"] = 0x14] = "ifne";
            OP[OP["iflt"] = 0x15] = "iflt";
            OP[OP["ifle"] = 0x16] = "ifle";
            OP[OP["ifgt"] = 0x17] = "ifgt";
            OP[OP["ifge"] = 0x18] = "ifge";
            OP[OP["ifstricteq"] = 0x19] = "ifstricteq";
            OP[OP["ifstrictne"] = 0x1A] = "ifstrictne";
            OP[OP["lookupswitch"] = 0x1B] = "lookupswitch";
            OP[OP["pushwith"] = 0x1C] = "pushwith";
            OP[OP["popscope"] = 0x1D] = "popscope";
            OP[OP["nextname"] = 0x1E] = "nextname";
            OP[OP["hasnext"] = 0x1F] = "hasnext";
            OP[OP["pushnull"] = 0x20] = "pushnull";
            OP[OP["pushundefined"] = 0x21] = "pushundefined";
            OP[OP["pushfloat"] = 0x22] = "pushfloat";
            OP[OP["nextvalue"] = 0x23] = "nextvalue";
            OP[OP["pushbyte"] = 0x24] = "pushbyte";
            OP[OP["pushshort"] = 0x25] = "pushshort";
            OP[OP["pushtrue"] = 0x26] = "pushtrue";
            OP[OP["pushfalse"] = 0x27] = "pushfalse";
            OP[OP["pushnan"] = 0x28] = "pushnan";
            OP[OP["pop"] = 0x29] = "pop";
            OP[OP["dup"] = 0x2A] = "dup";
            OP[OP["swap"] = 0x2B] = "swap";
            OP[OP["pushstring"] = 0x2C] = "pushstring";
            OP[OP["pushint"] = 0x2D] = "pushint";
            OP[OP["pushuint"] = 0x2E] = "pushuint";
            OP[OP["pushdouble"] = 0x2F] = "pushdouble";
            OP[OP["pushscope"] = 0x30] = "pushscope";
            OP[OP["pushnamespace"] = 0x31] = "pushnamespace";
            OP[OP["hasnext2"] = 0x32] = "hasnext2";
            OP[OP["li8"] = 0x35] = "li8";
            OP[OP["li16"] = 0x36] = "li16";
            OP[OP["li32"] = 0x37] = "li32";
            OP[OP["lf32"] = 0x38] = "lf32";
            OP[OP["lf64"] = 0x39] = "lf64";
            OP[OP["si8"] = 0x3A] = "si8";
            OP[OP["si16"] = 0x3B] = "si16";
            OP[OP["si32"] = 0x3C] = "si32";
            OP[OP["sf32"] = 0x3D] = "sf32";
            OP[OP["sf64"] = 0x3E] = "sf64";
            OP[OP["newfunction"] = 0x40] = "newfunction";
            OP[OP["call"] = 0x41] = "call";
            OP[OP["construct"] = 0x42] = "construct";
            OP[OP["callmethod"] = 0x43] = "callmethod";
            OP[OP["callstatic"] = 0x44] = "callstatic";
            OP[OP["callsuper"] = 0x45] = "callsuper";
            OP[OP["callproperty"] = 0x46] = "callproperty";
            OP[OP["returnvoid"] = 0x47] = "returnvoid";
            OP[OP["returnvalue"] = 0x48] = "returnvalue";
            OP[OP["constructsuper"] = 0x49] = "constructsuper";
            OP[OP["constructprop"] = 0x4A] = "constructprop";
            OP[OP["callsuperid"] = 0x4B] = "callsuperid";
            OP[OP["callproplex"] = 0x4C] = "callproplex";
            OP[OP["callinterface"] = 0x4D] = "callinterface";
            OP[OP["callsupervoid"] = 0x4E] = "callsupervoid";
            OP[OP["callpropvoid"] = 0x4F] = "callpropvoid";
            OP[OP["sxi1"] = 0x50] = "sxi1";
            OP[OP["sxi8"] = 0x51] = "sxi8";
            OP[OP["sxi16"] = 0x52] = "sxi16";
            OP[OP["applytype"] = 0x53] = "applytype";
            OP[OP["pushfloat4"] = 0x54] = "pushfloat4";
            OP[OP["newobject"] = 0x55] = "newobject";
            OP[OP["newarray"] = 0x56] = "newarray";
            OP[OP["newactivation"] = 0x57] = "newactivation";
            OP[OP["newclass"] = 0x58] = "newclass";
            OP[OP["getdescendants"] = 0x59] = "getdescendants";
            OP[OP["newcatch"] = 0x5A] = "newcatch";
            OP[OP["findpropstrict"] = 0x5D] = "findpropstrict";
            OP[OP["findproperty"] = 0x5E] = "findproperty";
            OP[OP["finddef"] = 0x5F] = "finddef";
            OP[OP["getlex"] = 0x60] = "getlex";
            OP[OP["setproperty"] = 0x61] = "setproperty";
            OP[OP["getlocal"] = 0x62] = "getlocal";
            OP[OP["setlocal"] = 0x63] = "setlocal";
            OP[OP["getglobalscope"] = 0x64] = "getglobalscope";
            OP[OP["getscopeobject"] = 0x65] = "getscopeobject";
            OP[OP["getproperty"] = 0x66] = "getproperty";
            OP[OP["getouterscope"] = 0x67] = "getouterscope";
            OP[OP["initproperty"] = 0x68] = "initproperty";
            OP[OP["setpropertylate"] = 0x69] = "setpropertylate";
            OP[OP["deleteproperty"] = 0x6A] = "deleteproperty";
            OP[OP["deletepropertylate"] = 0x6B] = "deletepropertylate";
            OP[OP["getslot"] = 0x6C] = "getslot";
            OP[OP["setslot"] = 0x6D] = "setslot";
            OP[OP["getglobalslot"] = 0x6E] = "getglobalslot";
            OP[OP["setglobalslot"] = 0x6F] = "setglobalslot";
            OP[OP["convert_s"] = 0x70] = "convert_s";
            OP[OP["esc_xelem"] = 0x71] = "esc_xelem";
            OP[OP["esc_xattr"] = 0x72] = "esc_xattr";
            OP[OP["convert_i"] = 0x73] = "convert_i";
            OP[OP["convert_u"] = 0x74] = "convert_u";
            OP[OP["convert_d"] = 0x75] = "convert_d";
            OP[OP["convert_b"] = 0x76] = "convert_b";
            OP[OP["convert_o"] = 0x77] = "convert_o";
            OP[OP["checkfilter"] = 0x78] = "checkfilter";
            OP[OP["convert_f"] = 0x79] = "convert_f";
            OP[OP["unplus"] = 0x7a] = "unplus";
            OP[OP["convert_f4"] = 0x7b] = "convert_f4";
            OP[OP["coerce"] = 0x80] = "coerce";
            OP[OP["coerce_b"] = 0x81] = "coerce_b";
            OP[OP["coerce_a"] = 0x82] = "coerce_a";
            OP[OP["coerce_i"] = 0x83] = "coerce_i";
            OP[OP["coerce_d"] = 0x84] = "coerce_d";
            OP[OP["coerce_s"] = 0x85] = "coerce_s";
            OP[OP["astype"] = 0x86] = "astype";
            OP[OP["astypelate"] = 0x87] = "astypelate";
            OP[OP["coerce_u"] = 0x88] = "coerce_u";
            OP[OP["coerce_o"] = 0x89] = "coerce_o";
            OP[OP["negate"] = 0x90] = "negate";
            OP[OP["increment"] = 0x91] = "increment";
            OP[OP["inclocal"] = 0x92] = "inclocal";
            OP[OP["decrement"] = 0x93] = "decrement";
            OP[OP["declocal"] = 0x94] = "declocal";
            OP[OP["typeof"] = 0x95] = "typeof";
            OP[OP["not"] = 0x96] = "not";
            OP[OP["bitnot"] = 0x97] = "bitnot";
            OP[OP["add"] = 0xA0] = "add";
            OP[OP["subtract"] = 0xA1] = "subtract";
            OP[OP["multiply"] = 0xA2] = "multiply";
            OP[OP["divide"] = 0xA3] = "divide";
            OP[OP["modulo"] = 0xA4] = "modulo";
            OP[OP["lshift"] = 0xA5] = "lshift";
            OP[OP["rshift"] = 0xA6] = "rshift";
            OP[OP["urshift"] = 0xA7] = "urshift";
            OP[OP["bitand"] = 0xA8] = "bitand";
            OP[OP["bitor"] = 0xA9] = "bitor";
            OP[OP["bitxor"] = 0xAA] = "bitxor";
            OP[OP["equals"] = 0xAB] = "equals";
            OP[OP["strictequals"] = 0xAC] = "strictequals";
            OP[OP["lessthan"] = 0xAD] = "lessthan";
            OP[OP["lessequals"] = 0xAE] = "lessequals";
            OP[OP["greaterthan"] = 0xAF] = "greaterthan";
            OP[OP["greaterequals"] = 0xB0] = "greaterequals";
            OP[OP["instanceof"] = 0xB1] = "instanceof";
            OP[OP["istype"] = 0xB2] = "istype";
            OP[OP["istypelate"] = 0xB3] = "istypelate";
            OP[OP["in"] = 0xB4] = "in";
            OP[OP["increment_i"] = 0xC0] = "increment_i";
            OP[OP["decrement_i"] = 0xC1] = "decrement_i";
            OP[OP["inclocal_i"] = 0xC2] = "inclocal_i";
            OP[OP["declocal_i"] = 0xC3] = "declocal_i";
            OP[OP["negate_i"] = 0xC4] = "negate_i";
            OP[OP["add_i"] = 0xC5] = "add_i";
            OP[OP["subtract_i"] = 0xC6] = "subtract_i";
            OP[OP["multiply_i"] = 0xC7] = "multiply_i";
            OP[OP["getlocal0"] = 0xD0] = "getlocal0";
            OP[OP["getlocal1"] = 0xD1] = "getlocal1";
            OP[OP["getlocal2"] = 0xD2] = "getlocal2";
            OP[OP["getlocal3"] = 0xD3] = "getlocal3";
            OP[OP["setlocal0"] = 0xD4] = "setlocal0";
            OP[OP["setlocal1"] = 0xD5] = "setlocal1";
            OP[OP["setlocal2"] = 0xD6] = "setlocal2";
            OP[OP["setlocal3"] = 0xD7] = "setlocal3";
            OP[OP["invalid"] = 0xED] = "invalid";
            OP[OP["debug"] = 0xEF] = "debug";
            OP[OP["debugline"] = 0xF0] = "debugline";
            OP[OP["debugfile"] = 0xF1] = "debugfile";
            OP[OP["bkptline"] = 0xF2] = "bkptline";
            OP[OP["timestamp"] = 0xF3] = "timestamp";
        })(AVM2.OP || (AVM2.OP = {}));
        var OP = AVM2.OP;

        /**
        * Provides a definition of AVM2 Bytecodes.
        *
        * Type (size) Prefix:
        *
        *   u08 - a one-byte unsigned integer
        *   s08 - a one-byte signed integer
        *   s24 - a three byte signed integer
        *   s16 - a variable-length encoded 30-bit unsigned integer value that is casted to a short value
        *   u30 - a variable-length encoded 30-bit unsigned integer value
        *
        * Type (semantic) Suffix:
        *
        *     I - an index into the integer constant pool
        *     U - an index into the unsigned integer constant pool
        *     D - an index into the doubles constant pool
        *     S - an index into the string constant pool
        *     N - an index into the namespace constant pool
        *     M - an index into the multiname constant pool
        *    CI - an index into the class info list
        *    EI - an index into the exception info list
        *    MI - an index into the method info list
        */
        AVM2.opcodeTable = [
            null,
            { name: "bkpt", canThrow: false, operands: [] },
            { name: "nop", canThrow: false, operands: [] },
            { name: "throw", canThrow: true, operands: [] },
            { name: "getsuper", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "setsuper", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "dxns", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "dxnslate", canThrow: true, operands: [] },
            { name: "kill", canThrow: false, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "label", canThrow: false, operands: [] },
            { name: "lf32x4", canThrow: true, operands: [] },
            { name: "sf32x4", canThrow: true, operands: [] },
            { name: "ifnlt", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifnle", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifngt", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifnge", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "jump", canThrow: false, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "iftrue", canThrow: false, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "iffalse", canThrow: false, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifeq", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifne", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "iflt", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifle", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifgt", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifge", canThrow: true, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifstricteq", canThrow: false, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "ifstrictne", canThrow: false, operands: [{ name: "offset", size: "s24", type: "" }] },
            { name: "lookupswitch", canThrow: false, operands: null },
            { name: "pushwith", canThrow: false, operands: [] },
            { name: "popscope", canThrow: false, operands: [] },
            { name: "nextname", canThrow: true, operands: [] },
            { name: "hasnext", canThrow: true, operands: [] },
            { name: "pushnull", canThrow: false, operands: [] },
            { name: "pushundefined", canThrow: false, operands: [] },
            null,
            { name: "nextvalue", canThrow: true, operands: [] },
            { name: "pushbyte", canThrow: false, operands: [{ name: "value", size: "s08", type: "" }] },
            { name: "pushshort", canThrow: false, operands: [{ name: "value", size: "s16", type: "" }] },
            { name: "pushtrue", canThrow: false, operands: [] },
            { name: "pushfalse", canThrow: false, operands: [] },
            { name: "pushnan", canThrow: false, operands: [] },
            { name: "pop", canThrow: false, operands: [] },
            { name: "dup", canThrow: false, operands: [] },
            { name: "swap", canThrow: false, operands: [] },
            { name: "pushstring", canThrow: false, operands: [{ name: "index", size: "u30", type: "S" }] },
            { name: "pushint", canThrow: false, operands: [{ name: "index", size: "u30", type: "I" }] },
            { name: "pushuint", canThrow: false, operands: [{ name: "index", size: "u30", type: "U" }] },
            { name: "pushdouble", canThrow: false, operands: [{ name: "index", size: "u30", type: "D" }] },
            { name: "pushscope", canThrow: false, operands: [] },
            { name: "pushnamespace", canThrow: false, operands: [{ name: "index", size: "u30", type: "N" }] },
            { name: "hasnext2", canThrow: true, operands: [{ name: "object", size: "u30", type: "" }, { name: "index", size: "u30", type: "" }] },
            { name: "lix8", canThrow: true, operands: null },
            { name: "lix16", canThrow: true, operands: null },
            { name: "li8", canThrow: true, operands: [] },
            { name: "li16", canThrow: true, operands: [] },
            { name: "li32", canThrow: true, operands: [] },
            { name: "lf32", canThrow: true, operands: [] },
            { name: "lf64", canThrow: true, operands: [] },
            { name: "si8", canThrow: true, operands: [] },
            { name: "si16", canThrow: true, operands: [] },
            { name: "si32", canThrow: true, operands: [] },
            { name: "sf32", canThrow: true, operands: [] },
            { name: "sf64", canThrow: true, operands: [] },
            null,
            { name: "newfunction", canThrow: true, operands: [{ name: "index", size: "u30", type: "MI" }] },
            { name: "call", canThrow: true, operands: [{ name: "argCount", size: "u30", type: "" }] },
            { name: "construct", canThrow: true, operands: [{ name: "argCount", size: "u30", type: "" }] },
            { name: "callmethod", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "callstatic", canThrow: true, operands: [{ name: "index", size: "u30", type: "MI" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "callsuper", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "callproperty", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "returnvoid", canThrow: false, operands: [] },
            { name: "returnvalue", canThrow: true, operands: [] },
            { name: "constructsuper", canThrow: true, operands: [{ name: "argCount", size: "u30", type: "" }] },
            { name: "constructprop", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "callsuperid", canThrow: true, operands: null },
            { name: "callproplex", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "callinterface", canThrow: true, operands: null },
            { name: "callsupervoid", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "callpropvoid", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }, { name: "argCount", size: "u30", type: "" }] },
            { name: "sxi1", canThrow: false, operands: [] },
            { name: "sxi8", canThrow: false, operands: [] },
            { name: "sxi16", canThrow: false, operands: [] },
            { name: "applytype", canThrow: true, operands: [{ name: "argCount", size: "u30", type: "" }] },
            { name: "pushfloat4", canThrow: false, operands: null },
            { name: "newobject", canThrow: true, operands: [{ name: "argCount", size: "u30", type: "" }] },
            { name: "newarray", canThrow: true, operands: [{ name: "argCount", size: "u30", type: "" }] },
            { name: "newactivation", canThrow: true, operands: [] },
            { name: "newclass", canThrow: true, operands: [{ name: "index", size: "u30", type: "CI" }] },
            { name: "getdescendants", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "newcatch", canThrow: true, operands: [{ name: "index", size: "u30", type: "EI" }] },
            { name: "findpropglobalstrict", canThrow: true, operands: null },
            { name: "findpropglobal", canThrow: true, operands: null },
            { name: "findpropstrict", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "findproperty", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "finddef", canThrow: true, operands: null },
            { name: "getlex", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "setproperty", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "getlocal", canThrow: false, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "setlocal", canThrow: false, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "getglobalscope", canThrow: false, operands: [] },
            { name: "getscopeobject", canThrow: false, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "getproperty", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "getouterscope", canThrow: false, operands: null },
            { name: "initproperty", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            null,
            { name: "deleteproperty", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            null,
            { name: "getslot", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "setslot", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "getglobalslot", canThrow: false, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "setglobalslot", canThrow: false, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "convert_s", canThrow: true, operands: [] },
            { name: "esc_xelem", canThrow: true, operands: [] },
            { name: "esc_xattr", canThrow: true, operands: [] },
            { name: "convert_i", canThrow: true, operands: [] },
            { name: "convert_u", canThrow: true, operands: [] },
            { name: "convert_d", canThrow: true, operands: [] },
            { name: "convert_b", canThrow: true, operands: [] },
            { name: "convert_o", canThrow: true, operands: [] },
            { name: "checkfilter", canThrow: true, operands: [] },
            { name: "convert_f", canThrow: true, operands: [] },
            { name: "unplus", canThrow: true, operands: [] },
            { name: "convert_f4", canThrow: true, operands: [] },
            null,
            null,
            null,
            null,
            { name: "coerce", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "coerce_b", canThrow: true, operands: [] },
            { name: "coerce_a", canThrow: true, operands: [] },
            { name: "coerce_i", canThrow: true, operands: [] },
            { name: "coerce_d", canThrow: true, operands: [] },
            { name: "coerce_s", canThrow: true, operands: [] },
            { name: "astype", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "astypelate", canThrow: true, operands: [] },
            { name: "coerce_u", canThrow: true, operands: [] },
            { name: "coerce_o", canThrow: true, operands: [] },
            null,
            null,
            null,
            null,
            null,
            null,
            { name: "negate", canThrow: true, operands: [] },
            { name: "increment", canThrow: true, operands: [] },
            { name: "inclocal", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "decrement", canThrow: true, operands: [] },
            { name: "declocal", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "typeof", canThrow: false, operands: [] },
            { name: "not", canThrow: false, operands: [] },
            { name: "bitnot", canThrow: true, operands: [] },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            { name: "add", canThrow: true, operands: [] },
            { name: "subtract", canThrow: true, operands: [] },
            { name: "multiply", canThrow: true, operands: [] },
            { name: "divide", canThrow: true, operands: [] },
            { name: "modulo", canThrow: true, operands: [] },
            { name: "lshift", canThrow: true, operands: [] },
            { name: "rshift", canThrow: true, operands: [] },
            { name: "urshift", canThrow: true, operands: [] },
            { name: "bitand", canThrow: true, operands: [] },
            { name: "bitor", canThrow: true, operands: [] },
            { name: "bitxor", canThrow: true, operands: [] },
            { name: "equals", canThrow: true, operands: [] },
            { name: "strictequals", canThrow: true, operands: [] },
            { name: "lessthan", canThrow: true, operands: [] },
            { name: "lessequals", canThrow: true, operands: [] },
            { name: "greaterthan", canThrow: true, operands: [] },
            { name: "greaterequals", canThrow: true, operands: [] },
            { name: "instanceof", canThrow: true, operands: [] },
            { name: "istype", canThrow: true, operands: [{ name: "index", size: "u30", type: "M" }] },
            { name: "istypelate", canThrow: true, operands: [] },
            { name: "in", canThrow: true, operands: [] },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            { name: "increment_i", canThrow: true, operands: [] },
            { name: "decrement_i", canThrow: true, operands: [] },
            { name: "inclocal_i", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "declocal_i", canThrow: true, operands: [{ name: "index", size: "u30", type: "" }] },
            { name: "negate_i", canThrow: true, operands: [] },
            { name: "add_i", canThrow: true, operands: [] },
            { name: "subtract_i", canThrow: true, operands: [] },
            { name: "multiply_i", canThrow: true, operands: [] },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            { name: "getlocal0", canThrow: false, operands: [] },
            { name: "getlocal1", canThrow: false, operands: [] },
            { name: "getlocal2", canThrow: false, operands: [] },
            { name: "getlocal3", canThrow: false, operands: [] },
            { name: "setlocal0", canThrow: false, operands: [] },
            { name: "setlocal1", canThrow: false, operands: [] },
            { name: "setlocal2", canThrow: false, operands: [] },
            { name: "setlocal3", canThrow: false, operands: [] },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            { name: "invalid", canThrow: false, operands: [] },
            null,
            { name: "debug", canThrow: true, operands: [{ name: "debugType", size: "u08", type: "" }, { name: "index", size: "u30", type: "S" }, { name: "reg", size: "u08", type: "" }, { name: "extra", size: "u30", type: "" }] },
            { name: "debugline", canThrow: true, operands: [{ name: "lineNumber", size: "u30", type: "" }] },
            { name: "debugfile", canThrow: true, operands: [{ name: "index", size: "u30", type: "S" }] },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null
        ];

        function opcodeName(op) {
            return AVM2.opcodeTable[op].name;
        }
        AVM2.opcodeName = opcodeName;

        /**
        * A normalized AS3 bytecode, or BasicBlock.
        */
        var Bytecode = (function () {
            function Bytecode(code) {
                var op = code.readU8();
                this.op = op;
                this.originalPosition = code.position;

                var opdesc = Shumway.AVM2.opcodeTable[op];
                if (!opdesc) {
                    unexpected("Unknown Op " + op);
                }

                this.canThrow = opdesc.canThrow;

                var i, n;

                switch (op) {
                    case 27 /* lookupswitch */:
                        var defaultOffset = code.readS24();
                        this.offsets = [];
                        var n = code.readU30() + 1;
                        for (i = 0; i < n; i++) {
                            this.offsets.push(code.readS24());
                        }
                        this.offsets.push(defaultOffset);
                        break;
                    default:
                        for (i = 0, n = opdesc.operands.length; i < n; i++) {
                            var operand = opdesc.operands[i];

                            switch (operand.size) {
                                case "u08":
                                    this[operand.name] = code.readU8();
                                    break;
                                case "s08":
                                    this[operand.name] = code.readS8();
                                    break;
                                case "s16":
                                    this[operand.name] = code.readS16();
                                    break;
                                case "s24":
                                    this[operand.name] = code.readS24();
                                    break;
                                case "u30":
                                    this[operand.name] = code.readU30();
                                    break;
                                case "u32":
                                    this[operand.name] = code.readU32();
                                    break;
                                default:
                                    unexpected();
                            }
                        }
                }
            }
            Bytecode.prototype.makeBlockHead = function (id) {
                if (this.succs) {
                    return id;
                }

                this.bid = id;

                // CFG edges.
                this.succs = [];
                this.preds = [];

                // Dominance relation edges.
                this.dominatees = [];

                return id + 1;
            };

            Bytecode.prototype.trace = function (writer) {
                if (!this.succs) {
                    return;
                }

                writer.writeLn("#" + this.bid);
            };

            Bytecode.prototype.toString = function (abc) {
                var opDescription = Shumway.AVM2.opcodeTable[this.op];
                var str = opDescription.name.padRight(' ', 20);
                var i, j;

                if (this.op === 27 /* lookupswitch */) {
                    str += "targets:";
                    for (i = 0, j = this.targets.length; i < j; i++) {
                        str += (i > 0 ? "," : "") + this.targets[i].position;
                    }
                } else {
                    for (i = 0, j = opDescription.operands.length; i < j; i++) {
                        var operand = opDescription.operands[i];
                        if (operand.name === "offset") {
                            str += "target:" + this.target.position;
                        } else {
                            str += operand.name + ": ";
                            var value = this[operand.name];
                            if (abc) {
                                switch (operand.type) {
                                    case "":
                                        str += value;
                                        break;
                                    case "I":
                                        str += abc.constantPool.ints[value];
                                        break;
                                    case "U":
                                        str += abc.constantPool.uints[value];
                                        break;
                                    case "D":
                                        str += abc.constantPool.doubles[value];
                                        break;
                                    case "S":
                                        str += abc.constantPool.strings[value];
                                        break;
                                    case "N":
                                        str += abc.constantPool.namespaces[value];
                                        break;
                                    case "CI":
                                        str += abc.classes[value];
                                        break;
                                    case "M":
                                        str += abc.constantPool.multinames[value];
                                        break;
                                    default:
                                        str += "?";
                                        break;
                                }
                            } else {
                                str += value;
                            }
                        }

                        if (i < j - 1) {
                            str += ", ";
                        }
                    }
                }

                return str;
            };
            return Bytecode;
        })();
        AVM2.Bytecode = Bytecode;

        var BITS_PER_WORD = Shumway.BitSets.BITS_PER_WORD;
        var ADDRESS_BITS_PER_WORD = Shumway.BitSets.ADDRESS_BITS_PER_WORD;
        var BIT_INDEX_MASK = Shumway.BitSets.BIT_INDEX_MASK;

        var BlockSet = (function (_super) {
            __extends(BlockSet, _super);
            function BlockSet(length, blockById) {
                _super.call(this, length);
                this.blockById = blockById;
            }
            BlockSet.prototype.forEachBlock = function (fn) {
                release || assert(fn);
                var byId = this.blockById;
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var word = bits[i];
                    if (word) {
                        for (var k = 0; k < BITS_PER_WORD; k++) {
                            if (word & (1 << k)) {
                                fn(byId[i * BITS_PER_WORD + k]);
                            }
                        }
                    }
                }
            };

            BlockSet.prototype.choose = function () {
                var byId = this.blockById;
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var word = bits[i];
                    if (word) {
                        for (var k = 0; k < BITS_PER_WORD; k++) {
                            if (word & (1 << k)) {
                                return byId[i * BITS_PER_WORD + k];
                            }
                        }
                    }
                }
            };

            BlockSet.prototype.members = function () {
                var byId = this.blockById;
                var set = [];
                var bits = this.bits;
                for (var i = 0, j = bits.length; i < j; i++) {
                    var word = bits[i];
                    if (word) {
                        for (var k = 0; k < BITS_PER_WORD; k++) {
                            if (word & (1 << k)) {
                                set.push(byId[i * BITS_PER_WORD + k]);
                            }
                        }
                    }
                }
                return set;
            };

            BlockSet.prototype.setBlocks = function (bs) {
                var bits = this.bits;
                for (var i = 0, j = bs.length; i < j; i++) {
                    var id = bs[i].bid;
                    bits[id >> ADDRESS_BITS_PER_WORD] |= 1 << (id & BIT_INDEX_MASK);
                }
            };
            return BlockSet;
        })(Shumway.BitSets.Uint32ArrayBitSet);
        AVM2.BlockSet = BlockSet;

        var Analysis = (function () {
            function Analysis(methodInfo) {
                this.methodInfo = methodInfo;
                if (this.methodInfo.code) {
                    AVM2.enterTimeline("normalizeBytecode");
                    this.normalizeBytecode();
                    AVM2.leaveTimeline();
                }
            }
            Analysis.prototype.makeBlockSetFactory = function (length, blockById) {
                release || assert(!this.boundBlockSet);
                this.boundBlockSet = (function blockSet() {
                    return new Shumway.AVM2.BlockSet(length, blockById);
                });
            };

            /**
            * Marks the parameter as used if it's ever accessed via getLocal.
            */
            Analysis.prototype.accessLocal = function (index) {
                if (index-- === 0)
                    return;
                if (index < this.methodInfo.parameters.length) {
                    this.methodInfo.parameters[index].isUsed = true;
                }
            };

            /**
            * Internal bytecode used for bogus jumps. They should be emitted as throws
            * so that if control flow ever reaches them, we crash.
            */
            Analysis.prototype.getInvalidTarget = function (cache, offset) {
                if (cache && cache[offset]) {
                    return cache[offset];
                }

                var code = Object.create(Bytecode.prototype);
                code.op = 237 /* invalid */;
                code.position = offset;
                cache && (cache[offset] = code);
                return code;
            };

            Analysis.prototype.normalizeBytecode = function () {
                var methodInfo = this.methodInfo;

                // This array is sparse, indexed by offset.
                var bytecodesOffset = [];

                // This array is dense.
                var bytecodes = [];
                var codeStream = new AbcStream(this.methodInfo.code);
                var bytecode;

                while (codeStream.remaining() > 0) {
                    var pos = codeStream.position;
                    bytecode = new Bytecode(codeStream);

                    switch (bytecode.op) {
                        case 2 /* nop */:
                        case 9 /* label */:
                            bytecodesOffset[pos] = bytecodes.length;
                            continue;

                        case 27 /* lookupswitch */:
                            this.methodInfo.hasLookupSwitches = true;
                            bytecode.targets = [];
                            var offsets = bytecode.offsets;
                            for (var i = 0, j = offsets.length; i < j; i++) {
                                offsets[i] += pos;
                            }
                            break;

                        case 16 /* jump */:
                        case 21 /* iflt */:
                        case 12 /* ifnlt */:
                        case 22 /* ifle */:
                        case 13 /* ifnle */:
                        case 23 /* ifgt */:
                        case 14 /* ifngt */:
                        case 24 /* ifge */:
                        case 15 /* ifnge */:
                        case 19 /* ifeq */:
                        case 20 /* ifne */:
                        case 25 /* ifstricteq */:
                        case 26 /* ifstrictne */:
                        case 17 /* iftrue */:
                        case 18 /* iffalse */:
                            bytecode.offset += codeStream.position;
                            break;
                        case 208 /* getlocal0 */:
                        case 209 /* getlocal1 */:
                        case 210 /* getlocal2 */:
                        case 211 /* getlocal3 */:
                            this.accessLocal(bytecode.op - 208 /* getlocal0 */);
                            break;
                        case 98 /* getlocal */:
                            this.accessLocal(bytecode.index);
                            break;
                        default:
                            break;
                    }

                    // Cache the position in the bytecode array.
                    bytecode.position = bytecodes.length;
                    bytecodesOffset[pos] = bytecodes.length;
                    bytecodes.push(bytecode);
                }

                var invalidJumps = {};
                var newOffset;
                for (var pc = 0, end = bytecodes.length; pc < end; pc++) {
                    bytecode = bytecodes[pc];
                    switch (bytecode.op) {
                        case 27 /* lookupswitch */:
                            var offsets = bytecode.offsets;
                            for (var i = 0, j = offsets.length; i < j; i++) {
                                newOffset = bytecodesOffset[offsets[i]];
                                bytecode.targets.push(bytecodes[newOffset] || this.getInvalidTarget(invalidJumps, offsets[i]));
                                offsets[i] = newOffset;
                            }
                            break;

                        case 16 /* jump */:
                        case 21 /* iflt */:
                        case 12 /* ifnlt */:
                        case 22 /* ifle */:
                        case 13 /* ifnle */:
                        case 23 /* ifgt */:
                        case 14 /* ifngt */:
                        case 24 /* ifge */:
                        case 15 /* ifnge */:
                        case 19 /* ifeq */:
                        case 20 /* ifne */:
                        case 25 /* ifstricteq */:
                        case 26 /* ifstrictne */:
                        case 17 /* iftrue */:
                        case 18 /* iffalse */:
                            newOffset = bytecodesOffset[bytecode.offset];
                            bytecode.target = (bytecodes[newOffset] || this.getInvalidTarget(invalidJumps, bytecode.offset));
                            bytecode.offset = newOffset;
                            break;
                        default:
                    }
                }

                this.bytecodes = bytecodes;

                // Normalize exceptions table to use new offsets.
                var exceptions = this.methodInfo.exceptions;
                for (var i = 0, j = exceptions.length; i < j; i++) {
                    var ex = exceptions[i];
                    ex.start = bytecodesOffset[ex.start];
                    ex.end = bytecodesOffset[ex.end];
                    ex.offset = bytecodesOffset[ex.target];
                    ex.target = bytecodes[ex.offset];
                    ex.target.exception = ex;
                }
            };

            Analysis.prototype.analyzeControlFlow = function () {
                release || assert(this.bytecodes);
                AVM2.enterTimeline("analyzeControlFlow");
                this.detectBasicBlocks();
                this.normalizeReachableBlocks();
                this.computeDominance();
                this.analyzedControlFlow = true;
                AVM2.leaveTimeline();
                return true;
            };

            Analysis.prototype.detectBasicBlocks = function () {
                var bytecodes = this.bytecodes;
                var exceptions = this.methodInfo.exceptions;
                var hasExceptions = exceptions.length > 0;
                var blockById = {};
                var code;
                var pc, end;
                var id = 0;

                function tryTargets(block) {
                    var targets = [];
                    for (var i = 0, j = exceptions.length; i < j; i++) {
                        var ex = exceptions[i];
                        if (block.position >= ex.start && block.end.position <= ex.end) {
                            targets.push(ex.target);
                        }
                    }
                    return targets;
                }

                id = bytecodes[0].makeBlockHead(id);
                for (pc = 0, end = bytecodes.length - 1; pc < end; pc++) {
                    code = bytecodes[pc];
                    switch (code.op) {
                        case 71 /* returnvoid */:
                        case 72 /* returnvalue */:
                        case 3 /* throw */:
                            id = bytecodes[pc + 1].makeBlockHead(id);
                            break;

                        case 27 /* lookupswitch */:
                            var targets = code.targets;
                            for (var i = 0, j = targets.length; i < j; i++) {
                                id = targets[i].makeBlockHead(id);
                            }
                            id = bytecodes[pc + 1].makeBlockHead(id);
                            break;

                        case 16 /* jump */:
                        case 21 /* iflt */:
                        case 12 /* ifnlt */:
                        case 22 /* ifle */:
                        case 13 /* ifnle */:
                        case 23 /* ifgt */:
                        case 14 /* ifngt */:
                        case 24 /* ifge */:
                        case 15 /* ifnge */:
                        case 19 /* ifeq */:
                        case 20 /* ifne */:
                        case 25 /* ifstricteq */:
                        case 26 /* ifstrictne */:
                        case 17 /* iftrue */:
                        case 18 /* iffalse */:
                            id = code.target.makeBlockHead(id);
                            id = bytecodes[pc + 1].makeBlockHead(id);
                            break;

                        default:
                    }
                }

                code = bytecodes[end];
                switch (code.op) {
                    case 71 /* returnvoid */:
                    case 72 /* returnvalue */:
                    case 3 /* throw */:
                        break;

                    case 27 /* lookupswitch */:
                        var targets = code.targets;
                        for (var i = 0, j = targets.length; i < j; i++) {
                            id = targets[i].makeBlockHead(id);
                        }
                        break;

                    case 16 /* jump */:
                        id = code.target.makeBlockHead(id);
                        break;

                    case 21 /* iflt */:
                    case 12 /* ifnlt */:
                    case 22 /* ifle */:
                    case 13 /* ifnle */:
                    case 23 /* ifgt */:
                    case 14 /* ifngt */:
                    case 24 /* ifge */:
                    case 15 /* ifnge */:
                    case 19 /* ifeq */:
                    case 20 /* ifne */:
                    case 25 /* ifstricteq */:
                    case 26 /* ifstrictne */:
                    case 17 /* iftrue */:
                    case 18 /* iffalse */:
                        id = code.target.makeBlockHead(id);
                        bytecodes[pc + 1] = this.getInvalidTarget(null, pc + 1);
                        id = bytecodes[pc + 1].makeBlockHead(id);
                        break;

                    default:
                }

                // Mark exceptions.
                if (hasExceptions) {
                    for (var i = 0; i < exceptions.length; i++) {
                        var ex = exceptions[i];
                        var tryStart = bytecodes[ex.start];
                        var afterTry = bytecodes[ex.end + 1];

                        id = tryStart.makeBlockHead(id);
                        if (afterTry) {
                            id = afterTry.makeBlockHead(id);
                        }
                        id = ex.target.makeBlockHead(id);
                    }
                }

                var currentBlock = bytecodes[0];
                for (pc = 1, end = bytecodes.length; pc < end; pc++) {
                    if (!bytecodes[pc].succs) {
                        continue;
                    }

                    release || assert(currentBlock.succs);

                    blockById[currentBlock.bid] = currentBlock;
                    code = bytecodes[pc - 1];
                    currentBlock.end = code;
                    var nextBlock = bytecodes[pc];

                    switch (code.op) {
                        case 71 /* returnvoid */:
                        case 72 /* returnvalue */:
                        case 3 /* throw */:
                            break;

                        case 27 /* lookupswitch */:
                            for (var i = 0, j = code.targets.length; i < j; i++) {
                                currentBlock.succs.push(code.targets[i]);
                            }
                            break;

                        case 16 /* jump */:
                            currentBlock.succs.push(code.target);
                            break;

                        case 21 /* iflt */:
                        case 12 /* ifnlt */:
                        case 22 /* ifle */:
                        case 13 /* ifnle */:
                        case 23 /* ifgt */:
                        case 14 /* ifngt */:
                        case 24 /* ifge */:
                        case 15 /* ifnge */:
                        case 19 /* ifeq */:
                        case 20 /* ifne */:
                        case 25 /* ifstricteq */:
                        case 26 /* ifstrictne */:
                        case 17 /* iftrue */:
                        case 18 /* iffalse */:
                            currentBlock.succs.push(code.target);
                            if (code.target !== nextBlock) {
                                currentBlock.succs.push(nextBlock);
                            }
                            break;

                        default:
                            currentBlock.succs.push(nextBlock);
                    }

                    if (hasExceptions) {
                        var targets = tryTargets(currentBlock);
                        currentBlock.hasCatches = targets.length > 0;
                        currentBlock.succs.push.apply(currentBlock.succs, targets);
                    }

                    currentBlock = nextBlock;
                }
                blockById[currentBlock.bid] = currentBlock;

                code = bytecodes[end - 1];
                switch (code.op) {
                    case 27 /* lookupswitch */:
                        for (var i = 0, j = code.targets.length; i < j; i++) {
                            currentBlock.succs.push(code.targets[i]);
                        }
                        break;

                    case 16 /* jump */:
                        currentBlock.succs.push(code.target);
                        break;

                    default:
                }
                currentBlock.end = code;

                this.makeBlockSetFactory(id, blockById);
            };

            Analysis.prototype.normalizeReachableBlocks = function () {
                var root = this.bytecodes[0];

                // The root must not have preds!
                release || assert(root.preds.length === 0);

                var ONCE = 1;
                var BUNCH_OF_TIMES = 2;

                var blocks = [];
                var visited = {};
                var ancestors = {};
                var worklist = [root];
                var node;

                ancestors[root.bid] = true;
                while ((node = top(worklist))) {
                    if (visited[node.bid]) {
                        if (visited[node.bid] === ONCE) {
                            visited[node.bid] = BUNCH_OF_TIMES;
                            blocks.push(node);

                            // Doubly link reachable blocks.
                            var succs = node.succs;
                            for (var i = 0, j = succs.length; i < j; i++) {
                                succs[i].preds.push(node);
                            }
                        }

                        ancestors[node.bid] = false;
                        worklist.pop();
                        continue;
                    }

                    visited[node.bid] = ONCE;
                    ancestors[node.bid] = true;

                    var succs = node.succs;
                    for (var i = 0, j = succs.length; i < j; i++) {
                        var s = succs[i];

                        if (ancestors[s.bid]) {
                            if (!node.spbacks) {
                                node.spbacks = new this.boundBlockSet();
                            }
                            node.spbacks.set(s.bid);
                        }
                        !visited[s.bid] && worklist.push(s);
                    }
                }

                this.blocks = blocks.reverse();
            };

            /**
            * Calculate the dominance relation iteratively.
            * Algorithm is from [1].
            * [1] Cooper et al. "A Simple, Fast Dominance Algorithm"
            */
            Analysis.prototype.computeDominance = function () {
                function intersectDominators(doms, b1, b2) {
                    var finger1 = b1;
                    var finger2 = b2;
                    while (finger1 !== finger2) {
                        while (finger1 > finger2) {
                            finger1 = doms[finger1];
                        }
                        while (finger2 > finger1) {
                            finger2 = doms[finger2];
                        }
                    }
                    return finger1;
                }

                var blocks = this.blocks;
                var n = blocks.length;
                var doms = new Array(n);
                doms[0] = 0;

                // Blocks must be given to us in reverse postorder.
                var rpo = {};
                for (var b = 0; b < n; b++) {
                    rpo[blocks[b].bid] = b;
                }

                var changed = true;
                while (changed) {
                    changed = false;

                    for (var b = 1; b < n; b++) {
                        var preds = blocks[b].preds;
                        var j = preds.length;

                        var newIdom = rpo[preds[0].bid];

                        // Because 0 is falsy, have to use |in| here.
                        if (!(newIdom in doms)) {
                            for (var i = 1; i < j; i++) {
                                newIdom = rpo[preds[i].bid];
                                if (newIdom in doms) {
                                    break;
                                }
                            }
                        }
                        release || assert(newIdom in doms);

                        for (var i = 0; i < j; i++) {
                            var p = rpo[preds[i].bid];
                            if (p === newIdom) {
                                continue;
                            }

                            if (p in doms) {
                                newIdom = intersectDominators(doms, p, newIdom);
                            }
                        }

                        if (doms[b] !== newIdom) {
                            doms[b] = newIdom;
                            changed = true;
                        }
                    }
                }

                blocks[0].dominator = blocks[0];
                var block;
                for (var b = 1; b < n; b++) {
                    block = blocks[b];
                    var idom = blocks[doms[b]];

                    // Store the immediate dominator.
                    block.dominator = idom;
                    idom.dominatees.push(block);

                    block.npreds = block.preds.length;
                }

                // Assign dominator tree levels.
                var worklist = [blocks[0]];
                blocks[0].level || (blocks[0].level = 0);
                while ((block = worklist.shift())) {
                    var dominatees = block.dominatees;
                    for (var i = 0; i < dominatees.length; i++) {
                        dominatees[i].level = block.level + 1;
                    }
                    worklist.push.apply(worklist, dominatees);
                }
            };

            Analysis.prototype.markLoops = function () {
                if (!this.analyzedControlFlow && !this.analyzeControlFlow()) {
                    return false;
                }

                var bytecodes = this.bytecodes;

                var BoundBlockSet = this.boundBlockSet;

                //
                // Find all SCCs at or below the level of some root that are not already
                // natural loops.
                //
                function findSCCs(root) {
                    var preorderId = 1;
                    var preorder = {};
                    var assigned = {};
                    var unconnectedNodes = [];
                    var pendingNodes = [];
                    var sccs = [];
                    var level = root.level + 1;
                    var worklist = [root];
                    var node;
                    var u, s;

                    while ((node = top(worklist))) {
                        if (preorder[node.bid]) {
                            if (peek(pendingNodes) === node) {
                                pendingNodes.pop();

                                var scc = [];
                                do {
                                    u = unconnectedNodes.pop();
                                    assigned[u.bid] = true;
                                    scc.push(u);
                                } while(u !== node);

                                if (scc.length > 1 || (u.spbacks && u.spbacks.get(u.bid))) {
                                    sccs.push(scc);
                                }
                            }

                            worklist.pop();
                            continue;
                        }

                        preorder[node.bid] = preorderId++;
                        unconnectedNodes.push(node);
                        pendingNodes.push(node);

                        var succs = node.succs;
                        for (var i = 0, j = succs.length; i < j; i++) {
                            s = succs[i];
                            if (s.level < level) {
                                continue;
                            }

                            var sid = s.bid;
                            if (!preorder[sid]) {
                                worklist.push(s);
                            } else if (!assigned[sid]) {
                                while (preorder[peek(pendingNodes).bid] > preorder[sid]) {
                                    pendingNodes.pop();
                                }
                            }
                        }
                    }

                    return sccs;
                }

                function findLoopHeads(blocks) {
                    var heads = new BoundBlockSet();

                    for (var i = 0, j = blocks.length; i < j; i++) {
                        var block = blocks[i];
                        var spbacks = block.spbacks;

                        if (!spbacks) {
                            continue;
                        }

                        var succs = block.succs;
                        for (var k = 0, l = succs.length; k < l; k++) {
                            var s = succs[k];
                            if (spbacks.get(s.bid)) {
                                heads.set(s.dominator.bid);
                            }
                        }
                    }

                    return heads.members();
                }

                function LoopInfo(scc, loopId) {
                    var body = new BoundBlockSet();
                    body.setBlocks(scc);
                    body.recount();

                    this.id = loopId;
                    this.body = body;
                    this.exit = new BoundBlockSet();
                    this.save = {};
                    this.head = new BoundBlockSet();
                    this.npreds = 0;
                    this._dirtyLocals = null;
                }

                LoopInfo.prototype.getDirtyLocals = function () {
                    if (this._dirtyLocals) {
                        return this._dirtyLocals;
                    }
                    var dirtyLocals = this._dirtyLocals = [];
                    var blocks = this.body.members();
                    blocks.forEach(function (block) {
                        for (var bci = block.position, end = block.end.position; bci <= end; bci++) {
                            var bc = bytecodes[bci];
                            var op = bc.op;
                            switch (op) {
                                case 146 /* inclocal */:
                                case 148 /* declocal */:
                                case 99 /* setlocal */:
                                case 194 /* inclocal_i */:
                                case 195 /* declocal_i */:
                                    dirtyLocals[bc.index] = true;
                                    break;
                                case 50 /* hasnext2 */:
                                    dirtyLocals[bc.index] = true;
                                    dirtyLocals[bc.object] = true;
                                    break;
                                case 212 /* setlocal0 */:
                                case 213 /* setlocal1 */:
                                case 214 /* setlocal2 */:
                                case 215 /* setlocal3 */:
                                    dirtyLocals[op - 212 /* setlocal0 */] = true;
                                    break;
                            }
                        }
                    });
                    return dirtyLocals;
                };

                var heads = findLoopHeads(this.blocks);
                if (heads.length <= 0) {
                    this.markedLoops = true;
                    return true;
                }

                var worklist = heads.sort(function (a, b) {
                    return a.level - b.level;
                });
                var loopId = 0;

                for (var n = worklist.length - 1; n >= 0; n--) {
                    var t = worklist[n];
                    var sccs = findSCCs(t);
                    if (sccs.length === 0) {
                        continue;
                    }

                    for (var i = 0, j = sccs.length; i < j; i++) {
                        var scc = sccs[i];
                        var loop = new LoopInfo(scc, loopId++);
                        for (var k = 0, l = scc.length; k < l; k++) {
                            var h = scc[k];
                            if (h.level === t.level + 1 && !h.loop) {
                                h.loop = loop;
                                loop.head.set(h.bid);

                                var preds = h.preds;
                                for (var pi = 0, pj = preds.length; pi < pj; pi++) {
                                    loop.body.get(preds[pi].bid) && h.npreds--;
                                }
                                loop.npreds += h.npreds;
                            }
                        }

                        for (var k = 0, l = scc.length; k < l; k++) {
                            var h = scc[k];
                            if (h.level === t.level + 1) {
                                h.npreds = loop.npreds;
                            }
                        }

                        loop.head.recount();
                    }
                }

                this.markedLoops = true;
                return true;
            };
            return Analysis;
        })();
        AVM2.Analysis = Analysis;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

var Bytecode = Shumway.AVM2.Bytecode;
var Analysis = Shumway.AVM2.Analysis;
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;

        var shumwayOptions = Shumway.Settings.shumwayOptions;

        var avm2Options = shumwayOptions.register(new OptionSet("AVM2"));

        (function (Runtime) {
            var options = avm2Options.register(new OptionSet("Runtime"));
            Runtime.traceExecution = options.register(new Option("tx", "traceExecution", "number", 0, "trace script execution", { choices: { "off": 0, "normal": 2, "verbose": 3 } }));
            Runtime.traceCallExecution = options.register(new Option("txc", "traceCallExecution", "number", 0, "trace call execution", { choices: { "off": 0, "normal": 1, "verbose": 2 } }));
            Runtime.traceFunctions = options.register(new Option("t", "traceFunctions", "number", 0, "trace functions", { choices: { "off": 0, "compiled": 1, "compiled & abc": 2 } }));
            Runtime.traceClasses = options.register(new Option("tc", "traceClasses", "boolean", false, "trace class creation"));
            Runtime.traceDomain = options.register(new Option("td", "traceDomain", "boolean", false, "trace domain property access"));
            Runtime.debuggerMode = options.register(new Option("db", "debuggerMode", "boolean", true, "enable debugger mode"));
            Runtime.globalMultinameAnalysis = options.register(new Option("ga", "globalMultinameAnalysis", "boolean", false, "Global multiname analysis."));
            Runtime.codeCaching = options.register(new Option("cc", "codeCaching", "boolean", false, "Enable code caching."));

            Runtime.compilerEnableExceptions = options.register(new Option("cex", "exceptions", "boolean", false, "Compile functions with catch blocks."));
            Runtime.compilerMaximumMethodSize = options.register(new Option("cmms", "maximumMethodSize", "number", 4 * 1024, "Compiler maximum method size."));

            (function (ExecutionMode) {
                ExecutionMode[ExecutionMode["INTERPRET"] = 0x1] = "INTERPRET";
                ExecutionMode[ExecutionMode["COMPILE"] = 0x2] = "COMPILE";
            })(Runtime.ExecutionMode || (Runtime.ExecutionMode = {}));
            var ExecutionMode = Runtime.ExecutionMode;
        })(AVM2.Runtime || (AVM2.Runtime = {}));
        var Runtime = AVM2.Runtime;

        (function (Compiler) {
            Compiler.options = avm2Options.register(new OptionSet("Compiler"));
            Compiler.traceLevel = Compiler.options.register(new Option("tc4", "tc4", "number", 0, "Compiler Trace Level"));
            Compiler.breakFilter = Compiler.options.register(new Option("", "break", "string", "", "Set a break point at methods whose qualified name matches this string pattern."));
            Compiler.compileFilter = Compiler.options.register(new Option("", "compile", "string", "", "Only compile methods whose qualified name matches this string pattern."));
            Compiler.enableDirtyLocals = Compiler.options.register(new Option("dl", "dirtyLocals", "boolean", true, "Performe dirty local analysis to minimise PHI nodes."));
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;

        (function (Verifier) {
            Verifier.options = avm2Options.register(new OptionSet("Verifier"));
            Verifier.enabled = Verifier.options.register(new Option("verifier", "verifier", "boolean", true, "Enable verifier."));
            Verifier.traceLevel = Verifier.options.register(new Option("tv", "tv", "number", 0, "Verifier Trace Level"));
        })(AVM2.Verifier || (AVM2.Verifier = {}));
        var Verifier = AVM2.Verifier;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Namespace = Shumway.AVM2.ABC.Namespace;


var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Runtime) {
            /**
            * Seals const traits. Technically we need to throw an exception if they are ever modified after
            * the static or instance constructor executes, but we can safely ignore this incompatibility.
            */
            Runtime.sealConstTraits = false;

            /**
            * Match AS3 add semantics related to toString/valueOf when adding values.
            */
            Runtime.useAsAdd = true;

            /**
            * Allow overwriting of the native toString / valueOf with AS3 versions.
            */
            var useSurrogates = true;

            var callCounter = new Shumway.Metrics.Counter(true);
            var counter = Shumway.Metrics.Counter.instance;

            var Multiname = Shumway.AVM2.ABC.Multiname;
            var Namespace = Shumway.AVM2.ABC.Namespace;

            var ClassInfo = Shumway.AVM2.ABC.ClassInfo;
            var InstanceInfo = Shumway.AVM2.ABC.InstanceInfo;
            var ScriptInfo = Shumway.AVM2.ABC.ScriptInfo;
            var SORT = Shumway.AVM2.ABC.SORT;

            var Trait = Shumway.AVM2.ABC.Trait;
            var IndentingWriter = Shumway.IndentingWriter;
            var hasOwnProperty = Shumway.ObjectUtilities.hasOwnProperty;
            var propertyIsEnumerable = Shumway.ObjectUtilities.propertyIsEnumerable;
            var isNullOrUndefined = Shumway.isNullOrUndefined;

            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;
            var boxValue = Shumway.ObjectUtilities.boxValue;
            var bindSafely = Shumway.FunctionUtilities.bindSafely;
            var assert = Shumway.Debug.assert;

            var defineNonEnumerableGetterOrSetter = Shumway.ObjectUtilities.defineNonEnumerableGetterOrSetter;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var defineReadOnlyProperty = Shumway.ObjectUtilities.defineReadOnlyProperty;
            var defineNonEnumerableGetter = Shumway.ObjectUtilities.defineNonEnumerableGetter;

            var toSafeString = Shumway.StringUtilities.toSafeString;
            var toSafeArrayString = Shumway.StringUtilities.toSafeArrayString;

            var TRAIT = Shumway.AVM2.ABC.TRAIT;

            Runtime.VM_SLOTS = "asSlots";
            Runtime.VM_LENGTH = "asLength";
            Runtime.VM_BINDINGS = "asBindings";
            Runtime.VM_NATIVE_PROTOTYPE_FLAG = "asIsNative";
            Runtime.VM_OPEN_METHODS = "asOpenMethods";

            Runtime.VM_OPEN_METHOD_PREFIX = "m";
            Runtime.VM_MEMOIZER_PREFIX = "z";
            Runtime.VM_OPEN_SET_METHOD_PREFIX = "s";
            Runtime.VM_OPEN_GET_METHOD_PREFIX = "g";

            Runtime.SAVED_SCOPE_NAME = "$SS";

            /**
            * Overriden AS3 methods (see hacks.js). This allows you to provide your own JS implementation
            * for AS3 methods.
            */
            Runtime.VM_METHOD_OVERRIDES = createEmptyObject();

            /**
            * We use this to give functions unique IDs to help with debugging.
            */
            var vmNextInterpreterFunctionId = 1;
            var vmNextCompiledFunctionId = 1;

            var compiledFunctionCount = 0;

            /**
            * Checks if the specified |object| is the prototype of a native JavaScript object.
            */
            function isNativePrototype(object) {
                return Object.prototype.hasOwnProperty.call(object, Runtime.VM_NATIVE_PROTOTYPE_FLAG);
            }
            Runtime.isNativePrototype = isNativePrototype;

            var traitsWriter = null;
            var callWriter = new IndentingWriter();

            function patch(patchTargets, value) {
                release || assert(Shumway.isFunction(value));
                for (var i = 0; i < patchTargets.length; i++) {
                    var patchTarget = patchTargets[i];
                    if (Runtime.traceExecution.value >= 3) {
                        var str = "Patching: ";
                        if (patchTarget.name) {
                            str += patchTarget.name;
                        } else if (patchTarget.get) {
                            str += "get " + patchTarget.get;
                        } else if (patchTarget.set) {
                            str += "set " + patchTarget.set;
                        }
                        traitsWriter && traitsWriter.redLn(str);
                    }
                    if (patchTarget.get) {
                        defineNonEnumerableGetterOrSetter(patchTarget.object, patchTarget.get, value, true);
                    } else if (patchTarget.set) {
                        defineNonEnumerableGetterOrSetter(patchTarget.object, patchTarget.set, value, false);
                    } else {
                        defineNonEnumerableProperty(patchTarget.object, patchTarget.name, value);
                    }
                }
            }
            Runtime.patch = patch;

            /**
            * Applies a method trait that doesn't need a memoizer.
            */
            function applyNonMemoizedMethodTrait(qn, trait, object, scope, natives) {
                release || assert(scope);
                if (trait.isMethod()) {
                    var trampoline = Runtime.makeTrampoline(function (self) {
                        var fn = getTraitFunction(trait, scope, natives);
                        patch(self.patchTargets, fn);
                        return fn;
                    }, trait.methodInfo.parameters.length);
                    trampoline.patchTargets = [
                        { object: object, name: qn },
                        { object: object, name: Runtime.VM_OPEN_METHOD_PREFIX + qn }
                    ];
                    var closure = bindSafely(trampoline, object);
                    defineReadOnlyProperty(closure, Runtime.VM_LENGTH, trampoline.asLength);
                    defineReadOnlyProperty(closure, Multiname.getPublicQualifiedName("prototype"), null);
                    defineNonEnumerableProperty(object, qn, closure);
                    defineNonEnumerableProperty(object, Runtime.VM_OPEN_METHOD_PREFIX + qn, closure);
                } else if (trait.isGetter() || trait.isSetter()) {
                    var trampoline = Runtime.makeTrampoline(function (self) {
                        var fn = getTraitFunction(trait, scope, natives);
                        patch(self.patchTargets, fn);
                        return fn;
                    }, trait.isSetter() ? 1 : 0);
                    if (trait.isGetter()) {
                        trampoline.patchTargets = [{ object: object, get: qn }];
                    } else {
                        trampoline.patchTargets = [{ object: object, set: qn }];
                    }
                    defineNonEnumerableGetterOrSetter(object, qn, trampoline, trait.isGetter());
                } else {
                    Shumway.Debug.unexpected(trait);
                }
            }
            Runtime.applyNonMemoizedMethodTrait = applyNonMemoizedMethodTrait;

            function applyMemoizedMethodTrait(qn, trait, object, scope, natives) {
                release || assert(scope, trait);

                if (trait.isMethod()) {
                    // Patch the target of the memoizer using a temporary |target| object that is visible to both the trampoline
                    // and the memoizer. The trampoline closes over it and patches the target value while the memoizer uses the
                    // target value for subsequent memoizations.
                    var memoizerTarget = { value: null };
                    var trampoline = Runtime.makeTrampoline(function (self) {
                        var fn = getTraitFunction(trait, scope, natives);
                        patch(self.patchTargets, fn);
                        return fn;
                    }, trait.methodInfo.parameters.length, String(trait.name));

                    memoizerTarget.value = trampoline;
                    var openMethods = object.asOpenMethods;
                    openMethods[qn] = trampoline;
                    defineNonEnumerableProperty(object, Runtime.VM_OPEN_METHOD_PREFIX + qn, trampoline);

                    // TODO: We make the |memoizeMethodClosure| configurable since it may be
                    // overridden by a derived class. Only do this non final classes.
                    defineNonEnumerableGetter(object, qn, Runtime.makeMemoizer(qn, memoizerTarget));

                    trampoline.patchTargets = [
                        { object: memoizerTarget, name: "value" },
                        { object: openMethods, name: qn },
                        { object: object, name: Runtime.VM_OPEN_METHOD_PREFIX + qn }
                    ];
                    tryInjectToStringAndValueOfForwarder(object, qn);
                } else if (trait.isGetter() || trait.isSetter()) {
                    var trampoline = Runtime.makeTrampoline(function (self) {
                        var fn = getTraitFunction(trait, scope, natives);
                        patch(self.patchTargets, fn);
                        return fn;
                    }, 0, String(trait.name));
                    if (trait.isGetter()) {
                        defineNonEnumerableProperty(object, Runtime.VM_OPEN_GET_METHOD_PREFIX + qn, trampoline);
                        trampoline.patchTargets = [
                            { object: object, get: qn },
                            { object: object, name: Runtime.VM_OPEN_GET_METHOD_PREFIX + qn }
                        ];
                    } else {
                        defineNonEnumerableProperty(object, Runtime.VM_OPEN_SET_METHOD_PREFIX + qn, trampoline);
                        trampoline.patchTargets = [
                            { object: object, set: qn },
                            { object: object, name: Runtime.VM_OPEN_SET_METHOD_PREFIX + qn }
                        ];
                    }
                    defineNonEnumerableGetterOrSetter(object, qn, trampoline, trait.isGetter());
                }
            }
            Runtime.applyMemoizedMethodTrait = applyMemoizedMethodTrait;

            /**
            * Property Accessors:
            *
            * Every AS3 object has the following "virtual" accessors methods:
            * - asGetProperty(namespaces, name, flags)
            * - asSetProperty(namespaces, name, flags, value)
            * - asHasProperty(namespaces, name, flags)
            * - asHasTraitProperty(namespaces, name, flags)
            * - asCallProperty(namespaces, name, flags, isLex, args)
            * - asDeleteProperty(namespaces, name, flags)
            *
            * If the compiler can prove that the property name is numeric, it calls these functions instead.
            *
            * - asGetNumericProperty(index)
            * - asSetNumericProperty(index, value)
            *
            * - asGetDescendants(namespaces, name, flags)
            * - asNextName(index)
            * - asNextNameIndex(index)
            * - asNextValue(index)
            * - asGetEnumerableKeys()
            *
            * Multiname resolution methods:
            * - getNamespaceResolutionMap(namespaces)
            * - resolveMultinameProperty(namespaces, name, flags)
            *
            * Special objects like Vector, Dictionary, XML, etc. can override these to provide different behaviour.
            *
            * To avoid boxing we represent multinames as a group of 3 parts: |namespaces| undefined or an array of
            * namespace objects, |name| any value, and |flags| an integer value. To resolve a multiname to a qualified
            * name we call |resolveMultinameProperty|. The expensive case is when we resolve multinames with multiple
            * namespaces. This is done with the help of |getNamespaceResolutionMap|.
            *
            * Every object that contains traits has a hidden array property called "resolutionMap". This maps between
            * namespace sets to an object that maps all trait names to their resolved qualified names in each namespace.
            *
            * For example, suppose we had the class A { n0 var x; n1 var x; n0 var y; n1 var y; } and two namespace sets:
            * {n0, n2} and {n2, n1}. The namespace sets are given the unique IDs 0 and 1 respectively. The resolution map
            * for class A would be:
            *
            * resolutionMap[0] = {x: n0$$x, y: n0$$y}
            * resolutionMap[1] = {x: n1$$x, y: n1$$y}
            *
            * Resolving {n2, n1}::x on a = new A() then becomes:
            *
            * a[a.resolutionMap[1]["x"]] -> a[{x: n1$$x, y: n1$$y}["x"]] -> a[n1$$x]
            *
            */
            function getNamespaceResolutionMap(namespaces) {
                var self = this;
                var map = self.resolutionMap[namespaces.runtimeId];
                if (map)
                    return map;
                map = self.resolutionMap[namespaces.runtimeId] = Shumway.ObjectUtilities.createMap();
                var bindings = self.bindings;

                for (var key in bindings.map) {
                    var multiname = key;
                    var trait = bindings.map[key].trait;
                    if (trait.isGetter() || trait.isSetter()) {
                        multiname = multiname.substring(Runtime.Binding.KEY_PREFIX_LENGTH);
                    }
                    multiname = Multiname.fromQualifiedName(multiname);
                    if (multiname.getNamespace().inNamespaceSet(namespaces)) {
                        map[multiname.getName()] = Multiname.getQualifiedName(trait.name);
                    }
                }
                return map;
            }
            Runtime.getNamespaceResolutionMap = getNamespaceResolutionMap;

            function resolveMultinameProperty(namespaces, name, flags) {
                var self = this;
                if (isNullOrUndefined(name)) {
                    name = String(asCoerceString(name));
                } else if (typeof name === "object") {
                    name = String(name);
                }
                if (Shumway.isNumeric(name)) {
                    return Shumway.toNumber(name);
                }
                if (!namespaces) {
                    return Multiname.getPublicQualifiedName(name);
                }
                if (namespaces.length > 1) {
                    var resolved = self.getNamespaceResolutionMap(namespaces)[name];
                    if (resolved)
                        return resolved;
                    return Multiname.getPublicQualifiedName(name);
                } else {
                    return Multiname.qualifyName(namespaces[0], name);
                }
            }
            Runtime.resolveMultinameProperty = resolveMultinameProperty;

            function asGetPublicProperty(name) {
                var self = this;
                return self.asGetProperty(undefined, name, 0);
            }
            Runtime.asGetPublicProperty = asGetPublicProperty;

            function asGetProperty(namespaces, name, flags) {
                var self = this;
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                if (self.asGetNumericProperty && Multiname.isNumeric(resolved)) {
                    return self.asGetNumericProperty(resolved);
                }
                return self[resolved];
            }
            Runtime.asGetProperty = asGetProperty;

            /**
            * Resolved string accessors.
            */
            function asGetResolvedStringProperty(resolved) {
                release || assert(Shumway.isString(resolved));
                return this[resolved];
            }
            Runtime.asGetResolvedStringProperty = asGetResolvedStringProperty;

            function asCallResolvedStringProperty(resolved, isLex, args) {
                var self = this;
                var receiver = isLex ? null : this;
                var openMethods = self.asOpenMethods;

                // TODO: Passing |null| as |this| doesn't work correctly for free methods. It just happens to work
                // when using memoizers because the function gets bound to |this|.
                var method;
                if (receiver && openMethods && openMethods[resolved]) {
                    method = openMethods[resolved];
                } else {
                    method = self[resolved];
                }
                return method.asApply(receiver, args);
            }
            Runtime.asCallResolvedStringProperty = asCallResolvedStringProperty;

            function asGetResolvedStringPropertyFallback(resolved) {
                var self = this;
                var name = Multiname.getNameFromPublicQualifiedName(resolved);
                return self.asGetProperty([Namespace.PUBLIC], name, 0);
            }
            Runtime.asGetResolvedStringPropertyFallback = asGetResolvedStringPropertyFallback;

            function asSetPublicProperty(name, value) {
                var self = this;
                return self.asSetProperty(undefined, name, 0, value);
            }
            Runtime.asSetPublicProperty = asSetPublicProperty;

            Runtime.forwardValueOf = new Function("", 'return this.' + Multiname.VALUE_OF + ".apply(this, arguments)");
            Runtime.forwardToString = new Function("", 'return this.' + Multiname.TO_STRING + ".apply(this, arguments)");

            /**
            * Patches the |object|'s toString properties with a forwarder that calls the AS3 toString. We only do this when
            * an AS3 object has the |toString| trait defined, or whenever the |toString| property is assigned to the object.
            *
            * Because native methods are linked lazily, if a class defines a native |toString| method we must make sure that
            * we don't overwrite its template definition. If we do, then lose the template definition and also create a cycle,
            * since we would be forwarding to ourselves.
            *
            * One way to solve this is to make sure that our template definitions don't live in the same objects as the ones
            * we apply bindings too. This is a huge pain to change at this point.
            *
            * Instead, we save the original toString as original_toString and special case the property lookup it in the
            * getNatve code in natives.ts.
            */
            function tryInjectToStringAndValueOfForwarder(self, resolved) {
                if (resolved === Multiname.VALUE_OF) {
                    defineNonEnumerableProperty(self, "original_valueOf", self.valueOf);
                    self.valueOf = Runtime.forwardValueOf;
                } else if (resolved === Multiname.TO_STRING) {
                    defineNonEnumerableProperty(self, "toString", self.toString);
                    self.toString = Runtime.forwardToString;
                }
            }

            function asSetProperty(namespaces, name, flags, value) {
                var self = this;
                if (typeof name === "object") {
                    name = String(name);
                }
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                if (self.asSetNumericProperty && Multiname.isNumeric(resolved)) {
                    return self.asSetNumericProperty(resolved, value);
                }
                var slotInfo = self.asSlots.byQN[resolved];
                if (slotInfo) {
                    if (slotInfo.isConst) {
                        // TODO: Seal after first assignment. return;
                    }
                    var type = slotInfo.type;
                    if (type && type.coerce) {
                        value = type.coerce(value);
                    }
                }
                tryInjectToStringAndValueOfForwarder(self, resolved);
                self[resolved] = value;
            }
            Runtime.asSetProperty = asSetProperty;

            function asDefinePublicProperty(name, descriptor) {
                var self = this;
                return self.asDefineProperty(undefined, name, 0, descriptor);
            }
            Runtime.asDefinePublicProperty = asDefinePublicProperty;

            function asDefineProperty(namespaces, name, flags, descriptor) {
                var self = this;
                if (typeof name === "object") {
                    name = String(name);
                }
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                Object.defineProperty(self, resolved, descriptor);
            }
            Runtime.asDefineProperty = asDefineProperty;

            function asCallPublicProperty(name, args) {
                var self = this;
                return self.asCallProperty(undefined, name, 0, false, args);
            }
            Runtime.asCallPublicProperty = asCallPublicProperty;

            function asCallProperty(namespaces, name, flags, isLex, args) {
                var self = this;
                if (Runtime.traceCallExecution.value) {
                    var receiverClassName = self.class ? self.class + " " : "";
                    callWriter.enter("call " + receiverClassName + name + "(" + toSafeArrayString(args) + ") #" + callCounter.count(name));
                }
                var receiver = isLex ? null : self;
                var result;
                var method;
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                if (self.asGetNumericProperty && Multiname.isNumeric(resolved)) {
                    method = self.asGetNumericProperty(resolved);
                } else {
                    var openMethods = self.asOpenMethods;

                    // TODO: Passing |null| as |this| doesn't work correctly for free methods. It just happens to work
                    // when using memoizers because the function gets bound to |this|.
                    if (receiver && openMethods && openMethods[resolved]) {
                        method = openMethods[resolved];
                    } else {
                        method = self[resolved];
                    }
                }
                result = method.asApply(receiver, args);
                Runtime.traceCallExecution.value > 0 && callWriter.leave("return " + toSafeString(result));
                return result;
            }
            Runtime.asCallProperty = asCallProperty;

            function asCallSuper(scope, namespaces, name, flags, args) {
                var self = this;
                if (Runtime.traceCallExecution.value) {
                    var receiverClassName = self.class ? self.class + " " : "";
                    callWriter.enter("call super " + receiverClassName + name + "(" + toSafeArrayString(args) + ") #" + callCounter.count(name));
                }
                var baseClass = scope.object.baseClass;
                var resolved = baseClass.traitsPrototype.resolveMultinameProperty(namespaces, name, flags);
                var openMethods = baseClass.traitsPrototype.asOpenMethods;
                release || assert(openMethods && openMethods[resolved]);
                var method = openMethods[resolved];
                var result = method.asApply(this, args);
                Runtime.traceCallExecution.value > 0 && callWriter.leave("return " + toSafeString(result));
                return result;
            }
            Runtime.asCallSuper = asCallSuper;

            function asSetSuper(scope, namespaces, name, flags, value) {
                var self = this;
                if (Runtime.traceCallExecution.value) {
                    var receiverClassName = self.class ? self.class + " " : "";
                    callWriter.enter("set super " + receiverClassName + name + "(" + toSafeString(value) + ") #" + callCounter.count(name));
                }
                var baseClass = scope.object.baseClass;
                var resolved = baseClass.traitsPrototype.resolveMultinameProperty(namespaces, name, flags);
                if (self.asSlots.byQN[resolved]) {
                    this.asSetProperty(namespaces, name, flags, value);
                } else {
                    baseClass.traitsPrototype[Runtime.VM_OPEN_SET_METHOD_PREFIX + resolved].call(this, value);
                }
                Runtime.traceCallExecution.value > 0 && callWriter.leave("");
            }
            Runtime.asSetSuper = asSetSuper;

            function asGetSuper(scope, namespaces, name, flags) {
                var self = this;
                if (Runtime.traceCallExecution.value) {
                    var receiver = self.class ? self.class + " " : "";
                    callWriter.enter("get super " + receiver + name + " #" + callCounter.count(name));
                }
                var baseClass = scope.object.baseClass;
                var resolved = baseClass.traitsPrototype.resolveMultinameProperty(namespaces, name, flags);
                var result;
                if (self.asSlots.byQN[resolved]) {
                    result = this.asGetProperty(namespaces, name, flags);
                } else {
                    result = baseClass.traitsPrototype[Runtime.VM_OPEN_GET_METHOD_PREFIX + resolved].call(this);
                }
                Runtime.traceCallExecution.value > 0 && callWriter.leave("return " + toSafeString(result));
                return result;
            }
            Runtime.asGetSuper = asGetSuper;

            function construct(cls, args) {
                if (cls.classInfo) {
                    // return primitive values for new'd boxes
                    var qn = Multiname.getQualifiedName(cls.classInfo.instanceInfo.name);
                    if (qn === Multiname.String) {
                        return String.asApply(null, args);
                    }
                    if (qn === Multiname.Boolean) {
                        return Boolean.asApply(null, args);
                    }
                    if (qn === Multiname.Number) {
                        return Number.asApply(null, args);
                    }
                }
                var c = cls.instanceConstructor;
                var a = args;
                switch (args.length) {
                    case 0:
                        return new c();
                    case 1:
                        return new c(a[0]);
                    case 2:
                        return new c(a[0], a[1]);
                    case 3:
                        return new c(a[0], a[1], a[2]);
                    case 4:
                        return new c(a[0], a[1], a[2], a[3]);
                    case 5:
                        return new c(a[0], a[1], a[2], a[3], a[4]);
                    case 6:
                        return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
                    case 7:
                        return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
                    case 8:
                        return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
                    case 9:
                        return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
                    case 10:
                        return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]);
                }
                var applyArguments = [];
                for (var i = 0; i < args.length; i++) {
                    applyArguments[i + 1] = args[i];
                }
                return new (Function.bind.asApply(c, applyArguments));
            }
            Runtime.construct = construct;

            function asConstructProperty(namespaces, name, flags, args) {
                var self = this;
                var constructor = self.asGetProperty(namespaces, name, flags);
                if (Runtime.traceCallExecution.value) {
                    callWriter.enter("construct " + name + "(" + toSafeArrayString(args) + ") #" + callCounter.count(name));
                }
                var result = construct(constructor, args);
                Runtime.traceCallExecution.value > 0 && callWriter.leave("return " + toSafeString(result));
                return result;
            }
            Runtime.asConstructProperty = asConstructProperty;

            function asHasProperty(namespaces, name, flags) {
                var self = this;
                return self.resolveMultinameProperty(namespaces, name, flags) in this;
            }
            Runtime.asHasProperty = asHasProperty;

            function asHasOwnProperty(namespaces, name, flags) {
                var self = this;
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                return hasOwnProperty(self, resolved);
            }
            Runtime.asHasOwnProperty = asHasOwnProperty;

            function asPropertyIsEnumerable(namespaces, name, flags) {
                var self = this;
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                return propertyIsEnumerable(self, resolved);
            }
            Runtime.asPropertyIsEnumerable = asPropertyIsEnumerable;

            function asDeleteProperty(namespaces, name, flags) {
                var self = this;
                if (self.asHasTraitProperty(namespaces, name, flags)) {
                    return false;
                }
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                return delete self[resolved];
            }
            Runtime.asDeleteProperty = asDeleteProperty;

            function asHasTraitProperty(namespaces, name, flags) {
                var self = this;
                var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                return self.asBindings.indexOf(resolved) >= 0;
            }
            Runtime.asHasTraitProperty = asHasTraitProperty;

            function asGetNumericProperty(i) {
                return this[i];
            }
            Runtime.asGetNumericProperty = asGetNumericProperty;

            function asSetNumericProperty(i, v) {
                this[i] = v;
            }
            Runtime.asSetNumericProperty = asSetNumericProperty;

            function asGetDescendants(namespaces, name, flags) {
                Shumway.Debug.notImplemented("asGetDescendants");
            }
            Runtime.asGetDescendants = asGetDescendants;

            /**
            * Gets the next name index of an object. Index |zero| is actually not an
            * index, but rather an indicator to start the iteration.
            */
            function asNextNameIndex(index) {
                var self = this;
                if (index === 0) {
                    // Gather all enumerable keys since we're starting a new iteration.
                    defineNonEnumerableProperty(self, "asEnumerableKeys", self.asGetEnumerableKeys());
                }
                var asEnumerableKeys = self.asEnumerableKeys;
                while (index < asEnumerableKeys.length) {
                    if (self.asHasProperty(undefined, asEnumerableKeys[index], 0)) {
                        return index + 1;
                    }
                    index++;
                }
                return 0;
            }
            Runtime.asNextNameIndex = asNextNameIndex;

            /**
            * Gets the nextName after the specified |index|, which you would expect to
            * be index + 1, but it's actually index - 1;
            */
            function asNextName(index) {
                var self = this;
                var asEnumerableKeys = self.asEnumerableKeys;
                release || assert(asEnumerableKeys && index > 0 && index < asEnumerableKeys.length + 1);
                return asEnumerableKeys[index - 1];
            }
            Runtime.asNextName = asNextName;

            function asNextValue(index) {
                return this.asGetPublicProperty(this.asNextName(index));
            }
            Runtime.asNextValue = asNextValue;

            /**
            * Determine if the given object has any more properties after the specified |index| and if so, return
            * the next index or |zero| otherwise. If the |obj| has no more properties then continue the search in
            * |obj.__proto__|. This function returns an updated index and object to be used during iteration.
            *
            * the |for (x in obj) { ... }| statement is compiled into the following pseudo bytecode:
            *
            * index = 0;
            * while (true) {
            *   (obj, index) = hasNext2(obj, index);
            *   if (index) { #1
            *     x = nextName(obj, index); #2
            *   } else {
            *     break;
            *   }
            * }
            *
            * #1 If we return zero, the iteration stops.
            * #2 The spec says we need to get the nextName at index + 1, but it's actually index - 1, this caused
            * me two hours of my life that I will probably never get back.
            *
            * TODO: We can't match the iteration order semantics of Action Script, hopefully programmers don't rely on it.
            */
            function asHasNext2(hasNext2Info) {
                if (isNullOrUndefined(hasNext2Info.object)) {
                    hasNext2Info.index = 0;
                    hasNext2Info.object = null;
                    return;
                }
                var object = boxValue(hasNext2Info.object);
                var nextIndex = object.asNextNameIndex(hasNext2Info.index);
                if (nextIndex > 0) {
                    hasNext2Info.index = nextIndex;
                    hasNext2Info.object = object;
                    return;
                }

                while (true) {
                    var object = Object.getPrototypeOf(object);
                    if (!object) {
                        hasNext2Info.index = 0;
                        hasNext2Info.object = null;
                        return;
                    }
                    nextIndex = object.asNextNameIndex(0);
                    if (nextIndex > 0) {
                        hasNext2Info.index = nextIndex;
                        hasNext2Info.object = object;
                        return;
                    }
                }
                hasNext2Info.index = 0;
                hasNext2Info.object = null;
                return;
            }
            Runtime.asHasNext2 = asHasNext2;

            function asGetEnumerableKeys() {
                var self = this;

                //    var boxedValue = self.valueOf();
                //    // TODO: This is probably broken if the object has overwritten |valueOf|.
                //    if (typeof boxedValue === "string" || typeof boxedValue === "number") {
                //      return [];
                //    }
                if (self instanceof String || self instanceof Number) {
                    return [];
                }

                var keys = Object.keys(this);
                var result = [];
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (Shumway.isNumeric(key)) {
                        result.push(key);
                    } else {
                        var name = Multiname.stripPublicQualifier(key);
                        if (name !== undefined) {
                            result.push(name);
                        }
                    }
                }
                return result;
            }
            Runtime.asGetEnumerableKeys = asGetEnumerableKeys;

            function asTypeOf(x) {
                // ABC doesn't box primitives, so typeof returns the primitive type even when
                // the value is new'd
                if (x) {
                    if (x.constructor === String) {
                        return "string";
                    } else if (x.constructor === Number) {
                        return "number";
                    } else if (x.constructor === Boolean) {
                        return "boolean";
                    } else if (x instanceof Shumway.AVM2.AS.ASXML || x instanceof Shumway.AVM2.AS.ASXMLList) {
                        return "xml";
                    } else if (Shumway.AVM2.AS.ASClass.isType(x)) {
                        return "object";
                    }
                }
                return typeof x;
            }
            Runtime.asTypeOf = asTypeOf;

            /**
            * Make an object's properties accessible from AS3. This prefixes all non-numeric
            * properties with the public prefix.
            */
            function publicizeProperties(object) {
                var keys = Object.keys(object);
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    if (!Multiname.isPublicQualifiedName(k)) {
                        var v = object[k];
                        object[Multiname.getPublicQualifiedName(k)] = v;
                        delete object[k];
                    }
                }
            }
            Runtime.publicizeProperties = publicizeProperties;

            function asGetSlot(object, index) {
                return object[object.asSlots.byID[index].name];
            }
            Runtime.asGetSlot = asGetSlot;

            function asSetSlot(object, index, value) {
                var slotInfo = object.asSlots.byID[index];
                if (slotInfo.const) {
                    return;
                }
                var name = slotInfo.name;
                var type = slotInfo.type;
                if (type && type.coerce) {
                    object[name] = type.coerce(value);
                } else {
                    object[name] = value;
                }
            }
            Runtime.asSetSlot = asSetSlot;

            function asCheckVectorSetNumericProperty(i, length, fixed) {
                if (i < 0 || i > length || (i === length && fixed) || !Shumway.isNumeric(i)) {
                    throwError("RangeError", AVM2.Errors.OutOfRangeError, i, length);
                }
            }
            Runtime.asCheckVectorSetNumericProperty = asCheckVectorSetNumericProperty;

            function asCheckVectorGetNumericProperty(i, length) {
                if (i < 0 || i >= length || !Shumway.isNumeric(i)) {
                    throwError("RangeError", AVM2.Errors.OutOfRangeError, i, length);
                }
            }
            Runtime.asCheckVectorGetNumericProperty = asCheckVectorGetNumericProperty;

            function throwError(name, error) {
                var rest = [];
                for (var _i = 0; _i < (arguments.length - 2); _i++) {
                    rest[_i] = arguments[_i + 2];
                }
                if (true) {
                    var message = Shumway.AVM2.formatErrorMessage.apply(null, Array.prototype.slice.call(arguments, 1));
                    throwErrorFromVM(Runtime.AVM2.currentDomain(), name, message, error.code);
                } else {
                    throwErrorFromVM(Runtime.AVM2.currentDomain(), name, Shumway.AVM2.getErrorMessage(error.code), error.code);
                }
            }
            Runtime.throwError = throwError;

            function throwErrorFromVM(domain, errorClass, message, id) {
                var error = new (domain.getClass(errorClass)).instanceConstructor(message, id);
                throw error;
            }
            Runtime.throwErrorFromVM = throwErrorFromVM;

            function translateError(domain, error) {
                if (error instanceof Error) {
                    var type = domain.getClass(error.name);
                    if (type) {
                        return new type.instanceConstructor(Shumway.AVM2.translateErrorMessage(error));
                    }
                    Shumway.Debug.unexpected("Can't translate error: " + error);
                }
                return error;
            }
            Runtime.translateError = translateError;

            function asIsInstanceOf(type, value) {
                return type.isInstanceOf(value);
            }
            Runtime.asIsInstanceOf = asIsInstanceOf;

            function asIsType(type, value) {
                return type.isType(value);
            }
            Runtime.asIsType = asIsType;

            function asAsType(type, value) {
                return asIsType(type, value) ? value : null;
            }
            Runtime.asAsType = asAsType;

            function asCoerceByMultiname(methodInfo, multiname, value) {
                release || assert(multiname.isQName());
                switch (Multiname.getQualifiedName(multiname)) {
                    case Multiname.Int:
                        return asCoerceInt(value);
                    case Multiname.Uint:
                        return asCoerceUint(value);
                    case Multiname.String:
                        return asCoerceString(value);
                    case Multiname.Number:
                        return asCoerceNumber(value);
                    case Multiname.Boolean:
                        return asCoerceBoolean(value);
                    case Multiname.Object:
                        return asCoerceObject(value);
                }
                return asCoerce(methodInfo.abc.applicationDomain.getType(multiname), value);
            }
            Runtime.asCoerceByMultiname = asCoerceByMultiname;

            function asCoerce(type, value) {
                return type.coerce(value);
            }
            Runtime.asCoerce = asCoerce;

            /**
            * Similar to |toString| but returns |null| for |null| or |undefined| instead
            * of "null" or "undefined".
            */
            function asCoerceString(x) {
                if (typeof x === "string") {
                    return x;
                } else if (x == undefined) {
                    return null;
                }
                return x + '';
            }
            Runtime.asCoerceString = asCoerceString;

            function asCoerceInt(x) {
                return x | 0;
            }
            Runtime.asCoerceInt = asCoerceInt;

            function asCoerceUint(x) {
                return x >>> 0;
            }
            Runtime.asCoerceUint = asCoerceUint;

            function asCoerceNumber(x) {
                return +x;
            }
            Runtime.asCoerceNumber = asCoerceNumber;

            function asCoerceBoolean(x) {
                return !!x;
            }
            Runtime.asCoerceBoolean = asCoerceBoolean;

            function asCoerceObject(x) {
                if (x == undefined) {
                    return null;
                }
                if (typeof x === 'string' || typeof x === 'number') {
                    return x;
                }
                return Object(x);
            }
            Runtime.asCoerceObject = asCoerceObject;

            function asDefaultCompareFunction(a, b) {
                return String(a).localeCompare(String(b));
            }
            Runtime.asDefaultCompareFunction = asDefaultCompareFunction;

            function asCompare(a, b, options, compareFunction) {
                release || Shumway.Debug.assertNotImplemented(!(options & 4 /* UNIQUESORT */), "UNIQUESORT");
                release || Shumway.Debug.assertNotImplemented(!(options & 8 /* RETURNINDEXEDARRAY */), "RETURNINDEXEDARRAY");
                var result = 0;
                if (!compareFunction) {
                    compareFunction = asDefaultCompareFunction;
                }
                if (options & 1 /* CASEINSENSITIVE */) {
                    a = String(a).toLowerCase();
                    b = String(b).toLowerCase();
                }
                if (options & 16 /* NUMERIC */) {
                    a = Shumway.toNumber(a);
                    b = Shumway.toNumber(b);
                    result = a < b ? -1 : (a > b ? 1 : 0);
                } else {
                    result = compareFunction(a, b);
                }
                if (options & 2 /* DESCENDING */) {
                    result *= -1;
                }
                return result;
            }
            Runtime.asCompare = asCompare;

            /**
            * ActionScript 3 has different behaviour when deciding whether to call toString or valueOf
            * when one operand is a string. Unlike JavaScript, it calls toString if one operand is a
            * string and valueOf otherwise. This sucks, but we have to emulate this behaviour because
            * YouTube depends on it.
            */
            function asAdd(l, r) {
                if (typeof l === "string" || typeof r === "string") {
                    return String(l) + String(r);
                }
                return l + r;
            }
            Runtime.asAdd = asAdd;

            function isXMLType(x) {
                return x instanceof Shumway.AVM2.AS.ASXML || x instanceof Shumway.AVM2.AS.ASXMLList;
            }

            function getDescendants(object, mn) {
                if (!isXMLType(object)) {
                    throw "Not XML object in getDescendants";
                }
                return object.descendants(mn);
            }
            Runtime.getDescendants = getDescendants;

            function checkFilter(value) {
                if (!value.class || !isXMLType(value)) {
                    throw "TypeError operand of childFilter not of XML type";
                }
                return value;
            }
            Runtime.checkFilter = checkFilter;

            function initializeGlobalObject(global) {
                ["Object", "Number", "Boolean", "String", "Array", "Date", "RegExp"].forEach(function (name) {
                    defineReadOnlyProperty(global[name].prototype, Runtime.VM_NATIVE_PROTOTYPE_FLAG, true);
                });

                defineNonEnumerableProperty(global.Object.prototype, "getNamespaceResolutionMap", getNamespaceResolutionMap);
                defineNonEnumerableProperty(global.Object.prototype, "resolveMultinameProperty", resolveMultinameProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asGetProperty", asGetProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asGetPublicProperty", asGetPublicProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asGetResolvedStringProperty", asGetResolvedStringProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asSetProperty", asSetProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asSetPublicProperty", asSetPublicProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asDefineProperty", asDefineProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asDefinePublicProperty", asDefinePublicProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asCallProperty", asCallProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asCallSuper", asCallSuper);
                defineNonEnumerableProperty(global.Object.prototype, "asGetSuper", asGetSuper);
                defineNonEnumerableProperty(global.Object.prototype, "asSetSuper", asSetSuper);
                defineNonEnumerableProperty(global.Object.prototype, "asCallPublicProperty", asCallPublicProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asCallResolvedStringProperty", asCallResolvedStringProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asConstructProperty", asConstructProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asHasProperty", asHasProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asHasPropertyInternal", asHasProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asHasOwnProperty", asHasOwnProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asPropertyIsEnumerable", asPropertyIsEnumerable);
                defineNonEnumerableProperty(global.Object.prototype, "asHasTraitProperty", asHasTraitProperty);
                defineNonEnumerableProperty(global.Object.prototype, "asDeleteProperty", asDeleteProperty);

                defineNonEnumerableProperty(global.Object.prototype, "asHasNext2", asHasNext2);
                defineNonEnumerableProperty(global.Object.prototype, "asNextName", asNextName);
                defineNonEnumerableProperty(global.Object.prototype, "asNextValue", asNextValue);
                defineNonEnumerableProperty(global.Object.prototype, "asNextNameIndex", asNextNameIndex);
                defineNonEnumerableProperty(global.Object.prototype, "asGetEnumerableKeys", asGetEnumerableKeys);

                defineNonEnumerableProperty(global.Function.prototype, "asCall", global.Function.prototype.call);
                defineNonEnumerableProperty(global.Function.prototype, "asApply", global.Function.prototype.apply);

                [
                    "Array",
                    "Object",
                    "Int8Array",
                    "Uint8Array",
                    "Uint8ClampedArray",
                    "Int16Array",
                    "Uint16Array",
                    "Int32Array",
                    "Uint32Array",
                    "Float32Array",
                    "Float64Array"
                ].forEach(function (name) {
                    if (!(name in global)) {
                        log(name + ' was not found in globals');
                        return;
                    }
                    defineNonEnumerableProperty(global[name].prototype, "asGetNumericProperty", asGetNumericProperty);
                    defineNonEnumerableProperty(global[name].prototype, "asSetNumericProperty", asSetNumericProperty);
                });

                global.Array.prototype.asGetProperty = function (namespaces, name, flags) {
                    if (typeof name === "number") {
                        return this[name];
                    }
                    return asGetProperty.call(this, namespaces, name, flags);
                };

                global.Array.prototype.asSetProperty = function (namespaces, name, flags, value) {
                    if (typeof name === "number") {
                        this[name] = value;
                        return;
                    }
                    return asSetProperty.call(this, namespaces, name, flags, value);
                };
            }
            Runtime.initializeGlobalObject = initializeGlobalObject;

            initializeGlobalObject(jsGlobal);

            /**
            * Check if a qualified name is in an object's traits.
            */
            function nameInTraits(object, qn) {
                // If the object itself holds traits, try to resolve it. This is true for
                // things like global objects and activations, but also for classes, which
                // both have their own traits and the traits of the Class class.
                if (object.hasOwnProperty(Runtime.VM_BINDINGS) && object.hasOwnProperty(qn)) {
                    return true;
                }

                // Else look on the prototype.
                var proto = Object.getPrototypeOf(object);
                return proto.hasOwnProperty(Runtime.VM_BINDINGS) && proto.hasOwnProperty(qn);
            }
            Runtime.nameInTraits = nameInTraits;

            /**
            * Scope object backing for catch blocks.
            */
            function CatchScopeObject(domain, trait) {
                if (trait) {
                    new Runtime.CatchBindings(new Runtime.Scope(null, this), trait).applyTo(domain, this);
                }
            }
            Runtime.CatchScopeObject = CatchScopeObject;

            /**
            * Global object for a script.
            */
            var Global = (function () {
                function Global(script) {
                    this.scriptInfo = script;
                    script.global = this;
                    this.scriptBindings = new Runtime.ScriptBindings(script, new Runtime.Scope(null, this, false));
                    this.scriptBindings.applyTo(script.abc.applicationDomain, this);
                    script.loaded = true;
                }
                Global.prototype.toString = function () {
                    return "[object global]";
                };

                Global.prototype.isExecuted = function () {
                    return this.scriptInfo.executed;
                };

                Global.prototype.isExecuting = function () {
                    return this.scriptInfo.executing;
                };

                Global.prototype.ensureExecuted = function () {
                    Shumway.AVM2.Runtime.ensureScriptIsExecuted(this.scriptInfo);
                };
                return Global;
            })();
            Runtime.Global = Global;

            defineNonEnumerableProperty(Global.prototype, Multiname.getPublicQualifiedName("toString"), function () {
                return this.toString();
            });

            /**
            * Self patching global property stub that lazily initializes objects like scripts and
            * classes.
            */
            var LazyInitializer = (function () {
                function LazyInitializer(target) {
                    release || assert(!target.asLazyInitializer);
                    this._target = target;
                    this._resolved = null;
                }
                LazyInitializer.create = function (target) {
                    if (target.asLazyInitializer) {
                        return target.asLazyInitializer;
                    }
                    return target.asLazyInitializer = new LazyInitializer(target);
                };

                LazyInitializer.prototype.resolve = function () {
                    if (this._resolved) {
                        return this._resolved;
                    }
                    if (this._target instanceof ScriptInfo) {
                        var scriptInfo = this._target;
                        Runtime.ensureScriptIsExecuted(scriptInfo, "Lazy Initializer");
                        return this._resolved = scriptInfo.global;
                    } else if (this._target instanceof ClassInfo) {
                        var classInfo = this._target;
                        if (classInfo.classObject) {
                            return this._resolved = classInfo.classObject;
                        }
                        return this._resolved = classInfo.abc.applicationDomain.getProperty(classInfo.instanceInfo.name, false, false);
                    } else {
                        Shumway.Debug.notImplemented(String(this._target));
                        return;
                    }
                };
                return LazyInitializer;
            })();
            Runtime.LazyInitializer = LazyInitializer;

            function forEachPublicProperty(object, fn, self) {
                if (!object.asBindings) {
                    for (var key in object) {
                        fn.call(self, key, object[key]);
                    }
                    return;
                }

                for (var key in object) {
                    if (Shumway.isNumeric(key)) {
                        fn.call(self, key, object[key]);
                    } else if (Multiname.isPublicQualifiedName(key) && object.asBindings.indexOf(key) < 0) {
                        var name = Multiname.stripPublicQualifier(key);
                        fn.call(self, name, object[key]);
                    }
                }
            }
            Runtime.forEachPublicProperty = forEachPublicProperty;

            function wrapJSObject(object) {
                var wrapper = Object.create(object);
                for (var i in object) {
                    Object.defineProperty(wrapper, Multiname.getPublicQualifiedName(i), (function (object, i) {
                        return {
                            get: function () {
                                return object[i];
                            },
                            set: function (value) {
                                object[i] = value;
                            },
                            enumerable: true
                        };
                    })(object, i));
                }
                return wrapper;
            }
            Runtime.wrapJSObject = wrapJSObject;

            function asCreateActivation(methodInfo) {
                return Object.create(methodInfo.activationPrototype);
            }
            Runtime.asCreateActivation = asCreateActivation;

            /**
            * It's not possible to resolve the multiname {a, b, c}::x to {b}::x if no trait exists in any of the currently
            * loaded abc files that defines the {b}::x name. Of course, this can change if we load an abc file that defines it.
            */
            var GlobalMultinameResolver = (function () {
                function GlobalMultinameResolver() {
                }
                GlobalMultinameResolver.updateTraits = function (traits) {
                    for (var i = 0; i < traits.length; i++) {
                        var trait = traits[i];
                        var name = trait.name.name;
                        var namespace = trait.name.getNamespace();
                        if (!namespace.isDynamic()) {
                            GlobalMultinameResolver.hasNonDynamicNamespaces[name] = true;
                            if (GlobalMultinameResolver.wasResolved[name]) {
                                Shumway.Debug.notImplemented("We have to the undo the optimization, " + name + " can now bind to " + namespace);
                            }
                        }
                    }
                };

                /**
                * Called after an .abc file is loaded. This invalidates inline caches if they have been created.
                */
                GlobalMultinameResolver.loadAbc = function (abc) {
                    if (!Runtime.globalMultinameAnalysis.value) {
                        return;
                    }
                    var scripts = abc.scripts;
                    var classes = abc.classes;
                    var methods = abc.methods;
                    for (var i = 0; i < scripts.length; i++) {
                        GlobalMultinameResolver.updateTraits(scripts[i].traits);
                    }
                    for (var i = 0; i < classes.length; i++) {
                        GlobalMultinameResolver.updateTraits(classes[i].traits);
                        GlobalMultinameResolver.updateTraits(classes[i].instanceInfo.traits);
                    }
                    for (var i = 0; i < methods.length; i++) {
                        if (methods[i].traits) {
                            GlobalMultinameResolver.updateTraits(methods[i].traits);
                        }
                    }
                };

                GlobalMultinameResolver.resolveMultiname = function (multiname) {
                    var name = multiname.name;
                    if (GlobalMultinameResolver.hasNonDynamicNamespaces[name]) {
                        return;
                    }
                    GlobalMultinameResolver.wasResolved[name] = true;
                    return new Multiname([Namespace.PUBLIC], multiname.name);
                };
                GlobalMultinameResolver.hasNonDynamicNamespaces = createEmptyObject();
                GlobalMultinameResolver.wasResolved = createEmptyObject();
                return GlobalMultinameResolver;
            })();
            Runtime.GlobalMultinameResolver = GlobalMultinameResolver;

            var ActivationInfo = (function () {
                function ActivationInfo(methodInfo) {
                    this.methodInfo = methodInfo;
                }
                return ActivationInfo;
            })();
            Runtime.ActivationInfo = ActivationInfo;

            var HasNext2Info = (function () {
                function HasNext2Info(object, index) {
                    this.object = object;
                    this.index = index;
                    // ...
                }
                return HasNext2Info;
            })();
            Runtime.HasNext2Info = HasNext2Info;

            function sliceArguments(args, offset) {
                if (typeof offset === "undefined") { offset = 0; }
                return Array.prototype.slice.call(args, offset);
            }
            Runtime.sliceArguments = sliceArguments;

            function canCompile(mi) {
                if (!mi.hasBody) {
                    return false;
                }
                if (mi.hasExceptions() && !Runtime.compilerEnableExceptions.value) {
                    return false;
                } else if (mi.hasSetsDxns()) {
                    return false;
                } else if (mi.code.length > Runtime.compilerMaximumMethodSize.value) {
                    return false;
                }
                return true;
            }
            Runtime.canCompile = canCompile;

            /**
            * Checks if the specified method should be compiled. For now we just ignore very large methods.
            */
            function shouldCompile(mi) {
                if (!canCompile(mi)) {
                    return false;
                }

                // Don't compile class and script initializers since they only run once.
                if (mi.isClassInitializer || mi.isScriptInitializer) {
                    return false;
                }
                return true;
            }
            Runtime.shouldCompile = shouldCompile;

            /**
            * Checks if the specified method must be compiled, even if the compiled is not enabled.
            */
            function forceCompile(mi) {
                if (mi.hasExceptions()) {
                    return false;
                }
                var holder = mi.holder;
                if (holder instanceof ClassInfo) {
                    holder = holder.instanceInfo;
                }
                if (holder instanceof InstanceInfo) {
                    var packageName = holder.name.namespaces[0].uri;
                    switch (packageName) {
                        case "flash.geom":
                        case "flash.events":
                            return true;
                        default:
                            break;
                    }
                    var className = holder.name.getOriginalName();
                    switch (className) {
                        case "com.google.youtube.model.VideoData":
                            return true;
                    }
                }
                return false;
            }
            Runtime.forceCompile = forceCompile;

            Runtime.CODE_CACHE = createEmptyObject();

            function searchCodeCache(methodInfo) {
                if (!Runtime.codeCaching.value) {
                    return;
                }
                var cacheInfo = Runtime.CODE_CACHE[methodInfo.abc.hash];
                if (!cacheInfo) {
                    warn("Cannot Find Code Cache For ABC, name: " + methodInfo.abc.name + ", hash: " + methodInfo.abc.hash);
                    AVM2.countTimeline("Code Cache ABC Miss");
                    return;
                }
                if (!cacheInfo.isInitialized) {
                    //      methodInfo.abc.scripts.forEach(function (scriptInfo) {
                    //        LazyInitializer.create(scriptInfo).getName();
                    //      });
                    //      methodInfo.abc.classes.forEach(function (classInfo) {
                    //        LazyInitializer.create(classInfo).getName();
                    //      });
                    cacheInfo.isInitialized = true;
                }
                var method = cacheInfo.methods[methodInfo.index];
                if (!method) {
                    if (methodInfo.isInstanceInitializer || methodInfo.isClassInitializer) {
                        AVM2.countTimeline("Code Cache Query On Initializer");
                    } else {
                        AVM2.countTimeline("Code Cache MISS ON OTHER");
                        warn("Shouldn't MISS: " + methodInfo + " " + methodInfo.debugName);
                    }

                    // warn("Cannot Find Code Cache For Method, name: " + methodInfo);
                    AVM2.countTimeline("Code Cache Miss");
                    return;
                }
                log("Linking CC: " + methodInfo);
                AVM2.countTimeline("Code Cache Hit");
                return method;
            }
            Runtime.searchCodeCache = searchCodeCache;

            function createInterpretedFunction(methodInfo, scope, hasDynamicScope) {
                var mi = methodInfo;
                var hasDefaults = false;
                var defaults = mi.parameters.map(function (p) {
                    if (p.value !== undefined) {
                        hasDefaults = true;
                    }
                    return p.value;
                });
                var fn;
                if (hasDynamicScope) {
                    fn = function (scope) {
                        var global = (this === jsGlobal ? scope.global.object : this);
                        var args = sliceArguments(arguments, 1);
                        if (hasDefaults && args.length < defaults.length) {
                            args = args.concat(defaults.slice(args.length - defaults.length));
                        }
                        return Shumway.AVM2.Interpreter.interpretMethod(global, methodInfo, scope, args);
                    };
                } else {
                    fn = function () {
                        var global = (this === jsGlobal ? scope.global.object : this);
                        var args = sliceArguments(arguments);
                        if (hasDefaults && args.length < defaults.length) {
                            args = args.concat(defaults.slice(arguments.length - defaults.length));
                        }
                        return Shumway.AVM2.Interpreter.interpretMethod(global, methodInfo, scope, args);
                    };
                }
                if (methodInfo.hasSetsDxns()) {
                    // SETS_DXNS means we allowed to save default xml namespace in the scope.
                    // Simulating that by saving/restoring current xml namespace, problem
                    // that this method will not work for closures.
                    fn = (function (fn) {
                        return function () {
                            var savedDxns = Shumway.AVM2.AS.ASXML.defaultNamespace;
                            try  {
                                var result = fn.apply(this, arguments);
                                Shumway.AVM2.AS.ASXML.defaultNamespace = savedDxns;
                                return result;
                            } catch (e) {
                                // Note: this doesn't use `finally` because that's a no-go for performance.
                                Shumway.AVM2.AS.ASXML.defaultNamespace = savedDxns;
                                throw e;
                            }
                        };
                    })(fn);
                }
                fn.instanceConstructor = fn;
                fn.debugName = "Interpreter Function #" + vmNextInterpreterFunctionId++;
                return fn;
            }
            Runtime.createInterpretedFunction = createInterpretedFunction;

            function debugName(value) {
                if (Shumway.isFunction(value)) {
                    return value.debugName;
                }
                return value;
            }
            Runtime.debugName = debugName;

            function createCompiledFunction(methodInfo, scope, hasDynamicScope, breakpoint, deferCompilation) {
                var mi = methodInfo;
                var cached = searchCodeCache(mi);
                var compilation;
                if (!cached) {
                    compilation = AVM2.Compiler.compileMethod(mi, scope, hasDynamicScope);
                }

                var fnName = mi.name ? Multiname.getQualifiedName(mi.name) : "fn" + compiledFunctionCount;
                if (mi.holder) {
                    var fnNamePrefix = "";
                    if (mi.holder instanceof ClassInfo) {
                        fnNamePrefix = "static$" + mi.holder.instanceInfo.name.getName();
                    } else if (mi.holder instanceof InstanceInfo) {
                        fnNamePrefix = mi.holder.name.getName();
                    } else if (mi.holder instanceof ScriptInfo) {
                        fnNamePrefix = "script";
                    }
                    fnName = fnNamePrefix + "$" + fnName;
                }
                fnName = Shumway.StringUtilities.escapeString(fnName);
                if (mi.verified) {
                    fnName += "$V";
                }
                if (!breakpoint) {
                    var breakFilter = Shumway.AVM2.Compiler.breakFilter.value;
                    if (breakFilter && fnName.search(breakFilter) >= 0) {
                        breakpoint = true;
                    }
                }
                var body = compilation.body;
                if (breakpoint) {
                    body = "{ debugger; \n" + body + "}";
                }
                if (!cached) {
                    var fnSource = "function " + fnName + " (" + compilation.parameters.join(", ") + ") " + body;
                }

                if (Runtime.traceFunctions.value > 1) {
                    mi.trace(new IndentingWriter(), mi.abc);
                }
                mi.debugTrace = function () {
                    mi.trace(new IndentingWriter(), mi.abc);
                };
                if (Runtime.traceFunctions.value > 0) {
                    log(fnSource);
                }

                // mi.freeMethod = (1, eval)('[$M[' + ($M.length - 1) + '],' + fnSource + '][1]');
                // mi.freeMethod = new Function(parameters, body);
                var fn = cached || new Function("return " + fnSource)();

                fn.debugName = "Compiled Function #" + vmNextCompiledFunctionId++;
                return fn;
            }
            Runtime.createCompiledFunction = createCompiledFunction;

            /**
            * Creates a function from the specified |methodInfo| that is bound to the given |scope|. If the
            * scope is dynamic (as is the case for closures) the compiler generates an additional prefix
            * parameter for the compiled function named |SAVED_SCOPE_NAME| and then wraps the compiled
            * function in a closure that is bound to the given |scope|. If the scope is not dynamic, the
            * compiler bakes it in as a constant which should be much more efficient. If the interpreter
            * is used, the scope object is passed in every time.
            */
            function createFunction(mi, scope, hasDynamicScope, breakpoint) {
                if (typeof breakpoint === "undefined") { breakpoint = false; }
                release || assert(!mi.isNative(), "Method should have a builtin: ", mi.name);

                if (mi.freeMethod) {
                    if (hasDynamicScope) {
                        return Runtime.bindFreeMethodScope(mi, scope);
                    }
                    return mi.freeMethod;
                }

                var fn;

                if ((fn = Runtime.checkMethodOverrides(mi))) {
                    release || assert(!hasDynamicScope);
                    return fn;
                }

                ensureFunctionIsInitialized(mi);

                var useInterpreter = false;
                if ((mi.abc.applicationDomain.mode === 1 /* INTERPRET */ || !shouldCompile(mi)) && !forceCompile(mi)) {
                    useInterpreter = true;
                }

                var compileFilter = Shumway.AVM2.Compiler.compileFilter.value;
                if (compileFilter && mi.name && Multiname.getQualifiedName(mi.name).search(compileFilter) < 0) {
                    useInterpreter = true;
                }

                if (useInterpreter) {
                    mi.freeMethod = createInterpretedFunction(mi, scope, hasDynamicScope);
                } else {
                    compiledFunctionCount++;
                    mi.freeMethod = createCompiledFunction(mi, scope, hasDynamicScope, breakpoint, mi.isInstanceInitializer);
                }

                mi.freeMethod.methodInfo = mi;

                if (hasDynamicScope) {
                    return Runtime.bindFreeMethodScope(mi, scope);
                }
                return mi.freeMethod;
            }
            Runtime.createFunction = createFunction;

            function ensureFunctionIsInitialized(methodInfo) {
                var mi = methodInfo;

                // We use not having an analysis to mean "not initialized".
                if (!mi.analysis) {
                    mi.analysis = new AVM2.Analysis(mi);

                    if (mi.needsActivation()) {
                        mi.activationPrototype = new ActivationInfo(mi);
                        new Runtime.ActivationBindings(mi).applyTo(mi.abc.applicationDomain, mi.activationPrototype);
                    }

                    // If we have exceptions, make the catch scopes now.
                    var exceptions = mi.exceptions;
                    for (var i = 0, j = exceptions.length; i < j; i++) {
                        var handler = exceptions[i];
                        if (handler.varName) {
                            var varTrait = Object.create(Trait.prototype);
                            varTrait.kind = 0 /* Slot */;
                            varTrait.name = handler.varName;
                            varTrait.typeName = handler.typeName;
                            varTrait.holder = mi;
                            handler.scopeObject = new CatchScopeObject(mi.abc.applicationDomain, varTrait);
                        } else {
                            handler.scopeObject = new CatchScopeObject(undefined, undefined);
                        }
                    }
                }
            }
            Runtime.ensureFunctionIsInitialized = ensureFunctionIsInitialized;

            /**
            * Gets the function associated with a given trait.
            */
            function getTraitFunction(trait, scope, natives) {
                release || assert(scope);
                release || assert(trait.isMethod() || trait.isGetter() || trait.isSetter());

                var mi = trait.methodInfo;
                var fn;

                if (mi.isNative()) {
                    var md = trait.metadata;
                    if (md && md.native) {
                        var nativeName = md.native.value[0].value;
                        fn = Shumway.AVM2.AS.getNative(nativeName);
                    } else if (natives) {
                        fn = Shumway.AVM2.AS.getMethodOrAccessorNative(trait, natives);
                    }
                    if (!fn) {
                        Shumway.Debug.warning("No native method for: " + trait.kindName() + " " + mi.holder + "::" + Multiname.getQualifiedName(mi.name) + ", make sure you've got the static keyword for static methods.");
                        return (function (mi) {
                            return function () {
                                Shumway.Debug.warning("Calling undefined native method: " + trait.kindName() + " " + mi.holder.name + "::" + Multiname.getQualifiedName(mi.name));
                            };
                        })(mi);
                    }
                } else {
                    if (Runtime.traceExecution.value >= 2) {
                        log("Creating Function For Trait: " + trait.holder + " " + trait);
                    }
                    fn = createFunction(mi, scope, false, false);
                    release || assert(fn);
                }
                if (Runtime.traceExecution.value >= 3) {
                    log("Made Function: " + Multiname.getQualifiedName(mi.name));
                }
                return fn;
            }
            Runtime.getTraitFunction = getTraitFunction;

            /**
            * ActionScript Classes are modeled as constructor functions (class objects) which hold additional properties:
            *
            * [scope]: a scope object holding the current class object
            *
            * [baseClass]: a reference to the base class object
            *
            * [instanceTraits]: an accumulated set of traits that are to be applied to instances of this class
            *
            * [prototype]: the prototype object of this constructor function  is populated with the set of instance traits,
            *   when instances are of this class are created, their __proto__ is set to this object thus inheriting this
            *   default set of properties.
            *
            * [construct]: a reference to the class object itself, this is used when invoking the constructor with an already
            *   constructed object (i.e. constructsuper)
            *
            * additionally, the class object also has a set of class traits applied to it which are visible via scope lookups.
            */
            function createClass(classInfo, baseClass, scope) {
                // release || assert (!baseClass || baseClass instanceof Class);
                var ci = classInfo;
                var ii = ci.instanceInfo;
                var domain = ci.abc.applicationDomain;

                var className = Multiname.getName(ii.name);

                AVM2.enterTimeline("createClass", { className: className, classInfo: classInfo });

                if (Runtime.traceExecution.value) {
                    log("Creating " + (ii.isInterface() ? "Interface" : "Class") + ": " + className + (ci.native ? " replaced with native " + ci.native.cls : ""));
                }

                var cls;

                if (ii.isInterface()) {
                    cls = Shumway.AVM2.AS.createInterface(classInfo);
                } else {
                    cls = Shumway.AVM2.AS.createClass(classInfo, baseClass, scope);
                }

                if (Runtime.traceClasses.value) {
                    domain.loadedClasses.push(cls);
                    domain.traceLoadedClasses(true);
                }

                if (ii.isInterface()) {
                    AVM2.leaveTimeline();
                    return cls;
                }

                // Notify domain of class creation.
                domain.onMessage.notify1('classCreated', cls);

                // TODO: Seal constant traits in the instance object. This should be done after
                // the instance constructor has executed.
                classInfo.classObject = cls;

                // Run the static initializer.
                if (Runtime.traceExecution.value) {
                    log("Running " + (ii.isInterface() ? "Interface" : "Class") + ": " + className + " Static Constructor");
                }
                AVM2.enterTimeline("staticInitializer");
                createFunction(classInfo.init, scope, false, false).call(cls);
                AVM2.leaveTimeline();
                if (Runtime.traceExecution.value) {
                    log("Done With Static Constructor");
                }

                // Seal constant traits in the class object.
                if (Runtime.sealConstTraits) {
                    this.sealConstantTraits(cls, ci.traits);
                }
                AVM2.leaveTimeline();
                return cls;
            }
            Runtime.createClass = createClass;

            /**
            * In ActionScript, assigning to a property defined as "const" outside of a static or instance
            * initializer throws a |ReferenceError| exception. To emulate this behaviour in JavaScript,
            * we "seal" constant traits properties by replacing them with setters that throw exceptions.
            */
            function sealConstantTraits(object, traits) {
                for (var i = 0, j = traits.length; i < j; i++) {
                    var trait = traits[i];
                    if (trait.isConst()) {
                        var qn = Multiname.getQualifiedName(trait.name);
                        var value = object[qn];
                        (function (qn, value) {
                            Object.defineProperty(object, qn, {
                                configurable: false, enumerable: false,
                                get: function () {
                                    return value;
                                },
                                set: function () {
                                    throwErrorFromVM(Runtime.AVM2.currentDomain(), "ReferenceError", "Illegal write to read-only property " + qn + ".", 0);
                                }
                            });
                        })(qn, value);
                    }
                }
            }
            Runtime.sealConstantTraits = sealConstantTraits;

            function applyType(methodInfo, factory, types) {
                var factoryClassName = factory.classInfo.instanceInfo.name.name;
                if (factoryClassName === "Vector") {
                    release || assert(types.length === 1);
                    var type = types[0];
                    var typeClassName;
                    if (!isNullOrUndefined(type)) {
                        typeClassName = type.classInfo.instanceInfo.name.name.toLowerCase();
                        switch (typeClassName) {
                            case "number":
                                typeClassName = "double";
                            case "int":
                            case "uint":
                            case "double":
                                return methodInfo.abc.applicationDomain.getClass("packageInternal __AS3__.vec.Vector$" + typeClassName);
                        }
                    }
                    return methodInfo.abc.applicationDomain.getClass("packageInternal __AS3__.vec.Vector$object").applyType(type);
                } else {
                    Shumway.Debug.notImplemented(factoryClassName);
                    return;
                }
            }
            Runtime.applyType = applyType;

            function createName(namespaces, name) {
                return new Multiname(namespaces, name);
            }
            Runtime.createName = createName;
        })(AVM2.Runtime || (AVM2.Runtime = {}));
        var Runtime = AVM2.Runtime;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

var CC = Shumway.AVM2.Runtime.CODE_CACHE;

/**
* Top level runtime definitinos used by compiler generated code.
*/
var HasNext2Info = Shumway.AVM2.Runtime.HasNext2Info;

var asCreateActivation = Shumway.AVM2.Runtime.asCreateActivation;
var asIsInstanceOf = Shumway.AVM2.Runtime.asIsInstanceOf;
var asIsType = Shumway.AVM2.Runtime.asIsType;
var asAsType = Shumway.AVM2.Runtime.asAsType;
var asTypeOf = Shumway.AVM2.Runtime.asTypeOf;
var asCoerceByMultiname = Shumway.AVM2.Runtime.asCoerceByMultiname;
var asCoerce = Shumway.AVM2.Runtime.asCoerce;
var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
var asCoerceInt = Shumway.AVM2.Runtime.asCoerceInt;
var asCoerceUint = Shumway.AVM2.Runtime.asCoerceUint;
var asCoerceNumber = Shumway.AVM2.Runtime.asCoerceNumber;
var asCoerceBoolean = Shumway.AVM2.Runtime.asCoerceBoolean;
var asCoerceObject = Shumway.AVM2.Runtime.asCoerceObject;
var asCompare = Shumway.AVM2.Runtime.asCompare;
var asAdd = Shumway.AVM2.Runtime.asAdd;
var applyType = Shumway.AVM2.Runtime.applyType;

var asGetSlot = Shumway.AVM2.Runtime.asGetSlot;
var asSetSlot = Shumway.AVM2.Runtime.asSetSlot;
var asHasNext2 = Shumway.AVM2.Runtime.asHasNext2;
var getDescendants = Shumway.AVM2.Runtime.getDescendants;
var checkFilter = Shumway.AVM2.Runtime.checkFilter;

var sliceArguments = Shumway.AVM2.Runtime.sliceArguments;

var createFunction = Shumway.AVM2.Runtime.createFunction;
var createName = Shumway.AVM2.Runtime.createName;
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Runtime) {
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

            var assert = Shumway.Debug.assert;

            var boxValue = Shumway.ObjectUtilities.boxValue;

            var counter = Shumway.Metrics.Counter.instance;

            function makeCacheKey(namespaces, name, flags) {
                if (!namespaces) {
                    return name;
                } else if (namespaces.length > 1) {
                    return namespaces.runtimeId + "$" + name;
                } else {
                    return namespaces[0].qualifiedName + "$" + name;
                }
            }

            /**
            * Scopes are used to emulate the scope stack as a linked list of scopes, rather than a stack. Each
            * scope holds a reference to a scope [object] (which may exist on multiple scope chains, thus preventing
            * us from chaining the scope objects together directly).
            *
            * Scope Operations:
            *
            *  push scope: scope = new Scope(scope, object)
            *  pop scope: scope = scope.parent
            *  get global scope: scope.global
            *  get scope object: scope.object
            *
            * Method closures have a [savedScope] property which is bound when the closure is created. Since we use a
            * linked list of scopes rather than a scope stack, we don't need to clone the scope stack, we can bind
            * the closure to the current scope.
            *
            * The "scope stack" for a method always starts off as empty and methods push and pop scopes on their scope
            * stack explicitly. If a property is not found on the current scope stack, it is then looked up
            * in the [savedScope]. To emulate this we actually wrap every generated function in a closure, such as
            *
            *  function fnClosure(scope) {
            *    return function fn() {
            *      ... scope;
            *    };
            *  }
            *
            * When functions are created, we bind the function to the current scope, using fnClosure.bind(null, this)();
            *
            * Scope Caching:
            *
            * Calls to |findScopeProperty| are very expensive. They recurse all the way to the top of the scope chain and then
            * laterally across other scripts. We optimize this by caching property lookups in each scope using Multiname
            * |id|s as keys. Each Multiname object is given a unique ID when it's constructed. For QNames we only cache
            * string QNames.
            *
            * TODO: This is not sound, since you can add/delete properties to/from with scopes.
            */
            var Scope = (function () {
                function Scope(parent, object, isWith) {
                    if (typeof isWith === "undefined") { isWith = false; }
                    this.parent = parent;
                    this.object = boxValue(object);
                    release || assert(Shumway.isObject(this.object));
                    this.global = parent ? parent.global : this;
                    this.isWith = isWith;
                    this.cache = createEmptyObject();
                }
                Scope.prototype.findDepth = function (object) {
                    var current = this;
                    var depth = 0;
                    while (current) {
                        if (current.object === object) {
                            return depth;
                        }
                        depth++;
                        current = current.parent;
                    }
                    return -1;
                };

                Scope.prototype.getScopeObjects = function () {
                    var objects = [];
                    var current = this;
                    while (current) {
                        objects.unshift(current.object);
                        current = current.parent;
                    }
                    return objects;
                };

                /**
                * Searches the scope stack for the object containing the specified property. If |strict| is specified then throw
                * an exception if the property is not found. If |scopeOnly| is specified then only search the scope chain and not
                * any of the top level domains (this is used by the verifier to bake in direct object references).
                *
                * Property lookups are cached in scopes but are not used when only looking at |scopesOnly|.
                */
                Scope.prototype.findScopeProperty = function (namespaces, name, flags, method, strict, scopeOnly) {
                    AVM2.countTimeline("findScopeProperty");
                    var object;
                    var key = makeCacheKey(namespaces, name, flags);
                    if (!scopeOnly && (object = this.cache[key])) {
                        return object;
                    }

                    // Scope lookups should not be trapped by proxies.
                    if (this.object.asHasPropertyInternal(namespaces, name, flags)) {
                        return this.isWith ? this.object : (this.cache[key] = this.object);
                    }
                    if (this.parent) {
                        return (this.cache[key] = this.parent.findScopeProperty(namespaces, name, flags, method, strict, scopeOnly));
                    }
                    if (scopeOnly) {
                        return null;
                    }

                    // If we can't find the property look in the domain.
                    if ((object = method.abc.applicationDomain.findDomainProperty(new Multiname(namespaces, name, flags), strict, true))) {
                        return object;
                    }
                    if (strict) {
                        Shumway.Debug.unexpected("Cannot find property " + name);
                    }

                    // Can't find it still, return the global object.
                    return this.global.object;
                };
                return Scope;
            })();
            Runtime.Scope = Scope;

            /**
            * Wraps the free method in a closure that passes the dynamic scope object as the
            * first argument and also makes sure that the |asGlobal| object gets passed in as
            * |this| when the method is called with |fn.call(null)|.
            */
            function bindFreeMethodScope(methodInfo, scope) {
                var fn = methodInfo.freeMethod;
                if (methodInfo.lastBoundMethod && methodInfo.lastBoundMethod.scope === scope) {
                    return methodInfo.lastBoundMethod.boundMethod;
                }
                release || assert(fn, "There should already be a cached method.");
                var boundMethod;
                var asGlobal = scope.global.object;
                if (!methodInfo.hasOptional() && !methodInfo.needsArguments() && !methodInfo.needsRest()) {
                    switch (methodInfo.parameters.length) {
                        case 0:
                            boundMethod = function () {
                                return fn.call(this === jsGlobal ? asGlobal : this, scope);
                            };
                            break;
                        case 1:
                            boundMethod = function (x) {
                                return fn.call(this === jsGlobal ? asGlobal : this, scope, x);
                            };
                            break;
                        case 2:
                            boundMethod = function (x, y) {
                                return fn.call(this === jsGlobal ? asGlobal : this, scope, x, y);
                            };
                            break;
                        case 3:
                            boundMethod = function (x, y, z) {
                                return fn.call(this === jsGlobal ? asGlobal : this, scope, x, y, z);
                            };
                            break;
                        default:
                            break;
                    }
                }
                if (!boundMethod) {
                    AVM2.countTimeline("Bind Scope - Slow Path");
                    boundMethod = function () {
                        Array.prototype.unshift.call(arguments, scope);
                        var global = (this === jsGlobal ? scope.global.object : this);
                        return fn.asApply(global, arguments);
                    };
                }
                boundMethod.methodInfo = methodInfo;
                boundMethod.instanceConstructor = boundMethod;
                methodInfo.lastBoundMethod = {
                    scope: scope,
                    boundMethod: boundMethod
                };
                return boundMethod;
            }
            Runtime.bindFreeMethodScope = bindFreeMethodScope;
        })(AVM2.Runtime || (AVM2.Runtime = {}));
        var Runtime = AVM2.Runtime;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

/**
* Top level runtime definitinos used by compiler generated code.
*/
var Scope = Shumway.AVM2.Runtime.Scope;
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Runtime) {
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var Trait = Shumway.AVM2.ABC.Trait;

            var hasOwnProperty = Shumway.ObjectUtilities.hasOwnProperty;
            var createMap = Shumway.ObjectUtilities.createMap;
            var cloneObject = Shumway.ObjectUtilities.cloneObject;
            var copyProperties = Shumway.ObjectUtilities.copyProperties;
            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

            var assert = Shumway.Debug.assert;

            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;

            var defineNonEnumerableGetter = Shumway.ObjectUtilities.defineNonEnumerableGetter;
            var makeForwardingGetter = Shumway.FunctionUtilities.makeForwardingGetter;

            var pushUnique = Shumway.ArrayUtilities.pushUnique;

            var Binding = (function () {
                function Binding(trait) {
                    this.trait = trait;
                }
                Binding.getKey = function (qn, trait) {
                    var key = qn;
                    if (trait.isGetter()) {
                        key = Binding.GET_PREFIX + qn;
                    } else if (trait.isSetter()) {
                        key = Binding.SET_PREFIX + qn;
                    }
                    return key;
                };
                Binding.prototype.toString = function () {
                    return String(this.trait);
                };
                Binding.SET_PREFIX = "set ";
                Binding.GET_PREFIX = "get ";
                Binding.KEY_PREFIX_LENGTH = 4;
                return Binding;
            })();
            Runtime.Binding = Binding;

            var SlotInfo = (function () {
                function SlotInfo(name, isConst, type, trait) {
                    this.name = name;
                    this.isConst = isConst;
                    this.type = type;
                    this.trait = trait;
                }
                return SlotInfo;
            })();
            Runtime.SlotInfo = SlotInfo;

            var SlotInfoMap = (function () {
                function SlotInfoMap() {
                    this.byID = createMap();
                    this.byQN = createMap();
                }
                return SlotInfoMap;
            })();
            Runtime.SlotInfoMap = SlotInfoMap;

            /**
            * Abstraction over a collection of traits.
            */
            var Bindings = (function () {
                function Bindings() {
                    this.map = createMap();
                    this.slots = [];
                    this.nextSlotId = 1;
                }
                /**
                * Assigns the next available slot to the specified trait. Traits that have a non-zero slotId
                * are allocated by ASC and we can't relocate them elsewhere.
                */
                Bindings.prototype.assignNextSlot = function (trait) {
                    release || assert(trait instanceof Trait);
                    release || assert(trait.isSlot() || trait.isConst() || trait.isClass());
                    if (!trait.slotId) {
                        trait.slotId = this.nextSlotId++;
                    } else {
                        this.nextSlotId = trait.slotId + 1;
                    }
                    release || assert(!this.slots[trait.slotId], "Trait slot already taken.");
                    this.slots[trait.slotId] = trait;
                };

                Bindings.prototype.trace = function (writer) {
                    writer.enter("Bindings");
                    for (var key in this.map) {
                        var binding = this.map[key];
                        writer.writeLn(binding.trait.kindName() + ": " + key + " -> " + binding);
                    }
                    writer.leaveAndEnter("Slots");
                    writer.writeArray(this.slots);
                    writer.outdent();
                };

                /**
                * Applies traits to a traitsPrototype object. Every traitsPrototype object must have the following layout:
                *
                * VM_BINDINGS = [ Array of Binding QNames ]
                * VM_SLOTS = {
                *   byID: [],
                *   byQN: {},
                * }
                *
                */
                Bindings.prototype.applyTo = function (domain, object, append) {
                    if (typeof append === "undefined") { append = false; }
                    if (!append) {
                        release || assert(!hasOwnProperty(object, Runtime.VM_SLOTS), "Already has VM_SLOTS.");
                        release || assert(!hasOwnProperty(object, Runtime.VM_BINDINGS), "Already has VM_BINDINGS.");
                        release || assert(!hasOwnProperty(object, Runtime.VM_OPEN_METHODS), "Already has VM_OPEN_METHODS.");

                        defineNonEnumerableProperty(object, Runtime.VM_SLOTS, new SlotInfoMap());
                        defineNonEnumerableProperty(object, Runtime.VM_BINDINGS, []);
                        defineNonEnumerableProperty(object, Runtime.VM_OPEN_METHODS, createMap());

                        defineNonEnumerableProperty(object, "bindings", this);
                        defineNonEnumerableProperty(object, "resolutionMap", []);
                    }

                    traitsWriter && traitsWriter.greenLn("Applying Traits" + (append ? " (Append)" : ""));

                    for (var key in this.map) {
                        var binding = this.map[key];
                        var trait = binding.trait;
                        var qn = Multiname.getQualifiedName(trait.name);
                        if (trait.isSlot() || trait.isConst() || trait.isClass()) {
                            var defaultValue = undefined;
                            if (trait.isSlot() || trait.isConst()) {
                                if (trait.hasDefaultValue) {
                                    defaultValue = trait.value;
                                } else if (trait.typeName) {
                                    defaultValue = domain.findClassInfo(trait.typeName).defaultValue;
                                }
                            }
                            if (key !== qn) {
                                traitsWriter && traitsWriter.yellowLn("Binding Trait: " + key + " -> " + qn);
                                defineNonEnumerableGetter(object, key, makeForwardingGetter(qn));
                                pushUnique(object.asBindings, key);
                            } else {
                                traitsWriter && traitsWriter.greenLn("Applying Trait " + trait.kindName() + ": " + trait);
                                defineNonEnumerableProperty(object, qn, defaultValue);
                                pushUnique(object.asBindings, qn);
                                var slotInfo = new SlotInfo(qn, trait.isConst(), trait.typeName ? domain.getProperty(trait.typeName, false, false) : null, trait);
                                object.asSlots.byID[trait.slotId] = slotInfo;
                                object.asSlots.byQN[qn] = slotInfo;
                            }
                        } else if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                            if (trait.isGetter() || trait.isSetter()) {
                                key = key.substring(Binding.KEY_PREFIX_LENGTH);
                            }
                            if (key !== qn) {
                                traitsWriter && traitsWriter.yellowLn("Binding Trait: " + key + " -> " + qn);
                            } else {
                                traitsWriter && traitsWriter.greenLn("Applying Trait " + trait.kindName() + ": " + trait);
                            }
                            pushUnique(object.asBindings, key);
                            AVM2.enterTimeline("applyMethodTrait");
                            if (this instanceof ScriptBindings) {
                                Runtime.applyNonMemoizedMethodTrait(key, trait, object, binding.scope, binding.natives);
                            } else {
                                Runtime.applyMemoizedMethodTrait(key, trait, object, binding.scope, binding.natives);
                            }
                            AVM2.leaveTimeline();
                        }
                    }
                };
                return Bindings;
            })();
            Runtime.Bindings = Bindings;

            var ActivationBindings = (function (_super) {
                __extends(ActivationBindings, _super);
                function ActivationBindings(methodInfo) {
                    _super.call(this);
                    release || assert(methodInfo.needsActivation());
                    this.methodInfo = methodInfo;

                    // ASC creates activation even if the method has no traits, weird.
                    // release || assert (methodInfo.traits.length);
                    /**
                    * Add activation traits.
                    */
                    var traits = methodInfo.traits;
                    for (var i = 0; i < traits.length; i++) {
                        var trait = traits[i];
                        release || assert(trait.isSlot() || trait.isConst(), "Only slot or constant traits are allowed in activation objects.");
                        var key = Multiname.getQualifiedName(trait.name);
                        this.map[key] = new Binding(trait);
                        this.assignNextSlot(trait);
                    }
                }
                return ActivationBindings;
            })(Bindings);
            Runtime.ActivationBindings = ActivationBindings;

            var CatchBindings = (function (_super) {
                __extends(CatchBindings, _super);
                function CatchBindings(scope, trait) {
                    _super.call(this);

                    /**
                    * Add catch traits.
                    */
                    var key = Multiname.getQualifiedName(trait.name);
                    this.map[key] = new Binding(trait);
                    release || assert(trait.isSlot(), "Only slot traits are allowed in catch objects.");
                    this.assignNextSlot(trait);
                }
                return CatchBindings;
            })(Bindings);
            Runtime.CatchBindings = CatchBindings;

            var ScriptBindings = (function (_super) {
                __extends(ScriptBindings, _super);
                function ScriptBindings(scriptInfo, scope) {
                    _super.call(this);
                    this.scope = scope;
                    this.scriptInfo = scriptInfo;

                    /**
                    * Add script traits.
                    */
                    var traits = scriptInfo.traits;
                    for (var i = 0; i < traits.length; i++) {
                        var trait = traits[i];
                        var name = Multiname.getQualifiedName(trait.name);
                        var key = Binding.getKey(name, trait);
                        var binding = this.map[key] = new Binding(trait);
                        if (trait.isSlot() || trait.isConst() || trait.isClass()) {
                            this.assignNextSlot(trait);
                        }
                        if (trait.isClass()) {
                            if (trait.metadata && trait.metadata.native) {
                                trait.classInfo.native = trait.metadata.native;
                            }
                        }
                        if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                            binding.scope = this.scope;
                        }
                    }
                }
                return ScriptBindings;
            })(Bindings);
            Runtime.ScriptBindings = ScriptBindings;

            var ClassBindings = (function (_super) {
                __extends(ClassBindings, _super);
                function ClassBindings(classInfo, scope, natives) {
                    _super.call(this);
                    this.scope = scope;
                    this.natives = natives;
                    this.classInfo = classInfo;

                    /**
                    * Add class traits.
                    */
                    var traits = classInfo.traits;
                    for (var i = 0; i < traits.length; i++) {
                        var trait = traits[i];
                        var name = Multiname.getQualifiedName(trait.name);
                        var key = Binding.getKey(name, trait);
                        var binding = this.map[key] = new Binding(trait);
                        if (trait.isSlot() || trait.isConst()) {
                            this.assignNextSlot(trait);
                        }
                        if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                            binding.scope = this.scope;
                            binding.natives = this.natives;
                        }
                    }
                }
                return ClassBindings;
            })(Bindings);
            Runtime.ClassBindings = ClassBindings;

            var InstanceBindings = (function (_super) {
                __extends(InstanceBindings, _super);
                function InstanceBindings(parent, instanceInfo, scope, natives) {
                    _super.call(this);
                    this.scope = scope;
                    this.natives = natives;
                    this.parent = parent;
                    this.instanceInfo = instanceInfo;
                    this.implementedInterfaces = parent ? cloneObject(parent.implementedInterfaces) : createEmptyObject();
                    if (parent) {
                        this.slots = parent.slots.slice();
                        this.nextSlotId = parent.nextSlotId;
                    }
                    this.extend(parent);
                }
                /*
                * Extend base Instance Bindings
                *
                * Protected Members:
                *
                *   In AS3, if you have the following code:
                *
                *   class A {
                *     protected foo() { ... } // this is actually protected$A$foo
                *   }
                *
                *   class B extends A {
                *     function bar() {
                *       foo(); // this looks for protected$B$foo, not protected$A$foo
                *     }
                *   }
                *
                *   You would expect the call to |foo| in the |bar| function to have the protected A
                *   namespace open, but it doesn't. So we must create a binding in B's instance
                *   prototype from protected$B$foo -> protected$A$foo.
                *
                *   If we override foo:
                *
                *   class C extends B {
                *     protected override foo() { ... } this is protected$C$foo
                *   }
                *
                *   Then we need a binding from protected$A$foo -> protected$C$foo, and
                *   protected$B$foo -> protected$C$foo.
                *
                * Interfaces:
                *
                *   interface IA {
                *     function foo();
                *   }
                *
                *   interface IB implements IA {
                *     function bar();
                *   }
                *
                *   class C implements IB {
                *     function foo() { ... }
                *     function bar() { ... }
                *   }
                *
                *   var a:IA = new C();
                *   a.foo(); // Call Property: IA::foo
                *
                *   var b:IB = new C();
                *   b.foo(); // Call Property: IB::foo
                *   b.bar(); // Call Property: IB::bar
                *
                *   So, class C must have bindings for:
                *
                *   IA$$foo -> public$$foo
                *   IB$$foo -> public$$foo
                *   IB$$bar -> public$$bar
                */
                InstanceBindings.prototype.extend = function (parent) {
                    var ii = this.instanceInfo, ib;
                    var map = this.map;
                    var name, key, trait, binding, protectedName, protectedKey;

                    /**
                    * Inherit parent traits.
                    */
                    if (parent) {
                        for (key in parent.map) {
                            binding = parent.map[key];
                            trait = binding.trait;
                            map[key] = binding;
                            if (trait.isProtected()) {
                                // Inherit protected trait also in the local protected namespace.
                                protectedName = Multiname.getQualifiedName(new Multiname([ii.protectedNs], trait.name.getName()));
                                protectedKey = Binding.getKey(protectedName, trait);
                                map[protectedKey] = binding;
                            }
                        }
                    }

                    function writeOrOverwriteBinding(object, key, binding) {
                        var trait = binding.trait;
                        var oldBinding = object[key];
                        if (oldBinding) {
                            var oldTrait = oldBinding.trait;
                            release || assert(!oldTrait.isFinal(), "Cannot redefine a final trait: ", trait);

                            // TODO: Object.as has a trait named length, we need to remove this since
                            // it doesn't appear in Tamarin.
                            release || assert(trait.isOverride() || trait.name.getName() === "length", "Overriding a trait that is not marked for override: ", trait);
                        } else {
                            release || assert(!trait.isOverride(), "Trait marked override must override another trait: ", trait);
                        }
                        object[key] = binding;
                    }

                    function overwriteProtectedBinding(object, key, binding) {
                        if (key in object) {
                            object[key] = binding;
                        }
                    }

                    /**
                    * Add instance traits.
                    */
                    var traits = ii.traits;
                    for (var i = 0; i < traits.length; i++) {
                        trait = traits[i];
                        name = Multiname.getQualifiedName(trait.name);
                        key = Binding.getKey(name, trait);
                        binding = new Binding(trait);
                        writeOrOverwriteBinding(map, key, binding);
                        if (trait.isProtected()) {
                            // Overwrite protected traits.
                            ib = this.parent;
                            while (ib) {
                                protectedName = Multiname.getQualifiedName(new Multiname([ib.instanceInfo.protectedNs], trait.name.getName()));
                                protectedKey = Binding.getKey(protectedName, trait);
                                overwriteProtectedBinding(map, protectedKey, binding);
                                ib = ib.parent;
                            }
                        }
                        if (trait.isSlot() || trait.isConst()) {
                            this.assignNextSlot(trait);
                        }
                        if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                            binding.scope = this.scope;
                            binding.natives = this.natives;
                        }
                    }

                    /**
                    * Add interface traits.
                    */
                    var domain = ii.abc.applicationDomain;
                    var interfaces = ii.interfaces;

                    var _interface;

                    for (var i = 0; i < interfaces.length; i++) {
                        _interface = domain.getProperty(interfaces[i], true, true);

                        // This can be undefined if the interface is defined after a class that implements it is defined.
                        release || assert(_interface);
                        copyProperties(this.implementedInterfaces, _interface.interfaceBindings.implementedInterfaces);
                        this.implementedInterfaces[Multiname.getQualifiedName(_interface.classInfo.instanceInfo.name)] = _interface;
                    }

                    for (var interfaceName in this.implementedInterfaces) {
                        _interface = this.implementedInterfaces[interfaceName];
                        ib = _interface.interfaceBindings;
                        for (var interfaceKey in ib.map) {
                            var interfaceBinding = ib.map[interfaceKey];
                            if (ii.isInterface()) {
                                map[interfaceKey] = interfaceBinding;
                            } else {
                                name = Multiname.getPublicQualifiedName(interfaceBinding.trait.name.getName());
                                key = Binding.getKey(name, interfaceBinding.trait);
                                map[interfaceKey] = map[key];
                            }
                        }
                    }
                };

                InstanceBindings.prototype.toString = function () {
                    return this.instanceInfo.toString();
                };
                return InstanceBindings;
            })(Bindings);
            Runtime.InstanceBindings = InstanceBindings;

            var traitsWriter = null;
        })(AVM2.Runtime || (AVM2.Runtime = {}));
        var Runtime = AVM2.Runtime;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

var Binding = Shumway.AVM2.Runtime.Binding;
var Bindings = Shumway.AVM2.Runtime.Bindings;
var ActivationBindings = Shumway.AVM2.Runtime.ActivationBindings;
var CatchBindings = Shumway.AVM2.Runtime.CatchBindings;
var ScriptBindings = Shumway.AVM2.Runtime.ScriptBindings;
var ClassBindings = Shumway.AVM2.Runtime.ClassBindings;
var InstanceBindings = Shumway.AVM2.Runtime.InstanceBindings;
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /*
        * XRegExp 3.0.0-pre
        * <http://xregexp.com/>
        * Steven Levithan (c) 2007-2012 MIT License
        */
        /**
        * XRegExp provides augmented, extensible regular expressions. You get new syntax, flags, and
        * methods beyond what browsers support natively. XRegExp is also a regex utility belt with tools
        * to make your client-side grepping simpler and more powerful, while freeing you from worrying
        * about pesky cross-browser inconsistencies and the dubious `lastIndex` property.
        */
        AVM2.XRegExp = (function () {
            'use strict';

            /* ==============================
            * Private variables
            * ============================== */
            var REGEX_DATA = 'xregexp', self, features = {
                astral: false,
                natives: false
            }, nativ = {
                exec: RegExp.prototype.exec,
                test: RegExp.prototype.test,
                match: String.prototype.match,
                replace: String.prototype.replace,
                split: String.prototype.split
            }, fixed = {}, cache = {}, patternCache = {}, tokens = [], defaultScope = 'default', classScope = 'class', nativeTokens = {
                // Any native multicharacter token in default scope, or any single character
                'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
                // Any native multicharacter token in character class scope, or any single character
                'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|[\s\S]/
            }, replacementToken = /\$(?:{([\w$]+)}|([\d$&`']))/g, correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined, hasNativeY = RegExp.prototype.sticky !== undefined, registeredFlags = {
                g: true,
                i: true,
                m: true,
                y: hasNativeY
            }, toString = {}.toString, add;

            /* ==============================
            * Private functions
            * ============================== */
            /**
            * Attaches named capture data and `XRegExp.prototype` properties to a regex object.
            * @private
            * @param {RegExp} regex Regex to augment.
            * @param {Array} captureNames Array with capture names, or `null`.
            * @param {Boolean} [addProto=false] Whether to attach `XRegExp.prototype` properties. Not
            *   attaching properties avoids a minor performance penalty.
            * @returns {RegExp} Augmented regex.
            */
            function augment(regex, captureNames, addProto) {
                var p;

                if (addProto) {
                    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
                    if (regex.__proto__) {
                        regex.__proto__ = self.prototype;
                    } else {
                        for (p in self.prototype) {
                            // A `self.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since
                            // this is performance sensitive, and enumerable `Object.prototype` or
                            // `RegExp.prototype` extensions exist on `regex.prototype` anyway
                            regex[p] = self.prototype[p];
                        }
                    }
                }

                regex[REGEX_DATA] = { captureNames: captureNames };

                return regex;
            }

            /**
            * Removes any duplicate characters from the provided string.
            * @private
            * @param {String} str String to remove duplicate characters from.
            * @returns {String} String with any duplicate characters removed.
            */
            function clipDuplicates(str) {
                return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
            }

            /**
            * Copies a regex object while preserving special properties for named capture and augmenting with
            * `XRegExp.prototype` methods. The copy has a fresh `lastIndex` property (set to zero). Allows
            * adding and removing native flags while copying the regex.
            * @private
            * @param {RegExp} regex Regex to copy.
            * @param {Object} [options] Allows specifying native flags to add or remove while copying the
            *   regex, and whether to attach `XRegExp.prototype` properties.
            * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
            */
            function copy(regex, options) {
                if (!self.isRegExp(regex)) {
                    throw new TypeError('Type RegExp expected');
                }

                // Get native flags in use
                var flags = nativ.exec.call(/\/([a-z]*)$/i, String(regex))[1];
                options = options || {};

                if (options.add) {
                    flags = clipDuplicates(flags + options.add);
                }

                if (options.remove) {
                    // Would need to escape `options.remove` if this was public
                    flags = nativ.replace.call(flags, new RegExp('[' + options.remove + ']+', 'g'), '');
                }

                // Augment with `XRegExp.prototype` methods, but use the native `RegExp` constructor and
                // avoid searching for special tokens. That would be wrong for regexes constructed by
                // `RegExp`, and unnecessary for regexes constructed by `XRegExp` because the regex has
                // already undergone the translation to native regex syntax
                regex = augment(new RegExp(regex.source, flags), hasNamedCapture(regex) ? regex[REGEX_DATA].captureNames.slice(0) : null, options.addProto);

                return regex;
            }

            /**
            * Returns a new copy of the object used to hold extended regex instance data, tailored for a
            * native nonaugmented regex.
            * @private
            * @returns {Object} Object with base regex instance data.
            */
            function getBaseProps() {
                return { captureNames: null };
            }

            /**
            * Determines whether a regex has extended instance data used to track capture names.
            * @private
            * @param {RegExp} regex Regex to check.
            * @returns {Boolean} Whether the regex uses named capture.
            */
            function hasNamedCapture(regex) {
                return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
            }

            /**
            * Returns the first index at which a given value can be found in an array.
            * @private
            * @param {Array} array Array to search.
            * @param {*} value Value to locate in the array.
            * @returns {Number} Zero-based index at which the item is found, or -1.
            */
            function indexOf(array, value) {
                // Use the native array method, if available
                if (Array.prototype.indexOf) {
                    return array.indexOf(value);
                }

                var len = array.length, i;

                for (i = 0; i < len; ++i) {
                    if (array[i] === value) {
                        return i;
                    }
                }

                return -1;
            }

            /**
            * Determines whether a value is of the specified type, by resolving its internal [[Class]].
            * @private
            * @param {*} value Object to check.
            * @param {String} type Type to check for, in TitleCase.
            * @returns {Boolean} Whether the object matches the type.
            */
            function isType(value, type) {
                return toString.call(value) === '[object ' + type + ']';
            }

            /**
            * Checks whether the next nonignorable token after the specified position is a quantifier.
            * @private
            * @param {String} pattern Pattern to search within.
            * @param {Number} pos Index in `pattern` to search at.
            * @param {String} flags Flags used by the pattern.
            * @returns {Boolean} Whether the next token is a quantifier.
            */
            function isQuantifierNext(pattern, pos, flags) {
                return nativ.test.call(flags.indexOf('x') > -1 ? /^(?:\s+|#.*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, pattern.slice(pos));
            }

            /**
            * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
            * the flag preparation logic from the `XRegExp` constructor.
            * @private
            * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
            * @param {String} flags Any combination of flags.
            * @returns {Object} Object with properties `pattern` and `flags`.
            */
            function prepareFlags(pattern, flags) {
                var i;

                // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
                if (clipDuplicates(flags) !== flags) {
                    throw new SyntaxError('Invalid duplicate regex flag ' + flags);
                }

                // Strip and apply a leading mode modifier with any combination of flags except g or y
                pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function ($0, $1) {
                    if (nativ.test.call(/[gy]/, $1)) {
                        throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
                    }

                    // Allow duplicate flags within the mode modifier
                    flags = clipDuplicates(flags + $1);
                    return '';
                });

                for (i = 0; i < flags.length; ++i) {
                    if (!registeredFlags[flags.charAt(i)]) {
                        throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
                    }
                }

                return {
                    pattern: pattern,
                    flags: flags
                };
            }

            /**
            * Prepares an options object from the given value.
            * @private
            * @param {String|Object} value Value to convert to an options object.
            * @returns {Object} Options object.
            */
            function prepareOptions(value) {
                value = value || {};

                if (isType(value, 'String')) {
                    value = self.forEach(value, /[^\s,]+/, function (match) {
                        this[match] = true;
                    }, {});
                }

                return value;
            }

            /**
            * Registers a flag so it doesn't throw an 'unknown flag' error.
            * @private
            * @param {String} flag Single-character flag to register.
            */
            function registerFlag(flag) {
                if (!/^[\w$]$/.test(flag)) {
                    throw new Error('Flag must be a single character A-Za-z0-9_$');
                }

                registeredFlags[flag] = true;
            }

            /**
            * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
            * position, until a match is found.
            * @private
            * @param {String} pattern Original pattern from which an XRegExp object is being built.
            * @param {String} flags Flags being used to construct the regex.
            * @param {Number} pos Position to search for tokens within `pattern`.
            * @param {Number} scope Regex scope to apply: 'default' or 'class'.
            * @param {Object} context Context object to use for token handler functions.
            * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
            */
            function runTokens(pattern, flags, pos, scope, context) {
                var i = tokens.length, result = null, match, t;

                while (i--) {
                    t = tokens[i];
                    if ((t.scope === scope || t.scope === 'all') && (!t.flag || flags.indexOf(t.flag) > -1)) {
                        match = self.exec(pattern, t.regex, pos, 'sticky');
                        if (match) {
                            result = {
                                matchLength: match[0].length,
                                output: t.handler.call(context, match, scope, flags),
                                reparse: t.reparse
                            };

                            break;
                        }
                    }
                }

                return result;
            }

            /**
            * Enables or disables implicit astral mode opt-in.
            * @private
            * @param {Boolean} on `true` to enable; `false` to disable.
            */
            function setAstral(on) {
                // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
                // flags might now produce different results
                self.cache.flush('patterns');

                features.astral = on;
            }

            /**
            * Enables or disables native method overrides.
            * @private
            * @param {Boolean} on `true` to enable; `false` to disable.
            */
            function setNatives(on) {
                RegExp.prototype.exec = (on ? fixed : nativ).exec;
                RegExp.prototype.test = (on ? fixed : nativ).test;
                String.prototype.match = (on ? fixed : nativ).match;
                String.prototype.replace = (on ? fixed : nativ).replace;
                String.prototype.split = (on ? fixed : nativ).split;

                features.natives = on;
            }

            /**
            * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
            * the ES5 abstract operation `ToObject`.
            * @private
            * @param {*} value Object to check and return.
            * @returns {*} The provided object.
            */
            function toObject(value) {
                // This matches both `null` and `undefined`
                if (value == null) {
                    throw new TypeError('Cannot convert null or undefined to object');
                }

                return value;
            }

            /* ==============================
            * Constructor
            * ============================== */
            /**
            * Creates an extended regular expression object for matching text with a pattern. Differs from a
            * native regular expression in that additional syntax and flags are supported. The returned object
            * is in fact a native `RegExp` and works with all native methods.
            * @class XRegExp
            * @constructor
            * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
            * @param {String} [flags] Any combination of flags.
            *   Native flags:
            *     <li>`g` - global
            *     <li>`i` - ignore case
            *     <li>`m` - multiline anchors
            *     <li>`y` - sticky (Firefox 3+)
            *   Additional XRegExp flags:
            *     <li>`n` - explicit capture
            *     <li>`s` - dot matches all (aka singleline)
            *     <li>`x` - free-spacing and line comments (aka extended)
            *     <li>`A` - astral (requires the Unicode Base addon)
            *   Flags cannot be provided when constructing one `RegExp` from another.
            * @returns {RegExp} Extended regular expression object.
            * @example
            *
            * // With named capture and flag x
            * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
            *          (?<month> [0-9]{2} ) -?  # month \n\
            *          (?<day>   [0-9]{2} )     # day   ', 'x');
            *
            * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
            * // syntax. Copies maintain special properties for named capture, are augmented with
            * // `XRegExp.prototype` methods, and have fresh `lastIndex` properties (set to zero).
            * XRegExp(/regex/);
            */
            self = function (pattern, flags) {
                var context = {
                    hasNamedCapture: false,
                    captureNames: []
                }, scope = defaultScope, output = '', pos = 0, result, token, key;

                if (self.isRegExp(pattern)) {
                    if (flags !== undefined) {
                        throw new TypeError('Cannot supply flags when copying a RegExp');
                    }
                    return copy(pattern, { addProto: true });
                }

                // Copy the argument behavior of `RegExp`
                pattern = pattern === undefined ? '' : String(pattern);
                flags = flags === undefined ? '' : String(flags);

                // Cache-lookup key; intentionally using an invalid regex sequence as the separator
                key = pattern + '***' + flags;

                if (!patternCache[key]) {
                    // Check for flag-related errors, and strip/apply flags in a leading mode modifier
                    result = prepareFlags(pattern, flags);
                    pattern = result.pattern;
                    flags = result.flags;

                    while (pos < pattern.length) {
                        do {
                            // Check for custom tokens at the current position
                            result = runTokens(pattern, flags, pos, scope, context);

                            // If the matched token used the `reparse` option, splice its output into the
                            // pattern before running tokens again at the same position
                            if (result && result.reparse) {
                                pattern = pattern.slice(0, pos) + result.output + pattern.slice(pos + result.matchLength);
                            }
                        } while(result && result.reparse);

                        if (result) {
                            output += result.output;
                            pos += (result.matchLength || 1);
                        } else {
                            // Get the native token at the current position
                            token = self.exec(pattern, nativeTokens[scope], pos, 'sticky')[0];
                            output += token;
                            pos += token.length;
                            if (token === '[' && scope === defaultScope) {
                                scope = classScope;
                            } else if (token === ']' && scope === classScope) {
                                scope = defaultScope;
                            }
                        }
                    }

                    patternCache[key] = {
                        // Cleanup token cruft: repeated `(?:)(?:)` and leading/trailing `(?:)`
                        pattern: nativ.replace.call(output, /\(\?:\)(?=\(\?:\))|^\(\?:\)|\(\?:\)$/g, ''),
                        // Strip all but native flags
                        flags: nativ.replace.call(flags, /[^gimy]+/g, ''),
                        // `context.captureNames` has an item for each capturing group, even if unnamed
                        captures: context.hasNamedCapture ? context.captureNames : null
                    };
                }

                key = patternCache[key];
                return augment(new RegExp(key.pattern, key.flags), key.captures, true);
            };

            // Add `RegExp.prototype` to the prototype chain
            self.prototype = new RegExp;

            /* ==============================
            * Public properties
            * ============================== */
            /**
            * The XRegExp version number.
            * @static
            * @memberOf XRegExp
            * @type String
            */
            self.version = '3.0.0-pre';

            /* ==============================
            * Public methods
            * ============================== */
            /**
            * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
            * create XRegExp addons. If more than one token can match the same string, the last added wins.
            * @memberOf XRegExp
            * @param {RegExp} regex Regex object that matches the new token.
            * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
            *   to replace the matched token within all future XRegExp regexes. Has access to persistent
            *   properties of the regex being built, through `this`. Invoked with three arguments:
            *   <li>The match array, with named backreference properties.
            *   <li>The regex scope where the match was found: 'default' or 'class'.
            *   <li>The flags used by the regex, including any flags in a leading mode modifier.
            *   The handler function becomes part of the XRegExp construction process, so be careful not to
            *   construct XRegExps within the function or you will trigger infinite recursion.
            * @param {Object} [options] Options object with optional properties:
            *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
            *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the
            *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
            *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are
            *     not required to trigger the token. This registers the flags, to prevent XRegExp from
            *     throwing an 'unknown flag' error when any of the flags are used.
            *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as
            *     final, and instead be reparseable by other tokens (including the current token). Allows
            *     token chaining or deferring.
            * @example
            *
            * // Basic usage: Add \a for the ALERT control code
            * XRegExp.addToken(
            *   /\\a/,
            *   function() {return '\\x07';},
            *   {scope: 'all'}
            * );
            * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
            *
            * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers
            * XRegExp.addToken(
            *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
            *   function(match) {return match[1] + (match[2] ? '' : '?');},
            *   {flag: 'U'}
            * );
            * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
            * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
            */
            self.addToken = function (regex, handler, options) {
                options = options || {};
                var optionalFlags = options.optionalFlags, i;

                if (options.flag) {
                    registerFlag(options.flag);
                }

                if (optionalFlags) {
                    optionalFlags = nativ.split.call(optionalFlags, '');
                    for (i = 0; i < optionalFlags.length; ++i) {
                        registerFlag(optionalFlags[i]);
                    }
                }

                // Add to the private list of syntax tokens
                tokens.push({
                    regex: copy(regex, { add: 'g' + (hasNativeY ? 'y' : '') }),
                    handler: handler,
                    scope: options.scope || defaultScope,
                    flag: options.flag,
                    reparse: options.reparse
                });

                // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
                // flags might now produce different results
                self.cache.flush('patterns');
            };

            /**
            * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
            * the same pattern and flag combination, the cached copy of the regex is returned.
            * @memberOf XRegExp
            * @param {String} pattern Regex pattern string.
            * @param {String} [flags] Any combination of XRegExp flags.
            * @returns {RegExp} Cached XRegExp object.
            * @example
            *
            * while (match = XRegExp.cache('.', 'gs').exec(str)) {
            *   // The regex is compiled once only
            * }
            */
            self.cache = function (pattern, flags) {
                var key = pattern + '***' + (flags || '');
                return cache[key] || (cache[key] = self(pattern, flags));
            };

            // Intentionally undocumented
            self.cache.flush = function (cacheName) {
                if (cacheName === 'patterns') {
                    // Flush the pattern cache used by the `XRegExp` constructor
                    patternCache = {};
                } else {
                    // Flush the regex object cache populated by `XRegExp.cache`
                    cache = {};
                }
            };

            /**
            * Escapes any regular expression metacharacters, for use when matching literal strings. The result
            * can safely be used at any point within a regex that uses any flags.
            * @memberOf XRegExp
            * @param {String} str String to escape.
            * @returns {String} String with regex metacharacters escaped.
            * @example
            *
            * XRegExp.escape('Escaped? <.>');
            * // -> 'Escaped\?\ <\.>'
            */
            self.escape = function (str) {
                return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            };

            /**
            * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
            * regex uses named capture, named backreference properties are included on the match array.
            * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
            * must start at the specified position only. The `lastIndex` property of the provided regex is not
            * used, but is updated for compatibility. Also fixes browser bugs compared to the native
            * `RegExp.prototype.exec` and can be used reliably cross-browser.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {RegExp} regex Regex to search with.
            * @param {Number} [pos=0] Zero-based index at which to start the search.
            * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
            *   only. The string `'sticky'` is accepted as an alternative to `true`.
            * @returns {Array} Match array with named backreference properties, or `null`.
            * @example
            *
            * // Basic use, with named backreference
            * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
            * match.hex; // -> '2620'
            *
            * // With pos and sticky, in a loop
            * var pos = 2, result = [], match;
            * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
            *   result.push(match[1]);
            *   pos = match.index + match[0].length;
            * }
            * // result -> ['2', '3', '4']
            */
            self.exec = function (str, regex, pos, sticky) {
                var cacheFlags = 'g', match, r2;

                if (hasNativeY && (sticky || (regex.sticky && sticky !== false))) {
                    cacheFlags += 'y';
                }

                regex[REGEX_DATA] = regex[REGEX_DATA] || getBaseProps();

                // Shares cached copies with `XRegExp.match`/`replace`
                r2 = regex[REGEX_DATA][cacheFlags] || (regex[REGEX_DATA][cacheFlags] = copy(regex, {
                    add: cacheFlags,
                    remove: sticky === false ? 'y' : ''
                }));

                r2.lastIndex = pos = pos || 0;

                // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
                match = fixed.exec.call(r2, str);

                if (sticky && match && match.index !== pos) {
                    match = null;
                }

                if (regex.global) {
                    regex.lastIndex = match ? r2.lastIndex : 0;
                }

                return match;
            };

            /**
            * Executes a provided function once per regex match.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {RegExp} regex Regex to search with.
            * @param {Function} callback Function to execute for each match. Invoked with four arguments:
            *   <li>The match array, with named backreference properties.
            *   <li>The zero-based match index.
            *   <li>The string being traversed.
            *   <li>The regex object being used to traverse the string.
            * @param {*} [context] Object to use as `this` when executing `callback`.
            * @returns {*} Provided `context` object.
            * @example
            *
            * // Extracts every other digit from a string
            * XRegExp.forEach('1a2345', /\d/, function(match, i) {
            *   if (i % 2) this.push(+match[0]);
            * }, []);
            * // -> [2, 4]
            */
            self.forEach = function (str, regex, callback, context) {
                var pos = 0, i = -1, match;

                while ((match = self.exec(str, regex, pos))) {
                    // Because `regex` is provided to `callback`, the function can use the deprecated/
                    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since
                    // `XRegExp.exec` doesn't use `lastIndex` to set the search position, this can't lead
                    // to an infinite loop, at least. Actually, because of the way `XRegExp.exec` caches
                    // globalized versions of regexes, mutating the regex will not have any effect on the
                    // iteration or matched strings, which is a nice side effect that brings extra safety
                    callback.call(context, match, ++i, str, regex);

                    pos = match.index + (match[0].length || 1);
                }

                return context;
            };

            /**
            * Copies a regex object and adds flag `g`. The copy maintains special properties for named
            * capture, is augmented with `XRegExp.prototype` methods, and has a fresh `lastIndex` property
            * (set to zero). Native regexes are not recompiled using XRegExp syntax.
            * @memberOf XRegExp
            * @param {RegExp} regex Regex to globalize.
            * @returns {RegExp} Copy of the provided regex with flag `g` added.
            * @example
            *
            * var globalCopy = XRegExp.globalize(/regex/);
            * globalCopy.global; // -> true
            */
            self.globalize = function (regex) {
                return copy(regex, { add: 'g', addProto: true });
            };

            /**
            * Installs optional features according to the specified options. Can be undone using
            * {@link #XRegExp.uninstall}.
            * @memberOf XRegExp
            * @param {Object|String} options Options object or string.
            * @example
            *
            * // With an options object
            * XRegExp.install({
            *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
            *   astral: true,
            *
            *   // Overrides native regex methods with fixed/extended versions that support named
            *   // backreferences and fix numerous cross-browser bugs
            *   natives: true
            * });
            *
            * // With an options string
            * XRegExp.install('astral natives');
            */
            self.install = function (options) {
                options = prepareOptions(options);

                if (!features.astral && options.astral) {
                    setAstral(true);
                }

                if (!features.natives && options.natives) {
                    setNatives(true);
                }
            };

            /**
            * Checks whether an individual optional feature is installed.
            * @memberOf XRegExp
            * @param {String} feature Name of the feature to check. One of:
            *   <li>`natives`
            *   <li>`astral`
            * @returns {Boolean} Whether the feature is installed.
            * @example
            *
            * XRegExp.isInstalled('natives');
            */
            self.isInstalled = function (feature) {
                return !!(features[feature]);
            };

            /**
            * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
            * created in another frame, when `instanceof` and `constructor` checks would fail.
            * @memberOf XRegExp
            * @param {*} value Object to check.
            * @returns {Boolean} Whether the object is a `RegExp` object.
            * @example
            *
            * XRegExp.isRegExp('string'); // -> false
            * XRegExp.isRegExp(/regex/i); // -> true
            * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
            * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
            */
            self.isRegExp = function (value) {
                return toString.call(value) === '[object RegExp]';
                //return isType(value, 'RegExp');
            };

            /**
            * Returns the first matched string, or in global mode, an array containing all matched strings.
            * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
            * the result types you actually want (string instead of `exec`-style array in match-first mode,
            * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
            * you override flag g and ignore `lastIndex`, and fixes browser bugs.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {RegExp} regex Regex to search with.
            * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
            *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
            *   `scope` is 'all'.
            * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
            *   mode: Array of all matched strings, or an empty array.
            * @example
            *
            * // Match first
            * XRegExp.match('abc', /\w/); // -> 'a'
            * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
            * XRegExp.match('abc', /x/g, 'one'); // -> null
            *
            * // Match all
            * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
            * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
            * XRegExp.match('abc', /x/, 'all'); // -> []
            */
            self.match = function (str, regex, scope) {
                var global = (regex.global && scope !== 'one') || scope === 'all', cacheFlags = (global ? 'g' : '') + (regex.sticky ? 'y' : ''), result, r2;

                regex[REGEX_DATA] = regex[REGEX_DATA] || getBaseProps();

                // Shares cached copies with `XRegExp.exec`/`replace`
                r2 = regex[REGEX_DATA][cacheFlags || 'noGY'] || (regex[REGEX_DATA][cacheFlags || 'noGY'] = copy(regex, {
                    add: cacheFlags,
                    remove: scope === 'one' ? 'g' : ''
                }));

                result = nativ.match.call(toObject(str), r2);

                if (regex.global) {
                    regex.lastIndex = ((scope === 'one' && result) ? (result.index + result[0].length) : 0);
                }

                return global ? (result || []) : (result && result[0]);
            };

            /**
            * Retrieves the matches from searching a string using a chain of regexes that successively search
            * within previous matches. The provided `chain` array can contain regexes and objects with `regex`
            * and `backref` properties. When a backreference is specified, the named or numbered backreference
            * is passed forward to the next regex or returned.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {Array} chain Regexes that each search for matches within preceding results.
            * @returns {Array} Matches by the last regex in the chain, or an empty array.
            * @example
            *
            * // Basic usage; matches numbers within <b> tags
            * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
            *   XRegExp('(?is)<b>.*?</b>'),
            *   /\d+/
            * ]);
            * // -> ['2', '4', '56']
            *
            * // Passing forward and returning specific backreferences
            * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
            *         <a href="http://www.google.com/">Google</a>';
            * XRegExp.matchChain(html, [
            *   {regex: /<a href="([^"]+)">/i, backref: 1},
            *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
            * ]);
            * // -> ['xregexp.com', 'www.google.com']
            */
            self.matchChain = function (str, chain) {
                return (function recurseChain(values, level) {
                    var item = chain[level].regex ? chain[level] : { regex: chain[level] }, matches = [], addMatch = function (match) {
                        if (item.backref) {
                            /* Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold
                            * the `undefined`s for backreferences to nonparticipating capturing
                            * groups. In such cases, a `hasOwnProperty` or `in` check on its own would
                            * inappropriately throw the exception, so also check if the backreference
                            * is a number that is within the bounds of the array.
                            */
                            if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                                throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                            }

                            matches.push(match[item.backref] || '');
                        } else {
                            matches.push(match[0]);
                        }
                    }, i;

                    for (i = 0; i < values.length; ++i) {
                        self.forEach(values[i], item.regex, addMatch);
                    }

                    return ((level === chain.length - 1) || !matches.length) ? matches : recurseChain(matches, level + 1);
                }([str], 0));
            };

            /**
            * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
            * or regex, and the replacement can be a string or a function to be called for each match. To
            * perform a global search and replace, use the optional `scope` argument or include flag g if
            * using a regex. Replacement strings can use `${n}` for named and numbered backreferences.
            * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser
            * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {RegExp|String} search Search pattern to be replaced.
            * @param {String|Function} replacement Replacement string or a function invoked to create it.
            *   Replacement strings can include special replacement syntax:
            *     <li>$$ - Inserts a literal $ character.
            *     <li>$&, $0 - Inserts the matched substring.
            *     <li>$` - Inserts the string that precedes the matched substring (left context).
            *     <li>$' - Inserts the string that follows the matched substring (right context).
            *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
            *       backreference n/nn.
            *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing
            *       group, inserts backreference n.
            *   Replacement functions are invoked with three or more arguments:
            *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as
            *       properties of this first argument.
            *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
            *     <li>The zero-based index of the match within the total search string.
            *     <li>The total string being searched.
            * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
            *   explicitly specified and using a regex with flag g, `scope` is 'all'.
            * @returns {String} New string with one or all matches replaced.
            * @example
            *
            * // Regex search, using named backreferences in replacement string
            * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
            * XRegExp.replace('John Smith', name, '${last}, ${first}');
            * // -> 'Smith, John'
            *
            * // Regex search, using named backreferences in replacement function
            * XRegExp.replace('John Smith', name, function(match) {
            *   return match.last + ', ' + match.first;
            * });
            * // -> 'Smith, John'
            *
            * // String search, with replace-all
            * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
            * // -> 'XRegExp builds XRegExps'
            */
            self.replace = function (str, search, replacement, scope) {
                var isRegex = self.isRegExp(search), global = (search.global && scope !== 'one') || scope === 'all', cacheFlags = (global ? 'g' : '') + (search.sticky ? 'y' : ''), s2 = search, result;

                if (isRegex) {
                    search[REGEX_DATA] = search[REGEX_DATA] || getBaseProps();

                    // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used,
                    // `search`'s `lastIndex` isn't updated *during* replacement iterations
                    s2 = search[REGEX_DATA][cacheFlags || 'noGY'] || (search[REGEX_DATA][cacheFlags || 'noGY'] = copy(search, {
                        add: cacheFlags,
                        remove: scope === 'one' ? 'g' : ''
                    }));
                } else if (global) {
                    s2 = new RegExp(self.escape(String(search)), 'g');
                }

                // Fixed `replace` required for named backreferences, etc.
                result = fixed.replace.call(toObject(str), s2, replacement);

                if (isRegex && search.global) {
                    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
                    search.lastIndex = 0;
                }

                return result;
            };

            /**
            * Performs batch processing of string replacements. Used like {@link #XRegExp.replace}, but
            * accepts an array of replacement details. Later replacements operate on the output of earlier
            * replacements. Replacement details are accepted as an array with a regex or string to search for,
            * the replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
            * replacement text syntax, which supports named backreference properties via `${name}`.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {Array} replacements Array of replacement detail arrays.
            * @returns {String} New string with all replacements.
            * @example
            *
            * str = XRegExp.replaceEach(str, [
            *   [XRegExp('(?<name>a)'), 'z${name}'],
            *   [/b/gi, 'y'],
            *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
            *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
            *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
            *   [/f/g, function($0) {
            *     return $0.toUpperCase();
            *   }]
            * ]);
            */
            self.replaceEach = function (str, replacements) {
                var i, r;

                for (i = 0; i < replacements.length; ++i) {
                    r = replacements[i];
                    str = self.replace(str, r[0], r[1], r[2]);
                }

                return str;
            };

            /**
            * Splits a string into an array of strings using a regex or string separator. Matches of the
            * separator are not included in the result array. However, if `separator` is a regex that contains
            * capturing groups, backreferences are spliced into the result each time `separator` is matched.
            * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
            * cross-browser.
            * @memberOf XRegExp
            * @param {String} str String to split.
            * @param {RegExp|String} separator Regex or string to use for separating the string.
            * @param {Number} [limit] Maximum number of items to include in the result array.
            * @returns {Array} Array of substrings.
            * @example
            *
            * // Basic use
            * XRegExp.split('a b c', ' ');
            * // -> ['a', 'b', 'c']
            *
            * // With limit
            * XRegExp.split('a b c', ' ', 2);
            * // -> ['a', 'b']
            *
            * // Backreferences in result array
            * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
            * // -> ['..', 'word', '1', '..']
            */
            self.split = function (str, separator, limit) {
                return fixed.split.call(toObject(str), separator, limit);
            };

            /**
            * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
            * `sticky` arguments specify the search start position, and whether the match must start at the
            * specified position only. The `lastIndex` property of the provided regex is not used, but is
            * updated for compatibility. Also fixes browser bugs compared to the native
            * `RegExp.prototype.test` and can be used reliably cross-browser.
            * @memberOf XRegExp
            * @param {String} str String to search.
            * @param {RegExp} regex Regex to search with.
            * @param {Number} [pos=0] Zero-based index at which to start the search.
            * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
            *   only. The string `'sticky'` is accepted as an alternative to `true`.
            * @returns {Boolean} Whether the regex matched the provided value.
            * @example
            *
            * // Basic use
            * XRegExp.test('abc', /c/); // -> true
            *
            * // With pos and sticky
            * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
            */
            self.test = function (str, regex, pos, sticky) {
                // Do this the easy way :-)
                return !!self.exec(str, regex, pos, sticky);
            };

            /**
            * Uninstalls optional features according to the specified options. All optional features start out
            * uninstalled, so this is used to undo the actions of {@link #XRegExp.install}.
            * @memberOf XRegExp
            * @param {Object|String} options Options object or string.
            * @example
            *
            * // With an options object
            * XRegExp.uninstall({
            *   // Disables support for astral code points in Unicode addons
            *   astral: true,
            *
            *   // Restores native regex methods
            *   natives: true
            * });
            *
            * // With an options string
            * XRegExp.uninstall('astral natives');
            */
            self.uninstall = function (options) {
                options = prepareOptions(options);

                if (features.astral && options.astral) {
                    setAstral(false);
                }

                if (features.natives && options.natives) {
                    setNatives(false);
                }
            };

            /**
            * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
            * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
            * Backreferences in provided regex objects are automatically renumbered to work correctly within
            * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
            * `flags` argument.
            * @memberOf XRegExp
            * @param {Array} patterns Regexes and strings to combine.
            * @param {String} [flags] Any combination of XRegExp flags.
            * @returns {RegExp} Union of the provided regexes and strings.
            * @example
            *
            * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
            * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
            */
            self.union = function (patterns, flags) {
                var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g, output = [], numCaptures = 0, numPriorCaptures, captureNames, pattern, rewrite = function (match, paren, backref) {
                    var name = captureNames[numCaptures - numPriorCaptures];

                    // Capturing group
                    if (paren) {
                        ++numCaptures;

                        // If the current capture has a name, preserve the name
                        if (name) {
                            return '(?<' + name + '>';
                        }
                        // Backreference
                    } else if (backref) {
                        // Rewrite the backreference
                        return '\\' + (+backref + numPriorCaptures);
                    }

                    return match;
                }, i;

                if (!(isType(patterns, 'Array') && patterns.length)) {
                    throw new TypeError('Must provide a nonempty array of patterns to merge');
                }

                for (i = 0; i < patterns.length; ++i) {
                    pattern = patterns[i];

                    if (self.isRegExp(pattern)) {
                        numPriorCaptures = numCaptures;
                        captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

                        // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns
                        // are independently valid; helps keep this simple. Named captures are put back
                        output.push(nativ.replace.call(self(pattern.source).source, parts, rewrite));
                    } else {
                        output.push(self.escape(pattern));
                    }
                }

                return self(output.join('|'), flags);
            };

            /* ==============================
            * Fixed/extended native methods
            * ============================== */
            /**
            * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
            * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
            * override the native method. Use via `XRegExp.exec` without overriding natives.
            * @private
            * @param {String} str String to search.
            * @returns {Array} Match array with named backreference properties, or `null`.
            */
            fixed.exec = function (str) {
                var origLastIndex = this.lastIndex, match = nativ.exec.apply(this, arguments), name, r2, i;

                if (match) {
                    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating
                    // capturing groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of
                    // older IEs. IE 9 in standards mode follows the spec
                    if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
                        r2 = copy(this, { remove: 'g' });

                        // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                        // matching due to characters outside the match
                        nativ.replace.call(String(str).slice(match.index), r2, function () {
                            var len = arguments.length, i;

                            for (i = 1; i < len - 2; ++i) {
                                if (arguments[i] === undefined) {
                                    match[i] = undefined;
                                }
                            }
                        });
                    }

                    // Attach named capture properties
                    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
                        for (i = 1; i < match.length; ++i) {
                            name = this[REGEX_DATA].captureNames[i - 1];
                            if (name) {
                                match[name] = match[i];
                            }
                        }
                    }

                    // Fix browsers that increment `lastIndex` after zero-length matches
                    if (this.global && !match[0].length && (this.lastIndex > match.index)) {
                        this.lastIndex = match.index;
                    }
                }

                if (!this.global) {
                    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
                    this.lastIndex = origLastIndex;
                }

                return match;
            };

            /**
            * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
            * uses this to override the native method.
            * @private
            * @param {String} str String to search.
            * @returns {Boolean} Whether the regex matched the provided value.
            */
            fixed.test = function (str) {
                // Do this the easy way :-)
                return !!fixed.exec.call(this, str);
            };

            /**
            * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
            * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
            * override the native method.
            * @private
            * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
            * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
            *   the result of calling `regex.exec(this)`.
            */
            fixed.match = function (regex) {
                var result;

                if (!self.isRegExp(regex)) {
                    // Use the native `RegExp` rather than `XRegExp`
                    regex = new RegExp(regex);
                } else if (regex.global) {
                    result = nativ.match.apply(this, arguments);

                    // Fixes IE bug
                    regex.lastIndex = 0;

                    return result;
                }

                return fixed.exec.call(regex, toObject(this));
            };

            /**
            * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
            * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes
            * browser bugs in replacement text syntax when performing a replacement using a nonregex search
            * value, and the value of a replacement regex's `lastIndex` property during replacement iterations
            * and upon completion. Note that this doesn't support SpiderMonkey's proprietary third (`flags`)
            * argument. Calling `XRegExp.install('natives')` uses this to override the native method. Use via
            * `XRegExp.replace` without overriding natives.
            * @private
            * @param {RegExp|String} search Search pattern to be replaced.
            * @param {String|Function} replacement Replacement string or a function invoked to create it.
            * @returns {String} New string with one or all matches replaced.
            */
            fixed.replace = function (search, replacement) {
                var isRegex = self.isRegExp(search), origLastIndex, captureNames, result;

                if (isRegex) {
                    if (search[REGEX_DATA]) {
                        captureNames = search[REGEX_DATA].captureNames;
                    }

                    // Only needed if `search` is nonglobal
                    origLastIndex = search.lastIndex;
                } else {
                    search += ''; // Type-convert
                }

                // Don't use `typeof`; some older browsers return 'function' for regex objects
                if (isType(replacement, 'Function')) {
                    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
                    // functions isn't type-converted to a string
                    result = nativ.replace.call(String(this), search, function () {
                        var args = arguments, i;
                        if (captureNames) {
                            // Change the `arguments[0]` string primitive to a `String` object that can
                            // store properties. This really does need to use `String` as a constructor
                            args[0] = new String(args[0]);

                            for (i = 0; i < captureNames.length; ++i) {
                                if (captureNames[i]) {
                                    args[0][captureNames[i]] = args[i + 1];
                                }
                            }
                        }

                        // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox,
                        // Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
                        if (isRegex && search.global) {
                            search.lastIndex = args[args.length - 2] + args[0].length;
                        }

                        // Should pass `undefined` as context; see
                        // <https://bugs.ecmascript.org/show_bug.cgi?id=154>
                        return replacement.apply(undefined, args);
                    });
                } else {
                    // Ensure that the last value of `args` will be a string when given nonstring `this`,
                    // while still throwing on `null` or `undefined` context
                    result = nativ.replace.call(this == null ? this : String(this), search, function () {
                        // Keep this function's `arguments` available through closure
                        var args = arguments;
                        return nativ.replace.call(String(replacement), replacementToken, function ($0, $1, $2) {
                            var n;

                            // Named or numbered backreference with curly braces
                            if ($1) {
                                /* XRegExp behavior for `${n}`:
                                * 1. Backreference to numbered capture, if `n` is an integer. Use `0` for
                                *    for the entire match. Any number of leading zeros may be used.
                                * 2. Backreference to named capture `n`, if it exists and is not an
                                *    integer overridden by numbered capture. In practice, this does not
                                *    overlap with numbered capture since XRegExp does not allow named
                                *    capture to use a bare integer as the name.
                                * 3. If the name or number does not refer to an existing capturing group,
                                *    it's an error.
                                */
                                n = +$1; // Type-convert; drop leading zeros
                                if (n <= args.length - 3) {
                                    return args[n] || '';
                                }

                                // Groups with the same name is an error, else would need `lastIndexOf`
                                n = captureNames ? indexOf(captureNames, $1) : -1;
                                if (n < 0) {
                                    throw new SyntaxError('Backreference to undefined group ' + $0);
                                }
                                return args[n + 1] || '';
                            }

                            // Else, special variable or numbered backreference without curly braces
                            if ($2 === '$') {
                                return '$';
                            }
                            if ($2 === '&' || +$2 === 0) {
                                return args[0];
                            }
                            if ($2 === '`') {
                                return args[args.length - 1].slice(0, args[args.length - 2]);
                            }
                            if ($2 === "'") {
                                return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                            }

                            // Else, numbered backreference without curly braces
                            $2 = +$2; // Type-convert; drop leading zero

                            /* XRegExp behavior for `$n` and `$nn`:
                            * - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                            * - `$1` is an error if no capturing groups.
                            * - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                            * - `$01` is `$1` if at least one capturing group, else it's an error.
                            * - `$0` (not followed by 1-9) and `$00` are the entire match.
                            * Native behavior, for comparison:
                            * - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                            * - `$1` is a literal `$1` if no capturing groups.
                            * - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                            * - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                            * - `$0` is a literal `$0`.
                            */
                            if (!isNaN($2)) {
                                if ($2 > args.length - 3) {
                                    throw new SyntaxError('Backreference to undefined group ' + $0);
                                }
                                return args[$2] || '';
                            }
                            throw new SyntaxError('Invalid token ' + $0);
                        });
                    });
                }

                if (isRegex) {
                    if (search.global) {
                        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
                        search.lastIndex = 0;
                    } else {
                        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
                        search.lastIndex = origLastIndex;
                    }
                }

                return result;
            };

            /**
            * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
            * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
            * @private
            * @param {RegExp|String} separator Regex or string to use for separating the string.
            * @param {Number} [limit] Maximum number of items to include in the result array.
            * @returns {Array} Array of substrings.
            */
            fixed.split = function (separator, limit) {
                if (!self.isRegExp(separator)) {
                    // Browsers handle nonregex split correctly, so use the faster native method
                    return nativ.split.apply(this, arguments);
                }

                var str = String(this), output = [], origLastIndex = separator.lastIndex, lastLastIndex = 0, lastLength;

                /* Values for `limit`, per the spec:
                * If undefined: pow(2,32) - 1
                * If 0, Infinity, or NaN: 0
                * If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
                * If negative number: pow(2,32) - floor(abs(limit))
                * If other: Type-convert, then use the above rules
                */
                // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63,
                // unless Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
                limit = (limit === undefined ? -1 : limit) >>> 0;

                self.forEach(str, separator, function (match) {
                    // This condition is not the same as `if (match[0].length)`
                    if ((match.index + match[0].length) > lastLastIndex) {
                        output.push(str.slice(lastLastIndex, match.index));
                        if (match.length > 1 && match.index < str.length) {
                            Array.prototype.push.apply(output, match.slice(1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = match.index + lastLength;
                    }
                });

                if (lastLastIndex === str.length) {
                    if (!nativ.test.call(separator, '') || lastLength) {
                        output.push('');
                    }
                } else {
                    output.push(str.slice(lastLastIndex));
                }

                separator.lastIndex = origLastIndex;
                return output.length > limit ? output.slice(0, limit) : output;
            };

            /* ==============================
            * Built-in syntax/flag tokens
            * ============================== */
            add = self.addToken;

            /* Letter identity escapes that natively match literal characters: `\a`, `\A`, etc. These should be
            * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
            * consistency and to reserve their syntax, but lets them be superseded by addons.
            */
            add(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4})|x(?![\dA-Fa-f]{2}))/, function (match, scope) {
                // \B is allowed in default scope only
                if (match[1] === 'B' && scope === defaultScope) {
                    return match[0];
                }
                throw new SyntaxError('Invalid escape ' + match[0]);
            }, { scope: 'all' });

            /* Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
            * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
            * character class endings can't be determined.
            */
            add(/\[(\^?)]/, function (match) {
                // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
                // (?!) should work like \b\B, but is unreliable in some versions of Firefox
                return match[1] ? '[\\s\\S]' : '\\b\\B';
            });

            /* Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
            * free-spacing mode (flag x).
            */
            add(/\(\?#[^)]*\)/, function (match, scope, flags) {
                // Keep tokens separated unless the following token is a quantifier
                return isQuantifierNext(match.input, match.index + match[0].length, flags) ? '' : '(?:)';
            });

            /* Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
            */
            add(/\s+|#.*/, function (match, scope, flags) {
                // Keep tokens separated unless the following token is a quantifier
                return isQuantifierNext(match.input, match.index + match[0].length, flags) ? '' : '(?:)';
            }, { flag: 'x' });

            /* Dot, in dotall mode (aka singleline mode, flag s) only.
            */
            add(/\./, function () {
                return '[\\s\\S]';
            }, { flag: 's' });

            /* Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
            * and $ only. Also allows numbered backreferences as `\k<n>`.
            */
            add(/\\k<([\w$]+)>/, function (match) {
                // Groups with the same name is an error, else would need `lastIndexOf`
                var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1], endIndex = match.index + match[0].length;
                if (!index || index > this.captureNames.length) {
                    throw new SyntaxError('Backreference to undefined group ' + match[0]);
                }

                // Keep backreferences separate from subsequent literal numbers
                return '\\' + index + (endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? '' : '(?:)');
            });

            /* Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
            * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
            * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
            */
            add(/\\(\d+)/, function (match, scope) {
                if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {
                    throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' + match[0]);
                }
                return match[0];
            }, { scope: 'all' });

            /* Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
            * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
            * `(?P<name>` as an alternate syntax to avoid issues in recent Opera (which natively supports the
            * Python-style syntax). Otherwise, XRegExp might treat numbered backreferences to Python-style
            * named capture as octals.
            */
            add(/\(\?P?<([\w$]+)>/, function (match) {
                // Disallow bare integers as names because named backreferences are added to match
                // arrays and therefore numeric properties may lead to incorrect lookups
                if (!isNaN(match[1])) {
                    throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
                }
                if (match[1] === 'length' || match[1] === '__proto__') {
                    throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
                }
                if (indexOf(this.captureNames, match[1]) > -1) {
                    throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
                }
                this.captureNames.push(match[1]);
                this.hasNamedCapture = true;
                return '(';
            });

            /* Capturing group; match the opening parenthesis only. Required for support of named capturing
            * groups. Also adds explicit capture mode (flag n).
            */
            add(/\((?!\?)/, function (match, scope, flags) {
                if (flags.indexOf('n') > -1) {
                    return '(?:';
                }
                this.captureNames.push(null);
                return '(';
            }, { optionalFlags: 'n' });

            /* ==============================
            * Expose XRegExp
            * ============================== */
            return self;
        }());
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

Shumway.AVM2.XRegExp.install({ natives: true });
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /**
        * TypedArray Vector Template
        *
        * If you make any changes to this code you'll need to regenerate uint32Vector.ts & float64Vector.ts. We duplicate all
        * the code for vectors because we want to keep things monomorphic as much as possible.
        *
        * NOTE: Not all of the AS3 methods need to be implemented natively, some are self-hosted in AS3 code.
        * For better performance we should probably implement them all natively (in JS that is) unless our
        * compiler is good enough.
        */
        (function (AS) {
            /**
            * Check arguments and throw the appropriate errors.
            */
            var checkArguments = true;

            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var notImplemented = Shumway.Debug.notImplemented;

            var throwError = Shumway.AVM2.Runtime.throwError;

            var clamp = Shumway.NumberUtilities.clamp;
            var asCheckVectorGetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorGetNumericProperty;
            var asCheckVectorSetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorSetNumericProperty;

            var Int32Vector = (function () {
                function Int32Vector(length, fixed) {
                    if (typeof length === "undefined") { length = 0; }
                    if (typeof fixed === "undefined") { fixed = false; }
                    length = length >>> 0;
                    fixed = !!fixed;
                    this._fixed = fixed;
                    this._buffer = new Int32Array(Math.max(Int32Vector.INITIAL_CAPACITY, length + Int32Vector.EXTRA_CAPACITY));
                    this._offset = 0;
                    this._length = length;
                }
                Int32Vector.defaultCompareFunction = function (a, b) {
                    return String(a).localeCompare(String(b));
                };

                Int32Vector.compare = function (a, b, options, compareFunction) {
                    release || assertNotImplemented(!(options & Int32Vector.CASEINSENSITIVE), "CASEINSENSITIVE");
                    release || assertNotImplemented(!(options & Int32Vector.UNIQUESORT), "UNIQUESORT");
                    release || assertNotImplemented(!(options & Int32Vector.RETURNINDEXEDARRAY), "RETURNINDEXEDARRAY");
                    var result = 0;
                    if (!compareFunction) {
                        compareFunction = Int32Vector.defaultCompareFunction;
                    }
                    if (options & Int32Vector.NUMERIC) {
                        a = Shumway.toNumber(a);
                        b = Shumway.toNumber(b);
                        result = a < b ? -1 : (a > b ? 1 : 0);
                    } else {
                        result = compareFunction(a, b);
                    }
                    if (options & Int32Vector.DESCENDING) {
                        result *= -1;
                    }
                    return result;
                };

                Int32Vector.callable = function (object) {
                    if (object instanceof Int32Vector) {
                        return object;
                    }
                    var length = object.asGetProperty(undefined, "length");
                    if (length !== undefined) {
                        var v = new Int32Vector(length, false);
                        for (var i = 0; i < length; i++) {
                            v.asSetNumericProperty(i, object.asGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };

                Int32Vector.prototype.internalToString = function () {
                    var str = "";
                    var start = this._offset;
                    var end = start + this._length;
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (i === start) {
                            str += "[";
                        }
                        if (i === end) {
                            str += "]";
                        }
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ",";
                        }
                    }
                    if (this._offset + this._length === this._buffer.length) {
                        str += "]";
                    }
                    return str + ": offset: " + this._offset + ", length: " + this._length + ", capacity: " + this._buffer.length;
                };

                Int32Vector.prototype.toString = function () {
                    var str = "";
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ",";
                        }
                    }
                    return str;
                };

                // vector.prototype.toString = vector.prototype.internalToString;
                Int32Vector.prototype._view = function () {
                    return this._buffer.subarray(this._offset, this._offset + this._length);
                };

                Int32Vector.prototype._ensureCapacity = function (length) {
                    var minCapacity = this._offset + length;
                    if (minCapacity < this._buffer.length) {
                        return;
                    }
                    if (length <= this._buffer.length) {
                        // New length exceeds bounds at current offset but fits in the buffer, so we center it.
                        var offset = (this._buffer.length - length) >> 2;
                        this._buffer.set(this._view(), offset);
                        this._offset = offset;
                        return;
                    }

                    // New length doesn't fit at all, resize buffer.
                    var oldCapacity = this._buffer.length;
                    var newCapacity = ((oldCapacity * 3) >> 1) + 1;
                    if (newCapacity < minCapacity) {
                        newCapacity = minCapacity;
                    }
                    var buffer = new Int32Array(newCapacity);
                    buffer.set(this._buffer, 0);
                    this._buffer = buffer;
                };

                Int32Vector.prototype.concat = function () {
                    notImplemented("Int32Vector.concat");
                };

                /**
                * Executes a |callback| function with three arguments: element, index, the vector itself as well
                * as passing the |thisObject| as |this| for each of the elements in the vector. If any of the
                * callbacks return |false| the function terminates, otherwise it returns |true|.
                */
                Int32Vector.prototype.every = function (callback, thisObject) {
                    for (var i = 0; i < this._length; i++) {
                        if (!callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return false;
                        }
                    }
                    return true;
                };

                /**
                * Filters the elements for which the |callback| method returns |true|. The |callback| function
                * is called with three arguments: element, index, the vector itself as well as passing the |thisObject|
                * as |this| for each of the elements in the vector.
                */
                Int32Vector.prototype.filter = function (callback, thisObject) {
                    var v = new Int32Vector();
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            v.push(this.asGetNumericProperty(i));
                        }
                    }
                    return v;
                };

                Int32Vector.prototype.some = function (callback, thisObject) {
                    if (arguments.length !== 2) {
                        throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError);
                    } else if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return true;
                        }
                    }
                    return false;
                };

                Int32Vector.prototype.forEach = function (callback, thisObject) {
                    for (var i = 0; i < this._length; i++) {
                        callback.call(thisObject, this.asGetNumericProperty(i), i, this);
                    }
                };

                Int32Vector.prototype.join = function (sep) {
                    notImplemented("Int32Vector.join");
                };

                Int32Vector.prototype.indexOf = function (searchElement, fromIndex) {
                    notImplemented("Int32Vector.indexOf");
                };

                Int32Vector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    notImplemented("Int32Vector.lastIndexOf");
                };

                Int32Vector.prototype.map = function (callback, thisObject) {
                    if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    var v = new Int32Vector();
                    for (var i = 0; i < this._length; i++) {
                        v.push(callback.call(thisObject, this.asGetNumericProperty(i), i, this));
                    }
                    return v;
                };

                Int32Vector.prototype.push = function () {
                    var rest = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        rest[_i] = arguments[_i + 0];
                    }
                    this._checkFixed();
                    this._ensureCapacity(this._length + arguments.length);
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + this._length++] = arguments[i];
                    }
                };

                Int32Vector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return Int32Vector.DEFAULT_VALUE;
                    }
                    this._length--;
                    return this._buffer[this._offset + this._length];
                };

                Int32Vector.prototype.reverse = function () {
                    var l = this._offset;
                    var r = this._offset + this._length - 1;
                    var b = this._buffer;
                    while (l < r) {
                        var t = b[l];
                        b[l] = b[r];
                        b[r] = t;
                        l++;
                        r--;
                    }
                };

                Int32Vector._sort = function (a) {
                    var stack = [];
                    var sp = -1;
                    var l = 0;
                    var r = a.length - 1;
                    var i, j, swap, temp;
                    while (true) {
                        if (r - l <= 100) {
                            for (j = l + 1; j <= r; j++) {
                                swap = a[j];
                                i = j - 1;
                                while (i >= l && a[i] > swap) {
                                    a[i + 1] = a[i--];
                                }
                                a[i + 1] = swap;
                            }
                            if (sp == -1) {
                                break;
                            }
                            r = stack[sp--];
                            l = stack[sp--];
                        } else {
                            var median = l + r >> 1;
                            i = l + 1;
                            j = r;
                            swap = a[median];
                            a[median] = a[i];
                            a[i] = swap;
                            if (a[l] > a[r]) {
                                swap = a[l];
                                a[l] = a[r];
                                a[r] = swap;
                            }
                            if (a[i] > a[r]) {
                                swap = a[i];
                                a[i] = a[r];
                                a[r] = swap;
                            }
                            if (a[l] > a[i]) {
                                swap = a[l];
                                a[l] = a[i];
                                a[i] = swap;
                            }
                            temp = a[i];
                            while (true) {
                                do {
                                    i++;
                                } while(a[i] < temp);
                                do {
                                    j--;
                                } while(a[j] > temp);
                                if (j < i) {
                                    break;
                                }
                                swap = a[i];
                                a[i] = a[j];
                                a[j] = swap;
                            }
                            a[l + 1] = a[j];
                            a[j] = temp;
                            if (r - i + 1 >= j - l) {
                                stack[++sp] = i;
                                stack[++sp] = r;
                                r = j - 1;
                            } else {
                                stack[++sp] = l;
                                stack[++sp] = j - 1;
                                l = i;
                            }
                        }
                    }
                    return a;
                };

                Int32Vector.prototype._sortNumeric = function (descending) {
                    Int32Vector._sort(this._view());
                    if (descending) {
                        this.reverse();
                    }
                };

                Int32Vector.prototype.sort = function () {
                    if (arguments.length === 0) {
                        return Array.prototype.sort.call(this._view());
                    }
                    var compareFunction, options = 0;
                    if (arguments[0] instanceof Function) {
                        compareFunction = arguments[0];
                    } else if (Shumway.isNumber(arguments[0])) {
                        options = arguments[0];
                    }
                    if (Shumway.isNumber(arguments[1])) {
                        options = arguments[1];
                    }
                    if (options & Int32Vector.NUMERIC) {
                        return this._sortNumeric(options & Int32Vector.DESCENDING);
                    }
                    Array.prototype.sort.call(this._view(), function (a, b) {
                        return Int32Vector.compare(a, b, options, compareFunction);
                    });
                };

                Int32Vector.prototype.asGetNumericProperty = function (i) {
                    checkArguments && asCheckVectorGetNumericProperty(i, this._length);
                    return this._buffer[this._offset + i];
                };

                Int32Vector.prototype.asSetNumericProperty = function (i, v) {
                    checkArguments && asCheckVectorSetNumericProperty(i, this._length, this._fixed);
                    if (i === this._length) {
                        this._ensureCapacity(this._length + 1);
                        this._length++;
                    }
                    this._buffer[this._offset + i] = v;
                };

                Int32Vector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return 0;
                    }
                    this._length--;
                    return this._buffer[this._offset++];
                };

                Int32Vector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        throwError("RangeError", AVM2.Errors.VectorFixedError);
                    }
                };

                Int32Vector.prototype._slide = function (distance) {
                    this._buffer.set(this._view(), this._offset + distance);
                    this._offset += distance;
                };

                Int32Vector.prototype.unshift = function () {
                    this._checkFixed();
                    if (!arguments.length) {
                        return;
                    }
                    this._ensureCapacity(this._length + arguments.length);
                    this._slide(arguments.length);
                    this._offset -= arguments.length;
                    this._length += arguments.length;
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + i] = arguments[i];
                    }
                };

                Int32Vector.prototype.asHasProperty = function (namespaces, name, flags) {
                    if (Int32Vector.prototype === this || !Shumway.isNumeric(name)) {
                        return Object.prototype.asHasProperty.call(this, namespaces, name, flags);
                    }
                    var index = Shumway.toNumber(name);
                    return index >= 0 && index < this._length;
                };

                Object.defineProperty(Int32Vector.prototype, "length", {
                    get: function () {
                        return this._length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._length) {
                            this._ensureCapacity(value);
                            for (var i = this._offset + this._length, j = this._offset + value; i < j; i++) {
                                this._buffer[i] = Int32Vector.DEFAULT_VALUE;
                            }
                        }
                        this._length = value;
                    },
                    enumerable: true,
                    configurable: true
                });



                Object.defineProperty(Int32Vector.prototype, "fixed", {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Delete |deleteCount| elements starting at |index| then insert |insertCount| elements
                * from |args| object starting at |offset|.
                */
                Int32Vector.prototype._spliceHelper = function (index, insertCount, deleteCount, args, offset) {
                    insertCount = clamp(insertCount, 0, args.length - offset);
                    deleteCount = clamp(deleteCount, 0, this._length - index);
                    this._ensureCapacity(this._length - deleteCount + insertCount);
                    var right = this._offset + index + deleteCount;
                    var slice = this._buffer.subarray(right, right + this._length - index - deleteCount);
                    this._buffer.set(slice, this._offset + index + insertCount);
                    this._length += insertCount - deleteCount;
                    for (var i = 0; i < insertCount; i++) {
                        this._buffer[this._offset + index + i] = args.asGetNumericProperty(offset + i);
                    }
                };

                Int32Vector.prototype.asNextName = function (index) {
                    return index - 1;
                };

                Int32Vector.prototype.asNextValue = function (index) {
                    return this._buffer[this._offset + index - 1];
                };

                Int32Vector.prototype.asNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._length) {
                        return nextNameIndex;
                    }
                    return 0;
                };

                Int32Vector.prototype.asHasNext2 = function (hasNext2Info) {
                    hasNext2Info.index = this.asNextNameIndex(hasNext2Info.index);
                };
                Int32Vector.EXTRA_CAPACITY = 4;
                Int32Vector.INITIAL_CAPACITY = 10;
                Int32Vector.DEFAULT_VALUE = 0;

                Int32Vector.CASEINSENSITIVE = 1;
                Int32Vector.DESCENDING = 2;
                Int32Vector.UNIQUESORT = 4;
                Int32Vector.RETURNINDEXEDARRAY = 8;
                Int32Vector.NUMERIC = 16;
                return Int32Vector;
            })();
            AS.Int32Vector = Int32Vector;

            Int32Vector.prototype._reverse = Int32Vector.prototype.reverse;
            Int32Vector.prototype._filter = Int32Vector.prototype.filter;
            Int32Vector.prototype._map = Int32Vector.prototype.map;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/* THIS FILE WAS AUTOMATICALLY GENERATED FROM int32Vector.ts */
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /*
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *     http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        /**
        * TypedArray Vector Template
        *
        * If you make any changes to this code you'll need to regenerate uint32Vector.ts & float64Vector.ts. We duplicate all
        * the code for vectors because we want to keep things monomorphic as much as possible.
        *
        * NOTE: Not all of the AS3 methods need to be implemented natively, some are self-hosted in AS3 code.
        * For better performance we should probably implement them all natively (in JS that is) unless our
        * compiler is good enough.
        */
        (function (AS) {
            /**
            * Check arguments and throw the appropriate errors.
            */
            var checkArguments = true;

            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var notImplemented = Shumway.Debug.notImplemented;

            var throwError = Shumway.AVM2.Runtime.throwError;

            var clamp = Shumway.NumberUtilities.clamp;
            var asCheckVectorGetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorGetNumericProperty;
            var asCheckVectorSetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorSetNumericProperty;

            var Uint32Vector = (function () {
                function Uint32Vector(length, fixed) {
                    if (typeof length === "undefined") { length = 0; }
                    if (typeof fixed === "undefined") { fixed = false; }
                    length = length >>> 0;
                    fixed = !!fixed;
                    this._fixed = fixed;
                    this._buffer = new Uint32Array(Math.max(Uint32Vector.INITIAL_CAPACITY, length + Uint32Vector.EXTRA_CAPACITY));
                    this._offset = 0;
                    this._length = length;
                }
                Uint32Vector.defaultCompareFunction = function (a, b) {
                    return String(a).localeCompare(String(b));
                };

                Uint32Vector.compare = function (a, b, options, compareFunction) {
                    release || assertNotImplemented(!(options & Uint32Vector.CASEINSENSITIVE), "CASEINSENSITIVE");
                    release || assertNotImplemented(!(options & Uint32Vector.UNIQUESORT), "UNIQUESORT");
                    release || assertNotImplemented(!(options & Uint32Vector.RETURNINDEXEDARRAY), "RETURNINDEXEDARRAY");
                    var result = 0;
                    if (!compareFunction) {
                        compareFunction = Uint32Vector.defaultCompareFunction;
                    }
                    if (options & Uint32Vector.NUMERIC) {
                        a = Shumway.toNumber(a);
                        b = Shumway.toNumber(b);
                        result = a < b ? -1 : (a > b ? 1 : 0);
                    } else {
                        result = compareFunction(a, b);
                    }
                    if (options & Uint32Vector.DESCENDING) {
                        result *= -1;
                    }
                    return result;
                };

                Uint32Vector.callable = function (object) {
                    if (object instanceof Uint32Vector) {
                        return object;
                    }
                    var length = object.asGetProperty(undefined, "length");
                    if (length !== undefined) {
                        var v = new Uint32Vector(length, false);
                        for (var i = 0; i < length; i++) {
                            v.asSetNumericProperty(i, object.asGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };

                Uint32Vector.prototype.internalToString = function () {
                    var str = "";
                    var start = this._offset;
                    var end = start + this._length;
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (i === start) {
                            str += "[";
                        }
                        if (i === end) {
                            str += "]";
                        }
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ",";
                        }
                    }
                    if (this._offset + this._length === this._buffer.length) {
                        str += "]";
                    }
                    return str + ": offset: " + this._offset + ", length: " + this._length + ", capacity: " + this._buffer.length;
                };

                Uint32Vector.prototype.toString = function () {
                    var str = "";
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ",";
                        }
                    }
                    return str;
                };

                // vector.prototype.toString = vector.prototype.internalToString;
                Uint32Vector.prototype._view = function () {
                    return this._buffer.subarray(this._offset, this._offset + this._length);
                };

                Uint32Vector.prototype._ensureCapacity = function (length) {
                    var minCapacity = this._offset + length;
                    if (minCapacity < this._buffer.length) {
                        return;
                    }
                    if (length <= this._buffer.length) {
                        // New length exceeds bounds at current offset but fits in the buffer, so we center it.
                        var offset = (this._buffer.length - length) >> 2;
                        this._buffer.set(this._view(), offset);
                        this._offset = offset;
                        return;
                    }

                    // New length doesn't fit at all, resize buffer.
                    var oldCapacity = this._buffer.length;
                    var newCapacity = ((oldCapacity * 3) >> 1) + 1;
                    if (newCapacity < minCapacity) {
                        newCapacity = minCapacity;
                    }
                    var buffer = new Uint32Array(newCapacity);
                    buffer.set(this._buffer, 0);
                    this._buffer = buffer;
                };

                Uint32Vector.prototype.concat = function () {
                    notImplemented("Uint32Vector.concat");
                };

                /**
                * Executes a |callback| function with three arguments: element, index, the vector itself as well
                * as passing the |thisObject| as |this| for each of the elements in the vector. If any of the
                * callbacks return |false| the function terminates, otherwise it returns |true|.
                */
                Uint32Vector.prototype.every = function (callback, thisObject) {
                    for (var i = 0; i < this._length; i++) {
                        if (!callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return false;
                        }
                    }
                    return true;
                };

                /**
                * Filters the elements for which the |callback| method returns |true|. The |callback| function
                * is called with three arguments: element, index, the vector itself as well as passing the |thisObject|
                * as |this| for each of the elements in the vector.
                */
                Uint32Vector.prototype.filter = function (callback, thisObject) {
                    var v = new Uint32Vector();
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            v.push(this.asGetNumericProperty(i));
                        }
                    }
                    return v;
                };

                Uint32Vector.prototype.some = function (callback, thisObject) {
                    if (arguments.length !== 2) {
                        throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError);
                    } else if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return true;
                        }
                    }
                    return false;
                };

                Uint32Vector.prototype.forEach = function (callback, thisObject) {
                    for (var i = 0; i < this._length; i++) {
                        callback.call(thisObject, this.asGetNumericProperty(i), i, this);
                    }
                };

                Uint32Vector.prototype.join = function (sep) {
                    notImplemented("Uint32Vector.join");
                };

                Uint32Vector.prototype.indexOf = function (searchElement, fromIndex) {
                    notImplemented("Uint32Vector.indexOf");
                };

                Uint32Vector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    notImplemented("Uint32Vector.lastIndexOf");
                };

                Uint32Vector.prototype.map = function (callback, thisObject) {
                    if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    var v = new Uint32Vector();
                    for (var i = 0; i < this._length; i++) {
                        v.push(callback.call(thisObject, this.asGetNumericProperty(i), i, this));
                    }
                    return v;
                };

                Uint32Vector.prototype.push = function () {
                    var rest = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        rest[_i] = arguments[_i + 0];
                    }
                    this._checkFixed();
                    this._ensureCapacity(this._length + arguments.length);
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + this._length++] = arguments[i];
                    }
                };

                Uint32Vector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return Uint32Vector.DEFAULT_VALUE;
                    }
                    this._length--;
                    return this._buffer[this._offset + this._length];
                };

                Uint32Vector.prototype.reverse = function () {
                    var l = this._offset;
                    var r = this._offset + this._length - 1;
                    var b = this._buffer;
                    while (l < r) {
                        var t = b[l];
                        b[l] = b[r];
                        b[r] = t;
                        l++;
                        r--;
                    }
                };

                Uint32Vector._sort = function (a) {
                    var stack = [];
                    var sp = -1;
                    var l = 0;
                    var r = a.length - 1;
                    var i, j, swap, temp;
                    while (true) {
                        if (r - l <= 100) {
                            for (j = l + 1; j <= r; j++) {
                                swap = a[j];
                                i = j - 1;
                                while (i >= l && a[i] > swap) {
                                    a[i + 1] = a[i--];
                                }
                                a[i + 1] = swap;
                            }
                            if (sp == -1) {
                                break;
                            }
                            r = stack[sp--];
                            l = stack[sp--];
                        } else {
                            var median = l + r >> 1;
                            i = l + 1;
                            j = r;
                            swap = a[median];
                            a[median] = a[i];
                            a[i] = swap;
                            if (a[l] > a[r]) {
                                swap = a[l];
                                a[l] = a[r];
                                a[r] = swap;
                            }
                            if (a[i] > a[r]) {
                                swap = a[i];
                                a[i] = a[r];
                                a[r] = swap;
                            }
                            if (a[l] > a[i]) {
                                swap = a[l];
                                a[l] = a[i];
                                a[i] = swap;
                            }
                            temp = a[i];
                            while (true) {
                                do {
                                    i++;
                                } while(a[i] < temp);
                                do {
                                    j--;
                                } while(a[j] > temp);
                                if (j < i) {
                                    break;
                                }
                                swap = a[i];
                                a[i] = a[j];
                                a[j] = swap;
                            }
                            a[l + 1] = a[j];
                            a[j] = temp;
                            if (r - i + 1 >= j - l) {
                                stack[++sp] = i;
                                stack[++sp] = r;
                                r = j - 1;
                            } else {
                                stack[++sp] = l;
                                stack[++sp] = j - 1;
                                l = i;
                            }
                        }
                    }
                    return a;
                };

                Uint32Vector.prototype._sortNumeric = function (descending) {
                    Uint32Vector._sort(this._view());
                    if (descending) {
                        this.reverse();
                    }
                };

                Uint32Vector.prototype.sort = function () {
                    if (arguments.length === 0) {
                        return Array.prototype.sort.call(this._view());
                    }
                    var compareFunction, options = 0;
                    if (arguments[0] instanceof Function) {
                        compareFunction = arguments[0];
                    } else if (Shumway.isNumber(arguments[0])) {
                        options = arguments[0];
                    }
                    if (Shumway.isNumber(arguments[1])) {
                        options = arguments[1];
                    }
                    if (options & Uint32Vector.NUMERIC) {
                        return this._sortNumeric(options & Uint32Vector.DESCENDING);
                    }
                    Array.prototype.sort.call(this._view(), function (a, b) {
                        return Uint32Vector.compare(a, b, options, compareFunction);
                    });
                };

                Uint32Vector.prototype.asGetNumericProperty = function (i) {
                    checkArguments && asCheckVectorGetNumericProperty(i, this._length);
                    return this._buffer[this._offset + i];
                };

                Uint32Vector.prototype.asSetNumericProperty = function (i, v) {
                    checkArguments && asCheckVectorSetNumericProperty(i, this._length, this._fixed);
                    if (i === this._length) {
                        this._ensureCapacity(this._length + 1);
                        this._length++;
                    }
                    this._buffer[this._offset + i] = v;
                };

                Uint32Vector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return 0;
                    }
                    this._length--;
                    return this._buffer[this._offset++];
                };

                Uint32Vector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        throwError("RangeError", AVM2.Errors.VectorFixedError);
                    }
                };

                Uint32Vector.prototype._slide = function (distance) {
                    this._buffer.set(this._view(), this._offset + distance);
                    this._offset += distance;
                };

                Uint32Vector.prototype.unshift = function () {
                    this._checkFixed();
                    if (!arguments.length) {
                        return;
                    }
                    this._ensureCapacity(this._length + arguments.length);
                    this._slide(arguments.length);
                    this._offset -= arguments.length;
                    this._length += arguments.length;
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + i] = arguments[i];
                    }
                };

                Uint32Vector.prototype.asHasProperty = function (namespaces, name, flags) {
                    if (Uint32Vector.prototype === this || !Shumway.isNumeric(name)) {
                        return Object.prototype.asHasProperty.call(this, namespaces, name, flags);
                    }
                    var index = Shumway.toNumber(name);
                    return index >= 0 && index < this._length;
                };

                Object.defineProperty(Uint32Vector.prototype, "length", {
                    get: function () {
                        return this._length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._length) {
                            this._ensureCapacity(value);
                            for (var i = this._offset + this._length, j = this._offset + value; i < j; i++) {
                                this._buffer[i] = Uint32Vector.DEFAULT_VALUE;
                            }
                        }
                        this._length = value;
                    },
                    enumerable: true,
                    configurable: true
                });



                Object.defineProperty(Uint32Vector.prototype, "fixed", {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Delete |deleteCount| elements starting at |index| then insert |insertCount| elements
                * from |args| object starting at |offset|.
                */
                Uint32Vector.prototype._spliceHelper = function (index, insertCount, deleteCount, args, offset) {
                    insertCount = clamp(insertCount, 0, args.length - offset);
                    deleteCount = clamp(deleteCount, 0, this._length - index);
                    this._ensureCapacity(this._length - deleteCount + insertCount);
                    var right = this._offset + index + deleteCount;
                    var slice = this._buffer.subarray(right, right + this._length - index - deleteCount);
                    this._buffer.set(slice, this._offset + index + insertCount);
                    this._length += insertCount - deleteCount;
                    for (var i = 0; i < insertCount; i++) {
                        this._buffer[this._offset + index + i] = args.asGetNumericProperty(offset + i);
                    }
                };

                Uint32Vector.prototype.asNextName = function (index) {
                    return index - 1;
                };

                Uint32Vector.prototype.asNextValue = function (index) {
                    return this._buffer[this._offset + index - 1];
                };

                Uint32Vector.prototype.asNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._length) {
                        return nextNameIndex;
                    }
                    return 0;
                };

                Uint32Vector.prototype.asHasNext2 = function (hasNext2Info) {
                    hasNext2Info.index = this.asNextNameIndex(hasNext2Info.index);
                };
                Uint32Vector.EXTRA_CAPACITY = 4;
                Uint32Vector.INITIAL_CAPACITY = 10;
                Uint32Vector.DEFAULT_VALUE = 0;

                Uint32Vector.CASEINSENSITIVE = 1;
                Uint32Vector.DESCENDING = 2;
                Uint32Vector.UNIQUESORT = 4;
                Uint32Vector.RETURNINDEXEDARRAY = 8;
                Uint32Vector.NUMERIC = 16;
                return Uint32Vector;
            })();
            AS.Uint32Vector = Uint32Vector;

            Uint32Vector.prototype._reverse = Uint32Vector.prototype.reverse;
            Uint32Vector.prototype._filter = Uint32Vector.prototype.filter;
            Uint32Vector.prototype._map = Uint32Vector.prototype.map;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/* THIS FILE WAS AUTOMATICALLY GENERATED FROM int32Vector.ts */
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /*
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *     http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        /**
        * TypedArray Vector Template
        *
        * If you make any changes to this code you'll need to regenerate uint32Vector.ts & float64Vector.ts. We duplicate all
        * the code for vectors because we want to keep things monomorphic as much as possible.
        *
        * NOTE: Not all of the AS3 methods need to be implemented natively, some are self-hosted in AS3 code.
        * For better performance we should probably implement them all natively (in JS that is) unless our
        * compiler is good enough.
        */
        (function (AS) {
            /**
            * Check arguments and throw the appropriate errors.
            */
            var checkArguments = true;

            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var notImplemented = Shumway.Debug.notImplemented;

            var throwError = Shumway.AVM2.Runtime.throwError;

            var clamp = Shumway.NumberUtilities.clamp;
            var asCheckVectorGetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorGetNumericProperty;
            var asCheckVectorSetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorSetNumericProperty;

            var Float64Vector = (function () {
                function Float64Vector(length, fixed) {
                    if (typeof length === "undefined") { length = 0; }
                    if (typeof fixed === "undefined") { fixed = false; }
                    length = length >>> 0;
                    fixed = !!fixed;
                    this._fixed = fixed;
                    this._buffer = new Float64Array(Math.max(Float64Vector.INITIAL_CAPACITY, length + Float64Vector.EXTRA_CAPACITY));
                    this._offset = 0;
                    this._length = length;
                }
                Float64Vector.defaultCompareFunction = function (a, b) {
                    return String(a).localeCompare(String(b));
                };

                Float64Vector.compare = function (a, b, options, compareFunction) {
                    release || assertNotImplemented(!(options & Float64Vector.CASEINSENSITIVE), "CASEINSENSITIVE");
                    release || assertNotImplemented(!(options & Float64Vector.UNIQUESORT), "UNIQUESORT");
                    release || assertNotImplemented(!(options & Float64Vector.RETURNINDEXEDARRAY), "RETURNINDEXEDARRAY");
                    var result = 0;
                    if (!compareFunction) {
                        compareFunction = Float64Vector.defaultCompareFunction;
                    }
                    if (options & Float64Vector.NUMERIC) {
                        a = Shumway.toNumber(a);
                        b = Shumway.toNumber(b);
                        result = a < b ? -1 : (a > b ? 1 : 0);
                    } else {
                        result = compareFunction(a, b);
                    }
                    if (options & Float64Vector.DESCENDING) {
                        result *= -1;
                    }
                    return result;
                };

                Float64Vector.callable = function (object) {
                    if (object instanceof Float64Vector) {
                        return object;
                    }
                    var length = object.asGetProperty(undefined, "length");
                    if (length !== undefined) {
                        var v = new Float64Vector(length, false);
                        for (var i = 0; i < length; i++) {
                            v.asSetNumericProperty(i, object.asGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };

                Float64Vector.prototype.internalToString = function () {
                    var str = "";
                    var start = this._offset;
                    var end = start + this._length;
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (i === start) {
                            str += "[";
                        }
                        if (i === end) {
                            str += "]";
                        }
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ",";
                        }
                    }
                    if (this._offset + this._length === this._buffer.length) {
                        str += "]";
                    }
                    return str + ": offset: " + this._offset + ", length: " + this._length + ", capacity: " + this._buffer.length;
                };

                Float64Vector.prototype.toString = function () {
                    var str = "";
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ",";
                        }
                    }
                    return str;
                };

                // vector.prototype.toString = vector.prototype.internalToString;
                Float64Vector.prototype._view = function () {
                    return this._buffer.subarray(this._offset, this._offset + this._length);
                };

                Float64Vector.prototype._ensureCapacity = function (length) {
                    var minCapacity = this._offset + length;
                    if (minCapacity < this._buffer.length) {
                        return;
                    }
                    if (length <= this._buffer.length) {
                        // New length exceeds bounds at current offset but fits in the buffer, so we center it.
                        var offset = (this._buffer.length - length) >> 2;
                        this._buffer.set(this._view(), offset);
                        this._offset = offset;
                        return;
                    }

                    // New length doesn't fit at all, resize buffer.
                    var oldCapacity = this._buffer.length;
                    var newCapacity = ((oldCapacity * 3) >> 1) + 1;
                    if (newCapacity < minCapacity) {
                        newCapacity = minCapacity;
                    }
                    var buffer = new Float64Array(newCapacity);
                    buffer.set(this._buffer, 0);
                    this._buffer = buffer;
                };

                Float64Vector.prototype.concat = function () {
                    notImplemented("Float64Vector.concat");
                };

                /**
                * Executes a |callback| function with three arguments: element, index, the vector itself as well
                * as passing the |thisObject| as |this| for each of the elements in the vector. If any of the
                * callbacks return |false| the function terminates, otherwise it returns |true|.
                */
                Float64Vector.prototype.every = function (callback, thisObject) {
                    for (var i = 0; i < this._length; i++) {
                        if (!callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return false;
                        }
                    }
                    return true;
                };

                /**
                * Filters the elements for which the |callback| method returns |true|. The |callback| function
                * is called with three arguments: element, index, the vector itself as well as passing the |thisObject|
                * as |this| for each of the elements in the vector.
                */
                Float64Vector.prototype.filter = function (callback, thisObject) {
                    var v = new Float64Vector();
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            v.push(this.asGetNumericProperty(i));
                        }
                    }
                    return v;
                };

                Float64Vector.prototype.some = function (callback, thisObject) {
                    if (arguments.length !== 2) {
                        throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError);
                    } else if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return true;
                        }
                    }
                    return false;
                };

                Float64Vector.prototype.forEach = function (callback, thisObject) {
                    for (var i = 0; i < this._length; i++) {
                        callback.call(thisObject, this.asGetNumericProperty(i), i, this);
                    }
                };

                Float64Vector.prototype.join = function (sep) {
                    notImplemented("Float64Vector.join");
                };

                Float64Vector.prototype.indexOf = function (searchElement, fromIndex) {
                    notImplemented("Float64Vector.indexOf");
                };

                Float64Vector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    notImplemented("Float64Vector.lastIndexOf");
                };

                Float64Vector.prototype.map = function (callback, thisObject) {
                    if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    var v = new Float64Vector();
                    for (var i = 0; i < this._length; i++) {
                        v.push(callback.call(thisObject, this.asGetNumericProperty(i), i, this));
                    }
                    return v;
                };

                Float64Vector.prototype.push = function () {
                    var rest = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        rest[_i] = arguments[_i + 0];
                    }
                    this._checkFixed();
                    this._ensureCapacity(this._length + arguments.length);
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + this._length++] = arguments[i];
                    }
                };

                Float64Vector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return Float64Vector.DEFAULT_VALUE;
                    }
                    this._length--;
                    return this._buffer[this._offset + this._length];
                };

                Float64Vector.prototype.reverse = function () {
                    var l = this._offset;
                    var r = this._offset + this._length - 1;
                    var b = this._buffer;
                    while (l < r) {
                        var t = b[l];
                        b[l] = b[r];
                        b[r] = t;
                        l++;
                        r--;
                    }
                };

                Float64Vector._sort = function (a) {
                    var stack = [];
                    var sp = -1;
                    var l = 0;
                    var r = a.length - 1;
                    var i, j, swap, temp;
                    while (true) {
                        if (r - l <= 100) {
                            for (j = l + 1; j <= r; j++) {
                                swap = a[j];
                                i = j - 1;
                                while (i >= l && a[i] > swap) {
                                    a[i + 1] = a[i--];
                                }
                                a[i + 1] = swap;
                            }
                            if (sp == -1) {
                                break;
                            }
                            r = stack[sp--];
                            l = stack[sp--];
                        } else {
                            var median = l + r >> 1;
                            i = l + 1;
                            j = r;
                            swap = a[median];
                            a[median] = a[i];
                            a[i] = swap;
                            if (a[l] > a[r]) {
                                swap = a[l];
                                a[l] = a[r];
                                a[r] = swap;
                            }
                            if (a[i] > a[r]) {
                                swap = a[i];
                                a[i] = a[r];
                                a[r] = swap;
                            }
                            if (a[l] > a[i]) {
                                swap = a[l];
                                a[l] = a[i];
                                a[i] = swap;
                            }
                            temp = a[i];
                            while (true) {
                                do {
                                    i++;
                                } while(a[i] < temp);
                                do {
                                    j--;
                                } while(a[j] > temp);
                                if (j < i) {
                                    break;
                                }
                                swap = a[i];
                                a[i] = a[j];
                                a[j] = swap;
                            }
                            a[l + 1] = a[j];
                            a[j] = temp;
                            if (r - i + 1 >= j - l) {
                                stack[++sp] = i;
                                stack[++sp] = r;
                                r = j - 1;
                            } else {
                                stack[++sp] = l;
                                stack[++sp] = j - 1;
                                l = i;
                            }
                        }
                    }
                    return a;
                };

                Float64Vector.prototype._sortNumeric = function (descending) {
                    Float64Vector._sort(this._view());
                    if (descending) {
                        this.reverse();
                    }
                };

                Float64Vector.prototype.sort = function () {
                    if (arguments.length === 0) {
                        return Array.prototype.sort.call(this._view());
                    }
                    var compareFunction, options = 0;
                    if (arguments[0] instanceof Function) {
                        compareFunction = arguments[0];
                    } else if (Shumway.isNumber(arguments[0])) {
                        options = arguments[0];
                    }
                    if (Shumway.isNumber(arguments[1])) {
                        options = arguments[1];
                    }
                    if (options & Float64Vector.NUMERIC) {
                        return this._sortNumeric(options & Float64Vector.DESCENDING);
                    }
                    Array.prototype.sort.call(this._view(), function (a, b) {
                        return Float64Vector.compare(a, b, options, compareFunction);
                    });
                };

                Float64Vector.prototype.asGetNumericProperty = function (i) {
                    checkArguments && asCheckVectorGetNumericProperty(i, this._length);
                    return this._buffer[this._offset + i];
                };

                Float64Vector.prototype.asSetNumericProperty = function (i, v) {
                    checkArguments && asCheckVectorSetNumericProperty(i, this._length, this._fixed);
                    if (i === this._length) {
                        this._ensureCapacity(this._length + 1);
                        this._length++;
                    }
                    this._buffer[this._offset + i] = v;
                };

                Float64Vector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return 0;
                    }
                    this._length--;
                    return this._buffer[this._offset++];
                };

                Float64Vector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        throwError("RangeError", AVM2.Errors.VectorFixedError);
                    }
                };

                Float64Vector.prototype._slide = function (distance) {
                    this._buffer.set(this._view(), this._offset + distance);
                    this._offset += distance;
                };

                Float64Vector.prototype.unshift = function () {
                    this._checkFixed();
                    if (!arguments.length) {
                        return;
                    }
                    this._ensureCapacity(this._length + arguments.length);
                    this._slide(arguments.length);
                    this._offset -= arguments.length;
                    this._length += arguments.length;
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + i] = arguments[i];
                    }
                };

                Float64Vector.prototype.asHasProperty = function (namespaces, name, flags) {
                    if (Float64Vector.prototype === this || !Shumway.isNumeric(name)) {
                        return Object.prototype.asHasProperty.call(this, namespaces, name, flags);
                    }
                    var index = Shumway.toNumber(name);
                    return index >= 0 && index < this._length;
                };

                Object.defineProperty(Float64Vector.prototype, "length", {
                    get: function () {
                        return this._length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._length) {
                            this._ensureCapacity(value);
                            for (var i = this._offset + this._length, j = this._offset + value; i < j; i++) {
                                this._buffer[i] = Float64Vector.DEFAULT_VALUE;
                            }
                        }
                        this._length = value;
                    },
                    enumerable: true,
                    configurable: true
                });



                Object.defineProperty(Float64Vector.prototype, "fixed", {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Delete |deleteCount| elements starting at |index| then insert |insertCount| elements
                * from |args| object starting at |offset|.
                */
                Float64Vector.prototype._spliceHelper = function (index, insertCount, deleteCount, args, offset) {
                    insertCount = clamp(insertCount, 0, args.length - offset);
                    deleteCount = clamp(deleteCount, 0, this._length - index);
                    this._ensureCapacity(this._length - deleteCount + insertCount);
                    var right = this._offset + index + deleteCount;
                    var slice = this._buffer.subarray(right, right + this._length - index - deleteCount);
                    this._buffer.set(slice, this._offset + index + insertCount);
                    this._length += insertCount - deleteCount;
                    for (var i = 0; i < insertCount; i++) {
                        this._buffer[this._offset + index + i] = args.asGetNumericProperty(offset + i);
                    }
                };

                Float64Vector.prototype.asNextName = function (index) {
                    return index - 1;
                };

                Float64Vector.prototype.asNextValue = function (index) {
                    return this._buffer[this._offset + index - 1];
                };

                Float64Vector.prototype.asNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._length) {
                        return nextNameIndex;
                    }
                    return 0;
                };

                Float64Vector.prototype.asHasNext2 = function (hasNext2Info) {
                    hasNext2Info.index = this.asNextNameIndex(hasNext2Info.index);
                };
                Float64Vector.EXTRA_CAPACITY = 4;
                Float64Vector.INITIAL_CAPACITY = 10;
                Float64Vector.DEFAULT_VALUE = 0;

                Float64Vector.CASEINSENSITIVE = 1;
                Float64Vector.DESCENDING = 2;
                Float64Vector.UNIQUESORT = 4;
                Float64Vector.RETURNINDEXEDARRAY = 8;
                Float64Vector.NUMERIC = 16;
                return Float64Vector;
            })();
            AS.Float64Vector = Float64Vector;

            Float64Vector.prototype._reverse = Float64Vector.prototype.reverse;
            Float64Vector.prototype._filter = Float64Vector.prototype.filter;
            Float64Vector.prototype._map = Float64Vector.prototype.map;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var Scope = Shumway.AVM2.Runtime.Scope;
            var hasOwnProperty = Shumway.ObjectUtilities.hasOwnProperty;
            var hasOwnGetter = Shumway.ObjectUtilities.hasOwnGetter;

            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var isNumber = Shumway.isNumber;
            var isNullOrUndefined = Shumway.isNullOrUndefined;
            var createObject = Shumway.ObjectUtilities.createObject;
            var isPrototypeWriteable = Shumway.ObjectUtilities.isPrototypeWriteable;
            var getOwnPropertyDescriptor = Shumway.ObjectUtilities.getOwnPropertyDescriptor;
            var notImplemented = Shumway.Debug.notImplemented;
            var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

            var _notImplemented = notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var assert = Shumway.Debug.assert;
            var createFunction = Shumway.AVM2.Runtime.createFunction;
            var Runtime = Shumway.AVM2.Runtime;
            var IndentingWriter = Shumway.IndentingWriter;
            var boxValue = Shumway.ObjectUtilities.boxValue;
            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;
            var SORT = Shumway.AVM2.ABC.SORT;

            var ClassBindings = Shumway.AVM2.Runtime.ClassBindings;
            var InstanceBindings = Shumway.AVM2.Runtime.InstanceBindings;

            var Int32Vector = Shumway.AVM2.AS.Int32Vector;
            var Uint32Vector = Shumway.AVM2.AS.Uint32Vector;
            var Float64Vector = Shumway.AVM2.AS.Float64Vector;
            var asCompare = Shumway.AVM2.Runtime.asCompare;

            var debug = false;

            function log(message) {
                var optionalParams = [];
                for (var _i = 0; _i < (arguments.length - 1); _i++) {
                    optionalParams[_i] = arguments[_i + 1];
                }
                if (debug) {
                    jsGlobal.print(message);
                }
            }

            var writer = debug ? new IndentingWriter() : null;

            /**
            * This is all very magical, things are not what they seem, beware!!!
            *
            * The AS3 Class Hierarchy can be expressed as TypeScript, which is nice because
            * we get all sorts of compile time error checking and default arguments support.
            *
            * TODO: TS default argument support is not semantically equivalent to AS3 which
            * uses the arguments.length, TS uses typeof argument === "undefined", so beware.
            *
            * For the most part, you can cut and paste AS3 code into TypeScript and it will
            * parse correctly.
            *
            * The prototype chain configured by TypeScript is not actually used, We only use
            * Class definitions as a templates from which we construct real AS3 classes.
            *
            * Linking:
            *
            * AS -> TS
            *
            * Native AS3 members are linked against TS members. A verification step makes
            * sure all native members are implemented.
            *
            * TS -> AS
            *
            * For this you need to provide TS type definitions and then specify which
            * properties should be made available.
            *
            */
            (function (InitializationFlags) {
                InitializationFlags[InitializationFlags["NONE"] = 0x0] = "NONE";
                InitializationFlags[InitializationFlags["OWN_INITIALIZE"] = 0x1] = "OWN_INITIALIZE";
                InitializationFlags[InitializationFlags["SUPER_INITIALIZE"] = 0x2] = "SUPER_INITIALIZE";
            })(AS.InitializationFlags || (AS.InitializationFlags = {}));
            var InitializationFlags = AS.InitializationFlags;

            /**
            * In order to avoid shadowing of JS top level Objects we prefix the AS top level
            * classes with the "AS" prefix.
            */
            var ASObject = (function () {
                function ASObject() {
                }
                /**
                * Makes native class definitions look like ASClass instances.
                */
                ASObject.morphIntoASClass = function (classInfo) {
                    this.classInfo = classInfo;
                    this.__proto__ = ASClass.prototype;
                };

                ASObject.create = function (self, baseClass, instanceConstructor) {
                    // ! The AS3 instanceConstructor is ignored.
                    ASClass.create(self, baseClass, this.instanceConstructor);
                };

                ASObject.initializeFrom = function (value) {
                    return ASClassPrototype.initializeFrom.call(this, value);
                };

                ASObject.asCall = function (self) {
                    var argArray = [];
                    for (var _i = 0; _i < (arguments.length - 1); _i++) {
                        argArray[_i] = arguments[_i + 1];
                    }
                    return this.callableConstructor.apply(self, argArray);
                };

                ASObject.asApply = function (self, argArray) {
                    return this.callableConstructor.apply(self, argArray);
                };

                ASObject.verify = function () {
                    ASClassPrototype.verify.call(this);
                };

                ASObject.trace = function (writer) {
                    ASClassPrototype.trace.call(this, writer);
                };

                ASObject.getQualifiedClassName = function () {
                    return ASClassPrototype.getQualifiedClassName.call(this);
                };

                ASObject._setPropertyIsEnumerable = function (o, V, enumerable) {
                    var name = Multiname.getPublicQualifiedName(V);
                    var descriptor = getOwnPropertyDescriptor(o, name);
                    descriptor.enumerable = false;
                    Object.defineProperty(o, name, descriptor);
                };

                ASObject._dontEnumPrototype = function (o) {
                    for (var key in o) {
                        if (Multiname.isPublicQualifiedName(key)) {
                            var descriptor = getOwnPropertyDescriptor(o, key);
                            descriptor.enumerable = false;
                            Object.defineProperty(o, key, descriptor);
                        }
                    }
                };

                ASObject.prototype.native_isPrototypeOf = function (V) {
                    notImplemented("isPrototypeOf");
                    return false;
                };

                ASObject.prototype.native_hasOwnProperty = function (name) {
                    var self = this;
                    return self.asHasOwnProperty(null, name, 0);
                };

                ASObject.prototype.native_propertyIsEnumerable = function (name) {
                    var self = this;
                    return self.asPropertyIsEnumerable(null, name, 0);
                };

                ASObject.prototype.setPropertyIsEnumerable = function (name, enumerable) {
                    ASObject._setPropertyIsEnumerable(this, name, enumerable);
                };

                /**
                * This is the top level Object.prototype.toString() function.
                */
                ASObject.prototype.toString = function () {
                    var self = boxValue(this);
                    if (self instanceof ASClass) {
                        var cls = self;
                        return "[class " + cls.classInfo.instanceInfo.name.name + "]";
                    }
                    return "[object " + self.class.classInfo.instanceInfo.name.name + "]";
                };
                ASObject.baseClass = null;

                ASObject.instanceConstructor = Object;
                ASObject.instanceConstructorNoInitialize = null;

                ASObject.initializer = null;

                ASObject.initializers = null;
                ASObject.classInitializer = null;

                ASObject.callableConstructor = ASObject.instanceConstructor;

                ASObject.defaultValue = null;
                ASObject.initializationFlags = 0 /* NONE */;

                ASObject.call = Function.prototype.call;
                ASObject.apply = Function.prototype.apply;

                ASObject.coerce = Runtime.asCoerceObject;

                ASObject.defineProperty = Object.defineProperty;
                return ASObject;
            })();
            AS.ASObject = ASObject;

            /**
            * Inherit from this if you don't want to inherit the static junk from ASObject
            */
            var ASNative = (function (_super) {
                __extends(ASNative, _super);
                function ASNative() {
                    _super.apply(this, arguments);
                }
                ASNative.baseClass = null;
                ASNative.classInfo = null;
                ASNative.instanceConstructor = null;
                ASNative.callableConstructor = null;
                ASNative.classBindings = null;
                ASNative.instanceBindings = null;
                ASNative.staticNatives = null;
                ASNative.instanceNatives = null;
                ASNative.traitsPrototype = null;
                ASNative.dynamicPrototype = null;
                ASNative.defaultValue = null;
                ASNative.initializationFlags = 0 /* NONE */;
                return ASNative;
            })(ASObject);
            AS.ASNative = ASNative;

            /**
            * In AS3 all objects inherit from the Object class. Class objects themselves are instances
            * of the Class class. In Shumway, Class instances can be constructed in two ways: dynamically,
            * through the |new ASClass()| constructor function, or "statically" by inheriting the static
            * properties from the ASObject class. Statically constructed functions get morphed into
            * proper ASClass instances when they get constructed at runtime.
            *
            * We need to be really careful not to step on TS's inheritance scheme.
            */
            var ASClass = (function (_super) {
                __extends(ASClass, _super);
                function ASClass(classInfo) {
                    false && _super.call(this);
                    this.classInfo = classInfo;
                    this.staticNatives = null;
                    this.instanceNatives = null;
                    this.initializationFlags = 0 /* NONE */;
                    this.defaultValue = null;
                }
                /**
                * We can't do our traits / dynamic prototype chaining trick when dealing with builtin
                * functions: Object, Array, etc. Here, we take over the builtin function prototype.
                */
                ASClass.configureBuiltinPrototype = function (self, baseClass) {
                    release || assert(self.instanceConstructor);
                    self.baseClass = baseClass;
                    self.dynamicPrototype = self.traitsPrototype = self.instanceConstructor.prototype;
                };

                ASClass.configurePrototype = function (self, baseClass) {
                    self.baseClass = baseClass;
                    self.dynamicPrototype = createObject(baseClass.dynamicPrototype);
                    if (self.instanceConstructor) {
                        self.traitsPrototype = self.instanceConstructor.prototype;
                        self.traitsPrototype.__proto__ = self.dynamicPrototype;
                    } else {
                        self.traitsPrototype = createObject(self.dynamicPrototype);
                    }

                    // TODO: Kind of a hack for now, this is to make all TS class instance members available in all
                    // classes, even though we change the prototypes. I think we need to guard against ASClassPrototype.
                    var traitsPrototype = self.traitsPrototype;
                    var classes = [];
                    while (self) {
                        classes.push(self);
                        self = self.baseClass;
                    }
                    for (var i = 0; i < classes.length; i++) {
                        var baseClassTraitsPrototype = classes[i].prototype;
                        for (var property in baseClassTraitsPrototype) {
                            if (i > 0 && property === "toString") {
                                continue;
                            }
                            if (hasOwnProperty(baseClassTraitsPrototype, property) && !hasOwnProperty(traitsPrototype, property)) {
                                var descriptor = Object.getOwnPropertyDescriptor(baseClassTraitsPrototype, property);
                                release || Shumway.Debug.assert(descriptor);
                                try  {
                                    Object.defineProperty(traitsPrototype, property, descriptor);
                                } catch (e) {
                                    // log("Can't define " + property);
                                }
                            }
                        }
                    }
                };

                /**
                * Called when the class is actually constructed during bytecode execution.
                */
                ASClass.create = function (self, baseClass, instanceConstructor) {
                    release || assert(!self.instanceConstructorNoInitialize, "This should not be set yet.");
                    release || assert(!self.dynamicPrototype && !self.traitsPrototype, "These should not be set yet.");
                    if (self.instanceConstructor && !isPrototypeWriteable(self.instanceConstructor)) {
                        ASClass.configureBuiltinPrototype(self, baseClass);
                    } else {
                        ASClass.configurePrototype(self, baseClass);
                    }

                    if (!self.instanceConstructor) {
                        self.instanceConstructor = instanceConstructor;
                        if (self !== instanceConstructor) {
                            self.instanceConstructor.__proto__ = self;
                        }
                    } else {
                        writer && writer.warnLn("Ignoring AS3 instanceConstructor.");
                    }

                    /**
                    * If no |callableConstructor| exists then we insert a coercing
                    */
                    if (!self.callableConstructor) {
                        self.callableConstructor = self.coerce.bind(self);
                    }

                    self.instanceConstructorNoInitialize = self.instanceConstructor;
                    self.instanceConstructor.prototype = self.traitsPrototype;
                    defineNonEnumerableProperty(self.instanceConstructor.prototype, "class", self);

                    /**
                    * Set the |constructor| property.
                    */
                    defineNonEnumerableProperty(self.dynamicPrototype, Multiname.getPublicQualifiedName("constructor"), self);

                    if (self.protocol) {
                        Shumway.ObjectUtilities.copyOwnPropertyDescriptors(self.dynamicPrototype, self.protocol);
                    }
                };

                /**
                * Creates an object of this class but doesn't run the constructors, just the initializers.
                */
                ASClass.prototype.initializeFrom = function (value) {
                    var o = Object.create(this.traitsPrototype);
                    ASClass.runInitializers(o, value);
                    return o;
                };

                /**
                * Calls the initializers of an object in order.
                */
                ASClass.runInitializers = function (self, argument) {
                    argument = argument || self.class.defaultInitializerArgument;
                    var cls = self.class;
                    var initializers = cls.initializers;
                    if (initializers) {
                        for (var i = 0; i < initializers.length; i++) {
                            initializers[i].call(self, argument);
                        }
                    }
                };

                /**
                * Some AS3 classes have two parallel constructor chains:
                *
                * Consider the following inheritance hierarchy, (superClass <- subClass)
                *
                * A  <- B  <- C  <- D
                *
                * X' is the Class X AS3 Constructor
                * X" is the Class X Native Constructor
                *
                * new D() first calls all the native constructors top down, and then
                * all the AS3 constructors bottom up. So, new D() calls:
                *
                * A", B", C", D", D', C', B', A'
                *
                * To implement this behaviour we maintain two constructors, |instanceConstructor|
                * and |instanceConstructorNoInitialize| as well as a list of native initializers
                * for each class, |initializers|. Classes that have at least one initializer need
                * their instanceConstructor to first call all the initializers and then recursively
                * go through all the super constructors.
                */
                ASClass.configureInitializers = function (self) {
                    if (self.baseClass && self.baseClass.initializers) {
                        self.initializers = self.baseClass.initializers.slice(0);
                    }
                    if (self.initializer) {
                        if (!self.initializers) {
                            self.initializers = [];
                        }
                        self.initializers.push(self.initializer);
                    }

                    if (self.initializers) {
                        release || assert(self.instanceConstructorNoInitialize === self.instanceConstructor);
                        var previousConstructor = self;
                        self.instanceConstructor = function () {
                            var args = [];
                            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                                args[_i] = arguments[_i + 0];
                            }
                            ASClass.runInitializers(this, undefined);
                            return self.instanceConstructorNoInitialize.apply(this, arguments);
                        };
                        self.instanceConstructor.prototype = self.traitsPrototype;
                        defineNonEnumerableProperty(self.instanceConstructor.prototype, "class", self);

                        (self.instanceConstructor).classInfo = previousConstructor.classInfo;
                        self.instanceConstructor.__proto__ = previousConstructor;
                    }
                };

                /**
                * Runs the class initializer, if it has one.
                */
                ASClass.runClassInitializer = function (self) {
                    if (self.classInitializer) {
                        self.classInitializer();
                    }
                };

                ASClass.linkSymbols = function (self) {
                    /**
                    * Only returns true if the symbol is available in debug or release modes. Only symbols
                    * followed by the  "!" suffix are available in release builds.
                    */
                    function containsSymbol(symbols, name) {
                        for (var i = 0; i < symbols.length; i++) {
                            var symbol = symbols[i];
                            if (symbol.indexOf(name) >= 0) {
                                var releaseSymbol = symbol[symbol.length - 1] === "!";
                                if (releaseSymbol) {
                                    symbol = symbol.slice(0, symbol.length - 1);
                                }
                                if (name !== symbol) {
                                    continue;
                                }
                                if (release) {
                                    return releaseSymbol;
                                }
                                return true;
                            }
                        }
                        return false;
                    }

                    function link(symbols, traits, object) {
                        for (var i = 0; i < traits.length; i++) {
                            var trait = traits[i];
                            if (!containsSymbol(symbols, trait.name.name)) {
                                continue;
                            }
                            release || assert(!trait.name.getNamespace().isPrivate(), "Why are you linking against private members?");
                            if (trait.isConst()) {
                                notImplemented("Don't link against const traits.");
                                return;
                            }
                            var name = trait.name.name;
                            var qn = Multiname.getQualifiedName(trait.name);
                            if (trait.isSlot()) {
                                Object.defineProperty(object, name, {
                                    get: new Function("", "return this." + qn),
                                    set: new Function("v", "this." + qn + " = v")
                                });
                            } else if (trait.isMethod()) {
                                release || assert(!object[name], "Symbol should not already exist.");
                                release || assert(object.asOpenMethods[qn], "There should be an open method for this symbol.");
                                object[name] = object.asOpenMethods[qn];
                            } else if (trait.isGetter()) {
                                release || assert(hasOwnGetter(object, qn), "There should be an getter method for this symbol.");
                                Object.defineProperty(object, name, {
                                    get: new Function("", "return this." + qn)
                                });
                            } else {
                                notImplemented(trait);
                            }
                        }
                    }

                    if (self.classSymbols) {
                        link(self.classSymbols, self.classInfo.traits, self);
                    }

                    if (self.instanceSymbols) {
                        link(self.instanceSymbols, self.classInfo.instanceInfo.traits, self.traitsPrototype);
                    }
                };

                ASClass.prototype.morphIntoASClass = function (classInfo) {
                    release || assert(this.classInfo === classInfo);
                    release || assert(this instanceof ASClass);
                };

                Object.defineProperty(ASClass.prototype, "native_prototype", {
                    get: function () {
                        release || assert(this.dynamicPrototype);
                        return this.dynamicPrototype;
                    },
                    enumerable: true,
                    configurable: true
                });

                ASClass.prototype.asCall = function (self) {
                    var argArray = [];
                    for (var _i = 0; _i < (arguments.length - 1); _i++) {
                        argArray[_i] = arguments[_i + 1];
                    }
                    return this.coerce(argArray[0]);
                };

                ASClass.prototype.asApply = function (self, argArray) {
                    return this.coerce(argArray[0]);
                };

                ASClass.prototype.applyType = function (type) {
                    debugger;
                    return null;
                };

                ASClass.prototype.isInstanceOf = function (value) {
                    // Nothing is an |instanceOf| interfaces.
                    if (this.isInterface()) {
                        return false;
                    }
                    return this.isType(value);
                };

                /**
                * The isType check for classes looks for the |dynamicPrototype| on the prototype chain.
                */
                ASClass.prototype.isType = function (value) {
                    if (Shumway.isNullOrUndefined(value)) {
                        return false;
                    }

                    // We need to box primitive types before doing the |isPrototypeOf| test. In AS3, primitive values are
                    // identical to their boxed representations: |0 === new Number(0)| is |true|.
                    value = boxValue(value);

                    if (this.isInterface()) {
                        if (value === null || typeof value !== "object") {
                            return false;
                        }
                        release || assert(value.class.implementedInterfaces, "No 'implementedInterfaces' map found on class " + value.class);
                        var qualifiedName = Multiname.getQualifiedName(this.classInfo.instanceInfo.name);
                        return value.class.implementedInterfaces[qualifiedName] !== undefined;
                    }

                    return this.dynamicPrototype.isPrototypeOf(value);
                };

                /**
                * Checks if this class derives from the specified class.
                */
                ASClass.prototype.isSubtypeOf = function (value) {
                    var that = this;
                    while (that) {
                        if (that.traitsPrototype === value.traitsPrototype) {
                            return true;
                        }
                        that = that.baseClass;
                    }
                    return false;
                };

                ASClass.prototype.coerce = function (value) {
                    log("Coercing " + value + " to " + this);
                    return value;
                };

                ASClass.prototype.isInterface = function () {
                    return this.classInfo.instanceInfo.isInterface();
                };

                ASClass.prototype.getQualifiedClassName = function () {
                    var name = this.classInfo.instanceInfo.name;
                    var uri = name.namespaces[0].uri;
                    if (uri) {
                        return uri + "::" + name.name;
                    }
                    return name.name;
                };

                /**
                * Checks the structural integrity of the class instance.
                */
                ASClass.prototype.verify = function () {
                    var self = this;

                    // Not much to check for interfaces.
                    if (this.isInterface()) {
                        return;
                    }

                    // Verify that we have bindings for all native traits.
                    writer && writer.enter("Verifying Class: " + self.classInfo + " {");
                    var traits = [self.classInfo.traits, self.classInfo.instanceInfo.traits];

                    var staticNatives = [self];
                    if (self.staticNatives) {
                        Shumway.ArrayUtilities.pushMany(staticNatives, self.staticNatives);
                    }

                    var instanceNatives = [self.prototype];
                    if (self.instanceNatives) {
                        Shumway.ArrayUtilities.pushMany(instanceNatives, self.instanceNatives);
                    }

                    if (self === ASObject) {
                        release || assert(!self.baseClass, "ASObject should have no base class.");
                    } else {
                        release || assert(self.baseClass, self.classInfo.instanceInfo.name + " has no base class.");
                        release || assert(self.baseClass !== self);
                    }

                    release || assert(self.traitsPrototype === self.instanceConstructor.prototype, "The traitsPrototype is not set correctly.");

                    if (self !== ASObject) {
                        if (ASObject.staticNatives === self.staticNatives) {
                            writer && writer.warnLn("Template does not override its staticNatives, possibly a bug.");
                        }
                        if (ASObject.instanceNatives === self.instanceNatives) {
                            writer && writer.warnLn("Template does not override its instanceNatives, possibly a bug.");
                        }
                    }

                    function has(objects, predicate, name) {
                        for (var i = 0; i < objects.length; i++) {
                            if (predicate(objects[i], name)) {
                                return true;
                            }
                        }
                        return false;
                    }

                    for (var j = 0; j < traits.length; j++) {
                        var isClassTrait = j === 0;
                        for (var i = 0; i < traits[j].length; i++) {
                            var trait = traits[j][i];
                            var name = escapeNativeName(trait.name.name);
                            if (!(trait.isMethodOrAccessor() && trait.methodInfo.isNative())) {
                                continue;
                            }
                            var holders = isClassTrait ? staticNatives : instanceNatives;
                            var hasDefinition = false;
                            if (trait.isMethod()) {
                                hasDefinition = has(holders, Shumway.ObjectUtilities.hasOwnProperty, name);
                            } else if (trait.isGetter()) {
                                hasDefinition = has(holders, Shumway.ObjectUtilities.hasOwnGetter, name);
                            } else if (trait.isSetter()) {
                                hasDefinition = has(holders, Shumway.ObjectUtilities.hasOwnSetter, name);
                            }
                            if (!hasDefinition) {
                                writer && writer.warnLn("Template is missing an implementation of the native " + (isClassTrait ? "static" : "instance") + " trait: " + trait + " in class: " + self.classInfo);
                            }
                        }
                    }

                    writer && writer.leave("}");

                    // writer && this.trace(writer);
                    Shumway.Debug.assert(self.instanceConstructor, "Must have a constructor function.");
                };

                ASClass.labelObject = function (o) {
                    if (!o) {
                        return o;
                    }
                    if (!hasOwnProperty(o, "labelId")) {
                        o.labelId = ASClass.labelCounter++;
                    }
                    if (o instanceof Function) {
                        return "Function [#" + o.labelId + "]";
                    }
                    return "Object [#" + o.labelId + "]";
                };

                ASClass.prototype.trace = function (writer) {
                    writer.enter("Class: " + this.classInfo);

                    // dumpObject(this);
                    writer.writeLn("baseClass: " + this);
                    writer.writeLn("baseClass: " + (this.baseClass ? this.baseClass.classInfo.instanceInfo.name : null));
                    writer.writeLn("instanceConstructor: " + this.instanceConstructor + " " + ASClass.labelObject(this.instanceConstructor));
                    writer.writeLn("instanceConstructorNoInitialize: " + this.instanceConstructorNoInitialize + " " + ASClass.labelObject(this.instanceConstructorNoInitialize));

                    writer.writeLn("traitsPrototype: " + ASClass.labelObject(this.traitsPrototype));
                    writer.writeLn("traitsPrototype.__proto__: " + ASClass.labelObject(this.traitsPrototype.__proto__));
                    writer.writeLn("dynamicPrototype: " + ASClass.labelObject(this.dynamicPrototype));
                    writer.writeLn("dynamicPrototype.__proto__: " + ASClass.labelObject(this.dynamicPrototype.__proto__));
                    writer.writeLn("instanceConstructor.prototype: " + ASClass.labelObject(this.instanceConstructor.prototype));

                    //      for (var k in this) {
                    //        var v = this[k];
                    //        if (v && ((typeof v === "function") || (typeof v === "object"))) {
                    //          if (v.traceId === undefined) {
                    //            v.traceId = ASClass.traceId ++;
                    //          }
                    //          if (typeof v === "function") {
                    //            writer.writeLns(k + ": " + v + " Function " + v.traceId);
                    //          } else {
                    //            writer.writeLns(k + ": " + v + " Object " + v.traceId);
                    //          }
                    //        } else {
                    //          writer.writeLns(k + ": " + v);
                    //        }
                    //      }
                    writer.leave("}");
                };
                ASClass.instanceConstructor = ASClass;
                ASClass.staticNatives = null;
                ASClass.instanceNatives = null;

                ASClass.labelCounter = 0;
                return ASClass;
            })(ASObject);
            AS.ASClass = ASClass;

            var ASClassPrototype = ASClass.prototype;

            ASClassPrototype.call = Function.prototype.call;
            ASClassPrototype.apply = Function.prototype.apply;

            var ASFunction = (function (_super) {
                __extends(ASFunction, _super);
                function ASFunction() {
                    false && _super.call(this);
                }
                Object.defineProperty(ASFunction.prototype, "native_prototype", {
                    get: function () {
                        var self = this;
                        return self.prototype;
                    },
                    set: function (p) {
                        var self = this;
                        self.prototype = p;
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(ASFunction.prototype, "native_length", {
                    get: function () {
                        // Check if we're getting the length of a trampoline.
                        if (this.hasOwnProperty(Runtime.VM_LENGTH)) {
                            return this.asLength;
                        }
                        return this.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASFunction.baseClass = null;

                ASFunction.instanceConstructor = Function;

                ASFunction.staticNatives = [Function];
                ASFunction.instanceNatives = [Function.prototype];
                return ASFunction;
            })(ASObject);
            AS.ASFunction = ASFunction;

            var ASBoolean = (function (_super) {
                __extends(ASBoolean, _super);
                function ASBoolean(value) {
                    if (typeof value === "undefined") { value = undefined; }
                    false && _super.call(this);
                }
                ASBoolean.instanceConstructor = Boolean;
                ASBoolean.callableConstructor = ASBoolean.instanceConstructor;

                ASBoolean.staticNatives = null;
                ASBoolean.instanceNatives = null;
                ASBoolean.coerce = Runtime.asCoerceBoolean;
                return ASBoolean;
            })(ASObject);
            AS.ASBoolean = ASBoolean;

            ASBoolean.prototype.toString = Boolean.prototype.toString;
            ASBoolean.prototype.valueOf = Boolean.prototype.valueOf;

            var ASMethodClosure = (function (_super) {
                __extends(ASMethodClosure, _super);
                function ASMethodClosure(self, fn) {
                    false && _super.call(this);
                    var bound = Shumway.FunctionUtilities.bindSafely(fn, self);
                    defineNonEnumerableProperty(this, "call", bound.call.bind(bound));
                    defineNonEnumerableProperty(this, "apply", bound.apply.bind(bound));
                }
                ASMethodClosure.prototype.toString = function () {
                    return "function Function() {}";
                };
                ASMethodClosure.staticNatives = null;
                ASMethodClosure.instanceNatives = null;
                ASMethodClosure.instanceConstructor = ASMethodClosure;
                return ASMethodClosure;
            })(ASFunction);
            AS.ASMethodClosure = ASMethodClosure;

            var ASNumber = (function (_super) {
                __extends(ASNumber, _super);
                function ASNumber() {
                    _super.apply(this, arguments);
                }
                ASNumber._numberToString = function (n, radix) {
                    radix = radix | 0;
                    return Number(n).toString(radix);
                };

                ASNumber._minValue = function () {
                    return Number.MIN_VALUE;
                };
                ASNumber.instanceConstructor = Number;
                ASNumber.callableConstructor = ASNumber.instanceConstructor;

                ASNumber.staticNatives = [Math];
                ASNumber.instanceNatives = [Number.prototype];
                ASNumber.defaultValue = Number(0);
                ASNumber.coerce = Runtime.asCoerceNumber;
                return ASNumber;
            })(ASObject);
            AS.ASNumber = ASNumber;

            var ASInt = (function (_super) {
                __extends(ASInt, _super);
                function ASInt(value) {
                    false && _super.call(this);
                    return Object(Number(value | 0));
                }
                ASInt.asCall = function (self) {
                    var argArray = [];
                    for (var _i = 0; _i < (arguments.length - 1); _i++) {
                        argArray[_i] = arguments[_i + 1];
                    }
                    return argArray[0] | 0;
                };

                ASInt.asApply = function (self, argArray) {
                    return argArray[0] | 0;
                };

                /**
                * In AS3, |new int(42) instanceof int| is |false|.
                */
                ASInt.isInstanceOf = function (value) {
                    return false;
                };

                ASInt.isType = function (value) {
                    if (isNumber(value) || value instanceof Number) {
                        value = +value; // Make sure value is unboxed.
                        return (value | 0) === value;
                    }
                    return false;
                };
                ASInt.instanceConstructor = ASInt;
                ASInt.callableConstructor = ASInt.instanceConstructor;

                ASInt.staticNatives = [Math];
                ASInt.instanceNatives = [Number.prototype];
                ASInt.defaultValue = 0;
                ASInt.coerce = Runtime.asCoerceInt;
                return ASInt;
            })(ASObject);
            AS.ASInt = ASInt;

            var ASUint = (function (_super) {
                __extends(ASUint, _super);
                function ASUint(value) {
                    false && _super.call(this);
                    return Object(Number(value >>> 0));
                }
                ASUint.asCall = function (self) {
                    var argArray = [];
                    for (var _i = 0; _i < (arguments.length - 1); _i++) {
                        argArray[_i] = arguments[_i + 1];
                    }
                    return argArray[0] >>> 0;
                };

                ASUint.asApply = function (self, argArray) {
                    return argArray[0] >>> 0;
                };

                /**
                * In AS3, |new int(42) instanceof int| is |false|.
                */
                ASUint.isInstanceOf = function (value) {
                    return false;
                };

                ASUint.isType = function (value) {
                    if (isNumber(value) || value instanceof Number) {
                        value = +value; // Make sure value is unboxed.
                        return (value >>> 0) === value;
                    }
                    return false;
                };
                ASUint.instanceConstructor = ASUint;
                ASUint.callableConstructor = ASUint.instanceConstructor;

                ASUint.staticNatives = [Math];
                ASUint.instanceNatives = [Number.prototype];
                ASUint.defaultValue = 0;
                ASUint.coerce = Runtime.asCoerceUint;
                return ASUint;
            })(ASObject);
            AS.ASUint = ASUint;

            var ASString = (function (_super) {
                __extends(ASString, _super);
                function ASString() {
                    _super.apply(this, arguments);
                }
                Object.defineProperty(ASString.prototype, "native_length", {
                    get: function () {
                        return this.length;
                    },
                    enumerable: true,
                    configurable: true
                });

                ASString.prototype.match = function (re) {
                    if (re === (void 0) || re === null) {
                        return null;
                    } else {
                        if (re instanceof RegExp && re.global) {
                            var matches = [], m;
                            while ((m = re.exec(this))) {
                                matches.push(m[0]);
                            }
                            return matches;
                        }
                        if (!(re instanceof RegExp) && !(typeof re === 'string')) {
                            re = String(re);
                        }
                        return this.match(re);
                    }
                };

                ASString.prototype.search = function (re) {
                    if (re === void 0) {
                        return -1;
                    } else {
                        return this.search(re);
                    }
                };

                ASString.prototype.toUpperCase = function () {
                    // avmshell bug compatibility
                    var str = String.prototype.toUpperCase.apply(this);
                    var str = str.replace(/\u039C/g, String.fromCharCode(181));
                    return str;
                };

                ASString.prototype.toLocaleUpperCase = function () {
                    // avmshell bug compatibility
                    var str = String.prototype.toLocaleUpperCase.apply(this);
                    var str = str.replace(/\u039C/g, String.fromCharCode(181));
                    return str;
                };
                ASString.instanceConstructor = String;
                ASString.callableConstructor = ASString.instanceConstructor;

                ASString.staticNatives = [String];
                ASString.instanceNatives = [String.prototype];
                ASString.coerce = Runtime.asCoerceString;
                return ASString;
            })(ASObject);
            AS.ASString = ASString;

            /**
            * Format: args: [compareFunction], [sortOptions]
            */
            function arraySort(o, args) {
                if (args.length === 0) {
                    return o.sort();
                }
                var compareFunction, options = 0;
                if (args[0] instanceof Function) {
                    compareFunction = args[0];
                } else if (isNumber(args[0])) {
                    options = args[0];
                }
                if (isNumber(args[1])) {
                    options = args[1];
                }
                o.sort(function (a, b) {
                    return asCompare(a, b, options, compareFunction);
                });
                return o;
            }
            AS.arraySort = arraySort;

            var ASArray = (function (_super) {
                __extends(ASArray, _super);
                function ASArray() {
                    _super.apply(this, arguments);
                }
                ASArray._pop = function (o) {
                    return o.pop();
                };
                ASArray._reverse = function (o) {
                    return o.reverse();
                };
                ASArray._concat = function (o, args) {
                    return o.concat.apply(o, args);
                };
                ASArray._shift = function (o) {
                    return o.shift();
                };
                ASArray._slice = function (o, A, B) {
                    A = +A;
                    B = +B;
                    return o.slice(A, B);
                };
                ASArray._unshift = function (o, args) {
                    return o.unshift.apply(o, args);
                };
                ASArray._splice = function (o, args) {
                    return o.splice.apply(o, args);
                };
                ASArray._sort = function (o, args) {
                    if (args.length === 0) {
                        return o.sort();
                    }
                    var compareFunction, options = 0;
                    if (args[0] instanceof Function) {
                        compareFunction = args[0];
                    } else if (isNumber(args[0])) {
                        options = args[0];
                    }
                    if (isNumber(args[1])) {
                        options = args[1];
                    }
                    o.sort(function (a, b) {
                        return Runtime.asCompare(a, b, options, compareFunction);
                    });
                    return o;
                };
                ASArray._sortOn = function (o, names, options) {
                    if (Shumway.isString(names)) {
                        names = [names];
                    }
                    if (isNumber(options)) {
                        options = [options];
                    }
                    for (var i = names.length - 1; i >= 0; i--) {
                        var key = Multiname.getPublicQualifiedName(names[i]);
                        if (ASArray.CACHE_NUMERIC_COMPARATORS && options[i] & 16 /* NUMERIC */) {
                            var str = "var x = +(a." + key + "), y = +(b." + key + ");";
                            if (options[i] & 2 /* DESCENDING */) {
                                str += "return x < y ? 1 : (x > y ? -1 : 0);";
                            } else {
                                str += "return x < y ? -1 : (x > y ? 1 : 0);";
                            }
                            var numericComparator = ASArray.numericComparatorCache[str];
                            if (!numericComparator) {
                                numericComparator = ASArray.numericComparatorCache[str] = new Function("a", "b", str);
                            }
                            o.sort(numericComparator);
                        } else {
                            o.sort(function (a, b) {
                                return Runtime.asCompare(a[key], b[key], options[i] | 0);
                            });
                        }
                    }
                    return o;
                };
                ASArray._indexOf = function (o, searchElement, fromIndex /*int*/ ) {
                    fromIndex = fromIndex | 0;
                    return o.indexOf(searchElement, fromIndex);
                };
                ASArray._lastIndexOf = function (o, searchElement, fromIndex) {
                    if (typeof fromIndex === "undefined") { fromIndex = 0; }
                    fromIndex = fromIndex | 0;
                    return o.lastIndexOf(searchElement, fromIndex);
                };
                ASArray._every = function (o, callback, thisObject) {
                    for (var i = 0; i < o.length; i++) {
                        if (callback.call(thisObject, o[i], i, o) !== true) {
                            return false;
                        }
                    }
                    return false;
                };
                ASArray._filter = function (o, callback, thisObject) {
                    var result = [];
                    for (var i = 0; i < o.length; i++) {
                        if (callback.call(thisObject, o[i], i, o) === true) {
                            result.push(o[i]);
                        }
                    }
                    return result;
                };
                ASArray._forEach = function (o, callback, thisObject) {
                    return o.forEach(callback, thisObject);
                };
                ASArray._map = function (o, callback, thisObject) {
                    return o.map(callback, thisObject);
                };
                ASArray._some = function (o, callback, thisObject) {
                    return o.some(callback, thisObject);
                };
                Object.defineProperty(ASArray.prototype, "native_length", {
                    get: function () {
                        return this.length;
                    },
                    set: function (newLength /*uint*/ ) {
                        newLength = newLength >>> 0;
                        this.length = newLength;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASArray.instanceConstructor = Array;
                ASArray.staticNatives = [Array];
                ASArray.instanceNatives = [Array.prototype];

                ASArray.CACHE_NUMERIC_COMPARATORS = true;
                ASArray.numericComparatorCache = createEmptyObject();
                return ASArray;
            })(ASObject);
            AS.ASArray = ASArray;

            var ASVector = (function (_super) {
                __extends(ASVector, _super);
                function ASVector() {
                    _super.apply(this, arguments);
                }
                ASVector.prototype.newThisType = function () {
                    return new this.class.instanceConstructor();
                };
                ASVector.staticNatives = null;
                ASVector.instanceNatives = null;
                ASVector.instanceConstructor = ASVector;
                ASVector.callableConstructor = null;
                return ASVector;
            })(ASNative);
            AS.ASVector = ASVector;

            var ASIntVector = (function (_super) {
                __extends(ASIntVector, _super);
                function ASIntVector() {
                    _super.apply(this, arguments);
                }
                ASIntVector._every = function (o, callback, thisObject) {
                    return o.every(callback, thisObject);
                };
                ASIntVector._forEach = function (o, callback, thisObject) {
                    return o.forEach(callback, thisObject);
                };
                ASIntVector._some = function (o, callback, thisObject) {
                    return o.some(callback, thisObject);
                };
                ASIntVector.instanceConstructor = Int32Vector;
                ASIntVector.staticNatives = [Int32Vector];
                ASIntVector.instanceNatives = [Int32Vector.prototype, ASVector.prototype];
                ASIntVector.callableConstructor = Int32Vector.callable;

                ASIntVector._sort = arraySort;
                return ASIntVector;
            })(ASVector);
            AS.ASIntVector = ASIntVector;

            var ASUIntVector = (function (_super) {
                __extends(ASUIntVector, _super);
                function ASUIntVector() {
                    _super.apply(this, arguments);
                }
                ASUIntVector._every = function (o, callback, thisObject) {
                    return o.every(callback, thisObject);
                };
                ASUIntVector._forEach = function (o, callback, thisObject) {
                    return o.forEach(callback, thisObject);
                };
                ASUIntVector._some = function (o, callback, thisObject) {
                    return o.some(callback, thisObject);
                };
                ASUIntVector.instanceConstructor = Uint32Vector;
                ASUIntVector.staticNatives = [Uint32Vector];
                ASUIntVector.instanceNatives = [Uint32Vector.prototype, ASVector.prototype];
                ASUIntVector.callableConstructor = Uint32Vector.callable;

                ASUIntVector._sort = arraySort;
                return ASUIntVector;
            })(ASVector);
            AS.ASUIntVector = ASUIntVector;

            var ASDoubleVector = (function (_super) {
                __extends(ASDoubleVector, _super);
                function ASDoubleVector() {
                    _super.apply(this, arguments);
                }
                ASDoubleVector._every = function (o, callback, thisObject) {
                    return o.every(callback, thisObject);
                };
                ASDoubleVector._forEach = function (o, callback, thisObject) {
                    return o.forEach(callback, thisObject);
                };
                ASDoubleVector._some = function (o, callback, thisObject) {
                    return o.some(callback, thisObject);
                };
                ASDoubleVector.instanceConstructor = Float64Vector;
                ASDoubleVector.staticNatives = [Float64Vector];
                ASDoubleVector.instanceNatives = [Float64Vector.prototype, ASVector.prototype];
                ASDoubleVector.callableConstructor = Float64Vector.callable;

                ASDoubleVector._sort = arraySort;
                return ASDoubleVector;
            })(ASVector);
            AS.ASDoubleVector = ASDoubleVector;

            var ASJSON = (function (_super) {
                __extends(ASJSON, _super);
                function ASJSON() {
                    _super.apply(this, arguments);
                }
                /**
                * Transforms a JS value into an AS value.
                */
                ASJSON.transformJSValueToAS = function (value) {
                    if (typeof value !== "object") {
                        return value;
                    }
                    var keys = Object.keys(value);
                    var result = value instanceof Array ? [] : {};
                    for (var i = 0; i < keys.length; i++) {
                        result.asSetPublicProperty(keys[i], ASJSON.transformJSValueToAS(value[keys[i]]));
                    }
                    return result;
                };

                /**
                * Transforms an AS value into a JS value.
                */
                ASJSON.transformASValueToJS = function (value) {
                    if (typeof value !== "object") {
                        return value;
                    }
                    if (isNullOrUndefined(value)) {
                        return value;
                    }
                    var keys = Object.keys(value);
                    var result = value instanceof Array ? [] : {};
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var jsKey = key;
                        if (!Shumway.isNumeric(key)) {
                            jsKey = Multiname.getNameFromPublicQualifiedName(key);
                        }
                        result[jsKey] = ASJSON.transformASValueToJS(value[key]);
                    }
                    return result;
                };

                ASJSON.parseCore = function (text) {
                    text = asCoerceString(text);
                    return ASJSON.transformJSValueToAS(JSON.parse(text));
                };

                ASJSON.stringifySpecializedToString = function (value, replacerArray, replacerFunction, gap) {
                    return JSON.stringify(ASJSON.transformASValueToJS(value), replacerFunction, gap);
                };
                ASJSON.instanceConstructor = ASJSON;
                ASJSON.staticNatives = null;
                ASJSON.instanceNatives = null;
                return ASJSON;
            })(ASObject);
            AS.ASJSON = ASJSON;

            var ASError = (function (_super) {
                __extends(ASError, _super);
                function ASError(msg, id) {
                    if (typeof msg === "undefined") { msg = ""; }
                    if (typeof id === "undefined") { id = 0; }
                    false && _super.call(this);
                    notImplemented("ASError");
                }
                ASError.prototype.getStackTrace = function () {
                    somewhatImplemented("Error.getStackTrace()");
                    return Shumway.AVM2.Runtime.AVM2.getStackTrace();
                };
                ASError.instanceConstructor = null;
                ASError.staticNatives = null;
                ASError.instanceNatives = null;
                ASError.getErrorMessage = Shumway.AVM2.getErrorMessage;
                return ASError;
            })(ASNative);
            AS.ASError = ASError;

            var ASDefinitionError = (function (_super) {
                __extends(ASDefinitionError, _super);
                function ASDefinitionError() {
                    _super.apply(this, arguments);
                }
                return ASDefinitionError;
            })(ASError);
            AS.ASDefinitionError = ASDefinitionError;
            var ASEvalError = (function (_super) {
                __extends(ASEvalError, _super);
                function ASEvalError() {
                    _super.apply(this, arguments);
                }
                return ASEvalError;
            })(ASError);
            AS.ASEvalError = ASEvalError;
            var ASRangeError = (function (_super) {
                __extends(ASRangeError, _super);
                function ASRangeError() {
                    _super.apply(this, arguments);
                }
                return ASRangeError;
            })(ASError);
            AS.ASRangeError = ASRangeError;
            var ASReferenceError = (function (_super) {
                __extends(ASReferenceError, _super);
                function ASReferenceError() {
                    _super.apply(this, arguments);
                }
                return ASReferenceError;
            })(ASError);
            AS.ASReferenceError = ASReferenceError;
            var ASSecurityError = (function (_super) {
                __extends(ASSecurityError, _super);
                function ASSecurityError() {
                    _super.apply(this, arguments);
                }
                return ASSecurityError;
            })(ASError);
            AS.ASSecurityError = ASSecurityError;
            var ASSyntaxError = (function (_super) {
                __extends(ASSyntaxError, _super);
                function ASSyntaxError() {
                    _super.apply(this, arguments);
                }
                return ASSyntaxError;
            })(ASError);
            AS.ASSyntaxError = ASSyntaxError;
            var ASTypeError = (function (_super) {
                __extends(ASTypeError, _super);
                function ASTypeError() {
                    _super.apply(this, arguments);
                }
                return ASTypeError;
            })(ASError);
            AS.ASTypeError = ASTypeError;
            var ASURIError = (function (_super) {
                __extends(ASURIError, _super);
                function ASURIError() {
                    _super.apply(this, arguments);
                }
                return ASURIError;
            })(ASError);
            AS.ASURIError = ASURIError;
            var ASVerifyError = (function (_super) {
                __extends(ASVerifyError, _super);
                function ASVerifyError() {
                    _super.apply(this, arguments);
                }
                return ASVerifyError;
            })(ASError);
            AS.ASVerifyError = ASVerifyError;
            var ASUninitializedError = (function (_super) {
                __extends(ASUninitializedError, _super);
                function ASUninitializedError() {
                    _super.apply(this, arguments);
                }
                return ASUninitializedError;
            })(ASError);
            AS.ASUninitializedError = ASUninitializedError;
            var ASArgumentError = (function (_super) {
                __extends(ASArgumentError, _super);
                function ASArgumentError() {
                    _super.apply(this, arguments);
                }
                return ASArgumentError;
            })(ASError);
            AS.ASArgumentError = ASArgumentError;

            var ASRegExp = (function (_super) {
                __extends(ASRegExp, _super);
                function ASRegExp() {
                    _super.apply(this, arguments);
                }
                Object.defineProperty(ASRegExp.prototype, "native_source", {
                    get: function () {
                        var self = this;
                        return self.source;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASRegExp.prototype, "native_global", {
                    get: function () {
                        var self = this;
                        return self.global;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASRegExp.prototype, "native_ignoreCase", {
                    get: function () {
                        var self = this;
                        return self.ignoreCase;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASRegExp.prototype, "native_multiline", {
                    get: function () {
                        var self = this;
                        return self.multiline;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASRegExp.prototype, "native_lastIndex", {
                    get: function () {
                        var self = this;
                        return self.lastIndex;
                    },
                    set: function (i /*int*/ ) {
                        var self = this;
                        i = i | 0;
                        self.lastIndex = i;
                    },
                    enumerable: true,
                    configurable: true
                });


                Object.defineProperty(ASRegExp.prototype, "native_dotall", {
                    get: function () {
                        var self = this;
                        return self.dotall;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASRegExp.prototype, "native_extended", {
                    get: function () {
                        var self = this;
                        return self.extended;
                    },
                    enumerable: true,
                    configurable: true
                });

                ASRegExp.prototype.exec = function (s) {
                    if (typeof s === "undefined") { s = ""; }
                    var result = RegExp.prototype.exec.apply(this, arguments);
                    if (!result) {
                        return result;
                    }

                    // For some reason named groups in AS3 are set to the empty string instead of
                    // undefined as is the case for indexed groups. Here we just emulate the AS3
                    // behaviour.
                    var keys = Object.keys(result);
                    for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        if (!Shumway.isNumeric(k)) {
                            if (result[k] === undefined) {
                                result[k] = "";
                            }
                        }
                    }
                    Shumway.AVM2.Runtime.publicizeProperties(result);
                    return result;
                };
                ASRegExp.instanceConstructor = AVM2.XRegExp;
                ASRegExp.staticNatives = [AVM2.XRegExp];
                ASRegExp.instanceNatives = [AVM2.XRegExp.prototype];
                return ASRegExp;
            })(ASObject);
            AS.ASRegExp = ASRegExp;

            var ASMath = (function (_super) {
                __extends(ASMath, _super);
                function ASMath() {
                    _super.apply(this, arguments);
                }
                ASMath.staticNatives = [Math];
                return ASMath;
            })(ASNative);
            AS.ASMath = ASMath;

            var ASDate = (function (_super) {
                __extends(ASDate, _super);
                function ASDate() {
                    _super.apply(this, arguments);
                }
                ASDate.staticNatives = [Date];
                ASDate.instanceNatives = [Date.prototype];
                ASDate.instanceConstructor = Date;
                return ASDate;
            })(ASNative);
            AS.ASDate = ASDate;

            var builtinNativeClasses = Shumway.ObjectUtilities.createMap();

            var isInitialized = false;

            function initialize(domain) {
                if (isInitialized) {
                    return;
                }

                builtinNativeClasses["ObjectClass"] = ASObject;
                builtinNativeClasses["Class"] = ASClass;
                builtinNativeClasses["FunctionClass"] = ASFunction;
                builtinNativeClasses["BooleanClass"] = ASBoolean;
                builtinNativeClasses["MethodClosureClass"] = ASMethodClosure;
                builtinNativeClasses["NamespaceClass"] = AS.ASNamespace;
                builtinNativeClasses["NumberClass"] = ASNumber;
                builtinNativeClasses["IntClass"] = ASInt;
                builtinNativeClasses["UIntClass"] = ASUint;
                builtinNativeClasses["StringClass"] = ASString;
                builtinNativeClasses["ArrayClass"] = ASArray;
                builtinNativeClasses["VectorClass"] = ASVector;
                builtinNativeClasses["ObjectVectorClass"] = AS.GenericVector;
                builtinNativeClasses["IntVectorClass"] = ASIntVector;
                builtinNativeClasses["UIntVectorClass"] = ASUIntVector;
                builtinNativeClasses["DoubleVectorClass"] = ASDoubleVector;
                builtinNativeClasses["JSONClass"] = ASJSON;
                builtinNativeClasses["XMLClass"] = AS.ASXML;
                builtinNativeClasses["XMLListClass"] = AS.ASXMLList;
                builtinNativeClasses["QNameClass"] = AS.ASQName;

                // Errors
                builtinNativeClasses["ErrorClass"] = ASError;
                builtinNativeClasses["DefinitionErrorClass"] = ASDefinitionError;
                builtinNativeClasses["EvalErrorClass"] = ASEvalError;
                builtinNativeClasses["RangeErrorClass"] = ASRangeError;
                builtinNativeClasses["ReferenceErrorClass"] = ASReferenceError;
                builtinNativeClasses["SecurityErrorClass"] = ASSecurityError;
                builtinNativeClasses["SyntaxErrorClass"] = ASSyntaxError;
                builtinNativeClasses["TypeErrorClass"] = ASTypeError;
                builtinNativeClasses["URIErrorClass"] = ASURIError;
                builtinNativeClasses["VerifyErrorClass"] = ASVerifyError;
                builtinNativeClasses["UninitializedErrorClass"] = ASUninitializedError;
                builtinNativeClasses["ArgumentErrorClass"] = ASArgumentError;

                builtinNativeClasses["DateClass"] = ASDate;
                builtinNativeClasses["MathClass"] = ASMath;

                builtinNativeClasses["RegExpClass"] = ASRegExp;

                /**
                * If the Linker links against flash.* classes then we end up in a cycle. A reference to
                * |flash.utils.ByteArray| for instance would cause us to initialize the |ByteArray| class,
                * when we're not fully initialized ourselves. To get around this we make sure we don't refer
                * to possibly linked classes by prefixing their names with "Original".
                */
                // flash.utils
                builtinNativeClasses["ProxyClass"] = AS.flash.utils.OriginalProxy;
                builtinNativeClasses["DictionaryClass"] = AS.flash.utils.OriginalDictionary;
                builtinNativeClasses["ByteArrayClass"] = AS.flash.utils.OriginalByteArray;

                // flash.system
                builtinNativeClasses["SystemClass"] = AS.flash.system.OriginalSystem;

                isInitialized = true;
            }
            AS.initialize = initialize;

            var nativeClasses = Shumway.ObjectUtilities.createMap();
            var nativeFunctions = Shumway.ObjectUtilities.createMap();

            function registerNativeClass(name, cls) {
                release || assert(!nativeClasses[name], "Native class: " + name + " is already registered.");
                nativeClasses[name] = cls;
            }
            AS.registerNativeClass = registerNativeClass;

            function registerNativeFunction(name, fn) {
                release || assert(!nativeFunctions[name], "Native function: " + name + " is already registered.");
                nativeFunctions[name] = fn;
            }
            AS.registerNativeFunction = registerNativeFunction;

            function createInterface(classInfo) {
                var ii = classInfo.instanceInfo;
                release || assert(ii.isInterface());
                var cls = new ASClass(classInfo);
                cls.interfaceBindings = new InstanceBindings(null, ii, null, null);
                cls.verify();
                return cls;
            }
            AS.createInterface = createInterface;

            function createClass(classInfo, baseClass, scope) {
                var ci = classInfo;
                var ii = ci.instanceInfo;
                var domain = ci.abc.applicationDomain;
                var isNativeClass = ci.native;
                var cls;
                if (isNativeClass) {
                    cls = builtinNativeClasses[ci.native.cls];
                    if (!cls) {
                        cls = nativeClasses[ci.native.cls];
                    }
                    if (!cls) {
                        Shumway.Debug.unexpected("No native class for " + ci.native.cls);
                    }
                    cls.morphIntoASClass(classInfo);
                } else {
                    cls = new ASClass(classInfo);
                }

                var classScope = new Scope(scope, null);
                classScope.object = cls;
                var instanceConstructor = null;
                if (ii.init.isNative()) {
                    release || assert(isNativeClass);
                    instanceConstructor = cls;
                } else {
                    instanceConstructor = createFunction(ii.init, classScope, false);
                }

                /**
                * Only collect natives for native classes.
                */
                var staticNatives = null;
                var instanceNatives = null;

                if (isNativeClass) {
                    staticNatives = [cls];
                    if (cls.staticNatives) {
                        Shumway.ArrayUtilities.pushMany(staticNatives, cls.staticNatives);
                    }
                    instanceNatives = [cls.prototype];
                    if (cls.instanceNatives) {
                        Shumway.ArrayUtilities.pushMany(instanceNatives, cls.instanceNatives);
                    }
                }

                ASClass.create(cls, baseClass, instanceConstructor);
                cls.verify();

                AVM2.enterTimeline("ClassBindings");
                cls.classBindings = new ClassBindings(classInfo, classScope, staticNatives);
                AVM2.enterTimeline("applyTo");
                cls.classBindings.applyTo(domain, cls);
                AVM2.leaveTimeline();
                AVM2.leaveTimeline();

                AVM2.enterTimeline("InstanceBindings");
                cls.instanceBindings = new InstanceBindings(baseClass ? baseClass.instanceBindings : null, ii, classScope, instanceNatives);
                if (cls.instanceConstructor) {
                    AVM2.enterTimeline("applyTo");
                    cls.instanceBindings.applyTo(domain, cls.traitsPrototype);
                    AVM2.leaveTimeline();
                }
                AVM2.leaveTimeline();

                cls.implementedInterfaces = cls.instanceBindings.implementedInterfaces;

                if (cls === ASClass) {
                    cls.instanceBindings.applyTo(domain, ASObject, true);
                } else if (ASClass.instanceBindings) {
                    ASClass.instanceBindings.applyTo(domain, cls, true);
                }

                AVM2.enterTimeline("Configure");
                ASClass.configureInitializers(cls);
                ASClass.linkSymbols(cls);
                ASClass.runClassInitializer(cls);
                AVM2.leaveTimeline();

                return cls;
            }
            AS.createClass = createClass;

            /**
            * These functions should never leak into the AS3 world.
            */
            var illegalAS3Functions = [
                Runtime.forwardValueOf,
                Runtime.forwardToString
            ];

            /**
            * Searches for a native property in a list of native holders.
            */
            function getMethodOrAccessorNative(trait, natives) {
                var name = escapeNativeName(Multiname.getName(trait.name));
                log("getMethodOrAccessorNative(" + name + ")");
                for (var i = 0; i < natives.length; i++) {
                    var native = natives[i];
                    var fullName = name;

                    // Check for cases where the method has been patched, as could be the case for
                    // toString and valueOf.
                    if (hasOwnProperty(native, "original_" + name)) {
                        fullName = "original_" + name;
                    }

                    // Because of name conflicts we need to prefix some names with "native_" sometimes,
                    // check for that case here.
                    if (!hasOwnProperty(native, name) && hasOwnProperty(native, "native_" + name)) {
                        fullName = "native_" + name;
                    }
                    if (hasOwnProperty(native, fullName)) {
                        var value;
                        if (trait.isAccessor()) {
                            var pd = getOwnPropertyDescriptor(native, fullName);
                            if (trait.isGetter()) {
                                value = pd.get;
                            } else {
                                value = pd.set;
                            }
                        } else {
                            release || assert(trait.isMethod());
                            value = native[fullName];
                        }
                        release || assert(value, "Method or Accessor property exists but it's undefined: " + trait);
                        release || assert(illegalAS3Functions.indexOf(value) < 0, "Leaking illegal function.");
                        return value;
                    }
                }
                log("Cannot find " + trait + " in natives.");
                return null;
            }
            AS.getMethodOrAccessorNative = getMethodOrAccessorNative;

            /**
            * This is to avoid conflicts with JS properties.
            */
            function escapeNativeName(name) {
                switch (name) {
                    case "prototype":
                        return "native_prototype";
                    case "hasOwnProperty":
                        return "native_hasOwnProperty";
                    case "isPrototypeOf":
                        return "native_isPrototypeOf";
                    case "propertyIsEnumerable":
                        return "native_propertyIsEnumerable";
                    default:
                        return name;
                }
            }
            AS.escapeNativeName = escapeNativeName;

            /**
            * Other natives can live in this module
            */
            (function (Natives) {
                // Expose Some Builtin Objects
                Natives.String = jsGlobal.String;
                Natives.Function = jsGlobal.Function;
                Natives.Boolean = jsGlobal.Boolean;
                Natives.Number = jsGlobal.Number;
                Natives.Date = jsGlobal.Date;
                Natives.ASObject = Shumway.AVM2.AS.ASObject;

                function makeOriginalPrototype(constructor) {
                    var o = { prototype: createEmptyObject() };
                    var keys = Object.getOwnPropertyNames(constructor.prototype);
                    for (var i = 0; i < keys.length; i++) {
                        o.prototype[keys[i]] = constructor.prototype[keys[i]];
                    }
                    return o;
                }

                /**
                * Make a copy of the original prototype functions in case they are patched. This is to
                * prevent cyycles.
                */
                Natives.Original = {
                    Date: makeOriginalPrototype(Natives.Date),
                    Array: makeOriginalPrototype(Array),
                    String: makeOriginalPrototype(Natives.String),
                    Number: makeOriginalPrototype(Natives.Number),
                    Boolean: makeOriginalPrototype(Natives.Boolean)
                };

                function print() {
                    var args = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        args[_i] = arguments[_i + 0];
                    }
                    jsGlobal.print.apply(null, args);
                }
                Natives.print = print;

                function notImplemented(v) {
                    _notImplemented(v);
                }
                Natives.notImplemented = notImplemented;

                function debugBreak(v) {
                    debugger;
                }
                Natives.debugBreak = debugBreak;

                function bugzilla(n) {
                    switch (n) {
                        case 574600:
                            return true;
                    }
                    return false;
                }
                Natives.bugzilla = bugzilla;

                Natives.decodeURI = jsGlobal.decodeURI;
                Natives.decodeURIComponent = jsGlobal.decodeURIComponent;
                Natives.encodeURI = jsGlobal.encodeURI;
                Natives.encodeURIComponent = jsGlobal.encodeURIComponent;
                Natives.isNaN = jsGlobal.isNaN;
                Natives.isFinite = jsGlobal.isFinite;
                Natives.parseInt = jsGlobal.parseInt;
                Natives.parseFloat = jsGlobal.parseFloat;
                Natives.escape = jsGlobal.escape;
                Natives.unescape = jsGlobal.unescape;
                Natives.isXMLName = typeof (Natives.isXMLName) !== "undefined" ? jsGlobal.isXMLName : function () {
                    notImplemented("Chrome doesn't support isXMLName.");
                };

                /**
                * Returns the fully qualified class name of an object.
                */
                function getQualifiedClassName(value) {
                    if (value === null) {
                        return "null";
                    } else if (value === undefined) {
                        return "void";
                    }
                    if (ASInt.isType(value)) {
                        return "int";
                    }
                    value = boxValue(value);
                    if (ASClass.isType(value)) {
                        return value.getQualifiedClassName();
                    }
                    return value.class.getQualifiedClassName();
                }
                Natives.getQualifiedClassName = getQualifiedClassName;

                /**
                * Returns the fully qualified class name of the base class of the object specified by the |value| parameter.
                */
                function getQualifiedSuperclassName(value) {
                    if (isNullOrUndefined(value)) {
                        return "null";
                    }
                    value = boxValue(value);
                    var cls = ASClass.isType(value) ? value : value.class;
                    if (!cls.baseClass) {
                        return "null";
                    }
                    return cls.baseClass.getQualifiedClassName();
                }
                Natives.getQualifiedSuperclassName = getQualifiedSuperclassName;

                function getDefinitionByName(name) {
                    var simpleName = Natives.String(name).replace("::", ".");
                    return Shumway.AVM2.Runtime.AVM2.currentDomain().getClass(simpleName);
                }
                Natives.getDefinitionByName = getDefinitionByName;

                function describeTypeJSON(value, flags) {
                    return Shumway.AVM2.AS.describeTypeJSON(value, flags);
                }
                Natives.describeTypeJSON = describeTypeJSON;
            })(AS.Natives || (AS.Natives = {}));
            var Natives = AS.Natives;

            /**
            * Searchs for natives using a string path "a.b.c...".
            */
            function getNative(path) {
                log("getNative(" + path + ")");
                var chain = path.split(".");
                var v = Natives;
                for (var i = 0, j = chain.length; i < j; i++) {
                    v = v && v[chain[i]];
                }

                if (!v) {
                    v = nativeFunctions[path];
                }

                release || assert(v, "getNative(" + path + ") not found.");
                release || assert(illegalAS3Functions.indexOf(v) < 0, "Leaking illegal function.");
                return v;
            }
            AS.getNative = getNative;

            registerNativeFunction("unsafeJSNative", getNative);
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            /**
            * Check arguments and throw the appropriate errors.
            */
            var checkArguments = true;

            var assert = Shumway.Debug.assert;
            var assertNotImplemented = Shumway.Debug.assertNotImplemented;

            var throwError = Shumway.AVM2.Runtime.throwError;
            var clamp = Shumway.NumberUtilities.clamp;
            var asCheckVectorGetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorGetNumericProperty;
            var asCheckVectorSetNumericProperty = Shumway.AVM2.Runtime.asCheckVectorSetNumericProperty;

            var arraySort = Shumway.AVM2.AS.arraySort;

            var GenericVector = (function (_super) {
                __extends(GenericVector, _super);
                function GenericVector(length /*uint*/ , fixed, type) {
                    false && _super.call(this);
                    length = length >>> 0;
                    fixed = !!fixed;
                    this._fixed = !!fixed;
                    this._buffer = new Array(length);
                    this._type = type;
                    this._defaultValue = type ? type.defaultValue : null;
                    this._fill(0, length, this._defaultValue);
                }
                GenericVector.defaultCompareFunction = function (a, b) {
                    return String(a).localeCompare(String(b));
                };

                GenericVector.compare = function (a, b, options, compareFunction) {
                    release || assertNotImplemented(!(options & GenericVector.CASEINSENSITIVE), "CASEINSENSITIVE");
                    release || assertNotImplemented(!(options & GenericVector.UNIQUESORT), "UNIQUESORT");
                    release || assertNotImplemented(!(options & GenericVector.RETURNINDEXEDARRAY), "RETURNINDEXEDARRAY");
                    var result = 0;
                    if (!compareFunction) {
                        compareFunction = GenericVector.defaultCompareFunction;
                    }
                    if (options & GenericVector.NUMERIC) {
                        a = Shumway.toNumber(a);
                        b = Shumway.toNumber(b);
                        result = a < b ? -1 : (a > b ? 1 : 0);
                    } else {
                        result = compareFunction(a, b);
                    }
                    if (options & GenericVector.DESCENDING) {
                        result *= -1;
                    }
                    return result;
                };

                GenericVector._every = function (o, callback, thisObject) {
                    return o.every(callback, thisObject);
                };

                GenericVector._forEach = function (o, callback, thisObject) {
                    return o.forEach(callback, thisObject);
                };

                GenericVector._some = function (o, callback, thisObject) {
                    return o.some(callback, thisObject);
                };

                /**
                * TODO: Need to really debug this, very tricky.
                */
                GenericVector.applyType = function (type) {
                    function parameterizedVectorConstructor(length /*uint*/ , fixed) {
                        Function.prototype.call.call(GenericVector.instanceConstructor, this, length, fixed, type);
                    }
                    ;

                    function parameterizedVectorCallableConstructor(object) {
                        if (object instanceof AS.Int32Vector) {
                            return object;
                        }
                        var length = object.asGetProperty(undefined, "length");
                        if (length !== undefined) {
                            var v = new parameterizedVectorConstructor(length, false);
                            for (var i = 0; i < length; i++) {
                                v.asSetNumericProperty(i, object.asGetPublicProperty(i));
                            }
                            return v;
                        }
                        Shumway.Debug.unexpected();
                    }

                    var parameterizedVector = parameterizedVectorConstructor;
                    parameterizedVector.prototype = GenericVector.prototype;
                    parameterizedVector.instanceConstructor = parameterizedVector;
                    parameterizedVector.callableConstructor = parameterizedVectorCallableConstructor;
                    parameterizedVector.__proto__ = GenericVector;
                    return parameterizedVector;
                };

                GenericVector.prototype._fill = function (index, length, value) {
                    for (var i = 0; i < length; i++) {
                        this._buffer[index + i] = value;
                    }
                };

                /**
                * Can't use Array.prototype.toString because it doesn't print |null|s the same way as AS3.
                */
                GenericVector.prototype.toString = function () {
                    var str = "";
                    for (var i = 0; i < this._buffer.length; i++) {
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ",";
                        }
                    }
                    return str;
                };

                /**
                * Executes a |callback| function with three arguments: element, index, the vector itself as well
                * as passing the |thisObject| as |this| for each of the elements in the vector. If any of the
                * callbacks return |false| the function terminates, otherwise it returns |true|.
                */
                GenericVector.prototype.every = function (callback, thisObject) {
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (!callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return false;
                        }
                    }
                    return true;
                };

                /**
                * Filters the elements for which the |callback| method returns |true|. The |callback| function
                * is called with three arguments: element, index, the vector itself as well as passing the |thisObject|
                * as |this| for each of the elements in the vector.
                */
                GenericVector.prototype.filter = function (callback, thisObject) {
                    var v = new GenericVector(0, false, this._type);
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            v.push(this.asGetNumericProperty(i));
                        }
                    }
                    return v;
                };

                GenericVector.prototype.some = function (callback, thisObject) {
                    if (arguments.length !== 2) {
                        throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError);
                    } else if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (callback.call(thisObject, this.asGetNumericProperty(i), i, this)) {
                            return true;
                        }
                    }
                    return false;
                };

                GenericVector.prototype.forEach = function (callback, thisObject) {
                    if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        callback.call(thisObject, this.asGetNumericProperty(i), i, this);
                    }
                };

                GenericVector.prototype.map = function (callback, thisObject) {
                    if (!Shumway.isFunction(callback)) {
                        throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError);
                    }
                    var v = new GenericVector(0, false, this._type);
                    for (var i = 0; i < this._buffer.length; i++) {
                        v.push(callback.call(thisObject, this.asGetNumericProperty(i), i, this));
                    }
                    return v;
                };

                GenericVector.prototype.push = function () {
                    var args = [];
                    for (var _i = 0; _i < (arguments.length - 0); _i++) {
                        args[_i] = arguments[_i + 0];
                    }
                    this._checkFixed();
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer.push(this._coerce(arguments[i]));
                    }
                };

                GenericVector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._buffer.length === 0) {
                        return undefined;
                    }
                    return this._buffer.pop();
                };

                GenericVector.prototype.reverse = function () {
                    this._buffer.reverse();
                };

                GenericVector.prototype.sort = function (comparator) {
                    return this._buffer.sort(comparator);
                };

                GenericVector.prototype.asGetNumericProperty = function (i) {
                    checkArguments && asCheckVectorGetNumericProperty(i, this._buffer.length);
                    return this._buffer[i];
                };

                GenericVector.prototype._coerce = function (v) {
                    if (this._type) {
                        return this._type.coerce(v);
                    } else if (v === undefined) {
                        return null;
                    }
                    return v;
                };

                GenericVector.prototype.asSetNumericProperty = function (i, v) {
                    checkArguments && asCheckVectorSetNumericProperty(i, this._buffer.length, this._fixed);
                    this._buffer[i] = this._coerce(v);
                };

                GenericVector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._buffer.length === 0) {
                        return undefined;
                    }
                    return this._buffer.shift();
                };

                GenericVector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        throwError("RangeError", AVM2.Errors.VectorFixedError);
                    }
                };

                GenericVector.prototype.unshift = function () {
                    if (!arguments.length) {
                        return;
                    }
                    this._checkFixed();
                    var items = [];
                    for (var i = 0; i < arguments.length; i++) {
                        items.push(this._coerce(arguments[i]));
                    }
                    this._buffer.unshift.apply(this._buffer, items);
                };

                Object.defineProperty(GenericVector.prototype, "length", {
                    get: function () {
                        return this._buffer.length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._buffer.length) {
                            for (var i = this._buffer.length; i < value; i++) {
                                this._buffer[i] = this._defaultValue;
                            }
                        } else {
                            this._buffer.length = value;
                        }
                        release || assert(this._buffer.length === value);
                    },
                    enumerable: true,
                    configurable: true
                });



                Object.defineProperty(GenericVector.prototype, "fixed", {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Delete |deleteCount| elements starting at |index| then insert |insertCount| elements
                * from |args| object starting at |offset|.
                */
                GenericVector.prototype._spliceHelper = function (index, insertCount, deleteCount, args, offset) {
                    insertCount = clamp(insertCount, 0, args.length - offset);
                    deleteCount = clamp(deleteCount, 0, this._buffer.length - index);
                    var items = [];
                    for (var i = 0; i < insertCount; i++) {
                        items.push(this._coerce(args.asGetNumericProperty(offset + i)));
                    }
                    this._buffer.splice.apply(this._buffer, [index, deleteCount].concat(items));
                };

                GenericVector.prototype.asNextName = function (index) {
                    return index - 1;
                };

                GenericVector.prototype.asNextValue = function (index) {
                    return this._buffer[index - 1];
                };

                GenericVector.prototype.asNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._buffer.length) {
                        return nextNameIndex;
                    }
                    return 0;
                };

                GenericVector.prototype.asHasProperty = function (namespaces, name, flags) {
                    if (GenericVector.prototype === this || !Shumway.isNumeric(name)) {
                        return Object.prototype.asHasProperty.call(this, namespaces, name, flags);
                    }
                    var index = Shumway.toNumber(name);
                    return index >= 0 && index < this._buffer.length;
                };

                GenericVector.prototype.asHasNext2 = function (hasNext2Info) {
                    hasNext2Info.index = this.asNextNameIndex(hasNext2Info.index);
                };
                GenericVector.CASEINSENSITIVE = 1;
                GenericVector.DESCENDING = 2;
                GenericVector.UNIQUESORT = 4;
                GenericVector.RETURNINDEXEDARRAY = 8;
                GenericVector.NUMERIC = 16;

                GenericVector.instanceConstructor = GenericVector;
                GenericVector.staticNatives = [GenericVector];
                GenericVector.instanceNatives = [GenericVector.prototype, AS.ASVector.prototype];

                GenericVector._sort = arraySort;
                return GenericVector;
            })(AS.ASVector);
            AS.GenericVector = GenericVector;

            GenericVector.prototype._reverse = GenericVector.prototype.reverse;
            GenericVector.prototype._filter = GenericVector.prototype.filter;
            GenericVector.prototype._map = GenericVector.prototype.map;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /*
        NOTE ON E4X METHOD CALLS
        
        E4X specifies some magic when making calls on XML and XMLList values. If a
        callee is not found on an XMLList value and the list has only one XML
        child, then the call is delegated to that XML child. If a callee is not
        found on an XML value and that value has simple content, then the simple
        content is converted to a string value and the call is made on that string
        value.
        
        Here are the relevant texts from the spec section 11.2.2.1:
        
        "If no such property exists and base is an XMLList of size 1, CallMethod
        delegates the method invocation to the single property it contains. This
        treatment intentionally blurs the distinction between XML objects and XMLLists
        of size 1."
        
        "If no such property exists and base is an XML object containing no XML valued
        children (i.e., an attribute, leaf node or element with simple content),
        CallMethod attempts to delegate the method lookup to the string value
        contained in the leaf node. This treatment allows users to perform operations
        directly on the value of a leaf node without having to explicitly select it."
        
        NOTE ON E4X ANY NAME AND NAMESPACE
        
        E4X allows the names of the form x.*, x.ns::*, x.*::id and x.*::* and their
        attribute name counterparts x.@*, x.@ns::*, etc. These forms result in
        Multiname values with the name part equal to undefined in the case of an ANY
        name, and the namespace set being empty in the case of an ANY namespace.
        
        Note also,
        x.*
        is shorthand for
        x.*::*
        .
        
        */
        (function (AS) {
            var assert = Shumway.Debug.assert;
            var Multiname = Shumway.AVM2.ABC.Multiname;
            var notImplemented = Shumway.Debug.notImplemented;

            var _asGetProperty = Object.prototype.asGetProperty;
            var _asSetProperty = Object.prototype.asSetProperty;
            var _asCallProperty = Object.prototype.asCallProperty;
            var _asHasProperty = Object.prototype.asHasProperty;
            var _asHasOwnProperty = Object.prototype.asHasOwnProperty;
            var _asHasTraitProperty = Object.prototype.asHasTraitProperty;
            var _asDeleteProperty = Object.prototype.asDeleteProperty;
            var _asGetEnumerableKeys = Object.prototype.asGetEnumerableKeys;

            function isXMLType(val) {
                return (val instanceof ASXML || val instanceof ASXMLList);
            }

            // 10.1 ToString
            function toString(node) {
                if (typeof node === "object" && node !== null) {
                    if (node instanceof ASXMLList) {
                        return node._children.map(toString).join('');
                    }
                    switch (node._kind) {
                        case 3 /* Text */:
                        case 2 /* Attribute */:
                            return node._value;
                        default:
                            if (node.hasSimpleContent()) {
                                return node._children.map(toString).join('');
                            }
                            return toXMLString(node);
                    }
                } else {
                    return String(node);
                }
            }

            // 10.2.1.1 EscapeElementValue ( s )
            function escapeElementValue(s) {
                var i = 0, ch;
                while (i < s.length && (ch = s[i]) !== '&' && ch !== '<' && ch !== '>') {
                    i++;
                }
                if (i >= s.length) {
                    return s;
                }
                var buf = s.substring(0, i);
                while (i < s.length) {
                    ch = s[i++];
                    switch (ch) {
                        case '&':
                            buf += '&amp;';
                            break;
                        case '<':
                            buf += '&lt;';
                            break;
                        case '>':
                            buf += '&gt;';
                            break;
                        default:
                            buf += ch;
                            break;
                    }
                }
                return buf;
            }

            // 10.2.1.2 EscapeAttributeValue ( s )
            function escapeAttributeValue(s) {
                var i = 0, ch;
                while (i < s.length && (ch = s[i]) !== '&' && ch !== '<' && ch !== '\"' && ch !== '\n' && ch !== '\r' && ch !== '\t') {
                    i++;
                }
                if (i >= s.length) {
                    return s;
                }
                var buf = s.substring(0, i);
                while (i < s.length) {
                    ch = s[i++];
                    switch (ch) {
                        case '&':
                            buf += '&amp;';
                            break;
                        case '<':
                            buf += '&lt;';
                            break;
                        case '\"':
                            buf += '&quot;';
                            break;
                        case '\n':
                            buf += '&#xA;';
                            break;
                        case '\r':
                            buf += '&#xD;';
                            break;
                        case '\t':
                            buf += '&#x9;';
                            break;
                        default:
                            buf += ch;
                            break;
                    }
                }
                return buf;
            }

            function isWhitespace(s, index) {
                var ch = s[index];
                return ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t';
            }

            function trimWhitespaces(s) {
                var i = 0;
                while (i < s.length && isWhitespace(s, i)) {
                    i++;
                }
                if (i >= s.length) {
                    return '';
                }
                var j = s.length - 1;
                while (isWhitespace(s, j)) {
                    j--;
                }
                return i === 0 && j === s.length - 1 ? s : s.substring(i, j + 1);
            }

            var indentStringCache = [];
            function getIndentString(indent) {
                if (indent > 0) {
                    if (indentStringCache[indent] !== undefined) {
                        return indentStringCache[indent];
                    }
                    var s = '';
                    for (var i = 0; i < indent; i++) {
                        s += ' ';
                    }
                    indentStringCache[indent] = s;
                    return s;
                }
                return '';
            }

            function generateUniquePrefix(namespaces) {
                var i = 1, newPrefix;
                while (true) {
                    newPrefix = '_ns' + i;
                    if (!namespaces.some(function (ns) {
                        return ns.prefix == newPrefix;
                    })) {
                        break;
                    }
                    i++;
                }
                return newPrefix;
            }

            // 10.2 ToXMLString
            function toXMLString(node, ancestorNamespaces, indentLevel) {
                if (node === null || node === undefined) {
                    throw new TypeError();
                }
                if (!(node instanceof ASXML)) {
                    if (node instanceof ASXMLList) {
                        // 10.2.2 ToXMLString Applied to the XMLList Type
                        return node._children.map(function (childNode) {
                            return toXMLString(childNode, ancestorNamespaces);
                        }).join(ASXML.prettyPrinting ? '\n' : '');
                    }
                    return escapeElementValue(String(node));
                }

                var prettyPrinting = ASXML.prettyPrinting;

                // 10.2.1 ToXMLString Applied to the XML Type
                indentLevel |= 0;
                var s = prettyPrinting ? getIndentString(indentLevel) : '';

                var kind = node._kind;
                switch (kind) {
                    case 3 /* Text */:
                        return prettyPrinting ? s + escapeElementValue(trimWhitespaces(node._value)) : escapeElementValue(node._value);

                    case 2 /* Attribute */:
                        return s + escapeAttributeValue(node._value);

                    case 4 /* Comment */:
                        return s + '<!--' + node._value + '-->';

                    case 5 /* ProcessingInstruction */:
                        return s + '<?' + node._name.localName + ' ' + node._value + '?>';
                    default:
                        release || assert(kind === 1 /* Element */);
                        break;
                }

                ancestorNamespaces = ancestorNamespaces || [];
                var namespaceDeclarations = [];

                for (var i = 0; i < node._inScopeNamespaces.length; i++) {
                    var nsPrefix = node._inScopeNamespaces[i].prefix;
                    var nsUri = node._inScopeNamespaces[i].uri;
                    if (ancestorNamespaces.every(function (ans) {
                        return ans.uri != nsUri || ans.prefix != nsPrefix;
                    })) {
                        var ns1 = new ASNamespace(nsPrefix, nsUri);
                        namespaceDeclarations.push(ns1);
                    }
                }

                // 11. For each name in the set of names consisting of x.[[Name]] and the name of each attribute in x.[[Attributes]]
                var currentNamespaces = ancestorNamespaces.concat(namespaceDeclarations);
                var namespace = node._name.getNamespace(currentNamespaces);
                if (namespace.prefix === undefined) {
                    // Let namespace.prefix be an arbitrary implementation defined namespace prefix, such that there is no ns2 ∈ (AncestorNamespaces ∪ namespaceDeclarations) with namespace.prefix == ns2.prefix
                    var newPrefix = generateUniquePrefix(currentNamespaces);
                    var ns2 = new ASNamespace(newPrefix, namespace.uri);

                    // Let namespaceDeclarations = namespaceDeclarations ∪ { namespace }
                    namespaceDeclarations.push(ns2);
                    currentNamespaces.push(ns2);
                }

                // 12. Let s be the result of concatenating s and the string "<"
                // 13. If namespace.prefix is not the empty string,
                //   a. Let s be the result of concatenating s, namespace.prefix and the string ":"
                // 14. Let s be the result of concatenating s and x.[[Name]].localName
                var elementName = (namespace.prefix ? namespace.prefix + ':' : '') + node._name.localName;
                s += '<' + elementName;

                node._attributes.forEach(function (attr) {
                    var name = attr._name;
                    var namespace = name.getNamespace(currentNamespaces);
                    if (namespace.prefix === undefined) {
                        // Let namespace.prefix be an arbitrary implementation defined namespace prefix, such that there is no ns2 ∈ (AncestorNamespaces ∪ namespaceDeclarations) with namespace.prefix == ns2.prefix
                        var newPrefix = generateUniquePrefix(currentNamespaces);
                        var ns2 = new ASNamespace(newPrefix, namespace.uri);

                        // Let namespaceDeclarations = namespaceDeclarations ∪ { namespace }
                        namespaceDeclarations.push(ns2);
                        currentNamespaces.push(ns2);
                    }
                });

                for (var i = 0; i < namespaceDeclarations.length; i++) {
                    var namespace = namespaceDeclarations[i];
                    var attributeName = namespace.prefix ? 'xmlns:' + namespace.prefix : 'xmlns';
                    s += ' ' + attributeName + '=\"' + escapeAttributeValue(namespace.uri) + '\"';
                }
                node._attributes.forEach(function (attr) {
                    var name = attr._name;
                    var namespace = name.getNamespace(ancestorNamespaces);
                    var attributeName = namespace.prefix ? namespace.prefix + ':' + name.localName : name.localName;
                    s += ' ' + attributeName + '=\"' + escapeAttributeValue(attr._value) + '\"';
                });

                // 17. If x.[[Length]] == 0
                if (node._children.length === 0) {
                    //   a. Let s be the result of concatenating s and "/>"
                    s += '/>';

                    //   b. Return s
                    return s;
                }

                // 18. Let s be the result of concatenating s and the string ">"
                s += '>';

                // 19. Let indentChildren = ((x.[[Length]] > 1) or (x.[[Length]] == 1 and x[0].[[Class]] is not equal to "text"))
                var indentChildren = node._children.length > 1 || (node._children.length === 1 && node._children[0]._kind !== 3 /* Text */);
                var nextIndentLevel = (prettyPrinting && indentChildren) ? indentLevel + ASXML.prettyIndent : 0;

                node._children.forEach(function (childNode, i) {
                    if (prettyPrinting && indentChildren) {
                        s += '\n';
                    }
                    var child = toXMLString(childNode, currentNamespaces, nextIndentLevel);
                    s += child;
                });
                if (prettyPrinting && indentChildren) {
                    s += '\n' + getIndentString(indentLevel);
                }

                s += '</' + elementName + '>';
                return s;
            }

            // 10.3 ToXML
            function toXML(v) {
                if (v === null) {
                    throw new TypeError(AVM2.formatErrorMessage(AVM2.Errors.ConvertNullToObjectError));
                } else if (v === undefined) {
                    throw new TypeError(AVM2.formatErrorMessage(AVM2.Errors.ConvertUndefinedToObjectError));
                } else if (v instanceof ASXML) {
                    return v;
                } else if (v instanceof ASXMLList) {
                    if (v.length() === 1) {
                        return v._children[0];
                    }
                    throw new TypeError(AVM2.formatErrorMessage(AVM2.Errors.XMLMarkupMustBeWellFormed));
                } else {
                    var x = xmlParser.parseFromString(String(v));
                    if (x.length() === 0) {
                        var x = new XML(3 /* Text */);
                        return x;
                    } else if (x.length() === 1) {
                        x._children[0]._parent = null;
                        return x._children[0];
                    }
                    throw "SyntaxError in ToXML";
                }
            }

            // 10.4 ToXMLList
            function toXMLList(value) {
                if (value === null) {
                    throw new TypeError(AVM2.formatErrorMessage(AVM2.Errors.ConvertNullToObjectError));
                } else if (value === undefined) {
                    throw new TypeError(AVM2.formatErrorMessage(AVM2.Errors.ConvertUndefinedToObjectError));
                } else if (value instanceof XML) {
                    var xl = new XMLList(value.parent, value.name);
                    xl.appendChild(value);
                    return xl;
                } else if (value instanceof XMLList) {
                    return value;
                } else {
                    var parentString = '<parent xmlns=\'' + ASXML.defaultNamespace + '\'>' + value + '</parent>';
                    var x = toXML(parentString);
                    var xl = new XMLList();
                    for (var i = 0; i < x.length(); i++) {
                        var v = x._children[i];
                        v._parent = null;
                        xl.appendChild(v);
                    }
                    return xl;
                }
            }

            // 10.5 ToAttributeName
            function toAttributeName(v) {
                if (v === undefined || v === null || typeof v === "boolean" || typeof v === "number") {
                    throw "TypeError: invalid operand to ToAttributeName()";
                } else if (isXMLType(v)) {
                    v = toString(v);
                } else if (typeof v === 'object' && v !== null) {
                    if (v instanceof ASQName) {
                        return new ASQName(v.uri, v.localName, true);
                    }
                    if (Multiname.isQName(v)) {
                        return ASQName.fromMultiname(v);
                    }
                    v = toString(v);
                }
                if (typeof v === "string") {
                    var ns = Namespace.createNamespace("", "");
                    var qn = new ASQName(ns, v, true);
                } else {
                    // FIXME implement
                }
                return qn;
            }

            // 10.6 ToXMLName
            function toXMLName(mn) {
                if (mn === undefined) {
                    return new ASQName('*');
                }

                // convert argument to a value of type AttributeName or a QName object
                // according to the following:
                if (typeof mn === 'object' && mn !== null) {
                    if (mn instanceof ASQName) {
                        // Object - If the input argument is a QName object,
                        // return the input argument.
                        return mn;
                    }
                    if (Multiname.isQName(mn)) {
                        // ... same as above plus
                        // AttributeName - Return the input argument (no conversion).
                        // AnyName - Return the result of calling ToXMLName("*")
                        return ASQName.fromMultiname(mn);
                    }
                    var name;
                    if (mn instanceof ASXML || mn instanceof ASXMLList) {
                        // XML or XMLList - Convert the input argument to a string using
                        // ToString
                        name = toString(mn);
                    } else if (mn instanceof Multiname) {
                        name = mn.name; // ?? Can be two or none namespaces here
                    } else {
                        // Object - Otherwise, convert the input argument to a
                        // string using ToString
                        name = mn.toString();
                    }
                } else if (typeof mn === 'string') {
                    // String - Create a QName object or AttributeName from the String
                    // as specified below in section 10.6.1. See below
                    name = mn;
                } else {
                    throw new TypeError();
                }

                // ... then convert the result to a QName object or AttributeName
                // as specified in section 10.6.1.
                if (name[0] === '@') {
                    // If the first character of s is "@", ToXMLName creates an
                    // AttributeName using the ToAttributeName operator.
                    return toAttributeName(name.substring(1));
                }
                return new ASQName(name);
            }

            function isQNameAttribute(name) {
                if (typeof name === 'object' && (name instanceof ASQName)) {
                    var flags = name._flags;
                    return !!(flags & 1 /* ATTR_NAME */);
                }
                return false;
            }

            function prefixWithNamespace(namespaces, name, isAttribute) {
                if (!namespaces || namespaces.length !== 1 || !(namespaces[0] instanceof ASNamespace) || (typeof name !== 'string' && name !== undefined)) {
                    return name;
                }
                return new ASQName(namespaces[0], name || '*', isAttribute);
            }

            // 12.1 GetDefaultNamespace
            function getDefaultNamespace() {
                // The scope's default xml namespace is stored in XML.defaultNamespace
                // (see runtime.ts createInterpretedFunction)
                return new ASNamespace("", ASXML.defaultNamespace);
            }

            // 13.1.2.1 isXMLName ( value )
            function isXMLName(v) {
                try  {
                    var qn = new ASQName(v);
                } catch (e) {
                    return false;
                }

                // FIXME scan v to see if it is a valid lexeme and return false if not
                return true;
            }

            function XMLParser() {
                function parseXml(s, sink) {
                    var i = 0, scopes = [{
                            namespaces: [],
                            lookup: {
                                "xmlns": 'http://www.w3.org/2000/xmlns/',
                                "xml": 'http://www.w3.org/XML/1998/namespace'
                            },
                            inScopes: !ASXML.defaultNamespace ? [] : [{ uri: ASXML.defaultNamespace, prefix: '' }],
                            space: 'default',
                            xmlns: (ASXML.defaultNamespace || '')
                        }];
                    function resolveEntities(s) {
                        return s.replace(/&([^;]+);/g, function (all, entity) {
                            if (entity.substring(0, 2) === '#x') {
                                return String.fromCharCode(parseInt(entity.substring(2), 16));
                            } else if (entity.substring(0, 1) === '#') {
                                return String.fromCharCode(parseInt(entity.substring(1), 10));
                            }
                            switch (entity) {
                                case 'lt':
                                    return '<';
                                case 'gt':
                                    return '>';
                                case 'amp':
                                    return '&';
                                case 'quot':
                                    return '\"';
                            }

                            // throw "Unknown entity: " + entity;
                            return all;
                        });
                    }
                    function isWhitespacePreserved() {
                        for (var j = scopes.length - 1; j >= 0; --j) {
                            if (scopes[j].space === "preserve") {
                                return true;
                            }
                        }
                        return false;
                    }
                    function lookupDefaultNs() {
                        for (var j = scopes.length - 1; j >= 0; --j) {
                            if ('xmlns' in scopes[j]) {
                                return scopes[j].xmlns;
                            }
                        }
                        return '';
                    }
                    function lookupNs(prefix) {
                        for (var j = scopes.length - 1; j >= 0; --j) {
                            if (prefix in scopes[j].lookup) {
                                return scopes[j].lookup[prefix];
                            }
                        }
                        return undefined;
                    }
                    function getName(name, resolveDefaultNs) {
                        var j = name.indexOf(':');
                        if (j >= 0) {
                            var prefix = name.substring(0, j);
                            var namespace = lookupNs(prefix);
                            if (namespace === undefined) {
                                throw "Unknown namespace: " + prefix;
                            }
                            var localName = name.substring(j + 1);
                            return {
                                name: namespace + '::' + localName,
                                localName: localName,
                                prefix: prefix,
                                namespace: namespace
                            };
                        } else if (resolveDefaultNs) {
                            return {
                                name: name,
                                localName: name,
                                prefix: '',
                                namespace: lookupDefaultNs()
                            };
                        } else {
                            return {
                                name: name,
                                localName: name,
                                prefix: '',
                                namespace: ''
                            };
                        }
                    }

                    function parseContent(s, start) {
                        var pos = start, name, attributes = [];
                        function skipWs() {
                            while (pos < s.length && isWhitespace(s, pos)) {
                                ++pos;
                            }
                        }
                        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                            ++pos;
                        }
                        name = s.substring(start, pos);
                        skipWs();
                        while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                            skipWs();
                            var attrName = "", attrValue = "";
                            while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                                attrName += s[pos];
                                ++pos;
                            }
                            skipWs();
                            if (s[pos] !== "=")
                                throw "'=' expected";
                            ++pos;
                            skipWs();
                            var attrEndChar = s[pos];
                            if (attrEndChar !== "\"" && attrEndChar !== "\'")
                                throw "Quote expected";
                            var attrEndIndex = s.indexOf(attrEndChar, ++pos);
                            if (attrEndIndex < 0)
                                throw "Unexpected EOF[6]";
                            attrValue = s.substring(pos, attrEndIndex);
                            attributes.push({ name: attrName, value: resolveEntities(attrValue) });
                            pos = attrEndIndex + 1;
                            skipWs();
                        }
                        return { name: name, attributes: attributes, parsed: pos - start };
                    }

                    function parseProcessingInstruction(s, start) {
                        var pos = start, name, value;
                        function skipWs() {
                            while (pos < s.length && isWhitespace(s, pos)) {
                                ++pos;
                            }
                        }
                        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                            ++pos;
                        }
                        name = s.substring(start, pos);
                        skipWs();
                        var attrStart = pos;
                        while (pos < s.length && (s[pos] !== "?" || s[pos + 1] != '>')) {
                            ++pos;
                        }
                        value = s.substring(attrStart, pos);
                        return { name: name, value: value, parsed: pos - start };
                    }

                    while (i < s.length) {
                        var ch = s[i];
                        var j = i;
                        if (ch === "<") {
                            ++j;
                            var ch2 = s[j], q, name;
                            switch (ch2) {
                                case "/":
                                    ++j;
                                    q = s.indexOf(">", j);
                                    if (q < 0) {
                                        throw "Unexpected EOF[1]";
                                    }
                                    name = getName(s.substring(j, q), true);
                                    sink.endElement(name);
                                    scopes.pop();
                                    j = q + 1;
                                    break;
                                case "?":
                                    ++j;
                                    var pi = parseProcessingInstruction(s, j);
                                    if (s.substring(j + pi.parsed, j + pi.parsed + 2) != "?>") {
                                        throw "Unexpected EOF[2]";
                                    }
                                    sink.pi(pi.name, pi.value);
                                    j += pi.parsed + 2;
                                    break;
                                case "!":
                                    if (s.substring(j + 1, j + 3) === "--") {
                                        q = s.indexOf("-->", j + 3);
                                        if (q < 0) {
                                            throw "Unexpected EOF[3]";
                                        }
                                        sink.comment(s.substring(j + 3, q));
                                        j = q + 3;
                                    } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                                        q = s.indexOf("]]>", j + 8);
                                        if (q < 0) {
                                            throw "Unexpected EOF[4]";
                                        }
                                        sink.cdata(s.substring(j + 8, q));
                                        j = q + 3;
                                    } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                                        var q2 = s.indexOf("[", j + 8), complexDoctype = false;
                                        q = s.indexOf(">", j + 8);
                                        if (q < 0) {
                                            throw "Unexpected EOF[5]";
                                        }
                                        if (q2 > 0 && q > q2) {
                                            q = s.indexOf("]>", j + 8);
                                            if (q < 0) {
                                                throw "Unexpected EOF[7]";
                                            }
                                            complexDoctype = true;
                                        }
                                        var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                                        sink.doctype(doctypeContent);

                                        // XXX pull entities ?
                                        j = q + (complexDoctype ? 2 : 1);
                                    } else {
                                        throw "Unknown !tag";
                                    }
                                    break;
                                default:
                                    var content = parseContent(s, j);
                                    var isClosed = false;
                                    if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                                        isClosed = true;
                                    } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                                        throw "Unexpected EOF[2]";
                                    }
                                    var scope = { namespaces: [], lookup: Object.create(null) };
                                    var contentAttributes = content.attributes;
                                    for (q = 0; q < contentAttributes.length; ++q) {
                                        var attribute = contentAttributes[q];
                                        var attributeName = attribute.name;
                                        if (attributeName.substring(0, 6) === "xmlns:") {
                                            var prefix = attributeName.substring(6);
                                            var uri = attribute.value;
                                            if (lookupNs(prefix) !== uri) {
                                                scope.lookup[prefix] = trimWhitespaces(uri);
                                                scope.namespaces.push({ uri: uri, prefix: prefix });
                                            }
                                            delete contentAttributes[q];
                                        } else if (attributeName === "xmlns") {
                                            var uri = attribute.value;
                                            if (lookupDefaultNs() !== uri) {
                                                scope["xmlns"] = trimWhitespaces(uri);
                                                scope.namespaces.push({ uri: uri, prefix: '' });
                                            }
                                            delete contentAttributes[q];
                                        } else if (attributeName.substring(0, 4) === "xml:") {
                                            var xmlAttrName = attributeName.substring(4);
                                            if (xmlAttrName !== 'space' && xmlAttrName !== 'lang' && xmlAttrName !== 'base') {
                                                throw "Invalid xml attribute: " + attributeName;
                                            }
                                            scope[xmlAttrName] = trimWhitespaces(attribute.value);
                                        } else if (attributeName.substring(0, 3) === "xml") {
                                            throw "Invalid xml attribute";
                                        } else {
                                            // skip ordinary attributes until all xmlns have been handled
                                        }
                                    }

                                    // build list of all namespaces including ancestors'
                                    var inScopeNamespaces = [];
                                    scope.namespaces.forEach(function (ns) {
                                        if (!ns.prefix || scope.lookup[ns.prefix] === ns.uri) {
                                            inScopeNamespaces.push(ns);
                                        }
                                    });
                                    scopes[scopes.length - 1].inScopes.forEach(function (ns) {
                                        if ((ns.prefix && !(ns.prefix in scope.lookup)) || (!ns.prefix && !('xmlns' in scope))) {
                                            inScopeNamespaces.push(ns);
                                        }
                                    });
                                    scope.inScopes = inScopeNamespaces;

                                    scopes.push(scope);
                                    var attributes = [];
                                    for (q = 0; q < contentAttributes.length; ++q) {
                                        attribute = contentAttributes[q];
                                        if (attribute) {
                                            attributes.push({ name: getName(attribute.name, false), value: attribute.value });
                                        }
                                    }
                                    sink.beginElement(getName(content.name, true), attributes, inScopeNamespaces, isClosed);
                                    j += content.parsed + (isClosed ? 2 : 1);
                                    if (isClosed)
                                        scopes.pop();
                                    break;
                            }
                        } else {
                            var isWs = true;
                            do {
                                isWs = isWs && isWhitespace(s, j);
                                if (++j >= s.length)
                                    break;
                            } while(s[j] !== "<");
                            var text = s.substring(i, j);
                            sink.text(resolveEntities(text), isWs || isWhitespacePreserved());
                        }
                        i = j;
                    }
                }

                // end of parser
                this.parseFromString = function (s, mimeType) {
                    var currentElement = new XML(1 /* Element */, '', '', '');
                    var elementsStack = [];
                    parseXml(s, {
                        beginElement: function (name, attrs, namespaces, isEmpty) {
                            var parent = currentElement;
                            elementsStack.push(parent);
                            currentElement = createNode(1 /* Element */, name.namespace, name.localName, name.prefix);
                            for (var i = 0; i < attrs.length; ++i) {
                                var rawAttr = attrs[i];
                                var attr = createNode(2 /* Attribute */, rawAttr.name.namespace, rawAttr.name.localName, rawAttr.name.prefix);
                                attr._value = rawAttr.value;
                                currentElement._attributes.push(attr);
                            }
                            for (var i = 0; i < namespaces.length; ++i) {
                                var rawNs = namespaces[i];
                                var ns = Namespace.createNamespace(rawNs.uri, rawNs.prefix);
                                currentElement._inScopeNamespaces.push(ns);
                            }
                            parent.insert(parent.length(), currentElement);
                            if (isEmpty) {
                                currentElement = elementsStack.pop();
                            }
                        },
                        endElement: function (name) {
                            currentElement = elementsStack.pop();
                        },
                        text: function (text, isWhitespace) {
                            if (isWhitespace && ASXML.ignoreWhitespace) {
                                return;
                            }
                            var node = createNode(3 /* Text */, "", "");
                            node._value = text;
                            currentElement.insert(currentElement.length(), node);
                        },
                        cdata: function (text) {
                            var node = createNode(3 /* Text */, "", "");
                            node._value = text;
                            currentElement.insert(currentElement.length(), node);
                        },
                        comment: function (text) {
                            if (ASXML.ignoreComments) {
                                return;
                            }
                            var node = createNode(4 /* Comment */, "", "");
                            node._value = text;
                            currentElement.insert(currentElement.length(), node);
                        },
                        pi: function (name, value) {
                            if (ASXML.ignoreProcessingInstructions) {
                                return;
                            }
                            var node = createNode(5 /* ProcessingInstruction */, "", name);
                            node._value = value;
                            currentElement.insert(currentElement.length(), node);
                        },
                        doctype: function (text) {
                        }
                    });
                    return currentElement;
                };

                function createNode(kind, uri, name, prefix) {
                    return new XML(kind, uri, name, prefix);
                }
            }

            var xmlParser = new XMLParser();

            var ASNamespace = (function (_super) {
                __extends(ASNamespace, _super);
                /**
                * 13.2.2 The Namespace Constructor
                *
                * Namespace ()
                * Namespace (uriValue)
                * Namespace (prefixValue, uriValue)
                */
                function ASNamespace(a, b) {
                    false && _super.call(this);

                    // 1. Create a new Namespace object n
                    var uri = "";
                    var prefix = "";

                    // 2. If prefixValue is not specified and uriValue is not specified
                    if (arguments.length === 0) {
                        // a. Let n.prefix be the empty string
                        // b. Let n.uri be the empty string
                    } else if (arguments.length === 1) {
                        var uriValue = a;

                        // a. If Type(uriValue) is Object and uriValue.[[Class]] == "Namespace"
                        if (Shumway.isObject(uriValue) && uriValue instanceof ASNamespace) {
                            var uriValueAsNamespace = uriValue;

                            // i. Let n.prefix = uriValue.prefix
                            prefix = uriValueAsNamespace.prefix;

                            // ii. Let n.uri = uriValue.uri
                            uri = uriValueAsNamespace.uri;
                        } else if (Shumway.isObject(uriValue) && uriValue instanceof ASQName && uriValue.uri !== null) {
                            // i. Let n.uri = uriValue.uri
                            uri = uriValue.uri;
                            // NOTE implementations that preserve prefixes in qualified names may also set n.prefix = uriValue.[[Prefix]]
                        } else {
                            // i. Let n.uri = ToString(uriValue)
                            uri = toString(uriValue);

                            // ii. If (n.uri is the empty string), let n.prefix be the empty string
                            if (uri === "") {
                                prefix = "";
                            } else {
                                prefix = undefined;
                            }
                        }
                    } else {
                        var prefixValue = a;
                        var uriValue = b;

                        // a. If Type(uriValue) is Object and uriValue.[[Class]] == "QName" and uriValue.uri is not null
                        if (Shumway.isObject(uriValue) && uriValue instanceof ASQName && uriValue.uri !== null) {
                            // i. Let n.uri = uriValue.uri
                            uri = uriValue.uri;
                        } else {
                            // i. Let n.uri = ToString(uriValue)
                            uri = toString(uriValue);
                        }

                        // c. If n.uri is the empty string
                        if (uri === "") {
                            // i. If prefixValue is undefined or ToString(prefixValue) is the empty string
                            if (prefixValue === undefined || toString(prefixValue) === "") {
                                // 1. Let n.prefix be the empty string
                                prefix = "";
                            } else {
                                throw new TypeError();
                            }
                        } else if (prefixValue === undefined) {
                            prefix = undefined;
                        } else if (isXMLName(prefixValue) === false) {
                            // i. Let n.prefix = undefined
                            prefix = undefined;
                        } else {
                            prefix = toString(prefixValue);
                        }
                    }

                    // 5. Return n
                    this._ns = Namespace.createNamespace(uri, prefix);
                }
                ASNamespace.fromNamespace = function (ns) {
                    return new ASNamespace._namespaceConstructor(ns);
                };

                Object.defineProperty(ASNamespace.prototype, "prefix", {
                    get: function () {
                        return this._ns.prefix;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASNamespace.prototype, "uri", {
                    get: function () {
                        return this._ns.uri;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASNamespace.staticNatives = null;
                ASNamespace.instanceNatives = null;
                ASNamespace.instanceConstructor = ASNamespace;

                ASNamespace._namespaceConstructor = function (ns) {
                    this._ns = ns;
                };

                ASNamespace._ = (function () {
                    ASNamespace._namespaceConstructor.prototype = ASNamespace.prototype;
                })();

                ASNamespace.callableConstructor = function (a, b) {
                    // 1. If (prefixValue is not specified and Type(uriValue) is Object and uriValue.[[Class]] == "Namespace")
                    if (arguments.length === 1 && Shumway.isObject(a) && a instanceof ASNamespace) {
                        // a. Return uriValue
                        return a;
                    }

                    switch (arguments.length) {
                        case 0:
                            return new ASNamespace();
                        case 1:
                            return new ASNamespace(a);
                        default:
                            return new ASNamespace(a, b);
                    }
                };
                return ASNamespace;
            })(AS.ASObject);
            AS.ASNamespace = ASNamespace;

            var ASQNameFlags;
            (function (ASQNameFlags) {
                ASQNameFlags[ASQNameFlags["ATTR_NAME"] = 1] = "ATTR_NAME";
                ASQNameFlags[ASQNameFlags["ELEM_NAME"] = 2] = "ELEM_NAME";
                ASQNameFlags[ASQNameFlags["ANY_NAME"] = 4] = "ANY_NAME";
                ASQNameFlags[ASQNameFlags["ANY_NAMESPACE"] = 8] = "ANY_NAMESPACE";
            })(ASQNameFlags || (ASQNameFlags = {}));

            var ASQName = (function (_super) {
                __extends(ASQName, _super);
                /**
                * 13.3.2 The QName Constructor
                *
                * new QName ()
                * new QName (Name)
                * new QName (Namespace, Name)
                */
                function ASQName(a, b, c) {
                    false && _super.call(this);

                    var name;
                    var namespace;

                    if (arguments.length === 0) {
                        name = "";
                    } else if (arguments.length === 1) {
                        name = a;
                    } else {
                        namespace = a;
                        name = b;
                    }

                    // 1. If (Type(Name) is Object and Name.[[Class]] == "QName")
                    if (Shumway.isObject(name) && name instanceof ASQName) {
                        // a. If (Namespace is not specified), return a copy of Name
                        if (arguments.length < 2) {
                            return name;
                        } else {
                            name = name.localName;
                        }
                    }

                    // 2. If (Name is undefined or not specified)
                    if (name === undefined || arguments.length === 0) {
                        // a. Let Name = ""
                        name = "";
                    } else {
                        name = toString(name);
                    }

                    // 4. If (Namespace is undefined or not specified)
                    if (namespace === undefined || arguments.length < 2) {
                        // a. If Name = "*"
                        if (name === "*") {
                            // i. Let Namespace = null
                            namespace = null;
                        } else {
                            // i. Let Namespace = GetDefaultNamespace()
                            namespace = getDefaultNamespace();
                        }
                    }

                    // 5. Let q be a new QName with q.localName = Name
                    var localName = name;
                    var uri;

                    // 6. If Namespace == null
                    if (namespace === null) {
                        // a. Let q.uri = null
                        // NOTE implementations that preserve prefixes in qualified names may also set q.[[Prefix]] to undefined
                        uri = null;
                    } else {
                        // a. Let Namespace be a new Namespace created as if by calling the constructor new Namespace(Namespace)
                        namespace = namespace instanceof ASNamespace ? namespace : new ASNamespace(namespace);

                        // b. Let q.uri = Namespace.uri
                        uri = namespace.uri;
                        // NOTE implementations that preserve prefixes in qualified names may also set q.[[Prefix]] to Namespace.prefix
                    }

                    // 8. Return q
                    var flags = c ? 1 /* ATTR_NAME */ : 2 /* ELEM_NAME */;
                    if (name === '*') {
                        flags |= 4 /* ANY_NAME */;
                    }
                    if (namespace === null) {
                        flags |= 8 /* ANY_NAMESPACE */;
                    }
                    this._mn = new Multiname([namespace ? namespace._ns : null], localName);
                    this._flags = flags;
                }
                ASQName.fromMultiname = function (mn) {
                    var result = Object.create(ASQName.prototype);
                    result._mn = mn;
                    var flags = 0;
                    if (mn.isAttribute()) {
                        flags |= 1 /* ATTR_NAME */;
                    } else {
                        flags |= 2 /* ELEM_NAME */;
                    }
                    if (mn.isAnyName()) {
                        flags |= 4 /* ANY_NAME */;
                    }
                    if (mn.isAnyNamespace()) {
                        flags |= 8 /* ANY_NAMESPACE */;
                    }
                    result._flags = flags;
                    return result;
                };

                Object.defineProperty(ASQName.prototype, "localName", {
                    get: function () {
                        return this._mn.name;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASQName.prototype, "uri", {
                    get: function () {
                        if (this._mn.namespaces[0]) {
                            return this._mn.namespaces[0].uri;
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(ASQName.prototype, "prefix", {
                    /**
                    * 13.3.5.3 [[Prefix]]
                    * The [[Prefix]] property is an optional internal property that is not directly visible to users. It may be used by implementations that preserve prefixes in qualified names.
                    * The value of the [[Prefix]] property is a value of type string or undefined. If the [[Prefix]] property is undefined, the prefix associated with this QName is unknown.
                    */
                    get: function () {
                        return this._mn.namespaces[0].prefix;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * 13.3.5.4 [[GetNamespace]] ( [ InScopeNamespaces ] )
                *
                * The [[GetNamespace]] method is an internal method that returns a Namespace object with a URI matching the URI of this QName. InScopeNamespaces is an optional parameter.
                * If InScopeNamespaces is unspecified, it is set to the empty set. If one or more Namespaces exists in InScopeNamespaces with a URI matching the URI of this QName, one
                * of the matching Namespaces will be returned. If no such namespace exists in InScopeNamespaces, [[GetNamespace]] creates and returns a new Namespace with a URI matching
                * that of this QName. For implementations that preserve prefixes in QNames, [[GetNamespace]] may return a Namespace that also has a matching prefix. The input argument
                * InScopeNamespaces is a set of Namespace objects.
                */
                ASQName.prototype.getNamespace = function (inScopeNamespaces) {
                    if (this.uri === null) {
                        throw "TypeError in QName.prototype.getNamespace()";
                    }
                    if (!inScopeNamespaces) {
                        inScopeNamespaces = [];
                    }
                    var ns;
                    for (var i = 0; i < inScopeNamespaces.length; i++) {
                        if (this.uri === inScopeNamespaces[i].uri) {
                            ns = inScopeNamespaces[i];
                        }
                    }
                    if (!ns) {
                        ns = new ASNamespace(this.prefix, this.uri);
                    }
                    return ns;
                };
                ASQName.instanceConstructor = ASQName;

                ASQName.callableConstructor = function (a, b) {
                    // 1. If Namespace is not specified and Type(Name) is Object and Name.[[Class]] == “QName”
                    if (arguments.length === 1 && Shumway.isObject(a) && a instanceof ASQName) {
                        // a. Return Name
                        return a;
                    }

                    switch (arguments.length) {
                        case 0:
                            return new ASQName();
                        case 1:
                            return new ASQName(a);
                        default:
                            return new ASQName(a, b);
                    }
                };
                return ASQName;
            })(AS.ASNative);
            AS.ASQName = ASQName;

            var ASXML_FLAGS;
            (function (ASXML_FLAGS) {
                ASXML_FLAGS[ASXML_FLAGS["FLAG_IGNORE_COMMENTS"] = 0x01] = "FLAG_IGNORE_COMMENTS";
                ASXML_FLAGS[ASXML_FLAGS["FLAG_IGNORE_PROCESSING_INSTRUCTIONS"] = 0x02] = "FLAG_IGNORE_PROCESSING_INSTRUCTIONS";
                ASXML_FLAGS[ASXML_FLAGS["FLAG_IGNORE_WHITESPACE"] = 0x04] = "FLAG_IGNORE_WHITESPACE";
                ASXML_FLAGS[ASXML_FLAGS["FLAG_PRETTY_PRINTING"] = 0x08] = "FLAG_PRETTY_PRINTING";
                ASXML_FLAGS[ASXML_FLAGS["ALL"] = ASXML_FLAGS.FLAG_IGNORE_COMMENTS | ASXML_FLAGS.FLAG_IGNORE_PROCESSING_INSTRUCTIONS | ASXML_FLAGS.FLAG_IGNORE_WHITESPACE | ASXML_FLAGS.FLAG_PRETTY_PRINTING] = "ALL";
            })(ASXML_FLAGS || (ASXML_FLAGS = {}));

            var ASXMLKind;
            (function (ASXMLKind) {
                ASXMLKind[ASXMLKind["Unknown"] = 0] = "Unknown";
                ASXMLKind[ASXMLKind["Element"] = 1] = "Element";
                ASXMLKind[ASXMLKind["Attribute"] = 2] = "Attribute";
                ASXMLKind[ASXMLKind["Text"] = 3] = "Text";
                ASXMLKind[ASXMLKind["Comment"] = 4] = "Comment";
                ASXMLKind[ASXMLKind["ProcessingInstruction"] = 5] = "ProcessingInstruction";
            })(ASXMLKind || (ASXMLKind = {}));

            var ASXMLKindNames = [
                null, 'element', 'attribute', 'text', 'comment',
                'processing-instruction'];

            var ASXML = (function (_super) {
                __extends(ASXML, _super);
                function ASXML(value) {
                    if (typeof value === "undefined") { value = undefined; }
                    false && _super.call(this);
                    if (!(this instanceof ASXML)) {
                        if (value instanceof ASXML) {
                            return value;
                        }
                        return new ASXML(value);
                    }
                    if (value === null || value === undefined) {
                        value = "";
                    }
                    var x = toXML(value);
                    if (isXMLType(value)) {
                        x = x._deepCopy();
                    }
                    return x;
                }
                ASXML.prototype.init = function (kind, uri, name, prefix) {
                    var namespace = uri || prefix ? new ASNamespace(prefix, uri) : undefined;
                    var isAttribute = kind === 2 /* Attribute */;
                    this._name = new ASQName(namespace, name, isAttribute);
                    this._kind = kind; // E4X [[Class]]
                    this._parent = null;
                    switch (kind) {
                        case 1 /* Element */:
                            this._inScopeNamespaces = [];
                            this._attributes = [];
                            this._children = []; // child nodes go here
                            break;
                        case 4 /* Comment */:
                        case 5 /* ProcessingInstruction */:
                        case 2 /* Attribute */:
                        case 3 /* Text */:
                            this._value = '';
                            break;
                        default:
                            break;
                    }
                    return this;
                };

                // XML.[[Length]]
                ASXML.prototype.length = function () {
                    if (!this._children) {
                        return 0;
                    }
                    return this._children.length;
                };

                // 9.1.1.7 [[DeepCopy]] ( )
                ASXML.prototype._deepCopy = function () {
                    var kind = this._kind;
                    var clone = new ASXML();
                    clone._kind = kind;
                    clone._name = this._name;
                    switch (kind) {
                        case 1 /* Element */:
                            clone._inScopeNamespaces = [];
                            if (this._inScopeNamespaces.length > 0) {
                                this._inScopeNamespaces.forEach(function (ns) {
                                    clone._inScopeNamespaces.push(new ASNamespace(ns.prefix, ns.uri));
                                });
                            }
                            clone._attributes = this._attributes.map(function (attr) {
                                attr = attr._deepCopy();
                                attr._parent = clone;
                                return attr;
                            });
                            clone._children = this._children.map(function (child) {
                                child = child._deepCopy();
                                child._parent = clone;
                                return child;
                            });
                            break;
                        case 4 /* Comment */:
                        case 5 /* ProcessingInstruction */:
                        case 2 /* Attribute */:
                        case 3 /* Text */:
                            clone._value = this._value;
                            break;
                        default:
                            break;
                    }
                    return clone;
                };

                // 9.1.1.10 [[ResolveValue]] ( )
                ASXML.prototype.resolveValue = function () {
                    return this;
                };

                ASXML.prototype._addInScopeNamespaces = function (ns) {
                    if (this._inScopeNamespaces.some(function (ins) {
                        return ins.uri === ns.uri && ins.prefix === ns.prefix;
                    })) {
                        return;
                    }
                    this._inScopeNamespaces.push(ns);
                };

                Object.defineProperty(ASXML, "ignoreComments", {
                    get: function () {
                        return !!(ASXML._flags & 1 /* FLAG_IGNORE_COMMENTS */);
                    },
                    set: function (newIgnore) {
                        newIgnore = !!newIgnore;
                        if (newIgnore) {
                            ASXML._flags |= 1 /* FLAG_IGNORE_COMMENTS */;
                        } else {
                            ASXML._flags &= ~1 /* FLAG_IGNORE_COMMENTS */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, "ignoreProcessingInstructions", {
                    get: function () {
                        return !!(ASXML._flags & 2 /* FLAG_IGNORE_PROCESSING_INSTRUCTIONS */);
                    },
                    set: function (newIgnore) {
                        newIgnore = !!newIgnore;
                        if (newIgnore) {
                            ASXML._flags |= 2 /* FLAG_IGNORE_PROCESSING_INSTRUCTIONS */;
                        } else {
                            ASXML._flags &= ~2 /* FLAG_IGNORE_PROCESSING_INSTRUCTIONS */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, "ignoreWhitespace", {
                    get: function () {
                        return !!(ASXML._flags & 4 /* FLAG_IGNORE_WHITESPACE */);
                    },
                    set: function (newIgnore) {
                        newIgnore = !!newIgnore;
                        if (newIgnore) {
                            ASXML._flags |= 4 /* FLAG_IGNORE_WHITESPACE */;
                        } else {
                            ASXML._flags &= ~4 /* FLAG_IGNORE_WHITESPACE */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, "prettyPrinting", {
                    get: function () {
                        return !!(ASXML._flags & 8 /* FLAG_PRETTY_PRINTING */);
                    },
                    set: function (newPretty) {
                        newPretty = !!newPretty;
                        if (newPretty) {
                            ASXML._flags |= 8 /* FLAG_PRETTY_PRINTING */;
                        } else {
                            ASXML._flags &= ~8 /* FLAG_PRETTY_PRINTING */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, "prettyIndent", {
                    get: function () {
                        return ASXML._prettyIndent;
                    },
                    set: function (newIndent /*int*/ ) {
                        newIndent = newIndent | 0;
                        ASXML._prettyIndent = newIndent;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASXML.prototype.toString = function () {
                    return toString(this);
                };
                ASXML.prototype.native_hasOwnProperty = function (P) {
                    if (typeof P === "undefined") { P = undefined; }
                    // 13.4.4.14 XML.prototype.hasOwnProperty ( P )
                    if (this.hasProperty(P, isQNameAttribute(P), false)) {
                        return true;
                    }
                    return _asHasOwnProperty.call(this, String(P));
                };
                ASXML.prototype.native_propertyIsEnumerable = function (P) {
                    if (typeof P === "undefined") { P = undefined; }
                    // 13.4.4.30 XML.prototype.propertyIsEnumerable ( P )
                    return String(P) === "0";
                };
                ASXML.prototype.addNamespace = function (ns) {
                    // 13.4.4.2 XML.prototype.addNamespace ( namespace )
                    this._addInScopeNamespaces(new ASNamespace(ns));
                    return this;
                };
                ASXML.prototype.appendChild = function (child) {
                    // TODO review
                    if (child._parent) {
                        var index = child._parent._children.indexOf(child);
                        release || assert(index >= 0);
                        child._parent._children.splice(index, 1);
                    }
                    this._children.push(child);
                    child._parent = this;
                    return this;
                };
                ASXML.prototype.attribute = function (arg) {
                    return this.getProperty(arg, true, false);
                };
                ASXML.prototype.attributes = function () {
                    var list = new XMLList();
                    Array.prototype.push.apply(list._children, this._attributes);
                    return list;
                };
                ASXML.prototype.child = function (propertyName) {
                    return this.getProperty(propertyName, isQNameAttribute(propertyName), false);
                };
                ASXML.prototype.childIndex = function () {
                    // 13.4.4.7 XML.prototype.childIndex ( )
                    if (!this._parent || this._kind === 2 /* Attribute */) {
                        return -1;
                    }
                    return this._parent._children.indexOf(this);
                };
                ASXML.prototype.children = function () {
                    var xl = new XMLList(this);
                    Array.prototype.push.apply(xl._children, this._children);
                    return xl;
                };
                ASXML.prototype.contains = function (value) {
                    // 13.4.4.10 XML.prototype.contains ( value )
                    return this === value;
                };
                ASXML.prototype.copy = function () {
                    return this._deepCopy();
                };
                ASXML.prototype.elements = function (name) {
                    if (typeof name === "undefined") { name = "*"; }
                    // 13.4.4.13 XML.prototype.elements ( [ name ] )
                    return this.getProperty(name, false, false);
                };
                ASXML.prototype.hasComplexContent = function () {
                    // 13.4.4.15 XML.prototype.hasComplexContent( )
                    if (this._kind === 2 /* Attribute */ || this._kind === 4 /* Comment */ || this._kind === 5 /* ProcessingInstruction */ || this._kind === 3 /* Text */) {
                        return false;
                    }
                    return this._children.some(function (child) {
                        return child._kind === 1 /* Element */;
                    });
                };
                ASXML.prototype.hasSimpleContent = function () {
                    // 13.4.4.16 XML.prototype.hasSimpleContent()
                    if (this._kind === 4 /* Comment */ || this._kind === 5 /* ProcessingInstruction */) {
                        return false;
                    }
                    if (!this._children && this._children.length === 0) {
                        return true;
                    }
                    return this._children.every(function (child) {
                        return child._kind !== 1 /* Element */;
                    });
                };

                ASXML.prototype.inScopeNamespaces = function () {
                    notImplemented("public.XML::inScopeNamespaces");
                    return;
                };
                ASXML.prototype.insertChildAfter = function (child1, child2) {
                    notImplemented("public.XML::insertChildAfter");
                    return;
                };
                ASXML.prototype.insertChildBefore = function (child1, child2) {
                    notImplemented("public.XML::insertChildBefore");
                    return;
                };
                ASXML.prototype.localName = function () {
                    return this._name.localName;
                };
                ASXML.prototype.name = function () {
                    return this._name;
                };
                ASXML.prototype._namespace = function (prefix, argc /*int*/ ) {
                    argc = argc | 0;
                    notImplemented("public.XML::private _namespace");
                    return;
                };
                ASXML.prototype.namespaceDeclarations = function () {
                    notImplemented("public.XML::namespaceDeclarations");
                    return;
                };
                ASXML.prototype.nodeKind = function () {
                    return ASXMLKindNames[this._kind];
                };
                ASXML.prototype.normalize = function () {
                    notImplemented("public.XML::normalize");
                    return;
                };
                ASXML.prototype.parent = function () {
                    return this._parent;
                };
                ASXML.prototype.processingInstructions = function (name) {
                    if (typeof name === "undefined") { name = "*"; }
                    notImplemented("public.XML::processingInstructions");
                    return;
                };
                ASXML.prototype.prependChild = function (value) {
                    notImplemented("public.XML::prependChild");
                    return;
                };
                ASXML.prototype.removeNamespace = function (ns) {
                    notImplemented("public.XML::removeNamespace");
                    return;
                };
                ASXML.prototype.setChildren = function (value) {
                    notImplemented("public.XML::setChildren");
                    return;
                };
                ASXML.prototype.setLocalName = function (name) {
                    notImplemented("public.XML::setLocalName");
                    return;
                };
                ASXML.prototype.setName = function (name) {
                    notImplemented("public.XML::setName");
                    return;
                };
                ASXML.prototype.setNamespace = function (ns) {
                    notImplemented("public.XML::setNamespace");
                    return;
                };
                ASXML.prototype.toXMLString = function () {
                    return toXMLString(this);
                };
                ASXML.prototype.notification = function () {
                    notImplemented("public.XML::notification");
                    return;
                };
                ASXML.prototype.setNotification = function (f) {
                    f = f;
                    notImplemented("public.XML::setNotification");
                    return;
                };

                ASXML.isTraitsOrDynamicPrototype = function (value) {
                    return value === ASXML.traitsPrototype || value === ASXML.dynamicPrototype;
                };

                ASXML.prototype.asGetEnumerableKeys = function () {
                    if (ASXML.isTraitsOrDynamicPrototype(this)) {
                        return _asGetEnumerableKeys.call(this);
                    }
                    var keys = [];
                    this._children.forEach(function (v, i) {
                        keys.push(v.name);
                    });
                    return keys;
                };

                ASXML.prototype.setProperty = function (p, isAttribute, v) {
                    var i, c, n;
                    var self = this;
                    if (p === p >>> 0) {
                        throw "TypeError in XML.prototype.setProperty(): invalid property name " + p;
                    }
                    if (self._kind === 3 /* Text */ || self._kind === 4 /* Comment */ || self._kind === 5 /* ProcessingInstruction */ || self._kind === 2 /* Attribute */) {
                        return;
                    }
                    if (!v || !isXMLType(v) || v._kind === 3 /* Text */ || v._kind === 2 /* Attribute */) {
                        c = toString(v);
                    } else {
                        c = v._deepCopy();
                    }
                    n = toXMLName(p);

                    if (isAttribute) {
                        if (!this._attributes) {
                            return;
                        }
                        this._attributes.forEach(function (v, i, o) {
                            if (v.name === n.localName) {
                                delete o[i];
                            }
                        });
                        var a = new XML(2 /* Attribute */, n.uri, n.localName);
                        a._value = v;
                        a._parent = this;
                        this._attributes.push(a);
                        return;
                    }

                    var i = undefined;
                    var primitiveAssign = !isXMLType(c) && n.localName !== "*";
                    var isAny = n._flags & 4 /* ANY_NAME */;
                    var isAnyNamespace = n._flags & 8 /* ANY_NAMESPACE */;
                    for (var k = self.length() - 1; k >= 0; k--) {
                        if ((isAny || self._children[k]._kind === 1 /* Element */ && self._children[k]._name.localName === n.localName) && (isAnyNamespace || self._children[k]._kind === 1 /* Element */ && self._children[k]._name.uri === n.uri)) {
                            if (i !== undefined) {
                                self.deleteByIndex(String(i));
                            }
                            i = k;
                        }
                    }
                    if (i === undefined) {
                        i = self.length();
                        if (primitiveAssign) {
                            if (n.uri === null) {
                                var name = new ASQName(getDefaultNamespace(), n);
                            } else {
                                var name = new ASQName(n);
                            }
                            var y = new XML(1 /* Element */, name.uri, name.localName, name.prefix);
                            y._parent = self;
                            var ns = name.getNamespace();
                            self.replace(String(i), y);
                            y.addInScopeNamespace(ns);
                        }
                    }
                    if (primitiveAssign) {
                        self._children[i]._children = []; // blow away kids of x[i]
                        var s = toString(c);
                        if (s !== "") {
                            self._children[i].replace("0", s);
                        }
                    } else {
                        self.replace(String(i), c);
                    }
                    return;
                };

                ASXML.prototype.asSetProperty = function (namespaces, name, flags, value) {
                    if (ASXML.isTraitsOrDynamicPrototype(this)) {
                        return _asSetProperty.call(this, namespaces, name, flags, value);
                    }
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    this.setProperty(prefixWithNamespace(namespaces, name, isAttribute), isAttribute, value);
                };

                // 9.1.1.1 XML.[[Get]] (P)
                ASXML.prototype.getProperty = function (mn, isAttribute, isMethod) {
                    if (isMethod) {
                        var resolved = Multiname.isQName(mn) ? mn : this.resolveMultinameProperty(mn.namespaces, mn.name, mn.flags);
                        return this[Multiname.getQualifiedName(resolved)];
                    }
                    if (!Multiname.isQName(mn) && Shumway.isNumeric(mn)) {
                        // this is a shortcut to the E4X logic that wants us to create a new
                        // XMLList with of size 1 and access it with the given index.
                        if (Number(mn) === 0) {
                            return this;
                        }
                        return null;
                    }
                    var self = this;
                    var name = toXMLName(mn);
                    var xl = new XMLList(self, name);
                    var flags = name._flags;
                    var anyName = flags & 4 /* ANY_NAME */;
                    var anyNamespace = flags & 8 /* ANY_NAMESPACE */;

                    if (isAttribute) {
                        if (self._attributes) {
                            self._attributes.forEach(function (v, i) {
                                if ((anyName || (v._name.localName === name.localName)) && ((anyNamespace || v._name.uri === name.uri))) {
                                    xl.appendChild(v);
                                }
                            });
                        }
                    } else {
                        self._children.forEach(function (v, i) {
                            if ((anyName || v._kind === 1 /* Element */ && v._name.localName === name.localName) && ((anyNamespace || v._kind === 1 /* Element */ && v._name.uri === name.uri))) {
                                xl.appendChild(v);
                            }
                        });
                    }
                    return xl;
                };

                ASXML.prototype.asGetNumericProperty = function (name) {
                    return this.asGetProperty(null, name, 0);
                };

                ASXML.prototype.asSetNumericProperty = function (name, value) {
                    this.asSetProperty(null, name, 0, value);
                };

                ASXML.prototype.asGetProperty = function (namespaces, name, flags) {
                    if (ASXML.isTraitsOrDynamicPrototype(this)) {
                        return _asGetProperty.call(this, namespaces, name, flags);
                    }
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    return this.getProperty(prefixWithNamespace(namespaces, name, isAttribute), isAttribute, false);
                };

                ASXML.prototype.hasProperty = function (mn, isAttribute, isMethod) {
                    if (isMethod) {
                        var resolved = Multiname.isQName(mn) ? mn : this.resolveMultinameProperty(mn.namespaces, mn.name, mn.flags);
                        return !!this[Multiname.getQualifiedName(resolved)];
                    }
                    var self = this;
                    var xl = new XMLList();
                    if (Shumway.isIndex(mn)) {
                        // this is a shortcut to the E4X logic that wants us to create a new
                        // XMLList with of size 1 and access it with the given index.
                        if (Number(mn) === 0) {
                            return true;
                        }
                        return false;
                    }
                    var name = toXMLName(mn);
                    var flags = name._flags;
                    var anyName = flags & 4 /* ANY_NAME */;
                    var anyNamespace = flags & 8 /* ANY_NAMESPACE */;
                    if (isAttribute) {
                        if (self._attributes) {
                            return this._attributes.some(function (v, i) {
                                return ((anyName || (v._name.localName === name.localName)) && ((anyNamespace || v._name.uri === name.uri)));
                            });
                        }
                    } else {
                        if (this._children.some(function (v, i) {
                            return ((anyName || v._kind === 1 /* Element */ && v._name.localName === name.localName) && ((anyNamespace || v._kind === 1 /* Element */ && v._name.uri === name.uri)));
                        })) {
                            return true;
                        }
                    }
                };

                ASXML.prototype.asHasProperty = function (namespaces, name, flags) {
                    if (ASXML.isTraitsOrDynamicPrototype(this)) {
                        return _asHasProperty.call(this, namespaces, name, flags);
                    }
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    name = prefixWithNamespace(namespaces, name, isAttribute);
                    if (this.hasProperty(name, isAttribute, false)) {
                        return true;
                    }

                    // HACK if child with specific name is not present, check object's attributes.
                    // The presence of the attribute/method can be checked during with(), see #850.
                    var resolved = Multiname.isQName(name) ? name : this.resolveMultinameProperty(namespaces, name, flags);
                    return !!this[Multiname.getQualifiedName(resolved)];
                };

                ASXML.prototype.asHasPropertyInternal = function (namespaces, name, flags) {
                    return this.asHasProperty(namespaces, name, flags);
                };

                ASXML.prototype.asCallProperty = function (namespaces, name, flags, isLex, args) {
                    if (ASXML.isTraitsOrDynamicPrototype(this) || isLex) {
                        return _asCallProperty.call(this, namespaces, name, flags, isLex, args);
                    }

                    // Checking if the method exists before calling it
                    var self = this;
                    var result;
                    var method;
                    var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                    if (self.asGetNumericProperty && Multiname.isNumeric(resolved)) {
                        method = self.asGetNumericProperty(resolved);
                    } else {
                        var openMethods = self.asOpenMethods;
                        method = (openMethods && openMethods[resolved]) || self[resolved];
                    }
                    if (method) {
                        return _asCallProperty.call(this, namespaces, name, flags, isLex, args);
                    }

                    // Otherwise, 11.2.2.1 CallMethod ( r , args )
                    // If f == undefined and Type(base) is XMLList and base.[[Length]] == 1
                    //   ii. Return the result of calling CallMethod(r0, args) recursively
                    // f. If f == undefined and Type(base) is XML and base.hasSimpleContent () == true
                    //   i. Let r0 be a new Reference with base object = ToObject(ToString(base)) and property name = P
                    //   ii. Return the result of calling CallMethod(r0, args) recursively
                    if (this.hasSimpleContent()) {
                        return Object(toString(this)).asCallProperty(namespaces, name, flags, isLex, args);
                    }
                    throw new TypeError();
                };

                ASXML.prototype._delete = function (key, isMethod) {
                    notImplemented("XML.[[Delete]]");
                };

                ASXML.prototype.deleteByIndex = function (p) {
                    var self = this;
                    var i = p >>> 0;
                    if (String(i) !== String(p)) {
                        throw "TypeError in XML.prototype.deleteByIndex(): invalid index " + p;
                    }
                    if (p < self.length()) {
                        if (self.children[p]) {
                            self.children[p]._parent = null;
                            delete self.children[p];
                            for (var q = i + 1; q < self.length(); q++) {
                                self.children[q - 1] = self.children[q];
                            }
                            self.children.length = self.children.length - 1;
                        }
                    }
                };

                // 9.1.1.11 [[Insert]] (P, V)
                ASXML.prototype.insert = function (p, v) {
                    var s, i, n;
                    var self = this;
                    if (self._kind === 3 /* Text */ || self._kind === 4 /* Comment */ || self._kind === 5 /* ProcessingInstruction */ || self._kind === 2 /* Attribute */) {
                        return;
                    }
                    i = p >>> 0;
                    if (String(p) !== String(i)) {
                        throw "TypeError in XML.prototype.insert(): invalid property name " + p;
                    }
                    if (self._kind === 1 /* Element */) {
                        var a = self;
                        while (a) {
                            if (a === v) {
                                throw "Error in XML.prototype.insert()";
                            }
                            a = a._parent;
                        }
                    }
                    if (self instanceof ASXMLList) {
                        n = self.length();
                        if (n === 0) {
                            return;
                        }
                    } else {
                        n = 1;
                    }
                    for (var j = self.length() - 1; j >= i; j--) {
                        self._children[j + n] = self._children[j];
                    }
                    if (self instanceof ASXMLList) {
                        n = v.length();
                        for (var j = 0; j < n; j++) {
                            v._children[j]._parent = self;
                            self[i + j] = v[j];
                        }
                    } else {
                        //x.replace(i, v);
                        v._parent = self;
                        self._children[i] = v;
                    }
                };

                // 9.1.1.12 [[Replace]] (P, V)
                ASXML.prototype.replace = function (p, v) {
                    var s;
                    var self = this;
                    if (self._kind === 3 /* Text */ || self._kind === 4 /* Comment */ || self._kind === 5 /* ProcessingInstruction */ || self._kind === 2 /* Attribute */) {
                        return self;
                    }
                    if (v._kind === 1 /* Element */) {
                        var a = self;
                        while (a) {
                            if (a === v) {
                                throw "Error in XML.prototype.replace()";
                            }
                            a = a._parent;
                        }
                    }
                    var i = p >>> 0;
                    if (String(p) === String(i)) {
                        if (i >= self.length()) {
                            p = String(self.length());
                        }
                        if (self._children[p]) {
                            self._children[p]._parent = null;
                        }
                    } else {
                        var toRemove = this.getProperty(p, false, false);
                        if (toRemove.length() === 0) {
                            return self;
                        }
                        toRemove._children.forEach(function (v, i) {
                            var index = self._children.indexOf(v);
                            v._parent = null;
                            if (i === 0) {
                                p = String(index);
                                self._children.splice(index, 1, undefined);
                            } else {
                                self._children.splice(index, 1);
                            }
                        });
                    }

                    if (v._kind === 1 /* Element */ || v._kind === 3 /* Text */ || v._kind === 4 /* Comment */ || v._kind === 5 /* ProcessingInstruction */) {
                        v._parent = self;
                        self._children[p] = v;
                    } else {
                        s = toString(v);
                        var t = new XML();
                        t._parent = self;
                        t._value = s;
                        self._children[p] = t;
                    }
                    return self;
                };

                // 9.1.1.13 [[AddInScopeNamespace]] ( N )
                ASXML.prototype.addInScopeNamespace = function (ns) {
                    var s;
                    var self = this;
                    if (self._kind === 3 /* Text */ || self._kind === 4 /* Comment */ || self._kind === 5 /* ProcessingInstruction */ || self._kind === 2 /* Attribute */) {
                        return;
                    }
                    if (ns.prefix !== undefined) {
                        if (ns.prefix === "" && self._name.uri === "") {
                            return;
                        }
                        var match = null;
                        self._inScopeNamespaces.forEach(function (v, i) {
                            if (v.prefix === ns.prefix) {
                                match = v;
                            }
                        });
                        if (match !== null && match.uri !== ns.uri) {
                            self._inScopeNamespaces.forEach(function (v, i) {
                                if (v.prefix === match.prefix) {
                                    self._inScopeNamespaces[i] = ns; // replace old with new
                                }
                            });
                        }
                        if (self._name.prefix === ns.prefix) {
                            self._name.prefix = undefined;
                        }
                        self._attributes.forEach(function (v, i) {
                            if (v._name.prefix === ns.prefix) {
                                v._name.prefix = undefined;
                            }
                        });
                    }
                };

                // 9.1.1.8 [[Descendants]] (P)
                ASXML.prototype.descendants = function (name) {
                    if (typeof name === "undefined") { name = "*"; }
                    name = toXMLName(name);
                    var flags = name._flags;
                    var self = this;
                    var xl = new XMLList();
                    if (self._kind !== 1 /* Element */) {
                        return xl;
                    }
                    var isAny = flags & 4 /* ANY_NAME */;
                    if (flags & 1 /* ATTR_NAME */) {
                        // Get attributes
                        this._attributes.forEach(function (v, i) {
                            if (isAny || name.localName === v._name.localName) {
                                xl.appendChild(v);
                            }
                        });
                    } else {
                        // Get children
                        this._children.forEach(function (v, i) {
                            if (isAny || name.localName === v._name.localName) {
                                xl.appendChild(v);
                            }
                        });
                    }

                    // Descend
                    this._children.forEach(function (v, i) {
                        xl.appendChild(v.descendants(name));
                    });
                    return xl;
                };

                ASXML.prototype.comments = function () {
                    // 13.4.4.9 XML.prototype.comments ( )
                    var self = this;
                    var xl = new XMLList(self, null);
                    self._children.forEach(function (v, i) {
                        if (v._kind === 4 /* Comment */) {
                            xl.appendChild(v);
                        }
                    });
                    return xl;
                };

                ASXML.prototype.text = function () {
                    // 13.4.4.37 XML.prototype.text ( );
                    var self = this;
                    var xl = new XMLList(self, null);
                    self._children.forEach(function (v, i) {
                        if (v._kind === 3 /* Text */) {
                            xl.appendChild(v);
                        }
                    });
                    return xl;
                };
                ASXML.instanceConstructor = ASXML;

                ASXML.callableConstructor = function (value) {
                    if (typeof value === "undefined") { value = undefined; }
                    // 13.5.1 The XMLList Constructor Called as a Function
                    if (value === null || value === undefined) {
                        value = '';
                    }
                    return toXML(value);
                };

                ASXML.defaultNamespace = '';
                ASXML._flags = ASXML_FLAGS.ALL;
                ASXML._prettyIndent = 2;
                return ASXML;
            })(AS.ASNative);
            AS.ASXML = ASXML;

            function XML(kind, uri, name, prefix) {
                if (kind === undefined) {
                    kind = 3 /* Text */;
                }
                if (uri === undefined) {
                    uri = "";
                }
                if (name === undefined) {
                    name = "";
                }
                this.init(kind, uri, name, prefix);
            }

            XML.prototype = ASXML.prototype;

            var ASXMLList = (function (_super) {
                __extends(ASXMLList, _super);
                function ASXMLList(value) {
                    if (typeof value === "undefined") { value = undefined; }
                    false && _super.call(this);

                    if (value === null || value === undefined) {
                        value = "";
                    }
                    var xl = toXMLList(value);
                    if (isXMLType(value)) {
                        xl = xl._deepCopy();
                    }
                    return xl;
                }
                ASXMLList.prototype.toString = function () {
                    return toString(this);
                };

                // 9.2.1.7 [[DeepCopy]] ( )
                ASXMLList.prototype._deepCopy = function () {
                    // TODO 2. Copy all internal properties of x to list
                    var xl = new XMLList();
                    for (var i = 0; i < this.length(); i++) {
                        xl.appendChild(this._children[i]._deepCopy());
                    }
                    return xl;
                };

                ASXMLList.prototype.hasOwnProperty = function (P) {
                    if (typeof P === "undefined") { P = undefined; }
                    notImplemented("public.XMLList::hasOwnProperty");
                    return;
                };
                ASXMLList.prototype.propertyIsEnumerable = function (P) {
                    if (typeof P === "undefined") { P = undefined; }
                    notImplemented("public.XMLList::propertyIsEnumerable");
                    return;
                };
                ASXMLList.prototype.attribute = function (arg) {
                    return this.getProperty(arg, true, false);
                };
                ASXMLList.prototype.attributes = function () {
                    // 13.5.4.3 XMLList.prototype.attributes ( )
                    return this.getProperty('*', true, false);
                };
                ASXMLList.prototype.child = function (propertyName) {
                    return this.getProperty(propertyName, false, false);
                };
                ASXMLList.prototype.children = function () {
                    // 13.5.4.4 XMLList.prototype.child ( propertyName )
                    return this.getProperty('*', false, false);
                };
                ASXMLList.prototype.comments = function () {
                    // 13.5.4.6 XMLList.prototype.comments ( )
                    var xl = new XMLList(this);
                    this._children.forEach(function (child) {
                        if (child._kind === 1 /* Element */) {
                            var r = child.comments();
                            Array.prototype.push.apply(xl._children, r._children);
                        }
                    });
                    return xl;
                };
                ASXMLList.prototype.contains = function (value) {
                    // 13.5.4.8 XMLList.prototype.contains ( value )
                    return this._children.indexOf(value) >= 0;
                };
                ASXMLList.prototype.copy = function () {
                    // 13.5.4.9 XMLList.prototype.copy ( )
                    return this._deepCopy();
                };
                ASXMLList.prototype.elements = function (name) {
                    if (typeof name === "undefined") { name = "*"; }
                    // 13.5.4.11 XMLList.prototype.elements ( [ name ] )
                    var xl = new XMLList(this, new ASQName(name));
                    this._children.forEach(function (child) {
                        if (child._kind === 1 /* Element */) {
                            var r = child.elements(name);
                            Array.prototype.push.apply(xl._children, r._children);
                        }
                    });
                    return xl;
                };
                ASXMLList.prototype.hasComplexContent = function () {
                    switch (this.length()) {
                        case 0:
                            return false;
                        case 1:
                            return this._children[0].hasComplexContent();
                        default:
                            return this._children.some(function (child) {
                                return child._kind === 1 /* Element */;
                            });
                    }
                };
                ASXMLList.prototype.hasSimpleContent = function () {
                    switch (this.length()) {
                        case 0:
                            return true;
                        case 1:
                            return this._children[0].hasSimpleContent();
                        default:
                            return this._children.every(function (child) {
                                return child._kind !== 1 /* Element */;
                            });
                    }
                };
                ASXMLList.prototype.length = function () {
                    return this._children.length;
                };
                ASXMLList.prototype.name = function () {
                    return this._children[0].name();
                };
                ASXMLList.prototype.normalize = function () {
                    notImplemented("public.XMLList::normalize");
                    return;
                };
                ASXMLList.prototype.parent = function () {
                    // 13.5.4.17 XMLList.prototype.parent ( )
                    if (this.length() === 0) {
                        return undefined;
                    }
                    var parent = this._children[0]._parent;
                    for (var i = 1; i < this.length(); i++) {
                        if (parent !== this._children[i]._parent) {
                            return undefined;
                        }
                    }
                    return parent;
                };
                ASXMLList.prototype.processingInstructions = function (name) {
                    if (typeof name === "undefined") { name = "*"; }
                    notImplemented("public.XMLList::processingInstructions");
                    return;
                };
                ASXMLList.prototype.text = function () {
                    // 13.5.4.20 XMLList.prototype.text ( )
                    var xl = new XMLList(this);
                    this._children.forEach(function (v, i) {
                        if (v._kind === 1 /* Element */) {
                            var gq = v.text();
                            if (gq.length() > 0) {
                                xl.appendChild(gq);
                            }
                        }
                    });
                    return xl;
                };
                ASXMLList.prototype.toXMLString = function () {
                    return toXMLString(this);
                };
                ASXMLList.prototype.addNamespace = function (ns) {
                    notImplemented("public.XMLList::addNamespace");
                    return;
                };
                ASXMLList.prototype.appendChild = function (child) {
                    if (child instanceof ASXMLList) {
                        this._children.push.apply(this._children, child._children);
                        return child;
                    }
                    this._children.push(child);
                    return child;
                    //notImplemented("public.XMLList::appendChild"); return;
                };
                ASXMLList.prototype.childIndex = function () {
                    notImplemented("public.XMLList::childIndex");
                    return;
                };
                ASXMLList.prototype.inScopeNamespaces = function () {
                    notImplemented("public.XMLList::inScopeNamespaces");
                    return;
                };
                ASXMLList.prototype.insertChildAfter = function (child1, child2) {
                    notImplemented("public.XMLList::insertChildAfter");
                    return;
                };
                ASXMLList.prototype.insertChildBefore = function (child1, child2) {
                    notImplemented("public.XMLList::insertChildBefore");
                    return;
                };
                ASXMLList.prototype.nodeKind = function () {
                    notImplemented("public.XMLList::nodeKind");
                    return;
                };
                ASXMLList.prototype._namespace = function (prefix, argc /*int*/ ) {
                    argc = argc | 0;
                    notImplemented("public.XMLList::private _namespace");
                    return;
                };
                ASXMLList.prototype.localName = function () {
                    notImplemented("public.XMLList::localName");
                    return;
                };
                ASXMLList.prototype.namespaceDeclarations = function () {
                    notImplemented("public.XMLList::namespaceDeclarations");
                    return;
                };
                ASXMLList.prototype.prependChild = function (value) {
                    notImplemented("public.XMLList::prependChild");
                    return;
                };
                ASXMLList.prototype.removeNamespace = function (ns) {
                    notImplemented("public.XMLList::removeNamespace");
                    return;
                };
                ASXMLList.prototype.replace = function (propertyName, value) {
                    notImplemented("public.XMLList::replace");
                    return;
                };
                ASXMLList.prototype.setChildren = function (value) {
                    notImplemented("public.XMLList::setChildren");
                    return;
                };
                ASXMLList.prototype.setLocalName = function (name) {
                    notImplemented("public.XMLList::setLocalName");
                    return;
                };
                ASXMLList.prototype.setName = function (name) {
                    notImplemented("public.XMLList::setName");
                    return;
                };
                ASXMLList.prototype.setNamespace = function (ns) {
                    notImplemented("public.XMLList::setNamespace");
                    return;
                };

                ASXMLList.isTraitsOrDynamicPrototype = function (value) {
                    return value === ASXMLList.traitsPrototype || value === ASXMLList.dynamicPrototype;
                };

                ASXMLList.prototype.asGetEnumerableKeys = function () {
                    if (ASXMLList.isTraitsOrDynamicPrototype(this)) {
                        return _asGetEnumerableKeys.call(this);
                    }
                    return this._children.asGetEnumerableKeys();
                };

                // 9.2.1.1 [[Get]] (P)
                ASXMLList.prototype.getProperty = function (mn, isAttribute, isMethod) {
                    if (isMethod) {
                        var resolved = Multiname.isQName(mn) ? mn : this.resolveMultinameProperty(mn.namespaces, mn.name, mn.flags);
                        return this[Multiname.getQualifiedName(resolved)];
                    }
                    if (Shumway.isIndex(mn)) {
                        return this._children[mn];
                    }
                    var name = toXMLName(mn);
                    var xl = new XMLList(this, name);
                    this._children.forEach(function (v, i) {
                        // a. If x[i].[[Class]] == "element",
                        if (v._kind === 1 /* Element */) {
                            // i. Let gq be the result of calling the [[Get]] method of x[i] with argument P
                            var gq = v.getProperty(name, isAttribute, isMethod);

                            // ii. If gq.[[Length]] > 0, call the [[Append]] method of list with argument gq
                            if (gq.length() > 0) {
                                xl.appendChild(gq);
                            }
                        }
                    });
                    return xl;
                };

                ASXMLList.prototype.asGetNumericProperty = function (name) {
                    return this.asGetProperty(null, name, 0);
                };

                ASXMLList.prototype.asSetNumericProperty = function (name, value) {
                    this.asSetProperty(null, name, 0, value);
                };

                ASXMLList.prototype.asGetProperty = function (namespaces, name, flags) {
                    if (ASXMLList.isTraitsOrDynamicPrototype(this)) {
                        return _asGetProperty.call(this, namespaces, name, flags);
                    }
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    return this.getProperty(prefixWithNamespace(namespaces, name, isAttribute), isAttribute, false);
                };

                ASXMLList.prototype.hasProperty = function (mn, isAttribute) {
                    if (Shumway.isIndex(mn)) {
                        return Number(mn) < this._children.length;
                    }

                    // TODO scan children on property presence?
                    return true;
                };

                ASXMLList.prototype.asHasProperty = function (namespaces, name, flags) {
                    if (ASXMLList.isTraitsOrDynamicPrototype(this)) {
                        return _asGetProperty.call(this, namespaces, name, flags);
                    }
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    return this.hasProperty(prefixWithNamespace(namespaces, name, isAttribute), isAttribute);
                };

                ASXMLList.prototype.asHasPropertyInternal = function (namespaces, name, flags) {
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    return this.hasProperty(prefixWithNamespace(namespaces, name, isAttribute), isAttribute);
                };

                ASXMLList.prototype.setProperty = function (mn, isAttribute, value) {
                    if (Shumway.isIndex(mn)) {
                        // TODO do we need to simulate a sparse array here?
                        this.appendChild(value);
                        return;
                    }

                    // TODO
                    var node = this.getProperty(mn, isAttribute, false);
                    toXML(node).replace(0, toXML(value));
                };

                ASXMLList.prototype.asSetProperty = function (namespaces, name, flags, value) {
                    if (ASXMLList.isTraitsOrDynamicPrototype(this)) {
                        return _asSetProperty.call(this, namespaces, name, flags, value);
                    }
                    var isAttribute = flags & Multiname.ATTRIBUTE;
                    name = prefixWithNamespace(namespaces, name, isAttribute);
                    return this.setProperty(name, isAttribute, value);
                };

                ASXMLList.prototype.asCallProperty = function (namespaces, name, flags, isLex, args) {
                    if (ASXMLList.isTraitsOrDynamicPrototype(this) || isLex) {
                        return _asCallProperty.call(this, namespaces, name, flags, isLex, args);
                    }

                    // Checking if the method exists before calling it
                    var self = this;
                    var result;
                    var method;
                    var resolved = self.resolveMultinameProperty(namespaces, name, flags);
                    if (self.asGetNumericProperty && Multiname.isNumeric(resolved)) {
                        method = self.asGetNumericProperty(resolved);
                    } else {
                        var openMethods = self.asOpenMethods;
                        method = (openMethods && openMethods[resolved]) || self[resolved];
                    }
                    if (method) {
                        return _asCallProperty.call(this, namespaces, name, flags, isLex, args);
                    }

                    // Otherwise, 11.2.2.1 CallMethod ( r , args )
                    // If f == undefined and Type(base) is XMLList and base.[[Length]] == 1
                    //   ii. Return the result of calling CallMethod(r0, args) recursively
                    if (this.length() === 1) {
                        return this._children[0].asCallProperty(namespaces, name, flags, isLex, args);
                    }
                    throw new TypeError();
                };
                ASXMLList.instanceConstructor = ASXMLList;

                ASXMLList.callableConstructor = function (value) {
                    if (typeof value === "undefined") { value = undefined; }
                    // 13.5.1 The XMLList Constructor Called as a Function
                    if (value === null || value === undefined) {
                        value = '';
                    }
                    return toXMLList(value);
                };
                return ASXMLList;
            })(AS.ASNative);
            AS.ASXMLList = ASXMLList;

            function XMLList(targetObject, targetProperty) {
                this._targetObject = targetObject ? targetObject : null;
                this._targetProperty = targetProperty ? targetProperty : null;
                this._children = [];
            }

            XMLList.prototype = ASXMLList.prototype;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            var assert = Shumway.Debug.assert;
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var DescribeTypeFlags;
            (function (DescribeTypeFlags) {
                DescribeTypeFlags[DescribeTypeFlags["HIDE_NSURI_METHODS"] = 0x0001] = "HIDE_NSURI_METHODS";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_BASES"] = 0x0002] = "INCLUDE_BASES";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_INTERFACES"] = 0x0004] = "INCLUDE_INTERFACES";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_VARIABLES"] = 0x0008] = "INCLUDE_VARIABLES";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_ACCESSORS"] = 0x0010] = "INCLUDE_ACCESSORS";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_METHODS"] = 0x0020] = "INCLUDE_METHODS";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_METADATA"] = 0x0040] = "INCLUDE_METADATA";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_CONSTRUCTOR"] = 0x0080] = "INCLUDE_CONSTRUCTOR";
                DescribeTypeFlags[DescribeTypeFlags["INCLUDE_TRAITS"] = 0x0100] = "INCLUDE_TRAITS";
                DescribeTypeFlags[DescribeTypeFlags["USE_ITRAITS"] = 0x0200] = "USE_ITRAITS";
                DescribeTypeFlags[DescribeTypeFlags["HIDE_OBJECT"] = 0x0400] = "HIDE_OBJECT";
            })(DescribeTypeFlags || (DescribeTypeFlags = {}));

            var CONSTANT = Shumway.AVM2.ABC.CONSTANT;
            var TRAIT = Shumway.AVM2.ABC.TRAIT;

            function describeTypeJSON(o, flags) {
                // public keys used multiple times while creating the description
                var declaredByKey = publicName("declaredBy");
                var metadataKey = publicName("metadata");
                var accessKey = publicName("access");
                var uriKey = publicName("uri");
                var nameKey = publicName("name");
                var typeKey = publicName("type");
                var returnTypeKey = publicName("returnType");
                var valueKey = publicName("value");
                var keyKey = publicName("key");
                var parametersKey = publicName("parameters");
                var optionalKey = publicName("optional");

                var cls = o.classInfo ? o : Object.getPrototypeOf(o).class;
                release || assert(cls, "No class found for object " + o);
                var info = cls.classInfo;

                var description = {};
                description[nameKey] = unmangledQualifiedName(info.instanceInfo.name);
                description[publicName("isDynamic")] = cls === o ? true : !(info.instanceInfo.flags & 1 /* ClassSealed */);

                //TODO: verify that `isStatic` is false for all instances, true for classes
                description[publicName("isStatic")] = cls === o;
                description[publicName("isFinal")] = cls === o ? true : !(info.instanceInfo.flags & 2 /* ClassFinal */);
                if (flags & 256 /* INCLUDE_TRAITS */) {
                    description[publicName("traits")] = addTraits(cls, flags);
                }
                var metadata = null;
                if (info.metadata) {
                    metadata = Object.keys(info.metadata).map(function (key) {
                        return describeMetadata(info.metadata[key]);
                    });
                }
                description[metadataKey] = metadata;
                return description;

                // privates
                function publicName(str) {
                    return Multiname.getPublicQualifiedName(str);
                }

                function unmangledQualifiedName(mn) {
                    var name = mn.name;
                    var namespace = mn.namespaces[0];
                    if (namespace && namespace.uri) {
                        return namespace.uri + '::' + name;
                    }
                    return name;
                }

                function describeMetadata(metadata) {
                    var result = {};
                    result[nameKey] = metadata.name;
                    result[valueKey] = metadata.value.map(function (value) {
                        var val = {};
                        val[keyKey] = value.key;
                        val[valueKey] = value.value;
                        return value;
                    });
                    return result;
                }

                function addTraits(cls, flags) {
                    var includedMembers = [
                        flags & 8 /* INCLUDE_VARIABLES */,
                        flags & 32 /* INCLUDE_METHODS */,
                        flags & 16 /* INCLUDE_ACCESSORS */,
                        flags & 16 /* INCLUDE_ACCESSORS */];
                    var includeBases = flags & 2 /* INCLUDE_BASES */;
                    var includeMetadata = flags & 64 /* INCLUDE_METADATA */;

                    var obj = {};

                    var basesVal = obj[publicName("bases")] = includeBases ? [] : null;
                    if (flags & 4 /* INCLUDE_INTERFACES */) {
                        var interfacesVal = obj[publicName("interfaces")] = [];
                        if (flags & 512 /* USE_ITRAITS */) {
                            for (var key in cls.implementedInterfaces) {
                                var ifaceName = cls.implementedInterfaces[key].getQualifiedClassName();
                                interfacesVal.push(ifaceName);
                            }
                        }
                    } else {
                        obj[publicName("interfaces")] = null;
                    }

                    var variablesVal = obj[publicName("variables")] = flags & 8 /* INCLUDE_VARIABLES */ ? [] : null;
                    var accessorsVal = obj[publicName("accessors")] = flags & 16 /* INCLUDE_ACCESSORS */ ? [] : null;
                    var methodsVal = obj[publicName("methods")] = flags & 32 /* INCLUDE_METHODS */ ? [] : null;

                    // Needed for accessor-merging
                    var encounteredAccessors = {};

                    var addBase = false;
                    while (cls) {
                        var className = unmangledQualifiedName(cls.classInfo.instanceInfo.name);
                        if (includeBases && addBase) {
                            basesVal.push(className);
                        } else {
                            addBase = true;
                        }
                        if (flags & 512 /* USE_ITRAITS */) {
                            describeTraits(cls.classInfo.instanceInfo.traits);
                        } else {
                            describeTraits(cls.classInfo.traits);
                        }
                        cls = cls.baseClass;
                    }

                    function describeTraits(traits) {
                        release || assert(traits, "No traits array found on class" + cls.classInfo.instanceInfo.name);

                        for (var i = 0; traits && i < traits.length; i++) {
                            var t = traits[i];
                            if (!includedMembers[t.kind] || !t.name.getNamespace().isPublic() && !t.name.uri) {
                                continue;
                            }
                            var name = unmangledQualifiedName(t.name);
                            if (encounteredAccessors[name]) {
                                var val = encounteredAccessors[name];
                                val[accessKey] = 'readwrite';
                                if (t.kind === 2 /* Getter */) {
                                    val[typeKey] = unmangledQualifiedName(t.methodInfo.returnType);
                                }
                                continue;
                            }
                            var val = {};
                            if (includeMetadata && t.metadata) {
                                var metadataVal = val[metadataKey] = [];
                                Object.keys(t.metadata).forEach(function (key) {
                                    metadataVal.push(describeMetadata(t.metadata[key]));
                                });
                            } else {
                                val[metadataKey] = null;
                            }
                            val[declaredByKey] = className;
                            val[uriKey] = t.name.uri === undefined ? null : t.name.uri;
                            val[nameKey] = name;

                            //TODO: check why we have public$$_init in `Object`
                            if (!t.typeName && !(t.methodInfo && t.methodInfo.returnType)) {
                                continue;
                            }
                            val[t.kind === 1 /* Method */ ? returnTypeKey : typeKey] = unmangledQualifiedName(t.kind === 0 /* Slot */ ? t.typeName : t.methodInfo.returnType);
                            switch (t.kind) {
                                case 0 /* Slot */:
                                    val[accessKey] = "readwrite";
                                    variablesVal.push(val);
                                    break;
                                case 1 /* Method */:
                                    var parametersVal = val[parametersKey] = [];
                                    var parameters = t.methodInfo.parameters;
                                    for (var j = 0; j < parameters.length; j++) {
                                        var param = parameters[j];
                                        var paramVal = {};
                                        paramVal[typeKey] = param.type ? unmangledQualifiedName(param.type) : '*';
                                        paramVal[optionalKey] = 'value' in param;
                                        parametersVal.push(paramVal);
                                    }
                                    methodsVal.push(val);
                                    break;
                                case 2 /* Getter */:
                                case 3 /* Setter */:
                                    val[accessKey] = t.kind === 2 /* Getter */ ? "read" : "write";
                                    accessorsVal.push(val);
                                    encounteredAccessors[name] = val;
                                    break;
                                default:
                                    release || assert(false, "Unknown trait type: " + t.kind);
                                    break;
                            }
                        }
                    }
                    return obj;
                }
            }
            AS.describeTypeJSON = describeTypeJSON;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            var assert = Shumway.Debug.assert;

            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

            (function (flash) {
                (function (utils) {
                    var _asGetProperty = Object.prototype.asGetProperty;
                    var _asSetProperty = Object.prototype.asSetProperty;
                    var _asCallProperty = Object.prototype.asCallProperty;
                    var _asHasProperty = Object.prototype.asHasProperty;
                    var _asHasOwnProperty = Object.prototype.asHasOwnProperty;
                    var _asHasTraitProperty = Object.prototype.asHasTraitProperty;
                    var _asDeleteProperty = Object.prototype.asDeleteProperty;
                    var _asGetEnumerableKeys = Object.prototype.asGetEnumerableKeys;

                    /**
                    * TODO: We need a more robust Dictionary implementation that doesn't only give you back
                    * string keys when enumerating.
                    */
                    var Dictionary = (function (_super) {
                        __extends(Dictionary, _super);
                        function Dictionary(weakKeys) {
                            if (typeof weakKeys === "undefined") { weakKeys = false; }
                            false && _super.call(this);
                        }
                        Dictionary.isTraitsOrDynamicPrototype = function (value) {
                            return value === Dictionary.traitsPrototype || value === Dictionary.dynamicPrototype;
                        };

                        Dictionary.makePrimitiveKey = function (key) {
                            if (typeof key === "string" || typeof key === "number") {
                                return key;
                            }
                            release || assert(typeof key === "object" || typeof key === "function", typeof key);
                            return undefined;
                        };

                        Dictionary.prototype.init = function (weakKeys) {
                            this.weakKeys = !!weakKeys;
                            this.map = new WeakMap();
                            if (!weakKeys) {
                                this.keys = [];
                            }
                            this.primitiveMap = createEmptyObject();
                        };

                        Dictionary.prototype.asGetNumericProperty = function (name) {
                            return this.asGetProperty(null, name, 0);
                        };

                        Dictionary.prototype.asSetNumericProperty = function (name, value) {
                            this.asSetProperty(null, name, 0, value);
                        };

                        Dictionary.prototype.asGetProperty = function (namespaces, name, flags) {
                            if (Dictionary.isTraitsOrDynamicPrototype(this)) {
                                return _asGetProperty.call(this, namespaces, name, flags);
                            }
                            var key = Dictionary.makePrimitiveKey(name);
                            if (key !== undefined) {
                                return this.primitiveMap[key];
                            }
                            return this.map.get(Object(name));
                        };

                        Dictionary.prototype.asSetProperty = function (namespaces, name, flags, value) {
                            if (Dictionary.isTraitsOrDynamicPrototype(this)) {
                                return _asSetProperty.call(this, namespaces, name, flags, value);
                            }
                            var key = Dictionary.makePrimitiveKey(name);
                            if (key !== undefined) {
                                this.primitiveMap[key] = value;
                                return;
                            }
                            this.map.set(Object(name), value);
                            if (!this.weakKeys && this.keys.indexOf(name) < 0) {
                                this.keys.push(name);
                            }
                        };

                        // TODO: Not implemented yet.
                        // public asCallProperty(namesp aces: Namespace [], name: any, flags: number, isLex: boolean, args: any []) {
                        //   notImplemented("asCallProperty");
                        // }
                        Dictionary.prototype.asHasProperty = function (namespaces, name, flags) {
                            if (Dictionary.isTraitsOrDynamicPrototype(this)) {
                                return _asHasProperty.call(this, namespaces, name, flags);
                            }
                            var key = Dictionary.makePrimitiveKey(name);
                            if (key !== undefined) {
                                return key in this.primitiveMap;
                            }
                            return this.map.has(Object(name));
                        };

                        Dictionary.prototype.asDeleteProperty = function (namespaces, name, flags) {
                            if (Dictionary.isTraitsOrDynamicPrototype(this)) {
                                return _asDeleteProperty.call(this, namespaces, name, flags);
                            }
                            var key = Dictionary.makePrimitiveKey(name);
                            if (key !== undefined) {
                                delete this.primitiveMap[key];
                            }
                            this.map.delete(Object(name));
                            var i;
                            if (!this.weakKeys && (i = this.keys.indexOf(name)) >= 0) {
                                this.keys.splice(i, 1);
                            }
                            return true;
                        };

                        Dictionary.prototype.asGetEnumerableKeys = function () {
                            if (Dictionary.isTraitsOrDynamicPrototype(this)) {
                                return _asGetEnumerableKeys.call(this);
                            }
                            var primitiveMapKeys = [];
                            for (var k in this.primitiveMap) {
                                primitiveMapKeys.push(k);
                            }
                            if (this.weakKeys) {
                                // TODO implement workaround for flashx.textLayout.external.WeakRef
                                return primitiveMapKeys;
                            }
                            return primitiveMapKeys.concat(this.keys);
                        };
                        Dictionary.protocol = Dictionary.prototype;
                        return Dictionary;
                    })(AS.ASNative);
                    utils.Dictionary = Dictionary;

                    utils.OriginalDictionary = Dictionary;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            var notImplemented = Shumway.Debug.notImplemented;

            var Namespace = Shumway.AVM2.ABC.Namespace;

            (function (flash) {
                (function (utils) {
                    var _asGetProperty = Object.prototype.asGetProperty;
                    var _asSetProperty = Object.prototype.asSetProperty;
                    var _asCallProperty = Object.prototype.asCallProperty;
                    var _asHasProperty = Object.prototype.asHasProperty;
                    var _asHasOwnProperty = Object.prototype.asHasOwnProperty;
                    var _asHasTraitProperty = Object.prototype.asHasTraitProperty;
                    var _asDeleteProperty = Object.prototype.asDeleteProperty;

                    /**
                    * The Proxy class lets you override the default behavior of ActionScript operations (such as retrieving and modifying properties) on an object.
                    */
                    var Proxy = (function (_super) {
                        __extends(Proxy, _super);
                        function Proxy() {
                            _super.apply(this, arguments);
                        }
                        Proxy.prototype.asGetProperty = function (namespaces, name, flags) {
                            var self = this;
                            if (_asHasTraitProperty.call(self, namespaces, name, flags)) {
                                return _asGetProperty.call(self, namespaces, name, flags);
                            }
                            return _asCallProperty.call(self, [Namespace.PROXY], "getProperty", 0, false, [name]);
                        };

                        Proxy.prototype.asGetNumericProperty = function (name) {
                            return this.asGetProperty(null, name, 0);
                        };

                        Proxy.prototype.asSetNumericProperty = function (name, value) {
                            this.asSetProperty(null, name, 0, value);
                        };

                        Proxy.prototype.asSetProperty = function (namespaces, name, flags, value) {
                            var self = this;
                            if (_asHasTraitProperty.call(self, namespaces, name, flags)) {
                                _asSetProperty.call(self, namespaces, name, flags, value);
                                return;
                            }
                            _asCallProperty.call(self, [Namespace.PROXY], "setProperty", 0, false, [name, value]);
                        };

                        Proxy.prototype.asCallProperty = function (namespaces, name, flags, isLex, args) {
                            var self = this;
                            if (_asHasTraitProperty.call(self, namespaces, name, flags)) {
                                return _asCallProperty.call(self, namespaces, name, flags, false, args);
                            }
                            return _asCallProperty.call(self, [Namespace.PROXY], "callProperty", 0, false, [name].concat(args));
                        };

                        Proxy.prototype.asHasProperty = function (namespaces, name, flags) {
                            var self = this;
                            if (_asHasTraitProperty.call(self, namespaces, name, flags)) {
                                return _asHasProperty.call(self, namespaces, name, flags);
                            }
                            return _asCallProperty.call(self, [Namespace.PROXY], "hasProperty", 0, false, [name]);
                        };

                        Proxy.prototype.asHasOwnProperty = function (namespaces, name, flags) {
                            var self = this;
                            if (_asHasTraitProperty.call(self, namespaces, name, flags)) {
                                return _asHasOwnProperty.call(self, namespaces, name, flags);
                            }
                            return _asCallProperty.call(self, [Namespace.PROXY], "hasProperty", 0, false, [name]);
                        };

                        Proxy.prototype.asDeleteProperty = function (namespaces, name, flags) {
                            var self = this;
                            if (_asHasTraitProperty.call(self, namespaces, name, flags)) {
                                return _asDeleteProperty.call(self, namespaces, name, flags);
                            }
                            return _asCallProperty.call(self, [Namespace.PROXY], "deleteProperty", 0, false, [name]);
                        };

                        Proxy.prototype.asNextName = function (index) {
                            notImplemented("Proxy asNextName");
                        };

                        Proxy.prototype.asNextValue = function (index) {
                            notImplemented("Proxy asNextValue");
                        };

                        Proxy.prototype.asNextNameIndex = function (index) {
                            notImplemented("Proxy asNextNameIndex");
                            return;
                        };
                        Proxy.protocol = Proxy.prototype;
                        return Proxy;
                    })(AS.ASNative);
                    utils.Proxy = Proxy;

                    utils.OriginalProxy = Proxy;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            var notImplemented = Shumway.Debug.notImplemented;
            var unexpected = Shumway.Debug.unexpected;

            var clamp = Shumway.NumberUtilities.clamp;

            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

            function throwEOFError() {
                notImplemented("throwEOFError");
                // Runtime.throwErrorFromVM(AVM2.currentDomain(), "flash.errors.EOFError", "End of file was encountered.");
            }

            function throwRangeError() {
                notImplemented("throwEOFError");
                // var error = Errors.ParamRangeError;
                // Runtime.throwErrorFromVM("RangeError", getErrorMessage(error.code), error.code);
            }

            function throwCompressedDataError() {
                notImplemented("throwEOFError");
                //    var error = Errors.CompressedDataError;
                //    Runtime.throwErrorFromVM("CompressedDataError", getErrorMessage(error.code), error.code);
            }

            function checkRange(x, min, max) {
                if (x !== clamp(x, min, max)) {
                    throwRangeError();
                }
            }

            (function (flash) {
                (function (net) {
                    var ObjectEncoding = (function (_super) {
                        __extends(ObjectEncoding, _super);
                        function ObjectEncoding() {
                            _super.apply(this, arguments);
                        }
                        ObjectEncoding.AMF0 = 0;
                        ObjectEncoding.AMF3 = 3;
                        ObjectEncoding.DEFAULT = ObjectEncoding.AMF3;
                        return ObjectEncoding;
                    })(AS.ASNative);
                    net.ObjectEncoding = ObjectEncoding;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;

            (function (flash) {
                (function (utils) {
                    var _asGetProperty = Object.prototype.asGetProperty;
                    var _asSetProperty = Object.prototype.asSetProperty;
                    var _asCallProperty = Object.prototype.asCallProperty;
                    var _asHasProperty = Object.prototype.asHasProperty;
                    var _asHasOwnProperty = Object.prototype.asHasOwnProperty;
                    var _asHasTraitProperty = Object.prototype.asHasTraitProperty;
                    var _asDeleteProperty = Object.prototype.asDeleteProperty;

                    var ByteArray = (function (_super) {
                        __extends(ByteArray, _super);
                        function ByteArray() {
                            false && _super.call(this);
                        }
                        Object.defineProperty(ByteArray, "defaultObjectEncoding", {
                            get: function () {
                                return this._defaultObjectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                this._defaultObjectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        ByteArray.prototype.readObject = function () {
                            switch (this._objectEncoding) {
                                case flash.net.ObjectEncoding.AMF0:
                                    return AVM2.AMF0.read(this);
                                case flash.net.ObjectEncoding.AMF3:
                                    return AVM2.AMF3.read(this);
                                default:
                                    unexpected("Object Encoding");
                            }
                        };

                        ByteArray.prototype.writeObject = function (object) {
                            switch (this._objectEncoding) {
                                case flash.net.ObjectEncoding.AMF0:
                                    return AVM2.AMF0.write(this, object);
                                case flash.net.ObjectEncoding.AMF3:
                                    return AVM2.AMF3.write(this, object);
                                default:
                                    unexpected("Object Encoding");
                            }
                        };
                        ByteArray.instanceConstructor = DataBuffer;
                        ByteArray.staticNatives = [DataBuffer];
                        ByteArray.instanceNatives = [DataBuffer.prototype];
                        ByteArray.callableConstructor = null;

                        ByteArray.initializer = function (source) {
                            var self = this;
                            var align = false;
                            var buffer, length;
                            if (source) {
                                length = 'byteLength' in source ? source.byteLength : source.length;
                                align = (length & 0x7) !== 0;
                                if (source instanceof ArrayBuffer) {
                                    buffer = source;
                                } else if ('buffer' in source && source.buffer instanceof ArrayBuffer) {
                                    buffer = align ? source.buffer : source.buffer.slice();
                                } else if (Array.isArray) {
                                    buffer = align ? source : (new Uint8Array(source)).buffer;
                                }

                                // We have to make sure that the length of the buffer is a multiple of 8 or else
                                // constructing 64 bit views will fail.
                                if (align) {
                                    length = (length + 7) & ~0x7;
                                    var tmp = new ArrayBuffer(length);

                                    // Copy into new buffer.
                                    (new Uint8Array(tmp)).set(new Uint8Array(buffer));
                                    buffer = tmp;
                                }
                            } else {
                                buffer = new ArrayBuffer(ByteArray.INITIAL_SIZE);
                                length = 0;
                            }
                            self._buffer = buffer;
                            self._length = length;
                            self._position = 0;
                            self._updateViews();
                            self._objectEncoding = ByteArray.defaultObjectEncoding;
                            self._littleEndian = false; // AS3 is bigEndian by default.
                            self._bitBuffer = 0;
                            self._bitLength = 0;
                        };

                        ByteArray.protocol = ByteArray.prototype;

                        ByteArray.INITIAL_SIZE = 128;

                        ByteArray._defaultObjectEncoding = flash.net.ObjectEncoding.DEFAULT;
                        return ByteArray;
                    })(AS.ASNative);
                    utils.ByteArray = ByteArray;

                    ByteArray.prototype.asGetNumericProperty = DataBuffer.prototype.getValue;
                    ByteArray.prototype.asSetNumericProperty = DataBuffer.prototype.setValue;

                    utils.OriginalByteArray = ByteArray;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            var notImplemented = Shumway.Debug.notImplemented;
            var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

            (function (flash) {
                (function (system) {
                    var IME = (function (_super) {
                        __extends(IME, _super);
                        function IME() {
                            false && _super.call(this);
                        }
                        Object.defineProperty(IME.prototype, "enabled", {
                            get: function () {
                                notImplemented("public flash.system.IME::get enabled");
                                return;
                            },
                            set: function (enabled) {
                                enabled = !!enabled;
                                notImplemented("public flash.system.IME::set enabled");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(IME.prototype, "conversionMode", {
                            get: function () {
                                notImplemented("public flash.system.IME::get conversionMode");
                                return;
                            },
                            set: function (mode) {
                                mode = asCoerceString(mode);
                                notImplemented("public flash.system.IME::set conversionMode");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        IME.setCompositionString = function (composition) {
                            composition = asCoerceString(composition);
                            notImplemented("public flash.system.IME::static setCompositionString");
                            return;
                        };
                        IME.doConversion = function () {
                            notImplemented("public flash.system.IME::static doConversion");
                            return;
                        };
                        IME.compositionSelectionChanged = function (start /*int*/ , end /*int*/ ) {
                            start = start | 0;
                            end = end | 0;
                            notImplemented("public flash.system.IME::static compositionSelectionChanged");
                            return;
                        };
                        IME.compositionAbandoned = function () {
                            notImplemented("public flash.system.IME::static compositionAbandoned");
                            return;
                        };
                        IME._checkSupported = function () {
                            notImplemented("public flash.system.IME::static _checkSupported");
                            return;
                        };
                        return IME;
                    })(AS.ASNative);
                    system.IME = IME;

                    var System = (function (_super) {
                        __extends(System, _super);
                        function System() {
                            _super.apply(this, arguments);
                        }
                        Object.defineProperty(System, "ime", {
                            get: function () {
                                notImplemented("public flash.system.System::get ime");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        System.setClipboard = function (string) {
                            string = asCoerceString(string);
                            notImplemented("public flash.system.System::static setClipboard");
                            return;
                        };

                        Object.defineProperty(System, "totalMemoryNumber", {
                            get: function () {
                                // notImplemented("public flash.system.System::get totalMemoryNumber"); return;
                                return 1024 * 1024 * 2;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(System, "freeMemory", {
                            get: function () {
                                // notImplemented("public flash.system.System::get freeMemory"); return;
                                return 1024 * 1024;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(System, "privateMemory", {
                            get: function () {
                                notImplemented("public flash.system.System::get privateMemory");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(System, "processCPUUsage", {
                            get: function () {
                                notImplemented("public flash.system.System::get processCPUUsage");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(System, "useCodePage", {
                            get: function () {
                                notImplemented("public flash.system.System::get useCodePage");
                                return;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.system.System::set useCodePage");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(System, "vmVersion", {
                            get: function () {
                                return "1.0 Shumway - Mozilla Research";
                            },
                            enumerable: true,
                            configurable: true
                        });

                        System.pause = function () {
                            notImplemented("public flash.system.System::static pause");
                            return;
                        };

                        System.resume = function () {
                            notImplemented("public flash.system.System::static resume");
                            return;
                        };

                        System.exit = function (code /*uint*/ ) {
                            code = code >>> 0;
                            notImplemented("public flash.system.System::static exit");
                            return;
                        };

                        System.gc = function () {
                            notImplemented("public flash.system.System::static gc");
                            return;
                        };

                        System.pauseForGCIfCollectionImminent = function (imminence) {
                            if (typeof imminence === "undefined") { imminence = 0.75; }
                            imminence = +imminence;
                            notImplemented("public flash.system.System::static pauseForGCIfCollectionImminent");
                            return;
                        };

                        System.disposeXML = function (node) {
                            node = node;
                            notImplemented("public flash.system.System::static disposeXML");
                            return;
                        };

                        Object.defineProperty(System, "swfVersion", {
                            get: function () {
                                return 19;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(System, "apiVersion", {
                            get: function () {
                                return 26;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        System.getArgv = function () {
                            return [];
                        };

                        System.getRunmode = function () {
                            return "mixed";
                        };
                        return System;
                    })(AS.ASNative);
                    system.System = System;
                    system.OriginalSystem = System;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (_Verifier) {
            var Multiname = Shumway.AVM2.ABC.Multiname;
            var ClassInfo = Shumway.AVM2.ABC.ClassInfo;
            var ScriptInfo = Shumway.AVM2.ABC.ScriptInfo;
            var InstanceInfo = Shumway.AVM2.ABC.InstanceInfo;

            var Info = Shumway.AVM2.ABC.Info;
            var MethodInfo = Shumway.AVM2.ABC.MethodInfo;
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var popManyIntoVoid = Shumway.ArrayUtilities.popManyIntoVoid;

            var VerifierError = (function () {
                function VerifierError(message) {
                    if (typeof message === "undefined") { message = ""; }
                    this.message = message;
                    this.name = "VerifierError";
                }
                return VerifierError;
            })();
            _Verifier.VerifierError = VerifierError;

            var TypeInformation = (function () {
                function TypeInformation() {
                }
                return TypeInformation;
            })();
            _Verifier.TypeInformation = TypeInformation;

            var Type = (function () {
                function Type() {
                }
                Type.from = function (info, domain) {
                    release || assert(info.hash);
                    var type = Type._cache[info.hash];
                    if (!type) {
                        type = Type._cache[info.hash] = new TraitsType(info, domain);
                    }
                    return type;
                };

                Type.fromSimpleName = function (name, domain) {
                    return Type.fromName(Multiname.fromSimpleName(name), domain);
                };

                Type.fromName = function (mn, domain) {
                    if (mn === undefined) {
                        return Type.Undefined;
                    } else {
                        var qn = Multiname.isQName(mn) ? Multiname.getFullQualifiedName(mn) : undefined;
                        if (qn) {
                            var type = Type._cache.byQN[qn];
                            if (type) {
                                return type;
                            }
                        }
                        if (qn === Multiname.getPublicQualifiedName("void")) {
                            return Type.Void;
                        }
                        release || assert(domain, "An ApplicationDomain is needed.");
                        var info = domain.findClassInfo(mn);
                        var type = info ? Type.from(info, domain) : Type.Any;
                        if (mn.hasTypeParameter()) {
                            type = new ParameterizedType(type, Type.fromName(mn.typeParameter, domain));
                        }
                        return Type._cache.byQN[qn] = type;
                    }
                    return null;
                };

                Type.initializeTypes = function (domain) {
                    if (Type._typesInitialized) {
                        return;
                    }
                    Type.Any = new AtomType("any", "?");
                    Type.Null = new AtomType("Null", "X");
                    Type.Void = new AtomType("Void", "V");
                    Type.Undefined = new AtomType("Undefined", "_");

                    Type.Int = Type.fromSimpleName("int", domain).instanceType();
                    Type.Uint = Type.fromSimpleName("uint", domain).instanceType();
                    Type.Class = Type.fromSimpleName("Class", domain).instanceType();
                    Type.Array = Type.fromSimpleName("Array", domain).instanceType();
                    Type.Object = Type.fromSimpleName("Object", domain).instanceType();
                    Type.String = Type.fromSimpleName("String", domain).instanceType();
                    Type.Number = Type.fromSimpleName("Number", domain).instanceType();
                    Type.Boolean = Type.fromSimpleName("Boolean", domain).instanceType();
                    Type.Function = Type.fromSimpleName("Function", domain).instanceType();
                    Type.XML = Type.fromSimpleName("XML", domain).instanceType();
                    Type.XMLList = Type.fromSimpleName("XMLList", domain).instanceType();
                    Type.Dictionary = Type.fromSimpleName("flash.utils.Dictionary", domain).instanceType();
                    Type._typesInitialized = true;
                };

                Type.prototype.equals = function (other) {
                    return this === other;
                };

                Type.prototype.merge = function (other) {
                    return Type.Any;
                };

                Type.prototype.instanceType = function () {
                    return Type.Any;
                };

                Type.prototype.classType = function () {
                    return Type.Any;
                };

                Type.prototype.super = function () {
                    Shumway.Debug.abstractMethod("super");
                    return null;
                };

                Type.prototype.applyType = function (parameter) {
                    return null;
                };

                Type.prototype.getTrait = function (mn, isSetter, followSuperType) {
                    return null;
                };

                Type.prototype.isNumeric = function () {
                    return this === Type.Int || this === Type.Uint || this === Type.Number;
                };

                Type.prototype.isString = function () {
                    return this === Type.String;
                };

                Type.prototype.isScriptInfo = function () {
                    return false;
                };

                Type.prototype.isClassInfo = function () {
                    return false;
                };

                Type.prototype.isInstanceInfo = function () {
                    return false;
                };

                Type.prototype.isMethodInfo = function () {
                    return false;
                };

                Type.prototype.isTraitsType = function () {
                    return this instanceof TraitsType;
                };

                Type.prototype.isParameterizedType = function () {
                    return this instanceof ParameterizedType;
                };

                Type.prototype.isMethodType = function () {
                    return this instanceof MethodType;
                };

                Type.prototype.isMultinameType = function () {
                    return this instanceof MultinameType;
                };

                Type.prototype.isConstantType = function () {
                    return this instanceof ConstantType;
                };

                Type.prototype.isSubtypeOf = function (other) {
                    if (this === other || this.equals(other)) {
                        return true;
                    }
                    return this.merge(other) === this;
                };

                Type.prototype.asTraitsType = function () {
                    release || assert(this.isTraitsType());
                    return this;
                };

                Type.prototype.asMethodType = function () {
                    release || assert(this.isMethodType());
                    return this;
                };

                Type.prototype.asMultinameType = function () {
                    release || assert(this.isMultinameType());
                    return this;
                };

                Type.prototype.asConstantType = function () {
                    release || assert(this.isConstantType());
                    return this;
                };

                Type.prototype.getConstantValue = function () {
                    release || assert(this.isConstantType());
                    return this.value;
                };

                Type.prototype.asParameterizedType = function () {
                    release || assert(this.isParameterizedType());
                    return this;
                };
                Type._cache = {
                    byQN: Shumway.ObjectUtilities.createEmptyObject(),
                    byHash: Shumway.ObjectUtilities.createEmptyObject()
                };

                Type._typesInitialized = false;
                return Type;
            })();
            _Verifier.Type = Type;

            var AtomType = (function (_super) {
                __extends(AtomType, _super);
                function AtomType(name, symbol) {
                    _super.call(this);
                    this.name = name;
                    this.symbol = symbol;
                }
                AtomType.prototype.toString = function () {
                    return this.symbol;
                };
                AtomType.prototype.instanceType = function () {
                    return Type.Any;
                };
                return AtomType;
            })(Type);
            _Verifier.AtomType = AtomType;

            var TraitsType = (function (_super) {
                __extends(TraitsType, _super);
                function TraitsType(info, domain) {
                    _super.call(this);
                    this.info = info;
                    this.domain = domain;
                }
                TraitsType.prototype.instanceType = function () {
                    release || assert(this.info instanceof ClassInfo);
                    var classInfo = this.info;
                    return (this._cachedType || (this._cachedType = Type.from(classInfo.instanceInfo, this.domain)));
                };

                TraitsType.prototype.classType = function () {
                    release || assert(this.info instanceof InstanceInfo);
                    var instanceInfo = this.info;
                    return (this._cachedType || (this._cachedType = Type.from(instanceInfo.classInfo, this.domain)));
                };

                TraitsType.prototype.super = function () {
                    if (this.info instanceof ClassInfo) {
                        return Type.Class;
                    }
                    release || assert(this.info instanceof InstanceInfo);
                    var instanceInfo = this.info;
                    if (instanceInfo.superName) {
                        var result = Type.fromName(instanceInfo.superName, this.domain).instanceType();
                        release || assert(result instanceof TraitsType && result.info instanceof InstanceInfo);
                        return result;
                    }
                    return null;
                };

                TraitsType.prototype.findTraitByName = function (traits, mn, isSetter) {
                    var isGetter = !isSetter;
                    var trait;
                    if (!Multiname.isQName(mn)) {
                        release || assert(mn instanceof Multiname);
                        var multiname = mn;
                        var dy;
                        for (var i = 0; i < multiname.namespaces.length; i++) {
                            var qname = multiname.getQName(i);
                            if (mn.namespaces[i].isDynamic()) {
                                dy = qname;
                            } else {
                                if ((trait = this.findTraitByName(traits, qname, isSetter))) {
                                    return trait;
                                }
                            }
                        }
                        if (dy) {
                            return this.findTraitByName(traits, dy, isSetter);
                        }
                    } else {
                        var qn = Multiname.getQualifiedName(mn);
                        for (var i = 0; i < traits.length; i++) {
                            trait = traits[i];
                            if (Multiname.getQualifiedName(trait.name) === qn) {
                                if (isSetter && trait.isGetter() || isGetter && trait.isSetter()) {
                                    continue;
                                }
                                return trait;
                            }
                        }
                    }
                };

                TraitsType.prototype.getTrait = function (mn, isSetter, followSuperType) {
                    if (mn.isMultinameType()) {
                        return null;
                    }
                    var mnValue = mn.getConstantValue();
                    if (mnValue.isAttribute()) {
                        return null;
                    }
                    if (followSuperType && (this.isInstanceInfo() || this.isClassInfo())) {
                        var node = this;
                        do {
                            var trait = node.getTrait(mn, isSetter, false);
                            if (!trait) {
                                node = node.super();
                            }
                        } while(!trait && node);
                        return trait;
                    } else {
                        return this.findTraitByName(this.info.traits, mnValue, isSetter);
                    }
                };

                TraitsType.prototype.getTraitAt = function (slotId) {
                    var traits = this.info.traits;
                    for (var i = traits.length - 1; i >= 0; i--) {
                        if (traits[i].slotId === slotId) {
                            return traits[i];
                        }
                    }
                    Shumway.Debug.unexpected("Cannot find trait with slotId: " + slotId + " in " + traits);
                };

                TraitsType.prototype.equals = function (other) {
                    if (other.isTraitsType()) {
                        return this.info.traits === other.info.traits;
                    }
                    return false;
                };

                TraitsType.prototype.merge = function (other) {
                    if (other.isTraitsType()) {
                        if (this.equals(other)) {
                            return this;
                        }
                        if (this.isNumeric() && other.isNumeric()) {
                            return Type.Number;
                        }
                        if (this.isInstanceInfo() && other.isInstanceInfo()) {
                            var path = [];
                            for (var curr = this; curr; curr = curr.super()) {
                                path.push(curr);
                            }
                            for (var curr = other; curr; curr = curr.super()) {
                                for (var i = 0; i < path.length; i++) {
                                    if (path[i].equals(curr)) {
                                        return curr;
                                    }
                                }
                            }
                            return Type.Object;
                        }
                    }
                    return Type.Any;
                };

                TraitsType.prototype.isScriptInfo = function () {
                    return this.info instanceof ScriptInfo;
                };

                TraitsType.prototype.isClassInfo = function () {
                    return this.info instanceof ClassInfo;
                };

                TraitsType.prototype.isMethodInfo = function () {
                    return this.info instanceof MethodInfo;
                };

                TraitsType.prototype.isInstanceInfo = function () {
                    return this.info instanceof InstanceInfo;
                };

                TraitsType.prototype.isInstanceOrClassInfo = function () {
                    return this.isInstanceInfo() || this.isClassInfo();
                };

                TraitsType.prototype.applyType = function (parameter) {
                    return new ParameterizedType(this, parameter);
                };

                TraitsType.prototype._getInfoName = function () {
                    if (this.info instanceof ScriptInfo) {
                        return "SI";
                    } else if (this.info instanceof ClassInfo) {
                        var classInfo = this.info;
                        return "CI:" + classInfo.instanceInfo.name.name;
                    } else if (this.info instanceof InstanceInfo) {
                        var instanceInfo = this.info;
                        return "II:" + instanceInfo.name.name;
                    } else if (this.info instanceof MethodInfo) {
                        return "MI";
                    }

                    //      else if (this.info instanceof ActivationInfo) {
                    //        return "AC";
                    //      }
                    release || assert(false);
                };

                TraitsType.prototype.toString = function () {
                    switch (this) {
                        case Type.Int:
                            return "I";
                        case Type.Uint:
                            return "U";
                        case Type.Array:
                            return "A";
                        case Type.Object:
                            return "O";
                        case Type.String:
                            return "S";
                        case Type.Number:
                            return "N";
                        case Type.Boolean:
                            return "B";
                        case Type.Function:
                            return "F";
                    }
                    return this._getInfoName();
                };
                return TraitsType;
            })(Type);
            _Verifier.TraitsType = TraitsType;

            var MethodType = (function (_super) {
                __extends(MethodType, _super);
                function MethodType(methodInfo, domain) {
                    _super.call(this, Type.Function.info, domain);
                    this.methodInfo = methodInfo;
                }
                MethodType.prototype.toString = function () {
                    return "MT " + this.methodInfo;
                };
                MethodType.prototype.returnType = function () {
                    return this._cachedType || (this._cachedType = Type.fromName(this.methodInfo.returnType, this.domain));
                };
                return MethodType;
            })(TraitsType);
            _Verifier.MethodType = MethodType;

            var MultinameType = (function (_super) {
                __extends(MultinameType, _super);
                function MultinameType(namespaces, name, flags) {
                    _super.call(this);
                    this.namespaces = namespaces;
                    this.name = name;
                    this.flags = flags;
                }
                MultinameType.prototype.toString = function () {
                    return "MN";
                };
                return MultinameType;
            })(Type);
            _Verifier.MultinameType = MultinameType;

            var ParameterizedType = (function (_super) {
                __extends(ParameterizedType, _super);
                function ParameterizedType(type, parameter) {
                    _super.call(this, type.info, type.domain);
                    this.type = type;
                    this.parameter = parameter;
                }
                return ParameterizedType;
            })(TraitsType);
            _Verifier.ParameterizedType = ParameterizedType;

            var ConstantType = (function (_super) {
                __extends(ConstantType, _super);
                function ConstantType(value) {
                    _super.call(this);
                    this.value = value;
                }
                ConstantType.prototype.toString = function () {
                    return String(this.value);
                };
                ConstantType.from = function (value) {
                    return new ConstantType(value);
                };
                ConstantType.fromArray = function (array) {
                    return array.map(function (value) {
                        return new ConstantType(value);
                    });
                };
                return ConstantType;
            })(Type);
            _Verifier.ConstantType = ConstantType;

            /**
            * Abstract Program State
            */
            var State = (function () {
                function State() {
                    this.id = State.id += 1;
                    this.stack = [];
                    this.scope = [];
                    this.local = [];
                }
                State.prototype.clone = function () {
                    var s = new State();
                    s.originalId = this.id;
                    s.stack = this.stack.slice(0);
                    s.scope = this.scope.slice(0);
                    s.local = this.local.slice(0);
                    return s;
                };
                State.prototype.trace = function (writer) {
                    writer.writeLn(this.toString());
                };
                State.prototype.toString = function () {
                    return "<" + this.id + (this.originalId ? ":" + this.originalId : "") + ", L[" + this.local.join(", ") + "]" + ", S[" + this.stack.join(", ") + "]" + ", $[" + this.scope.join(", ") + "]>";
                };
                State.prototype.equals = function (other) {
                    return State._arrayEquals(this.stack, other.stack) && State._arrayEquals(this.scope, other.scope) && State._arrayEquals(this.local, other.local);
                };
                State._arrayEquals = function (a, b) {
                    if (a.length != b.length) {
                        return false;
                    }
                    for (var i = a.length - 1; i >= 0; i--) {
                        if (!a[i].equals(b[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                State.prototype.isSubset = function (other) {
                    return State._arraySubset(this.stack, other.stack) && State._arraySubset(this.scope, other.scope) && State._arraySubset(this.local, other.local);
                };
                State._arraySubset = function (a, b) {
                    if (a.length != b.length) {
                        return false;
                    }
                    for (var i = a.length - 1; i >= 0; i--) {
                        if (a[i] === b[i] || a[i].equals(b[i])) {
                            continue;
                        }
                        if (a[i].merge(b[i]) !== a[i]) {
                            return false;
                        }
                    }
                    return true;
                };
                State.prototype.merge = function (other) {
                    State._mergeArrays(this.local, other.local);
                    State._mergeArrays(this.stack, other.stack);
                    State._mergeArrays(this.scope, other.scope);
                };
                State._mergeArrays = function (a, b) {
                    release || assert(a.length === b.length, "a: ", a, " b: ", b);
                    for (var i = a.length - 1; i >= 0; i--) {
                        release || assert((a[i] !== undefined) && (b[i] !== undefined));
                        if (a[i] === b[i]) {
                            continue;
                        }
                        a[i] = a[i].merge(b[i]);
                    }
                };
                State.id = 0;
                return State;
            })();
            _Verifier.State = State;

            var Verification = (function () {
                function Verification(methodInfo, domain, savedScope) {
                    this.methodInfo = methodInfo;
                    this.domain = domain;
                    this.savedScope = savedScope;
                    this.writer = new Shumway.IndentingWriter();
                    this.pushCount = 0;
                    this.pushAnyCount = 0;
                    // ...
                    Type.initializeTypes(domain);
                    this.writer = Shumway.AVM2.Verifier.traceLevel.value ? new Shumway.IndentingWriter() : null;
                    this.multinames = methodInfo.abc.constantPool.multinames;
                    this.returnType = Type.Undefined;
                }
                Verification.prototype.verify = function () {
                    var methodInfo = this.methodInfo;
                    if (this.writer) {
                        this.methodInfo.trace(this.writer);
                    }
                    release || assert(methodInfo.localCount >= methodInfo.parameters.length + 1);
                    this._verifyBlocks(this._prepareEntryState());
                };

                Verification.prototype._prepareEntryState = function () {
                    var writer = this.writer;
                    var entryState = new State();
                    var methodInfo = this.methodInfo;
                    this.thisType = methodInfo.holder ? Type.from(methodInfo.holder, this.domain) : Type.Any;
                    entryState.local.push(this.thisType);

                    // Initialize entry state with parameter types.
                    var parameters = methodInfo.parameters;
                    for (var i = 0; i < parameters.length; i++) {
                        entryState.local.push(Type.fromName(parameters[i].type, this.domain).instanceType());
                    }

                    // Push the |rest| or |arguments| array type in the locals.
                    var remainingLocals = methodInfo.localCount - methodInfo.parameters.length - 1;

                    if (methodInfo.needsRest() || methodInfo.needsArguments()) {
                        entryState.local.push(Type.Array);
                        remainingLocals -= 1;
                    }

                    for (var i = 0; i < remainingLocals; i++) {
                        entryState.local.push(Type.Undefined);
                    }

                    release || assert(entryState.local.length === methodInfo.localCount);

                    return entryState;
                };

                Verification.prototype._verifyBlocks = function (entryState) {
                    var writer = this.writer;

                    var blocks = this.methodInfo.analysis.blocks;
                    blocks.forEach(function (x) {
                        x.verifierEntryState = x.verifierExitState = null;
                    });

                    for (var i = 0; i < blocks.length; i++) {
                        blocks[i].bdo = i;
                    }

                    /**
                    * Keep the blocks sorted in dominator order. The SortedList structure is based on a linked
                    * list and uses a liniar search to find the right insertion position and keep the list
                    * sorted. The push operation takes O(n), the pull operations takes O(1).
                    */
                    var worklist = new Shumway.SortedList(function compare(a, b) {
                        return a.bdo - b.bdo;
                    });

                    blocks[0].verifierEntryState = entryState;
                    worklist.push(blocks[0]);

                    while (!worklist.isEmpty()) {
                        var block = worklist.pop();
                        var exitState = block.verifierExitState = block.verifierEntryState.clone();

                        this._verifyBlock(block, exitState);

                        block.succs.forEach(function (successor) {
                            if (worklist.contains(successor)) {
                                if (writer) {
                                    writer.writeLn("Forward Merged Block: " + successor.bid + " " + exitState.toString() + " with " + successor.verifierEntryState.toString());
                                }

                                // merge existing item entry state with current block exit state
                                successor.verifierEntryState.merge(exitState);
                                if (writer) {
                                    writer.writeLn("Merged State: " + successor.verifierEntryState);
                                }
                                return;
                            }

                            if (successor.verifierEntryState) {
                                if (!successor.verifierEntryState.isSubset(exitState)) {
                                    if (writer) {
                                        writer.writeLn("Backward Merged Block: " + block.bid + " with " + successor.bid + " " + exitState.toString() + " with " + successor.verifierEntryState.toString());
                                    }
                                    successor.verifierEntryState.merge(exitState);
                                    worklist.push(successor);
                                    if (writer) {
                                        writer.writeLn("Merged State: " + successor.verifierEntryState);
                                    }
                                }
                                return;
                            }

                            successor.verifierEntryState = exitState.clone();
                            worklist.push(successor);
                            if (writer) {
                                writer.writeLn("Added Block: " + successor.bid + " to worklist: " + successor.verifierEntryState.toString());
                            }
                        });
                    }

                    if (writer) {
                        writer.writeLn("Inferred return type: " + this.returnType);
                        writer.writeLn("Quality pushCount: " + this.pushCount + ", pushAnyCount: " + this.pushAnyCount);
                    }
                    this.methodInfo.inferredReturnType = this.returnType;
                };

                Verification.prototype._verifyBlock = function (block, state) {
                    var self = this;
                    var writer = this.writer;
                    var methodInfo = this.methodInfo;
                    var bytecodes = (methodInfo.analysis.bytecodes);

                    var local = state.local;
                    var stack = state.stack;
                    var scope = state.scope;
                    var bc;

                    function ti() {
                        return bc.ti || (bc.ti = new TypeInformation());
                    }

                    function push(x) {
                        release || assert(x);
                        ti().type = x;
                        stack.push(x);
                        self.pushCount++;
                        if (x === Type.Any) {
                            self.pushAnyCount++;
                        }
                    }

                    function pop(expectedType) {
                        return stack.pop();
                    }

                    function notImplementedBC() {
                        notImplemented(String(bc));
                    }

                    function popMultiname() {
                        var mn = self.multinames[bc.index];
                        if (mn.isRuntime()) {
                            var name;
                            if (mn.isRuntimeName()) {
                                name = pop();
                            } else {
                                name = ConstantType.from(mn.name);
                            }
                            var namespaces;
                            if (mn.isRuntimeNamespace()) {
                                namespaces = [pop()];
                            } else {
                                namespaces = ConstantType.fromArray(mn.namespaces);
                            }
                            return new MultinameType(namespaces, name, mn.flags);
                        }
                        return ConstantType.from(mn);
                    }

                    function isNumericMultiname(mn) {
                        if (mn.isMultinameType() && mn.asMultinameType().name.isNumeric()) {
                            return true;
                        }
                        if (mn.isConstantType() && Multiname.isNumeric(mn.getConstantValue())) {
                            return true;
                        }
                        return false;
                    }

                    function getProperty(object, mn) {
                        if (object.isTraitsType() || object.isParameterizedType()) {
                            var traitsType = object;
                            var trait = traitsType.getTrait(mn, false, true);
                            if (trait) {
                                writer && writer.debugLn("getProperty(" + mn + ") -> " + trait);
                                ti().trait = trait;
                                if (trait.isSlot() || trait.isConst()) {
                                    return Type.fromName(trait.typeName, self.domain).instanceType();
                                } else if (trait.isGetter()) {
                                    return Type.fromName(trait.methodInfo.returnType, self.domain).instanceType();
                                } else if (trait.isClass()) {
                                    return Type.from(trait.classInfo, self.domain);
                                } else if (trait.isMethod()) {
                                    return new MethodType(trait.methodInfo, self.domain);
                                }
                            } else if (isNumericMultiname(mn) && traitsType.isParameterizedType()) {
                                var parameter = traitsType.asParameterizedType().parameter;
                                writer && writer.debugLn("getProperty(" + mn + ") -> " + parameter);
                                return parameter;
                            } else if (traitsType === Type.Array) {
                                // Can't do much about Arrays unfortunately.
                            } else {
                                writer && writer.warnLn("getProperty(" + mn + ")");
                            }
                        }
                        return Type.Any;
                    }

                    function setProperty(object, mn, value) {
                        if (object.isTraitsType() || object.isParameterizedType()) {
                            var traitsType = object;
                            var trait = traitsType.getTrait(mn, true, true);
                            if (trait) {
                                writer && writer.debugLn("setProperty(" + mn + ") -> " + trait);
                                ti().trait = trait;
                            } else if (isNumericMultiname(mn) && traitsType.isParameterizedType()) {
                                // We can optimize these.
                            } else if (traitsType === Type.Array) {
                                // We can optimize these.
                            } else {
                                writer && writer.warnLn("setProperty(" + mn + ")");
                            }
                        }
                    }

                    function findProperty(mn, strict) {
                        if (mn.isMultinameType()) {
                            return Type.Any;
                        }

                        var savedScope = self.savedScope;

                        for (var i = scope.length - 1; i >= -savedScope.length; i--) {
                            var type = i >= 0 ? scope[i] : savedScope[savedScope.length + i];
                            if (type.isTraitsType()) {
                                var traitsType = type;

                                // TODO: Should we be looking for getter / setter traits?
                                var trait = traitsType.getTrait(mn, false, true);
                                if (trait) {
                                    ti().scopeDepth = scope.length - i - 1;
                                    if (traitsType.isClassInfo() || traitsType.isScriptInfo()) {
                                        ti().object = AVM2.Runtime.LazyInitializer.create(traitsType.info);
                                    }
                                    writer && writer.debugLn("findProperty(" + mn + ") -> " + traitsType);
                                    return traitsType;
                                }
                            } else {
                                writer && writer.warnLn("findProperty(" + mn + ")");
                                return Type.Any;
                            }
                        }

                        var resolved = self.domain.findDefiningScript(mn.getConstantValue(), false);
                        if (resolved) {
                            ti().object = AVM2.Runtime.LazyInitializer.create(resolved.script);
                            var type = Type.from(resolved.script, self.domain);
                            writer && writer.debugLn("findProperty(" + mn + ") -> " + type);
                            return type;
                        }

                        if (mn.isConstantType()) {
                            if (mn.getConstantValue().name === "unsafeJSNative") {
                                return Type.Any;
                            }
                        }

                        writer && writer.warnLn("findProperty(" + mn + ")");
                        return Type.Any;
                    }

                    function accessSlot(object) {
                        if (object instanceof TraitsType) {
                            var traitsType = object;
                            var trait = traitsType.getTraitAt(bc.index);
                            writer && writer.debugLn("accessSlot() -> " + trait);
                            if (trait) {
                                ti().trait = trait;
                                if (trait.isSlot()) {
                                    return Type.fromName(trait.typeName, self.domain).instanceType();
                                } else if (trait.isClass()) {
                                    return Type.from(trait.classInfo, self.domain);
                                }
                            }
                        }
                        return Type.Any;
                    }

                    function construct(object) {
                        if (object.isTraitsType() || object.isParameterizedType()) {
                            if (object === Type.Function || object === Type.Class || object === Type.Object) {
                                return Type.Object;
                            }
                            return object.instanceType();
                        } else {
                            writer && writer.warnLn("construct(" + object + ")");
                            return Type.Any;
                        }
                    }

                    var globalScope = this.savedScope[0];
                    var value, object, a, b, object, mn, type, returnType;

                    for (var bci = block.position, end = block.end.position; bci <= end; bci++) {
                        bc = bytecodes[bci];
                        var op = bc.op;

                        /**
                        * Skip debug ops.
                        */
                        if (op === 240 /* debugline */ || op === 241 /* debugfile */) {
                            continue;
                        }

                        if (writer && Shumway.AVM2.Verifier.traceLevel.value > 1) {
                            writer.writeLn(("stateBefore: " + state.toString() + " $$[" + this.savedScope.join(", ") + "]").padRight(' ', 100) + " : " + bci + ", " + bc.toString(methodInfo.abc));
                        }

                        switch (op) {
                            case 1 /* bkpt */:
                                break;
                            case 3 /* throw */:
                                pop();
                                break;
                            case 4 /* getsuper */:
                                mn = popMultiname();
                                object = pop();
                                release || assert(object.super());
                                ti().baseClass = AVM2.Runtime.LazyInitializer.create(this.thisType.asTraitsType().super().classType().info);
                                push(getProperty(object.super(), mn));
                                break;
                            case 5 /* setsuper */:
                                value = pop();
                                mn = popMultiname();
                                object = pop();
                                release || assert(object.super());
                                ti().baseClass = AVM2.Runtime.LazyInitializer.create(this.thisType.asTraitsType().super().classType().info);
                                setProperty(object.super(), mn, value);
                                break;
                            case 6 /* dxns */:
                                notImplementedBC();
                                break;
                            case 7 /* dxnslate */:
                                notImplementedBC();
                                break;
                            case 8 /* kill */:
                                state.local[bc.index] = Type.Undefined;
                                break;
                            case 10 /* lf32x4 */:
                                notImplementedBC();
                                break;
                            case 11 /* sf32x4 */:
                                notImplementedBC();
                                break;
                            case 12 /* ifnlt */:
                            case 24 /* ifge */:
                            case 13 /* ifnle */:
                            case 23 /* ifgt */:
                            case 14 /* ifngt */:
                            case 22 /* ifle */:
                            case 15 /* ifnge */:
                            case 21 /* iflt */:
                            case 19 /* ifeq */:
                            case 20 /* ifne */:
                            case 25 /* ifstricteq */:
                            case 26 /* ifstrictne */:
                                pop();
                                pop();
                                break;
                            case 16 /* jump */:
                                break;
                            case 17 /* iftrue */:
                            case 18 /* iffalse */:
                                pop();
                                break;
                            case 27 /* lookupswitch */:
                                pop(Type.Int);
                                break;
                            case 29 /* popscope */:
                                scope.pop();
                                break;
                            case 30 /* nextname */:
                            case 35 /* nextvalue */:
                                pop(Type.Int);
                                pop();
                                push(Type.Any);
                                break;
                            case 31 /* hasnext */:
                                push(Type.Boolean);
                                break;
                            case 50 /* hasnext2 */:
                                push(Type.Boolean);
                                break;
                            case 32 /* pushnull */:
                                push(Type.Null);
                                break;
                            case 33 /* pushundefined */:
                                push(Type.Undefined);
                                break;
                            case 34 /* pushfloat */:
                                notImplementedBC();
                                break;
                            case 36 /* pushbyte */:
                                push(Type.Int);
                                break;
                            case 37 /* pushshort */:
                                push(Type.Int);
                                break;
                            case 44 /* pushstring */:
                                push(Type.String);
                                break;
                            case 45 /* pushint */:
                                push(Type.Int);
                                break;
                            case 46 /* pushuint */:
                                push(Type.Uint);
                                break;
                            case 47 /* pushdouble */:
                                push(Type.Number);
                                break;
                            case 38 /* pushtrue */:
                                push(Type.Boolean);
                                break;
                            case 39 /* pushfalse */:
                                push(Type.Boolean);
                                break;
                            case 40 /* pushnan */:
                                push(Type.Number);
                                break;
                            case 41 /* pop */:
                                pop();
                                break;
                            case 42 /* dup */:
                                value = pop();
                                push(value);
                                push(value);
                                break;
                            case 43 /* swap */:
                                a = pop();
                                b = pop();
                                push(a);
                                push(b);
                                break;
                            case 28 /* pushwith */:
                                // TODO: We need to keep track that this is a with scope and thus it can have dynamic properties
                                // attached to it. For now, push |Type.Any|.
                                pop();
                                scope.push(Type.Any);
                                break;
                            case 48 /* pushscope */:
                                scope.push(pop());
                                break;
                            case 49 /* pushnamespace */:
                                notImplementedBC();
                                break;
                            case 53 /* li8 */:
                            case 54 /* li16 */:
                            case 55 /* li32 */:
                                push(Type.Int);
                                break;
                            case 56 /* lf32 */:
                            case 57 /* lf64 */:
                                push(Type.Number);
                                break;
                            case 58 /* si8 */:
                            case 59 /* si16 */:
                            case 60 /* si32 */:
                                pop(Type.Int);
                                break;
                            case 61 /* sf32 */:
                            case 62 /* sf64 */:
                                pop(Type.Number);
                                break;
                            case 64 /* newfunction */:
                                push(Type.Function);
                                break;
                            case 65 /* call */:
                                popManyIntoVoid(stack, bc.argCount);
                                object = pop();
                                pop();
                                push(Type.Any);
                                break;
                            case 67 /* callmethod */:
                                throw new VerifierError("callmethod");
                            case 68 /* callstatic */:
                                notImplementedBC();
                                break;
                            case 69 /* callsuper */:
                            case 78 /* callsupervoid */:
                            case 79 /* callpropvoid */:
                            case 70 /* callproperty */:
                            case 76 /* callproplex */:
                                popManyIntoVoid(stack, bc.argCount);
                                mn = popMultiname();
                                object = pop();
                                if (op === 69 /* callsuper */ || op === 78 /* callsupervoid */) {
                                    object = this.thisType.super();
                                    ti().baseClass = AVM2.Runtime.LazyInitializer.create(this.thisType.asTraitsType().super().classType().info);
                                }
                                type = getProperty(object, mn);
                                if (op === 79 /* callpropvoid */ || op === 78 /* callsupervoid */) {
                                    break;
                                }
                                if (type.isMethodType()) {
                                    returnType = type.asMethodType().returnType().instanceType();
                                } else if (type.isTraitsType() && type.isClassInfo()) {
                                    returnType = type.instanceType();
                                } else {
                                    returnType = Type.Any;
                                }
                                push(returnType);
                                break;
                            case 71 /* returnvoid */:
                                this.returnType.merge(Type.Undefined);
                                break;
                            case 72 /* returnvalue */:
                                type = pop();
                                if (methodInfo.returnType) {
                                    var coerceType = Type.fromName(methodInfo.returnType, this.domain).instanceType();
                                    if (coerceType.isSubtypeOf(type)) {
                                        ti().noCoercionNeeded = true;
                                    }
                                }
                                break;
                            case 73 /* constructsuper */:
                                popManyIntoVoid(stack, bc.argCount);
                                stack.pop();
                                if (this.thisType.isInstanceInfo() && this.thisType.super() === Type.Object) {
                                    ti().noCallSuperNeeded = true;
                                } else {
                                    ti().baseClass = AVM2.Runtime.LazyInitializer.create(this.thisType.asTraitsType().super().classType().info);
                                }
                                break;
                            case 66 /* construct */:
                                popManyIntoVoid(stack, bc.argCount);
                                push(construct(pop()));
                                break;
                            case 74 /* constructprop */:
                                popManyIntoVoid(stack, bc.argCount);
                                mn = popMultiname();
                                push(construct(getProperty(stack.pop(), mn)));
                                break;
                            case 75 /* callsuperid */:
                                notImplementedBC();
                                break;
                            case 77 /* callinterface */:
                                notImplementedBC();
                                break;
                            case 80 /* sxi1 */:
                            case 81 /* sxi8 */:
                            case 82 /* sxi16 */:
                                break;
                            case 83 /* applytype */:
                                release || assert(bc.argCount === 1);
                                value = pop();
                                object = pop();
                                if (object === Type.Any) {
                                    push(Type.Any);
                                } else {
                                    push(object.applyType(value));
                                }
                                break;
                            case 84 /* pushfloat4 */:
                                notImplementedBC();
                                break;
                            case 85 /* newobject */:
                                popManyIntoVoid(stack, bc.argCount * 2);
                                push(Type.Object);
                                break;
                            case 86 /* newarray */:
                                popManyIntoVoid(stack, bc.argCount);
                                push(Type.Array);
                                break;
                            case 87 /* newactivation */:
                                push(Type.from(this.methodInfo, this.domain));
                                break;
                            case 88 /* newclass */:
                                // The newclass bytecode is not supported because it needs
                                // the base class which might not always be available.
                                // The functions initializing classes should not be performance
                                // critical anyway.
                                // throw new VerifierError("Not Supported");
                                push(Type.Any);
                                break;
                            case 89 /* getdescendants */:
                                popMultiname();
                                pop();
                                push(Type.XMLList);
                                break;
                            case 90 /* newcatch */:
                                push(Type.Any);
                                break;
                            case 93 /* findpropstrict */:
                                push(findProperty(popMultiname(), true));
                                break;
                            case 94 /* findproperty */:
                                push(findProperty(popMultiname(), false));
                                break;
                            case 95 /* finddef */:
                                notImplementedBC();
                                break;
                            case 96 /* getlex */:
                                mn = popMultiname();
                                push(getProperty(findProperty(mn, true), mn));
                                break;
                            case 104 /* initproperty */:
                            case 97 /* setproperty */:
                                value = pop();
                                mn = popMultiname();
                                object = pop();
                                setProperty(object, mn, value);
                                break;
                            case 98 /* getlocal */:
                                push(local[bc.index]);
                                break;
                            case 99 /* setlocal */:
                                local[bc.index] = pop();
                                break;
                            case 100 /* getglobalscope */:
                                push(globalScope);
                                ti().object = AVM2.Runtime.LazyInitializer.create(globalScope.asTraitsType().info);
                                break;
                            case 101 /* getscopeobject */:
                                push(scope[bc.index]);
                                break;
                            case 102 /* getproperty */:
                                mn = popMultiname();
                                object = pop();
                                push(getProperty(object, mn));
                                break;
                            case 103 /* getouterscope */:
                                notImplementedBC();
                                break;
                            case 105 /* setpropertylate */:
                                notImplementedBC();
                                break;
                            case 106 /* deleteproperty */:
                                popMultiname();
                                pop();
                                push(Type.Boolean);
                                break;
                            case 107 /* deletepropertylate */:
                                notImplementedBC();
                                break;
                            case 108 /* getslot */:
                                push(accessSlot(pop()));
                                break;
                            case 109 /* setslot */:
                                value = pop();
                                object = pop();
                                accessSlot(object);
                                break;
                            case 110 /* getglobalslot */:
                                notImplementedBC();
                                break;
                            case 111 /* setglobalslot */:
                                notImplementedBC();
                                break;
                            case 112 /* convert_s */:
                                pop();
                                push(Type.String);
                                break;
                            case 113 /* esc_xelem */:
                                pop();
                                push(Type.String);
                                break;
                            case 114 /* esc_xattr */:
                                pop();
                                push(Type.String);
                                break;
                            case 131 /* coerce_i */:
                            case 115 /* convert_i */:
                                pop();
                                push(Type.Int);
                                break;
                            case 136 /* coerce_u */:
                            case 116 /* convert_u */:
                                pop();
                                push(Type.Uint);
                                break;
                            case 132 /* coerce_d */:
                            case 117 /* convert_d */:
                                pop();
                                push(Type.Number);
                                break;
                            case 129 /* coerce_b */:
                            case 118 /* convert_b */:
                                pop();
                                push(Type.Boolean);
                                break;
                            case 119 /* convert_o */:
                                notImplementedBC();
                                break;
                            case 120 /* checkfilter */:
                                break;
                            case 121 /* convert_f */:
                                pop();
                                push(Type.Number);
                                break;
                            case 122 /* unplus */:
                                notImplementedBC();
                                break;
                            case 123 /* convert_f4 */:
                                notImplementedBC();
                                break;
                            case 128 /* coerce */:
                                // print("<<< " + multinames[bc.index] + " >>>");
                                type = pop();
                                var coerceType = Type.fromName(this.multinames[bc.index], this.domain).instanceType();
                                if (coerceType.isSubtypeOf(type)) {
                                    ti().noCoercionNeeded = true;
                                }
                                push(coerceType);
                                break;
                            case 130 /* coerce_a */:
                                break;
                            case 133 /* coerce_s */:
                                pop();
                                push(Type.String);
                                break;
                            case 134 /* astype */:
                                type = pop();
                                var asType = Type.fromName(this.multinames[bc.index], this.domain).instanceType();
                                if (asType.isSubtypeOf(type)) {
                                    ti().noCoercionNeeded = true;
                                }
                                push(asType);
                                break;
                            case 135 /* astypelate */:
                                type = pop();
                                pop();
                                if (type.isTraitsType()) {
                                    push(type.instanceType());
                                } else {
                                    push(Type.Any);
                                }
                                break;
                            case 137 /* coerce_o */:
                                notImplementedBC();
                                break;
                            case 144 /* negate */:
                            case 145 /* increment */:
                            case 147 /* decrement */:
                                pop();
                                push(Type.Number);
                                break;
                            case 146 /* inclocal */:
                            case 148 /* declocal */:
                                local[bc.index] = Type.Number;
                                break;
                            case 149 /* typeof */:
                                pop();
                                push(Type.String);
                                break;
                            case 150 /* not */:
                                pop();
                                push(Type.Boolean);
                                break;
                            case 160 /* add */:
                                b = pop();
                                a = pop();
                                if (a.isNumeric() && b.isNumeric()) {
                                    push(Type.Number);
                                } else if (a === Type.String || b === Type.String) {
                                    push(Type.String);
                                } else {
                                    push(Type.Any);
                                }
                                break;
                            case 161 /* subtract */:
                            case 162 /* multiply */:
                            case 163 /* divide */:
                            case 164 /* modulo */:
                                pop();
                                pop();
                                push(Type.Number);
                                break;
                            case 168 /* bitand */:
                            case 169 /* bitor */:
                            case 170 /* bitxor */:
                            case 165 /* lshift */:
                            case 166 /* rshift */:
                            case 167 /* urshift */:
                                pop();
                                pop();
                                push(Type.Int);
                                break;
                            case 151 /* bitnot */:
                                pop();
                                push(Type.Int);
                                break;
                            case 171 /* equals */:
                            case 172 /* strictequals */:
                            case 173 /* lessthan */:
                            case 174 /* lessequals */:
                            case 175 /* greaterthan */:
                            case 176 /* greaterequals */:
                            case 177 /* instanceof */:
                            case 180 /* in */:
                                pop();
                                pop();
                                push(Type.Boolean);
                                break;
                            case 178 /* istype */:
                                pop();
                                push(Type.Boolean);
                                break;
                            case 179 /* istypelate */:
                                pop();
                                pop();
                                push(Type.Boolean);
                                break;
                            case 194 /* inclocal_i */:
                            case 195 /* declocal_i */:
                                local[bc.index] = Type.Int;
                                break;
                            case 193 /* decrement_i */:
                            case 192 /* increment_i */:
                            case 196 /* negate_i */:
                                pop();
                                push(Type.Int);
                                break;
                            case 197 /* add_i */:
                            case 198 /* subtract_i */:
                            case 199 /* multiply_i */:
                                pop();
                                pop();
                                push(Type.Int); // or Number?
                                break;
                            case 208 /* getlocal0 */:
                            case 209 /* getlocal1 */:
                            case 210 /* getlocal2 */:
                            case 211 /* getlocal3 */:
                                push(local[op - 208 /* getlocal0 */]);
                                break;
                            case 212 /* setlocal0 */:
                            case 213 /* setlocal1 */:
                            case 214 /* setlocal2 */:
                            case 215 /* setlocal3 */:
                                local[op - 212 /* setlocal0 */] = pop();
                                break;
                            case 239 /* debug */:
                                break;
                            case 242 /* bkptline */:
                                break;
                            case 243 /* timestamp */:
                                break;
                            default:
                                console.info("Not Implemented: " + bc);
                        }
                    }
                };
                return Verification;
            })();

            var Verifier = (function () {
                function Verifier() {
                }
                Verifier.prototype._prepareScopeObjects = function (methodInfo, scope) {
                    var domain = methodInfo.abc.applicationDomain;
                    var scopeObjects = scope.getScopeObjects();
                    return scopeObjects.map(function (object) {
                        if (object instanceof Info) {
                            return Type.from(object, domain);
                        }
                        if (object instanceof Shumway.AVM2.Runtime.Global) {
                            return Type.from(object.scriptInfo, domain);
                        }
                        if (object instanceof Shumway.AVM2.AS.ASClass) {
                            return Type.from(object.classInfo, domain);
                        }
                        if (object instanceof Shumway.AVM2.Runtime.ActivationInfo) {
                            return Type.from(object.methodInfo, domain);
                        }
                        if (object.class) {
                            return Type.from(object.class.classInfo.instanceInfo, domain);
                        }
                        release || assert(false, object.toString());
                        return Type.Any;
                    });
                };
                Verifier.prototype.verifyMethod = function (methodInfo, scope) {
                    var scopeTypes = this._prepareScopeObjects(methodInfo, scope);
                    new Verification(methodInfo, methodInfo.abc.applicationDomain, scopeTypes).verify();
                };
                return Verifier;
            })();
            _Verifier.Verifier = Verifier;
        })(AVM2.Verifier || (AVM2.Verifier = {}));
        var Verifier = AVM2.Verifier;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            /**
            * SSA-based Sea-of-Nodes IR based on Cliff Click's Work: A simple graph-based intermediate
            * representation (http://doi.acm.org/10.1145/202530.202534)
            *
            * Node Hierarchy:
            *
            * Node
            *  - Control
            *    - Region
            *      - Start
            *    - End
            *      - Stop
            *      - If
            *      - Jump
            *  - Value
            *    - Constant, Parameter, Phi, Binary, GetProperty ...
            *
            * Control flow is modeled with control edges rather than with CFGs. Each basic block is represented
            * as a region node which has control dependencies on predecessor regions. Nodes that are dependent
            * on the execution of a region, have a |control| property assigned to the region they belong to.
            *
            * Memory (and the external world) is modeled as an SSA value called the Store. Nodes that mutate the
            * Store produce a new Store.
            *
            * Nodes that produce multiple values, such as Ifs which produce two values (a True and False control
            * value) can have their values projected (extracted) using Projection nodes.
            *
            * A node scheduler is responsible for serializing nodes back into a CFG such that all dependencies
            * are satisfied.
            *
            * Compiler Pipeline:
            *
            * Graph Builder -> IR (DFG) -> Optimizations -> CFG -> Restructuring -> Backend
            *
            */
            (function (IR) {
                var assert = Shumway.Debug.assert;
                var Multiname = Shumway.AVM2.ABC.Multiname;
                var unexpected = Shumway.Debug.unexpected;
                var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

                function visitArrayInputs(array, visitor) {
                    for (var i = 0; i < array.length; i++) {
                        visitor(array[i]);
                    }
                }

                // Clean this up.
                (function (Flags) {
                    Flags[Flags["NumericProperty"] = 0x01] = "NumericProperty";
                    Flags[Flags["RESOLVED"] = 0x02] = "RESOLVED";
                    Flags[Flags["PRISTINE"] = 0x04] = "PRISTINE";
                    Flags[Flags["IS_METHOD"] = 0x08] = "IS_METHOD";
                    Flags[Flags["AS_CALL"] = 0x10] = "AS_CALL";
                })(IR.Flags || (IR.Flags = {}));
                var Flags = IR.Flags;

                var Node = (function () {
                    function Node() {
                        this.id = Node.getNextID();
                    }
                    Node.getNextID = function () {
                        return Node._nextID[Node._nextID.length - 1] += 1;
                    };

                    Node.prototype.visitInputs = function (visitor) {
                    };

                    Node.startNumbering = function () {
                        Node._nextID.push(0);
                    };

                    Node.stopNumbering = function () {
                        Node._nextID.pop();
                    };

                    Node.prototype.toString = function (brief) {
                        if (brief) {
                            return nameOf(this);
                        }
                        var inputs = [];
                        this.visitInputs(function (input) {
                            inputs.push(nameOf(input));
                        });
                        var result = nameOf(this) + " = " + this.nodeName.toUpperCase();
                        if (inputs.length) {
                            result += " " + inputs.join(", ");
                        }
                        return result;
                    };

                    Node.prototype.visitInputsNoConstants = function (visitor) {
                        this.visitInputs(function (node) {
                            if (IR.isConstant(node)) {
                                return;
                            }
                            visitor(node);
                        });
                    };

                    Node.prototype.replaceInput = function (oldInput, newInput) {
                        var count = 0;
                        for (var k in this) {
                            var v = this[k];
                            if (v instanceof Node) {
                                if (v === oldInput) {
                                    this[k] = newInput;
                                    count++;
                                }
                            }
                            if (v instanceof Array) {
                                count += v.replace(oldInput, newInput);
                            }
                        }
                        return count;
                    };
                    Node._nextID = [];
                    return Node;
                })();
                IR.Node = Node;

                Node.prototype.nodeName = "Node";

                var Control = (function (_super) {
                    __extends(Control, _super);
                    function Control() {
                        _super.call(this);
                    }
                    return Control;
                })(Node);
                IR.Control = Control;
                Control.prototype.nodeName = "Control";

                var Region = (function (_super) {
                    __extends(Region, _super);
                    function Region(control) {
                        _super.call(this);
                        this.predecessors = control ? [control] : [];
                    }
                    Region.prototype.visitInputs = function (visitor) {
                        visitArrayInputs(this.predecessors, visitor);
                    };
                    return Region;
                })(Control);
                IR.Region = Region;
                Region.prototype.nodeName = "Region";

                var Start = (function (_super) {
                    __extends(Start, _super);
                    function Start() {
                        _super.call(this, null);
                        this.control = this;
                    }
                    Start.prototype.visitInputs = function (visitor) {
                        visitArrayInputs(this.predecessors, visitor);
                        visitor(this.scope);
                    };
                    return Start;
                })(Region);
                IR.Start = Start;
                Start.prototype.nodeName = "Start";

                var End = (function (_super) {
                    __extends(End, _super);
                    function End(control) {
                        _super.call(this);
                        this.control = control;
                    }
                    End.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                    };
                    return End;
                })(Control);
                IR.End = End;
                End.prototype.nodeName = "End";

                var Stop = (function (_super) {
                    __extends(Stop, _super);
                    function Stop(control, store, argument) {
                        _super.call(this, control);
                        this.store = store;
                        this.argument = argument;
                    }
                    Stop.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                        visitor(this.store);
                        visitor(this.argument);
                    };
                    return Stop;
                })(End);
                IR.Stop = Stop;
                Stop.prototype.nodeName = "Stop";

                var If = (function (_super) {
                    __extends(If, _super);
                    function If(control, predicate) {
                        _super.call(this, control);
                        this.predicate = predicate;
                    }
                    If.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                        visitor(this.predicate);
                    };
                    return If;
                })(End);
                IR.If = If;
                If.prototype.nodeName = "If";

                var Switch = (function (_super) {
                    __extends(Switch, _super);
                    function Switch(control, determinant) {
                        _super.call(this, control);
                        this.determinant = determinant;
                    }
                    Switch.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                        visitor(this.determinant);
                    };
                    return Switch;
                })(End);
                IR.Switch = Switch;
                Switch.prototype.nodeName = "Switch";

                var Jump = (function (_super) {
                    __extends(Jump, _super);
                    function Jump(control) {
                        _super.call(this, control);
                    }
                    Jump.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                    };
                    return Jump;
                })(End);
                IR.Jump = Jump;
                Jump.prototype.nodeName = "Jump";

                var Value = (function (_super) {
                    __extends(Value, _super);
                    function Value() {
                        _super.call(this);
                    }
                    return Value;
                })(Node);
                IR.Value = Value;
                Value.prototype.nodeName = "Value";

                var Store = (function (_super) {
                    __extends(Store, _super);
                    function Store() {
                        _super.call(this);
                    }
                    return Store;
                })(Value);
                IR.Store = Store;
                Store.prototype.nodeName = "Store";

                var StoreDependent = (function (_super) {
                    __extends(StoreDependent, _super);
                    function StoreDependent(control, store) {
                        _super.call(this);
                        this.control = control;
                        this.store = store;
                    }
                    StoreDependent.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                    };
                    return StoreDependent;
                })(Value);
                IR.StoreDependent = StoreDependent;

                StoreDependent.prototype.nodeName = "StoreDependent";

                var Call = (function (_super) {
                    __extends(Call, _super);
                    function Call(control, store, callee, object, args, flags) {
                        _super.call(this, control, store);
                        this.callee = callee;
                        this.object = object;
                        this.args = args;
                        this.flags = flags;
                    }
                    Call.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                        visitor(this.callee);
                        this.object && visitor(this.object);
                        visitArrayInputs(this.args, visitor);
                    };
                    return Call;
                })(StoreDependent);
                IR.Call = Call;

                Call.prototype.nodeName = "Call";

                var New = (function (_super) {
                    __extends(New, _super);
                    function New(control, store, callee, args) {
                        _super.call(this, control, store);
                        this.callee = callee;
                        this.args = args;
                    }
                    New.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                        visitor(this.callee);
                        visitArrayInputs(this.args, visitor);
                    };
                    return New;
                })(StoreDependent);
                IR.New = New;

                New.prototype.nodeName = "New";

                var GetProperty = (function (_super) {
                    __extends(GetProperty, _super);
                    function GetProperty(control, store, object, name) {
                        _super.call(this, control, store);
                        this.object = object;
                        this.name = name;
                    }
                    GetProperty.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                        visitor(this.object);
                        visitor(this.name);
                    };
                    return GetProperty;
                })(StoreDependent);
                IR.GetProperty = GetProperty;

                GetProperty.prototype.nodeName = "GetProperty";

                var SetProperty = (function (_super) {
                    __extends(SetProperty, _super);
                    function SetProperty(control, store, object, name, value) {
                        _super.call(this, control, store);
                        this.object = object;
                        this.name = name;
                        this.value = value;
                    }
                    SetProperty.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                        visitor(this.object);
                        visitor(this.name);
                        visitor(this.value);
                    };
                    return SetProperty;
                })(StoreDependent);
                IR.SetProperty = SetProperty;

                SetProperty.prototype.nodeName = "SetProperty";

                var DeleteProperty = (function (_super) {
                    __extends(DeleteProperty, _super);
                    function DeleteProperty(control, store, object, name) {
                        _super.call(this, control, store);
                        this.object = object;
                        this.name = name;
                    }
                    DeleteProperty.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                        visitor(this.object);
                        visitor(this.name);
                    };
                    return DeleteProperty;
                })(StoreDependent);
                IR.DeleteProperty = DeleteProperty;

                DeleteProperty.prototype.nodeName = "DeleteProperty";

                var CallProperty = (function (_super) {
                    __extends(CallProperty, _super);
                    function CallProperty(control, store, object, name, args, flags) {
                        _super.call(this, control, store);
                        this.object = object;
                        this.name = name;
                        this.args = args;
                        this.flags = flags;
                    }
                    CallProperty.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        this.store && visitor(this.store);
                        this.loads && visitArrayInputs(this.loads, visitor);
                        visitor(this.object);
                        visitor(this.name);
                        visitArrayInputs(this.args, visitor);
                    };
                    return CallProperty;
                })(StoreDependent);
                IR.CallProperty = CallProperty;

                CallProperty.prototype.nodeName = "CallProperty";

                var Phi = (function (_super) {
                    __extends(Phi, _super);
                    function Phi(control, value) {
                        _super.call(this);
                        this.control = control;
                        this.control = control;
                        this.args = value ? [value] : [];
                    }
                    Phi.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        visitArrayInputs(this.args, visitor);
                    };
                    Phi.prototype.seal = function () {
                        this.sealed = true;
                    };
                    Phi.prototype.pushValue = function (x) {
                        release || assert(!this.sealed);
                        this.args.push(x);
                    };
                    return Phi;
                })(Value);
                IR.Phi = Phi;

                Phi.prototype.nodeName = "Phi";

                var Variable = (function (_super) {
                    __extends(Variable, _super);
                    function Variable(name) {
                        _super.call(this);
                        this.name = name;
                    }
                    return Variable;
                })(Value);
                IR.Variable = Variable;

                Variable.prototype.nodeName = "Variable";

                var Copy = (function (_super) {
                    __extends(Copy, _super);
                    function Copy(argument) {
                        _super.call(this);
                        this.argument = argument;
                    }
                    Copy.prototype.visitInputs = function (visitor) {
                        visitor(this.argument);
                    };
                    return Copy;
                })(Value);
                IR.Copy = Copy;

                Copy.prototype.nodeName = "Copy";

                var Move = (function (_super) {
                    __extends(Move, _super);
                    function Move(to, from) {
                        _super.call(this);
                        this.to = to;
                        this.from = from;
                    }
                    Move.prototype.visitInputs = function (visitor) {
                        visitor(this.to);
                        visitor(this.from);
                    };
                    return Move;
                })(Value);
                IR.Move = Move;

                Move.prototype.nodeName = "Move";

                (function (ProjectionType) {
                    ProjectionType[ProjectionType["CASE"] = 0] = "CASE";
                    ProjectionType[ProjectionType["TRUE"] = 1] = "TRUE";
                    ProjectionType[ProjectionType["FALSE"] = 2] = "FALSE";
                    ProjectionType[ProjectionType["STORE"] = 3] = "STORE";
                    ProjectionType[ProjectionType["SCOPE"] = 4] = "SCOPE";
                })(IR.ProjectionType || (IR.ProjectionType = {}));
                var ProjectionType = IR.ProjectionType;

                var Projection = (function (_super) {
                    __extends(Projection, _super);
                    function Projection(argument, type, selector) {
                        _super.call(this);
                        this.argument = argument;
                        this.type = type;
                        this.selector = selector;
                    }
                    Projection.prototype.visitInputs = function (visitor) {
                        visitor(this.argument);
                    };
                    Projection.prototype.project = function () {
                        return this.argument;
                    };
                    return Projection;
                })(Value);
                IR.Projection = Projection;

                Projection.prototype.nodeName = "Projection";

                var Latch = (function (_super) {
                    __extends(Latch, _super);
                    function Latch(control, condition, left, right) {
                        _super.call(this);
                        this.control = control;
                        this.condition = condition;
                        this.left = left;
                        this.right = right;
                    }
                    Latch.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        visitor(this.condition);
                        visitor(this.left);
                        visitor(this.right);
                    };
                    return Latch;
                })(Value);
                IR.Latch = Latch;

                Latch.prototype.nodeName = "Latch";

                var Operator = (function () {
                    function Operator(name, evaluate, isBinary) {
                        this.name = name;
                        this.evaluate = evaluate;
                        this.isBinary = isBinary;
                        Operator.byName[name] = this;
                    }
                    Operator.linkOpposites = function (a, b) {
                        a.not = b;
                        b.not = a;
                    };

                    Operator.fromName = function (name) {
                        return Operator.byName[name];
                    };
                    Operator.byName = createEmptyObject();

                    Operator.ADD = new Operator("+", function (l, r) {
                        return l + r;
                    }, true);
                    Operator.SUB = new Operator("-", function (l, r) {
                        return l - r;
                    }, true);
                    Operator.MUL = new Operator("*", function (l, r) {
                        return l * r;
                    }, true);
                    Operator.DIV = new Operator("/", function (l, r) {
                        return l / r;
                    }, true);
                    Operator.MOD = new Operator("%", function (l, r) {
                        return l % r;
                    }, true);
                    Operator.AND = new Operator("&", function (l, r) {
                        return l & r;
                    }, true);
                    Operator.OR = new Operator("|", function (l, r) {
                        return l | r;
                    }, true);
                    Operator.XOR = new Operator("^", function (l, r) {
                        return l ^ r;
                    }, true);
                    Operator.LSH = new Operator("<<", function (l, r) {
                        return l << r;
                    }, true);
                    Operator.RSH = new Operator(">>", function (l, r) {
                        return l >> r;
                    }, true);
                    Operator.URSH = new Operator(">>>", function (l, r) {
                        return l >>> r;
                    }, true);
                    Operator.SEQ = new Operator("===", function (l, r) {
                        return l === r;
                    }, true);
                    Operator.SNE = new Operator("!==", function (l, r) {
                        return l !== r;
                    }, true);
                    Operator.EQ = new Operator("==", function (l, r) {
                        return l == r;
                    }, true);
                    Operator.NE = new Operator("!=", function (l, r) {
                        return l != r;
                    }, true);
                    Operator.LE = new Operator("<=", function (l, r) {
                        return l <= r;
                    }, true);
                    Operator.GT = new Operator(">", function (l, r) {
                        return l > r;
                    }, true);
                    Operator.LT = new Operator("<", function (l, r) {
                        return l < r;
                    }, true);
                    Operator.GE = new Operator(">=", function (l, r) {
                        return l >= r;
                    }, true);
                    Operator.PLUS = new Operator("+", function (a) {
                        return +a;
                    }, false);
                    Operator.NEG = new Operator("-", function (a) {
                        return -a;
                    }, false);
                    Operator.TRUE = new Operator("!!", function (a) {
                        return !!a;
                    }, false);
                    Operator.FALSE = new Operator("!", function (a) {
                        return !a;
                    }, false);

                    Operator.TYPE_OF = new Operator("typeof", function (a) {
                        return typeof a;
                    }, false);
                    Operator.BITWISE_NOT = new Operator("~", function (a) {
                        return ~a;
                    }, false);
                    Operator.AS_ADD = new Operator("+", function (l, r) {
                        if (typeof l === "string" || typeof r === "string") {
                            return String(l) + String(r);
                        }
                        return l + r;
                    }, true);
                    return Operator;
                })();
                IR.Operator = Operator;

                Operator.linkOpposites(Operator.SEQ, Operator.SNE);
                Operator.linkOpposites(Operator.EQ, Operator.NE);
                Operator.linkOpposites(Operator.TRUE, Operator.FALSE);

                var Binary = (function (_super) {
                    __extends(Binary, _super);
                    function Binary(operator, left, right) {
                        _super.call(this);
                        this.operator = operator;
                        this.left = left;
                        this.right = right;
                    }
                    Binary.prototype.visitInputs = function (visitor) {
                        visitor(this.left);
                        visitor(this.right);
                    };
                    return Binary;
                })(Value);
                IR.Binary = Binary;

                Binary.prototype.nodeName = "Binary";

                var Unary = (function (_super) {
                    __extends(Unary, _super);
                    function Unary(operator, argument) {
                        _super.call(this);
                        this.operator = operator;
                        this.argument = argument;
                    }
                    Unary.prototype.visitInputs = function (visitor) {
                        visitor(this.argument);
                    };
                    return Unary;
                })(Value);
                IR.Unary = Unary;

                Unary.prototype.nodeName = "Unary";

                var Constant = (function (_super) {
                    __extends(Constant, _super);
                    function Constant(value) {
                        _super.call(this);
                        this.value = value;
                    }
                    return Constant;
                })(Value);
                IR.Constant = Constant;

                Constant.prototype.nodeName = "Constant";

                var GlobalProperty = (function (_super) {
                    __extends(GlobalProperty, _super);
                    function GlobalProperty(name) {
                        _super.call(this);
                        this.name = name;
                    }
                    return GlobalProperty;
                })(Value);
                IR.GlobalProperty = GlobalProperty;

                GlobalProperty.prototype.nodeName = "GlobalProperty";

                var This = (function (_super) {
                    __extends(This, _super);
                    function This(control) {
                        _super.call(this);
                        this.control = control;
                    }
                    This.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                    };
                    return This;
                })(Value);
                IR.This = This;

                This.prototype.nodeName = "This";

                var Throw = (function (_super) {
                    __extends(Throw, _super);
                    function Throw(control, argument) {
                        _super.call(this);
                        this.control = control;
                        this.argument = argument;
                    }
                    Throw.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                        visitor(this.argument);
                    };
                    return Throw;
                })(Value);
                IR.Throw = Throw;

                Throw.prototype.nodeName = "Throw";

                var Arguments = (function (_super) {
                    __extends(Arguments, _super);
                    function Arguments(control) {
                        _super.call(this);
                        this.control = control;
                    }
                    Arguments.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                    };
                    return Arguments;
                })(Value);
                IR.Arguments = Arguments;

                Arguments.prototype.nodeName = "Arguments";

                var Parameter = (function (_super) {
                    __extends(Parameter, _super);
                    function Parameter(control, index, name) {
                        _super.call(this);
                        this.control = control;
                        this.index = index;
                        this.name = name;
                    }
                    Parameter.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                    };
                    return Parameter;
                })(Value);
                IR.Parameter = Parameter;

                Parameter.prototype.nodeName = "Parameter";

                var NewArray = (function (_super) {
                    __extends(NewArray, _super);
                    function NewArray(control, elements) {
                        _super.call(this);
                        this.control = control;
                        this.elements = elements;
                    }
                    NewArray.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                        visitArrayInputs(this.elements, visitor);
                    };
                    return NewArray;
                })(Value);
                IR.NewArray = NewArray;

                NewArray.prototype.nodeName = "NewArray";

                var NewObject = (function (_super) {
                    __extends(NewObject, _super);
                    function NewObject(control, properties) {
                        _super.call(this);
                        this.control = control;
                        this.properties = properties;
                    }
                    NewObject.prototype.visitInputs = function (visitor) {
                        visitor(this.control);
                        visitArrayInputs(this.properties, visitor);
                    };
                    return NewObject;
                })(Value);
                IR.NewObject = NewObject;

                NewObject.prototype.nodeName = "NewObject";

                var KeyValuePair = (function (_super) {
                    __extends(KeyValuePair, _super);
                    function KeyValuePair(key, value) {
                        _super.call(this);
                        this.key = key;
                        this.value = value;
                    }
                    KeyValuePair.prototype.visitInputs = function (visitor) {
                        visitor(this.key);
                        visitor(this.value);
                    };
                    return KeyValuePair;
                })(Value);
                IR.KeyValuePair = KeyValuePair;

                KeyValuePair.prototype.mustFloat = true;
                KeyValuePair.prototype.nodeName = "KeyValuePair";

                function nameOf(node) {
                    var useColors = false;
                    var result;
                    if (node instanceof Constant) {
                        if (node.value instanceof Multiname) {
                            return node.value.name;
                        }
                        return node.value;
                    } else if (node instanceof Variable) {
                        return node.name;
                    } else if (node instanceof Phi) {
                        return result = "|" + node.id + "|", useColors ? Shumway.IndentingWriter.PURPLE + result + Shumway.IndentingWriter.ENDC : result;
                    } else if (node instanceof Control) {
                        return result = "{" + node.id + "}", useColors ? Shumway.IndentingWriter.RED + result + Shumway.IndentingWriter.ENDC : result;
                    } else if (node instanceof Projection) {
                        if (node.type === 3 /* STORE */) {
                            return result = "[" + node.id + "->" + node.argument.id + "]", useColors ? Shumway.IndentingWriter.YELLOW + result + Shumway.IndentingWriter.ENDC : result;
                        }
                        return result = "(" + node.id + ")", useColors ? Shumway.IndentingWriter.GREEN + result + Shumway.IndentingWriter.ENDC : result;
                    } else if (node instanceof Value) {
                        return result = "(" + node.id + ")", useColors ? Shumway.IndentingWriter.GREEN + result + Shumway.IndentingWriter.ENDC : result;
                    } else if (node instanceof Node) {
                        return node.id;
                    }
                    unexpected(node + " " + typeof node);
                }
                IR.nameOf = nameOf;
            })(Compiler.IR || (Compiler.IR = {}));
            var IR = Compiler.IR;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            (function (IR) {
                var assert = Shumway.Debug.assert;
                var unexpected = Shumway.Debug.unexpected;
                var Multiname = Shumway.AVM2.ABC.Multiname;

                var top = Shumway.ArrayUtilities.top;
                var bitCount = Shumway.IntegerUtilities.bitCount;
                var IndentingWriter = Shumway.IndentingWriter;
                var pushUnique = Shumway.ArrayUtilities.pushUnique;
                var unique = Shumway.ArrayUtilities.unique;

                var debug = false;

                function toID(node) {
                    return node.id;
                }

                function visitNothing() {
                }

                function isNotPhi(phi) {
                    return !isPhi(phi);
                }
                IR.isNotPhi = isNotPhi;

                function isPhi(phi) {
                    return phi instanceof IR.Phi;
                }
                IR.isPhi = isPhi;

                function isScope(scope) {
                    return isPhi(scope) || scope instanceof IR.ASScope || isProjection(scope, 4 /* SCOPE */);
                }
                IR.isScope = isScope;

                function isMultinameConstant(node) {
                    return node instanceof IR.Constant && node.value instanceof Multiname;
                }
                IR.isMultinameConstant = isMultinameConstant;

                function isMultiname(name) {
                    return isMultinameConstant(name) || name instanceof IR.ASMultiname;
                }
                IR.isMultiname = isMultiname;

                function isStore(store) {
                    return isPhi(store) || store instanceof IR.Store || isProjection(store, 3 /* STORE */);
                }
                IR.isStore = isStore;

                function isConstant(constant) {
                    return constant instanceof IR.Constant;
                }
                IR.isConstant = isConstant;

                function isBoolean(value) {
                    return value === true || value === false;
                }

                function isControlOrNull(control) {
                    return isControl(control) || control === null;
                }
                IR.isControlOrNull = isControlOrNull;

                function isStoreOrNull(store) {
                    return isStore(store) || store === null;
                }
                IR.isStoreOrNull = isStoreOrNull;

                function isControl(control) {
                    return control instanceof IR.Control;
                }
                IR.isControl = isControl;

                function isValueOrNull(value) {
                    return isValue(value) || value === null;
                }
                IR.isValueOrNull = isValueOrNull;

                function isValue(value) {
                    return value instanceof IR.Value;
                }
                IR.isValue = isValue;

                function isProjection(node, type) {
                    return node instanceof IR.Projection && (!type || node.type === type);
                }
                IR.isProjection = isProjection;

                function followProjection(node) {
                    return node instanceof IR.Projection ? node.project() : node;
                }

                IR.Null = new IR.Constant(null);
                IR.Undefined = new IR.Constant(undefined);
                IR.True = new IR.Constant(true);
                IR.False = new IR.Constant(false);

                var Block = (function () {
                    function Block(id, start, end) {
                        this.id = id;
                        this.nodes = [start, end];
                        this.region = start;
                        this.successors = [];
                        this.predecessors = [];
                    }
                    Block.prototype.pushSuccessorAt = function (successor, index, pushPredecessor) {
                        release || assert(successor);
                        release || assert(!this.successors[index]);
                        this.successors[index] = successor;
                        if (pushPredecessor) {
                            successor.pushPredecessor(this);
                        }
                    };
                    Block.prototype.pushSuccessor = function (successor, pushPredecessor) {
                        release || assert(successor);
                        this.successors.push(successor);
                        if (pushPredecessor) {
                            successor.pushPredecessor(this);
                        }
                    };
                    Block.prototype.pushPredecessor = function (predecessor) {
                        release || assert(predecessor);
                        this.predecessors.push(predecessor);
                    };
                    Block.prototype.visitNodes = function (fn) {
                        var nodes = this.nodes;
                        for (var i = 0, j = nodes.length; i < j; i++) {
                            fn(nodes[i]);
                        }
                    };
                    Block.prototype.visitSuccessors = function (fn) {
                        var successors = this.successors;
                        for (var i = 0, j = successors.length; i < j; i++) {
                            fn(successors[i]);
                        }
                    };
                    Block.prototype.visitPredecessors = function (fn) {
                        var predecessors = this.predecessors;
                        for (var i = 0, j = predecessors.length; i < j; i++) {
                            fn(predecessors[i]);
                        }
                    };
                    Block.prototype.append = function (node) {
                        release || assert(this.nodes.length >= 2);
                        release || assert(isValue(node), node);
                        release || assert(isNotPhi(node));
                        release || assert(this.nodes.indexOf(node) < 0);
                        if (node.mustFloat) {
                            return;
                        }
                        this.nodes.splice(this.nodes.length - 1, 0, node);
                    };
                    Block.prototype.toString = function () {
                        return "B" + this.id + (this.name ? " (" + this.name + ")" : "");
                    };
                    Block.prototype.trace = function (writer) {
                        writer.writeLn(this.toString());
                    };
                    return Block;
                })();
                IR.Block = Block;

                var DFG = (function () {
                    function DFG(exit) {
                        this.exit = exit;
                        this.exit = exit;
                    }
                    DFG.prototype.buildCFG = function () {
                        return CFG.fromDFG(this);
                    };

                    DFG.preOrderDepthFirstSearch = function (root, visitChildren, pre) {
                        var visited = [];
                        var worklist = [root];
                        var push = worklist.push.bind(worklist);
                        var node;
                        while ((node = worklist.pop())) {
                            if (visited[node.id] === 1) {
                                continue;
                            }
                            visited[node.id] = 1;
                            pre(node);
                            worklist.push(node);
                            visitChildren(node, push);
                        }
                    };

                    DFG.postOrderDepthFirstSearch = function (root, visitChildren, post) {
                        var ONE_TIME = 1, MANY_TIMES = 2;
                        var visited = [];
                        var worklist = [root];
                        function visitChild(child) {
                            if (!visited[child.id]) {
                                worklist.push(child);
                            }
                        }
                        var node;
                        while ((node = top(worklist))) {
                            if (visited[node.id]) {
                                if (visited[node.id] === ONE_TIME) {
                                    visited[node.id] = MANY_TIMES;
                                    post(node);
                                }
                                worklist.pop();
                                continue;
                            }
                            visited[node.id] = ONE_TIME;
                            visitChildren(node, visitChild);
                        }
                    };

                    DFG.prototype.forEachInPreOrderDepthFirstSearch = function (visitor) {
                        var visited = new Array(1024);
                        var worklist = [this.exit];
                        function push(node) {
                            if (isConstant(node)) {
                                return;
                            }
                            release || assert(node instanceof IR.Node);
                            worklist.push(node);
                        }
                        var node;
                        while ((node = worklist.pop())) {
                            if (visited[node.id]) {
                                continue;
                            }
                            visited[node.id] = 1;
                            visitor && visitor(node);
                            worklist.push(node);
                            node.visitInputs(push);
                        }
                    };

                    DFG.prototype.forEach = function (visitor, postOrder) {
                        var search = postOrder ? DFG.postOrderDepthFirstSearch : DFG.preOrderDepthFirstSearch;
                        search(this.exit, function (node, v) {
                            node.visitInputsNoConstants(v);
                        }, visitor);
                    };

                    DFG.prototype.traceMetrics = function (writer) {
                        var counter = new Shumway.Metrics.Counter(true);
                        DFG.preOrderDepthFirstSearch(this.exit, function (node, visitor) {
                            node.visitInputsNoConstants(visitor);
                        }, function (node) {
                            AVM2.countTimeline(node.nodeName);
                        });
                        counter.trace(writer);
                    };

                    DFG.prototype.trace = function (writer) {
                        var nodes = [];
                        var visited = {};

                        function colorOf(node) {
                            if (node instanceof IR.Control) {
                                return "yellow";
                            } else if (node instanceof IR.Phi) {
                                return "purple";
                            } else if (node instanceof IR.Value) {
                                return "green";
                            }
                            return "white";
                        }

                        var blocks = [];

                        function followProjection(node) {
                            return node instanceof IR.Projection ? node.project() : node;
                        }

                        function next(node) {
                            node = followProjection(node);
                            if (!visited[node.id]) {
                                visited[node.id] = true;
                                if (node.block) {
                                    blocks.push(node.block);
                                }
                                nodes.push(node);
                                node.visitInputsNoConstants(next);
                            }
                        }

                        next(this.exit);

                        writer.writeLn("");
                        writer.enter("digraph DFG {");
                        writer.writeLn("graph [bgcolor = gray10];");
                        writer.writeLn("edge [color = white];");
                        writer.writeLn("node [shape = box, fontname = Consolas, fontsize = 11, color = white, fontcolor = white];");
                        writer.writeLn("rankdir = BT;");

                        function writeNode(node) {
                            writer.writeLn("N" + node.id + " [label = \"" + node.toString() + "\", color = \"" + colorOf(node) + "\"];");
                        }

                        function defineNode(node) {
                            writer.writeLn("N" + node.id + ";");
                        }

                        blocks.forEach(function (block) {
                            writer.enter("subgraph cluster" + block.nodes[0].id + " { bgcolor = gray20;");
                            block.visitNodes(function (node) {
                                defineNode(followProjection(node));
                            });
                            writer.leave("}");
                        });

                        nodes.forEach(writeNode);

                        nodes.forEach(function (node) {
                            node.visitInputsNoConstants(function (input) {
                                input = followProjection(input);
                                writer.writeLn("N" + node.id + " -> " + "N" + input.id + " [color=" + colorOf(input) + "];");
                            });
                        });

                        writer.leave("}");
                        writer.writeLn("");
                    };
                    return DFG;
                })();
                IR.DFG = DFG;

                var Uses = (function () {
                    function Uses() {
                        this.entries = [];
                    }
                    Uses.prototype.addUse = function (def, use) {
                        var entry = this.entries[def.id];
                        if (!entry) {
                            entry = this.entries[def.id] = { def: def, uses: [] };
                        }
                        pushUnique(entry.uses, use);
                    };
                    Uses.prototype.trace = function (writer) {
                        writer.enter("> Uses");
                        this.entries.forEach(function (entry) {
                            writer.writeLn(entry.def.id + " -> [" + entry.uses.map(toID).join(", ") + "] " + entry.def);
                        });
                        writer.leave("<");
                    };
                    Uses.prototype.replace = function (def, value) {
                        var entry = this.entries[def.id];
                        if (entry.uses.length === 0) {
                            return false;
                        }
                        var count = 0;
                        entry.uses.forEach(function (use) {
                            count += use.replaceInput(def, value);
                        });
                        release || assert(count >= entry.uses.length);
                        entry.uses = [];
                        return true;
                    };
                    Uses.prototype.updateUses = function (def, value, useEntries, writer) {
                        debug && writer.writeLn("Update " + def + " with " + value);
                        var entry = useEntries[def.id];
                        if (entry.uses.length === 0) {
                            return false;
                        }
                        debug && writer.writeLn("Replacing: " + def.id + " in [" + entry.uses.map(toID).join(", ") + "] with " + value.id);
                        var count = 0;
                        entry.uses.forEach(function (use) {
                            count += use.replaceInput(def, value);
                        });
                        release || assert(count >= entry.uses.length);
                        entry.uses = [];
                        return true;
                    };
                    return Uses;
                })();
                IR.Uses = Uses;

                var CFG = (function () {
                    function CFG() {
                        this.nextBlockID = 0;
                        this.blocks = [];
                    }
                    CFG.fromDFG = function (dfg) {
                        var cfg = new CFG();

                        release || assert(dfg && dfg instanceof DFG);
                        cfg.dfg = dfg;

                        var visited = [];

                        function buildEnd(end) {
                            if (end instanceof IR.Projection) {
                                end = end.project();
                            }
                            release || assert(end instanceof IR.End || end instanceof IR.Start, end);
                            if (visited[end.id]) {
                                return;
                            }
                            visited[end.id] = true;
                            var start = end.control;
                            if (!(start instanceof IR.Region)) {
                                start = end.control = new IR.Region(start);
                            }
                            var block = start.block = cfg.buildBlock(start, end);
                            if (start instanceof IR.Start) {
                                cfg.root = block;
                            }
                            for (var i = 0; i < start.predecessors.length; i++) {
                                var c = start.predecessors[i];
                                var d;
                                var trueProjection = false;
                                if (c instanceof IR.Projection) {
                                    d = c.project();
                                    trueProjection = c.type === 1 /* TRUE */;
                                } else {
                                    d = c;
                                }
                                if (d instanceof IR.Region) {
                                    d = new IR.Jump(c);
                                    d = new IR.Projection(d, 1 /* TRUE */);
                                    start.predecessors[i] = d;
                                    d = d.project();
                                    trueProjection = true;
                                }
                                buildEnd(d);
                                var controlBlock = d.control.block;
                                if (d instanceof IR.Switch) {
                                    release || assert(isProjection(c, 0 /* CASE */));
                                    controlBlock.pushSuccessorAt(block, c.selector.value, true);
                                } else if (trueProjection && controlBlock.successors.length > 0) {
                                    controlBlock.pushSuccessor(block, true);
                                    controlBlock.hasFlippedSuccessors = true;
                                } else {
                                    controlBlock.pushSuccessor(block, true);
                                }
                            }
                        }

                        buildEnd(dfg.exit);
                        cfg.splitCriticalEdges();
                        cfg.exit = dfg.exit.control.block;
                        cfg.computeDominators(true);
                        return cfg;
                    };

                    /**
                    * Makes sure root node has no predecessors and that there is only one
                    * exit node.
                    */
                    CFG.prototype.buildRootAndExit = function () {
                        release || assert(!this.root && !this.exit);

                        // Create new root node if the root node has predecessors.
                        if (this.blocks[0].predecessors.length > 0) {
                            this.root = new Block(this.nextBlockID++);
                            this.blocks.push(this.root);
                            this.root.pushSuccessor(this.blocks[0], true);
                        } else {
                            this.root = this.blocks[0];
                        }
                        var exitBlocks = [];

                        for (var i = 0; i < this.blocks.length; i++) {
                            var block = this.blocks[i];
                            if (block.successors.length === 0) {
                                exitBlocks.push(block);
                            }
                        }

                        if (exitBlocks.length === 0) {
                            unexpected("Must have an exit block.");
                        } else if (exitBlocks.length === 1 && exitBlocks[0] !== this.root) {
                            this.exit = exitBlocks[0];
                        } else {
                            // Create new exit block to merge flow.
                            this.exit = new Block(this.nextBlockID++);
                            this.blocks.push(this.exit);
                            for (var i = 0; i < exitBlocks.length; i++) {
                                exitBlocks[i].pushSuccessor(this.exit, true);
                            }
                        }

                        release || assert(this.root && this.exit);
                        release || assert(this.root !== this.exit);
                    };

                    CFG.prototype.fromString = function (list, rootName) {
                        var cfg = this;
                        var names = cfg.blockNames || (cfg.blockNames = {});
                        var blocks = cfg.blocks;

                        var sets = list.replace(/\ /g, "").split(",");
                        sets.forEach(function (set) {
                            var edgeList = set.split("->");
                            var last = null;
                            for (var i = 0; i < edgeList.length; i++) {
                                var next = edgeList[i];
                                if (last) {
                                    buildEdge(last, next);
                                } else {
                                    buildBlock(next);
                                }
                                last = next;
                            }
                        });

                        function buildBlock(name) {
                            var block = names[name];
                            if (block) {
                                return block;
                            }
                            names[name] = block = new Block(cfg.nextBlockID++);
                            block.name = name;
                            blocks.push(block);
                            return block;
                        }

                        function buildEdge(from, to) {
                            buildBlock(from).pushSuccessor(buildBlock(to), true);
                        }

                        release || assert(rootName && names[rootName]);
                        this.root = names[rootName];
                    };

                    CFG.prototype.buildBlock = function (start, end) {
                        var block = new Block(this.nextBlockID++, start, end);
                        this.blocks.push(block);
                        return block;
                    };

                    CFG.prototype.createBlockSet = function () {
                        if (!this.setConstructor) {
                            this.setConstructor = Shumway.BitSets.BitSetFunctor(this.blocks.length);
                        }
                        return new this.setConstructor();
                    };

                    CFG.prototype.computeReversePostOrder = function () {
                        if (this.order) {
                            return this.order;
                        }
                        var order = this.order = [];
                        this.depthFirstSearch(null, order.push.bind(order));
                        order.reverse();
                        for (var i = 0; i < order.length; i++) {
                            order[i].rpo = i;
                        }
                        return order;
                    };

                    CFG.prototype.depthFirstSearch = function (preFn, postFn) {
                        var visited = this.createBlockSet();
                        function visit(node) {
                            visited.set(node.id);
                            if (preFn)
                                preFn(node);
                            var successors = node.successors;
                            for (var i = 0, j = successors.length; i < j; i++) {
                                var s = successors[i];
                                if (!visited.get(s.id)) {
                                    visit(s);
                                }
                            }
                            if (postFn)
                                postFn(node);
                        }
                        visit(this.root);
                    };

                    CFG.prototype.computeDominators = function (apply) {
                        release || assert(this.root.predecessors.length === 0, "Root node ", this.root, " must not have predecessors.");

                        var dom = new Int32Array(this.blocks.length);
                        for (var i = 0; i < dom.length; i++) {
                            dom[i] = -1;
                        }
                        var map = this.createBlockSet();
                        function computeCommonDominator(a, b) {
                            map.clearAll();
                            while (a >= 0) {
                                map.set(a);
                                a = dom[a];
                            }
                            while (b >= 0 && !map.get(b)) {
                                b = dom[b];
                            }
                            return b;
                        }
                        function computeDominator(blockID, parentID) {
                            if (dom[blockID] < 0) {
                                dom[blockID] = parentID;
                            } else {
                                dom[blockID] = computeCommonDominator(dom[blockID], parentID);
                            }
                        }
                        this.depthFirstSearch(function visit(block) {
                            var s = block.successors;
                            for (var i = 0, j = s.length; i < j; i++) {
                                computeDominator(s[i].id, block.id);
                            }
                        });
                        if (apply) {
                            for (var i = 0, j = this.blocks.length; i < j; i++) {
                                this.blocks[i].dominator = this.blocks[dom[i]];
                            }
                            function computeDominatorDepth(block) {
                                var dominatorDepth;
                                if (block.dominatorDepth !== undefined) {
                                    return block.dominatorDepth;
                                } else if (!block.dominator) {
                                    dominatorDepth = 0;
                                } else {
                                    dominatorDepth = computeDominatorDepth(block.dominator) + 1;
                                }
                                return block.dominatorDepth = dominatorDepth;
                            }
                            for (var i = 0, j = this.blocks.length; i < j; i++) {
                                computeDominatorDepth(this.blocks[i]);
                            }
                        }
                        return dom;
                    };

                    CFG.prototype.computeLoops = function () {
                        var active = this.createBlockSet();
                        var visited = this.createBlockSet();
                        var nextLoop = 0;

                        function makeLoopHeader(block) {
                            if (!block.isLoopHeader) {
                                release || assert(nextLoop < 32, "Can't handle too many loops, fall back on BitMaps if it's a problem.");
                                block.isLoopHeader = true;
                                block.loops = 1 << nextLoop;
                                nextLoop += 1;
                            }
                            release || assert(bitCount(block.loops) === 1);
                        }

                        function visit(block) {
                            if (visited.get(block.id)) {
                                if (active.get(block.id)) {
                                    makeLoopHeader(block);
                                }
                                return block.loops;
                            }
                            visited.set(block.id);
                            active.set(block.id);
                            var loops = 0;
                            for (var i = 0, j = block.successors.length; i < j; i++) {
                                loops |= visit(block.successors[i]);
                            }
                            if (block.isLoopHeader) {
                                release || assert(bitCount(block.loops) === 1);
                                loops &= ~block.loops;
                            }
                            block.loops = loops;
                            active.clear(block.id);
                            return loops;
                        }

                        var loop = visit(this.root);
                        release || assert(loop === 0);
                    };

                    /**
                    * Computes def-use chains.
                    *
                    * () -> Map[id -> {def:Node, uses:Array[Node]}]
                    */
                    CFG.prototype.computeUses = function () {
                        AVM2.enterTimeline("computeUses");
                        var writer = debug && new IndentingWriter();

                        debug && writer.enter("> Compute Uses");
                        var dfg = this.dfg;

                        var uses = new Uses();

                        dfg.forEachInPreOrderDepthFirstSearch(function (use) {
                            use.visitInputs(function (def) {
                                uses.addUse(def, use);
                            });
                        });

                        if (debug) {
                            writer.enter("> Uses");
                            uses.entries.forEach(function (entry) {
                                writer.writeLn(entry.def.id + " -> [" + entry.uses.map(toID).join(", ") + "] " + entry.def);
                            });
                            writer.leave("<");
                            writer.leave("<");
                        }
                        AVM2.leaveTimeline();
                        return uses;
                    };

                    CFG.prototype.verify = function () {
                        var writer = debug && new IndentingWriter();
                        debug && writer.enter("> Verify");

                        var order = this.computeReversePostOrder();

                        order.forEach(function (block) {
                            if (block.phis) {
                                block.phis.forEach(function (phi) {
                                    release || assert(phi.control === block.region);
                                    release || assert(phi.args.length === block.predecessors.length);
                                });
                            }
                        });

                        debug && writer.leave("<");
                    };

                    /**
                    * Simplifies phis of the form:
                    *
                    * replace |x = phi(y)| -> y
                    * replace |x = phi(x, y)| -> y
                    * replace |x = phi(y, y, x, y, x)| -> |phi(y, x)| -> y
                    */
                    CFG.prototype.optimizePhis = function () {
                        var writer = debug && new IndentingWriter();
                        debug && writer.enter("> Optimize Phis");

                        var phis = [];
                        var useEntries = this.computeUses().entries;
                        useEntries.forEach(function (entry) {
                            if (isPhi(entry.def)) {
                                phis.push(entry.def);
                            }
                        });

                        debug && writer.writeLn("Trying to optimize " + phis.length + " phis.");

                        /**
                        * Updates all uses to a new definition. Returns true if anything was updated.
                        */
                        function updateUses(def, value) {
                            debug && writer.writeLn("Update " + def + " with " + value);
                            var entry = useEntries[def.id];
                            if (entry.uses.length === 0) {
                                return false;
                            }
                            debug && writer.writeLn("Replacing: " + def.id + " in [" + entry.uses.map(toID).join(", ") + "] with " + value.id);
                            var count = 0;
                            var entryUses = entry.uses;
                            for (var i = 0, j = entryUses.length; i < j; i++) {
                                count += entryUses[i].replaceInput(def, value);
                            }
                            release || assert(count >= entry.uses.length);
                            entry.uses = [];
                            return true;
                        }

                        function simplify(phi, args) {
                            args = unique(args);
                            if (args.length === 1) {
                                // x = phi(y) -> y
                                return args[0];
                            } else {
                                if (args.length === 2) {
                                    // x = phi(y, x) -> y
                                    if (args[0] === phi) {
                                        return args[1];
                                    } else if (args[1] === phi) {
                                        return args[0];
                                    }
                                    return phi;
                                }
                            }
                            return phi;
                        }

                        var count = 0;
                        var iterations = 0;
                        var changed = true;
                        while (changed) {
                            iterations++;
                            changed = false;
                            phis.forEach(function (phi) {
                                var value = simplify(phi, phi.args);
                                if (value !== phi) {
                                    if (updateUses(phi, value)) {
                                        changed = true;
                                        count++;
                                    }
                                }
                            });
                        }

                        if (debug) {
                            writer.writeLn("Simplified " + count + " phis, in " + iterations + " iterations.");
                            writer.leave("<");
                        }
                    };

                    /**
                    * "A critical edge is an edge which is neither the only edge leaving its source block, nor the only edge entering
                    * its destination block. These edges must be split: a new block must be created in the middle of the edge, in order
                    * to insert computations on the edge without affecting any other edges." - Wikipedia
                    */
                    CFG.prototype.splitCriticalEdges = function () {
                        var writer = debug && new IndentingWriter();
                        var blocks = this.blocks;
                        var criticalEdges = [];
                        debug && writer.enter("> Splitting Critical Edges");
                        for (var i = 0; i < blocks.length; i++) {
                            var successors = blocks[i].successors;
                            if (successors.length > 1) {
                                for (var j = 0; j < successors.length; j++) {
                                    if (successors[j].predecessors.length > 1) {
                                        criticalEdges.push({ from: blocks[i], to: successors[j] });
                                    }
                                }
                            }
                        }

                        var criticalEdgeCount = criticalEdges.length;
                        if (criticalEdgeCount && debug) {
                            writer.writeLn("Splitting: " + criticalEdgeCount);
                            this.trace(writer);
                        }

                        var edge;
                        while ((edge = criticalEdges.pop())) {
                            var fromIndex = edge.from.successors.indexOf(edge.to);
                            var toIndex = edge.to.predecessors.indexOf(edge.from);
                            release || assert(fromIndex >= 0 && toIndex >= 0);
                            debug && writer.writeLn("Splitting critical edge: " + edge.from + " -> " + edge.to);
                            var toBlock = edge.to;
                            var toRegion = toBlock.region;
                            var control = toRegion.predecessors[toIndex];
                            var region = new IR.Region(control);
                            var jump = new IR.Jump(region);
                            var block = this.buildBlock(region, jump);
                            toRegion.predecessors[toIndex] = new IR.Projection(jump, 1 /* TRUE */);

                            var fromBlock = edge.from;
                            fromBlock.successors[fromIndex] = block;
                            block.pushPredecessor(fromBlock);
                            block.pushSuccessor(toBlock);
                            toBlock.predecessors[toIndex] = block;
                        }

                        if (criticalEdgeCount && debug) {
                            this.trace(writer);
                        }

                        if (criticalEdgeCount && !release) {
                            release || assert(this.splitCriticalEdges() === 0);
                        }

                        debug && writer.leave("<");

                        return criticalEdgeCount;
                    };

                    /**
                    * Allocate virtual registers and break out of SSA.
                    */
                    CFG.prototype.allocateVariables = function () {
                        var writer = debug && new IndentingWriter();

                        debug && writer.enter("> Allocating Virtual Registers");
                        var order = this.computeReversePostOrder();

                        function allocate(node) {
                            if (isProjection(node, 3 /* STORE */)) {
                                return;
                            }
                            if (node instanceof IR.SetProperty) {
                                return;
                            }
                            if (node instanceof IR.Value) {
                                node.variable = new IR.Variable("v" + node.id);
                                debug && writer.writeLn("Allocated: " + node.variable + " to " + node);
                            }
                        }

                        order.forEach(function (block) {
                            block.nodes.forEach(allocate);
                            if (block.phis) {
                                block.phis.forEach(allocate);
                            }
                        });

                        /**
                        * To break out of SSA form we need to emit moves in the phi's predecessor blocks. Here we
                        * collect the set of all moves in |blockMoves| : Map[id -> Array[Move]]
                        *
                        * The moves actually need to be emitted along the phi's predecessor edges. Emitting them in the
                        * predecessor blocks is only correct in the absence of CFG critical edges.
                        */
                        var blockMoves = [];
                        for (var i = 0; i < order.length; i++) {
                            var block = order[i];
                            var phis = block.phis;
                            var predecessors = block.predecessors;
                            if (phis) {
                                for (var j = 0; j < phis.length; j++) {
                                    var phi = phis[j];
                                    debug && writer.writeLn("Emitting moves for: " + phi);
                                    var arguments = phi.args;
                                    release || assert(predecessors.length === arguments.length);
                                    for (var k = 0; k < predecessors.length; k++) {
                                        var predecessor = predecessors[k];
                                        var argument = arguments[k];
                                        if (argument.abstract || isProjection(argument, 3 /* STORE */)) {
                                            continue;
                                        }
                                        var moves = blockMoves[predecessor.id] || (blockMoves[predecessor.id] = []);
                                        argument = argument.variable || argument;
                                        if (phi.variable !== argument) {
                                            moves.push(new IR.Move(phi.variable, argument));
                                        }
                                    }
                                }
                            }
                        }

                        /**
                        * All move instructions must execute simultaneously. Since there may be dependencies between
                        * source and destination operands we need to sort moves topologically. This is not always
                        * possible because of cyclic dependencies. In such cases break the cycles using temporaries.
                        *
                        * Simplest example where this happens:
                        *   var a, b, t;
                        *   while (true) {
                        *     t = a; a = b; b = t;
                        *   }
                        */
                        var blocks = this.blocks;
                        blockMoves.forEach(function (moves, blockID) {
                            var block = blocks[blockID];
                            var temporary = 0;
                            debug && writer.writeLn(block + " Moves: " + moves);
                            while (moves.length) {
                                for (var i = 0; i < moves.length; i++) {
                                    var move = moves[i];

                                    for (var j = 0; j < moves.length; j++) {
                                        if (i === j) {
                                            continue;
                                        }
                                        if (moves[j].from === move.to) {
                                            move = null;
                                            break;
                                        }
                                    }
                                    if (move) {
                                        moves.splice(i--, 1);
                                        block.append(move);
                                    }
                                }

                                if (moves.length) {
                                    // We have a cycle, break it with a temporary.
                                    debug && writer.writeLn("Breaking Cycle");

                                    // 1. Pick any move.
                                    var move = moves[0];

                                    // 2. Emit a move to save its destination in a temporary.
                                    var temp = new IR.Variable("t" + temporary++);
                                    blocks[blockID].append(new IR.Move(temp, move.to));

                                    for (var i = 1; i < moves.length; i++) {
                                        if (moves[i].from === move.to) {
                                            moves[i].from = temp;
                                        }
                                    }
                                    // 4. Loop, baby, loop.
                                }
                            }
                        });

                        debug && writer.leave("<");
                    };

                    CFG.prototype.scheduleEarly = function () {
                        var debugScheduler = false;
                        var writer = debugScheduler && new IndentingWriter();

                        debugScheduler && writer.enter("> Schedule Early");

                        var cfg = this;
                        var dfg = this.dfg;

                        var scheduled = [];

                        var roots = [];

                        dfg.forEachInPreOrderDepthFirstSearch(function (node) {
                            if (node instanceof IR.Region || node instanceof IR.Jump) {
                                return;
                            }
                            if (node.control) {
                                roots.push(node);
                            }
                            if (isPhi(node)) {
                                /**
                                * When breaking out of SSA, move instructions need to have non-floating source nodes. Otherwise
                                * the topological sorting of moves gets more complicated, especially when cyclic dependencies
                                * are involved. Here we just mark all floating inputs of phi nodes as non-floating which forces
                                * them to get scheduled.
                                *
                                * TODO: Find out if this requirement is too expensive. We can make the move insertion algorithm
                                * more intelligent so that it walks the inputs of floating nodes when looking for dependencies.
                                */
                                node.args.forEach(function (input) {
                                    if (shouldFloat(input)) {
                                        input.mustNotFloat = true;
                                    }
                                });
                            }
                        });

                        if (debugScheduler) {
                            roots.forEach(function (node) {
                                writer && writer.writeLn("Root: " + node);
                            });
                        }

                        for (var i = 0; i < roots.length; i++) {
                            var root = roots[i];
                            if (root instanceof IR.Phi) {
                                var block = root.control.block;
                                (block.phis || (block.phis = [])).push(root);
                            }
                            if (root.control) {
                                schedule(root);
                            }
                        }

                        function isScheduled(node) {
                            return scheduled[node.id];
                        }

                        function shouldFloat(node) {
                            if (node.mustNotFloat || node.shouldNotFloat) {
                                return false;
                            }
                            if (node.mustFloat || node.shouldFloat) {
                                return true;
                            }
                            if (node instanceof IR.Parameter || node instanceof IR.This || node instanceof IR.Arguments) {
                                return true;
                            }
                            return node instanceof IR.Binary || node instanceof IR.Unary || node instanceof IR.Parameter;
                        }

                        function append(node) {
                            release || assert(!isScheduled(node), "Already scheduled ", node);
                            scheduled[node.id] = true;
                            release || assert(node.control, node);
                            if (shouldFloat(node)) {
                            } else {
                                node.control.block.append(node);
                            }
                        }

                        function scheduleIn(node, region) {
                            release || assert(!node.control, node);
                            release || assert(!isScheduled(node));
                            release || assert(region);
                            debugScheduler && writer.writeLn("Scheduled: " + node + " in " + region);
                            node.control = region;
                            append(node);
                        }

                        function schedule(node) {
                            debugScheduler && writer.enter("> Schedule: " + node);

                            var inputs = [];

                            // node.checkInputVisitors();
                            node.visitInputs(function (input) {
                                if (isConstant(input)) {
                                     {
                                        return;
                                    }
                                }
                                if (isValue(input)) {
                                    inputs.push(followProjection(input));
                                }
                            });

                            debugScheduler && writer.writeLn("Inputs: [" + inputs.map(toID) + "], length: " + inputs.length);

                            for (var i = 0; i < inputs.length; i++) {
                                var input = inputs[i];
                                if (isNotPhi(input) && !isScheduled(input)) {
                                    schedule(input);
                                }
                            }

                            if (node.control) {
                                if (node instanceof IR.End || node instanceof IR.Phi || node instanceof IR.Start || isScheduled(node)) {
                                } else {
                                    append(node);
                                }
                            } else {
                                if (inputs.length) {
                                    var x = inputs[0].control;
                                    for (var i = 1; i < inputs.length; i++) {
                                        var y = inputs[i].control;
                                        if (x.block.dominatorDepth < y.block.dominatorDepth) {
                                            x = y;
                                        }
                                    }
                                    scheduleIn(node, x);
                                } else {
                                    scheduleIn(node, cfg.root.region);
                                }
                            }

                            debugScheduler && writer.leave("<");
                        }

                        debugScheduler && writer.leave("<");

                        roots.forEach(function (node) {
                            node = followProjection(node);
                            if (node === dfg.start || node instanceof IR.Region) {
                                return;
                            }
                            release || assert(node.control, "Node is not scheduled: ", node);
                        });
                    };

                    CFG.prototype.trace = function (writer) {
                        var visited = [];
                        var blocks = [];

                        function next(block) {
                            if (!visited[block.id]) {
                                visited[block.id] = true;
                                blocks.push(block);
                                block.visitSuccessors(next);
                            }
                        }

                        var root = this.root;
                        var exit = this.exit;

                        next(root);

                        function colorOf(block) {
                            return "black";
                        }

                        function styleOf(block) {
                            return "filled";
                        }

                        function shapeOf(block) {
                            release || assert(block);
                            if (block === root) {
                                return "house";
                            } else if (block === exit) {
                                return "invhouse";
                            }
                            return "box";
                        }

                        writer.writeLn("");
                        writer.enter("digraph CFG {");

                        writer.writeLn("graph [bgcolor = gray10];");
                        writer.writeLn("edge [fontname = Consolas, fontsize = 11, color = white, fontcolor = white];");
                        writer.writeLn("node [shape = box, fontname = Consolas, fontsize = 11, color = white, fontcolor = white, style = filled];");
                        writer.writeLn("rankdir = TB;");

                        blocks.forEach(function (block) {
                            var loopInfo = "";
                            var blockInfo = "";
                            var intervalInfo = "";

                            // if (block.dominatorDepth !== undefined) {
                            //  blockInfo = " D" + block.dominatorDepth;
                            // }
                            if (block.loops !== undefined) {
                                // loopInfo = "loop: " + block.loops + ", nest: " + bitCount(block.loops);
                                // loopInfo = " L" + bitCount(block.loops);
                            }
                            if (block.name !== undefined) {
                                blockInfo += " " + block.name;
                            }
                            if (block.rpo !== undefined) {
                                blockInfo += " O: " + block.rpo;
                            }
                            writer.writeLn("B" + block.id + " [label = \"B" + block.id + blockInfo + loopInfo + "\", fillcolor = \"" + colorOf(block) + "\", shape=" + shapeOf(block) + ", style=" + styleOf(block) + "];");
                        });

                        blocks.forEach(function (block) {
                            block.visitSuccessors(function (successor) {
                                writer.writeLn("B" + block.id + " -> " + "B" + successor.id);
                            });
                            if (block.dominator) {
                                writer.writeLn("B" + block.id + " -> " + "B" + block.dominator.id + " [color = orange];");
                            }
                            if (block.follow) {
                                writer.writeLn("B" + block.id + " -> " + "B" + block.follow.id + " [color = purple];");
                            }
                        });

                        writer.leave("}");
                        writer.writeLn("");
                    };
                    return CFG;
                })();
                IR.CFG = CFG;

                /**
                * Peephole optimizations:
                */
                var PeepholeOptimizer = (function () {
                    function PeepholeOptimizer() {
                    }
                    PeepholeOptimizer.prototype.foldUnary = function (node, truthy) {
                        release || assert(node instanceof IR.Unary);
                        if (isConstant(node.argument)) {
                            return new IR.Constant(node.operator.evaluate(node.argument.value));
                        }
                        if (truthy) {
                            var argument = this.fold(node.argument, true);
                            if (node.operator === IR.Operator.TRUE) {
                                return argument;
                            }
                            if (argument instanceof IR.Unary) {
                                if (node.operator === IR.Operator.FALSE && argument.operator === IR.Operator.FALSE) {
                                    return argument.argument;
                                }
                            } else {
                                return new IR.Unary(node.operator, argument);
                            }
                        }
                        return node;
                    };
                    PeepholeOptimizer.prototype.foldBinary = function (node, truthy) {
                        release || assert(node instanceof IR.Binary);
                        if (isConstant(node.left) && isConstant(node.right)) {
                            return new IR.Constant(node.operator.evaluate(node.left.value, node.right.value));
                        }
                        return node;
                    };
                    PeepholeOptimizer.prototype.fold = function (node, truthy) {
                        if (node instanceof IR.Unary) {
                            return this.foldUnary(node, truthy);
                        } else if (node instanceof IR.Binary) {
                            return this.foldBinary(node, truthy);
                        }
                        return node;
                    };
                    return PeepholeOptimizer;
                })();
                IR.PeepholeOptimizer = PeepholeOptimizer;
            })(Compiler.IR || (Compiler.IR = {}));
            var IR = Compiler.IR;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var InstanceInfo = Shumway.AVM2.ABC.InstanceInfo;

            var notImplemented = Shumway.Debug.notImplemented;
            var assert = Shumway.Debug.assert;

            var top = Shumway.ArrayUtilities.top;
            var unique = Shumway.ArrayUtilities.unique;

            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;
            var Runtime = Shumway.AVM2.Runtime;
            var GlobalMultinameResolver = Shumway.AVM2.Runtime.GlobalMultinameResolver;

            var counter = Shumway.Metrics.Counter.instance;

            var Node = Compiler.IR.Node;

            var Start = Compiler.IR.Start;
            var Region = Compiler.IR.Region;
            var Null = Compiler.IR.Null;
            var Undefined = Compiler.IR.Undefined;
            var True = Compiler.IR.True;
            var False = Compiler.IR.False;
            var This = Compiler.IR.This;
            var Projection = Compiler.IR.Projection;
            var ProjectionType = Compiler.IR.ProjectionType;
            var Binary = Compiler.IR.Binary;
            var Unary = Compiler.IR.Unary;
            var Constant = Compiler.IR.Constant;
            var Call = Compiler.IR.Call;
            var Phi = Compiler.IR.Phi;
            var Stop = Compiler.IR.Stop;
            var Operator = Compiler.IR.Operator;
            var Parameter = Compiler.IR.Parameter;
            var NewArray = Compiler.IR.NewArray;
            var NewObject = Compiler.IR.NewObject;
            var KeyValuePair = Compiler.IR.KeyValuePair;
            var isConstant = Compiler.IR.isConstant;

            var writer = new Shumway.IndentingWriter();
            var peepholeOptimizer = new Compiler.IR.PeepholeOptimizer();

            /**
            * Use the 'typeof argument === "undefined" ? defaultValue : argument' pattern to
            * check for undefined arguments instead of the more correct arguments.length version.
            */
            var useTypeOfForDefaultArgumentChecking = false;

            /**
            * Coerce non-primitive parameters. We can "safely" ignore non-primitive coercions because AS3
            * programs with invalid coercions would throw runtime exceptions.
            */
            var emitCoerceNonPrimitiveParameters = false;

            /**
            * Coerce non-primitive values. Same logic as above.
            */
            var emitCoerceNonPrimitive = false;

            var emitAsType = true;
            var emitAsTypeLate = true;

            var State = (function () {
                function State(index) {
                    if (typeof index === "undefined") { index = 0; }
                    this.id = State._nextID += 1;
                    this.index = index;
                    this.local = [];
                    this.stack = [];
                    this.scope = [];
                    this.store = Undefined;
                    this.loads = [];
                    this.saved = Undefined;
                }
                State.prototype.clone = function (index) {
                    var s = new State();
                    s.index = index !== undefined ? index : this.index;
                    s.local = this.local.slice(0);
                    s.stack = this.stack.slice(0);
                    s.scope = this.scope.slice(0);
                    s.loads = this.loads.slice(0);
                    s.saved = this.saved;
                    s.store = this.store;
                    return s;
                };

                State.prototype.matches = function (other) {
                    return this.stack.length === other.stack.length && this.scope.length === other.scope.length && this.local.length === other.local.length;
                };

                State.prototype.makeLoopPhis = function (control, dirtyLocals) {
                    var s = new State();
                    release || assert(control);
                    function makePhi(x) {
                        var phi = new Phi(control, x);
                        phi.isLoop = true;
                        return phi;
                    }
                    s.index = this.index;
                    s.local = this.local.map(function (v, i) {
                        if (dirtyLocals[i]) {
                            return makePhi(v);
                        }
                        return v;
                    });
                    s.stack = this.stack.map(makePhi);
                    s.scope = this.scope.map(makePhi);
                    s.loads = this.loads.slice(0);
                    s.saved = this.saved;
                    s.store = makePhi(this.store);
                    return s;
                };

                State.tryOptimizePhi = function (x) {
                    if (x instanceof Phi) {
                        var phi = x;
                        if (phi.isLoop) {
                            return phi;
                        }
                        var args = unique(phi.args);
                        if (args.length === 1) {
                            phi.seal();
                            AVM2.countTimeline("Builder: OptimizedPhi");
                            return args[0];
                        }
                    }
                    return x;
                };

                State.prototype.optimize = function () {
                    this.local = this.local.map(State.tryOptimizePhi);
                    this.stack = this.stack.map(State.tryOptimizePhi);
                    this.scope = this.scope.map(State.tryOptimizePhi);
                    this.saved = State.tryOptimizePhi(this.saved);
                    this.store = State.tryOptimizePhi(this.store);
                };

                State.mergeValue = function (control, a, b) {
                    var phi = (a instanceof Phi && a.control === control ? a : new Phi(control, a));
                    phi.pushValue(b);
                    return phi;
                };

                State.mergeValues = function (control, a, b) {
                    for (var i = 0; i < a.length; i++) {
                        a[i] = State.mergeValue(control, a[i], b[i]);
                    }
                };

                State.prototype.merge = function (control, other) {
                    release || assert(control);
                    release || assert(this.matches(other), this, " !== ", other);
                    State.mergeValues(control, this.local, other.local);
                    State.mergeValues(control, this.stack, other.stack);
                    State.mergeValues(control, this.scope, other.scope);
                    this.store = State.mergeValue(control, this.store, other.store);
                    this.store.abstract = true;
                };

                State.prototype.trace = function (writer) {
                    writer.writeLn(this.toString());
                };

                State.toBriefString = function (x) {
                    if (x instanceof Node) {
                        return x.toString(true);
                    }
                    return x;
                };

                State.prototype.toString = function () {
                    return "<" + String(this.id + " @ " + this.index).padRight(' ', 10) + (" M: " + State.toBriefString(this.store)).padRight(' ', 14) + (" X: " + State.toBriefString(this.saved)).padRight(' ', 14) + (" $: " + this.scope.map(State.toBriefString).join(", ")).padRight(' ', 20) + (" L: " + this.local.map(State.toBriefString).join(", ")).padRight(' ', 40) + (" S: " + this.stack.map(State.toBriefString).join(", ")).padRight(' ', 60);
                };
                State._nextID = 0;
                return State;
            })();

            function asConstant(node) {
                release || assert(node instanceof Constant);
                return node;
            }

            function isNumericConstant(node) {
                return node instanceof Constant && Shumway.isNumeric(node.value);
            }

            function isStringConstant(node) {
                return node instanceof Constant && Shumway.isString(node.value);
            }

            function isMultinameConstant(node) {
                return node instanceof Constant && node.value instanceof Multiname;
            }

            function hasNumericType(node) {
                if (isNumericConstant(node)) {
                    return true;
                }
                return node.ty && node.ty.isNumeric();
            }

            function typesAreEqual(a, b) {
                if (hasNumericType(a) && hasNumericType(b) || hasStringType(a) && hasStringType(b)) {
                    return true;
                }
                return false;
            }

            function hasStringType(node) {
                if (isStringConstant(node)) {
                    return true;
                }
                return node.ty && node.ty.isString();
            }

            function constant(value) {
                return new Constant(value);
            }

            function qualifiedNameConstant(name) {
                return constant(Multiname.getQualifiedName(name));
            }

            function operatorFromOP(op) {
                switch (op) {
                    case 161 /* subtract */:
                        return Operator.SUB;
                    case 162 /* multiply */:
                        return Operator.MUL;
                    case 163 /* divide */:
                        return Operator.DIV;
                    case 164 /* modulo */:
                        return Operator.MOD;
                    case 165 /* lshift */:
                        return Operator.LSH;
                    case 166 /* rshift */:
                        return Operator.RSH;
                    case 167 /* urshift */:
                        return Operator.URSH;
                    case 168 /* bitand */:
                        return Operator.AND;
                    case 169 /* bitor */:
                        return Operator.OR;
                    case 170 /* bitxor */:
                        return Operator.XOR;
                    case 20 /* ifne */:
                        return Operator.NE;
                    case 26 /* ifstrictne */:
                        return Operator.SNE;
                    case 19 /* ifeq */:
                    case 171 /* equals */:
                        return Operator.EQ;
                    case 25 /* ifstricteq */:
                    case 172 /* strictequals */:
                        return Operator.SEQ;
                    case 21 /* iflt */:
                    case 173 /* lessthan */:
                        return Operator.LT;
                    case 22 /* ifle */:
                    case 174 /* lessequals */:
                        return Operator.LE;
                    case 23 /* ifgt */:
                    case 175 /* greaterthan */:
                        return Operator.GT;
                    case 24 /* ifge */:
                    case 176 /* greaterequals */:
                        return Operator.GE;
                    case 144 /* negate */:
                        return Operator.NEG;
                    case 196 /* negate_i */:
                        return Operator.NEG;
                    case 197 /* add_i */:
                        return Operator.ADD;
                    case 198 /* subtract_i */:
                        return Operator.SUB;
                    case 199 /* multiply_i */:
                        return Operator.MUL;
                    case 17 /* iftrue */:
                        return Operator.TRUE;
                    case 18 /* iffalse */:
                        return Operator.FALSE;
                    case 150 /* not */:
                        return Operator.FALSE;
                    case 151 /* bitnot */:
                        return Operator.BITWISE_NOT;
                    default:
                        notImplemented(String(op));
                }
            }

            function getJSPropertyWithState(state, object, path) {
                release || assert(Shumway.isString(path));
                var names = path.split(".");
                var node = object;
                for (var i = 0; i < names.length; i++) {
                    node = new Compiler.IR.GetProperty(null, state.store, node, constant(names[i]));
                    node.shouldFloat = true;
                    state.loads.push(node);
                }
                return node;
            }

            function globalProperty(name) {
                var node = new Compiler.IR.GlobalProperty(name);
                node.mustFloat = true;
                return node;
            }

            function warn(message) {
                // writer.warnLn(message);
            }

            function unary(operator, argument) {
                var node = new Unary(operator, argument);
                if (peepholeOptimizer) {
                    node = peepholeOptimizer.fold(node);
                }
                return node;
            }

            function binary(operator, left, right) {
                var node = new Binary(operator, left, right);
                if (left.ty && left.ty !== Shumway.AVM2.Verifier.Type.Any && left.ty === right.ty) {
                    if (operator === Operator.EQ) {
                        node.operator = Operator.SEQ;
                    } else if (operator === Operator.NE) {
                        node.operator = Operator.SNE;
                    }
                }
                if (peepholeOptimizer) {
                    node = peepholeOptimizer.fold(node);
                }
                return node;
            }

            function coerceInt(value) {
                return binary(Operator.OR, value, constant(0));
            }

            function coerceUint(value) {
                return binary(Operator.URSH, value, constant(0));
            }

            function coerceNumber(value) {
                if (hasNumericType(value)) {
                    return value;
                }
                return unary(Operator.PLUS, value);
            }

            function coerceBoolean(value) {
                return unary(Operator.FALSE, unary(Operator.FALSE, value));
            }

            function shouldNotFloat(node) {
                node.shouldNotFloat = true;
                return node;
            }

            function shouldFloat(node) {
                release || assert(!(node instanceof Compiler.IR.GetProperty), "Cannot float node : " + node);
                node.shouldFloat = true;
                return node;
            }

            function mustFloat(node) {
                node.mustFloat = true;
                return node;
            }

            function callPure(callee, object, args) {
                return new Call(null, null, callee, object, args, 4 /* PRISTINE */);
            }

            function callGlobalProperty(name, value) {
                return callPure(globalProperty(name), null, [value]);
            }

            function convertString(value) {
                if (isStringConstant(value)) {
                    return value;
                }
                return callPure(globalProperty("String"), null, [value]);
            }

            function coerceString(value) {
                if (isStringConstant(value)) {
                    return value;
                } else if (isConstant(value)) {
                    return new Constant(Runtime.asCoerceString(asConstant(value).value));
                }
                return callPure(globalProperty("asCoerceString"), null, [value]);
            }

            var coerceObject = callGlobalProperty.bind(null, "asCoerceObject");

            var coercers = createEmptyObject();
            coercers[Multiname.Int] = coerceInt;
            coercers[Multiname.Uint] = coerceUint;
            coercers[Multiname.Number] = coerceNumber;
            coercers[Multiname.String] = coerceString;
            coercers[Multiname.Object] = coerceObject;
            coercers[Multiname.Boolean] = coerceBoolean;

            function getCoercerForType(multiname) {
                release || assert(multiname instanceof Multiname);
                return coercers[Multiname.getQualifiedName(multiname)];
            }

            var callableConstructors = createEmptyObject();
            callableConstructors[Multiname.Int] = coerceInt;
            callableConstructors[Multiname.Uint] = coerceUint;
            callableConstructors[Multiname.Number] = callGlobalProperty.bind(null, "Number");
            callableConstructors[Multiname.String] = callGlobalProperty.bind(null, "String");
            callableConstructors[Multiname.Object] = callGlobalProperty.bind(null, "Object");
            callableConstructors[Multiname.Boolean] = callGlobalProperty.bind(null, "Boolean");

            function getCallableConstructorForType(multiname) {
                release || assert(multiname instanceof Multiname);
                return callableConstructors[Multiname.getQualifiedName(multiname)];
            }

            var callObject = callGlobalProperty.bind(null, "Object");

            /**
            * All the state needed when building blocks.
            */
            var BlockBuilder = (function () {
                function BlockBuilder(builder, region, block, state) {
                    this.builder = builder;
                    this.region = region;
                    this.block = block;
                    this.state = state;
                    this.abc = builder.abc;
                    this.methodInfoConstant = builder.methodInfoConstant;
                    this.bytecodes = builder.methodInfo.analysis.bytecodes;
                    this.constantPool = builder.abc.constantPool;
                    this.traceBuilder = builder.traceBuilder;
                    this.methodInfo = builder.methodInfo;
                }
                BlockBuilder.prototype.popMultiname = function () {
                    var multiname = this.constantPool.multinames[this.bc.index];
                    var namespaces, name, flags = multiname.flags;
                    if (multiname.isRuntimeName()) {
                        name = this.state.stack.pop();
                    } else {
                        name = constant(multiname.name);
                    }
                    if (multiname.isRuntimeNamespace()) {
                        namespaces = shouldFloat(new NewArray(this.region, [this.state.stack.pop()]));
                    } else {
                        namespaces = constant(multiname.namespaces);
                    }
                    return new Compiler.IR.ASMultiname(namespaces, name, flags);
                };

                BlockBuilder.prototype.setIfStops = function (predicate) {
                    release || assert(!this.stops);
                    var _if = new Compiler.IR.If(this.region, predicate);
                    this.stops = [
                        {
                            control: new Projection(_if, 2 /* FALSE */),
                            target: this.bytecodes[this.bc.position + 1],
                            state: this.state
                        }, {
                            control: new Projection(_if, 1 /* TRUE */),
                            target: this.bc.target,
                            state: this.state
                        }];
                };

                BlockBuilder.prototype.setJumpStop = function () {
                    release || assert(!this.stops);
                    this.stops = [{
                            control: this.region,
                            target: this.bc.target,
                            state: this.state
                        }];
                };

                BlockBuilder.prototype.setThrowStop = function () {
                    release || assert(!this.stops);
                    this.stops = [];
                };

                BlockBuilder.prototype.setReturnStop = function () {
                    release || assert(!this.stops);
                    this.stops = [];
                };

                BlockBuilder.prototype.setSwitchStops = function (determinant) {
                    release || assert(!this.stops);
                    if (this.bc.targets.length > 2) {
                        this.stops = [];
                        var _switch = new Compiler.IR.Switch(this.region, determinant);
                        for (var i = 0; i < this.bc.targets.length; i++) {
                            this.stops.push({
                                control: new Projection(_switch, 0 /* CASE */, constant(i)),
                                target: this.bc.targets[i],
                                state: this.state
                            });
                        }
                    } else {
                        release || assert(this.bc.targets.length === 2);
                        var predicate = binary(Operator.SEQ, determinant, constant(0));
                        var _if = new Compiler.IR.If(this.region, predicate);
                        this.stops = [
                            {
                                control: new Projection(_if, 2 /* FALSE */),
                                target: this.bc.targets[1],
                                state: this.state
                            }, {
                                control: new Projection(_if, 1 /* TRUE */),
                                target: this.bc.targets[0],
                                state: this.state
                            }];
                    }
                };

                BlockBuilder.prototype.savedScope = function () {
                    return this.state.saved;
                };

                BlockBuilder.prototype.topScope = function (depth) {
                    var scope = this.state.scope;
                    if (depth !== undefined) {
                        if (depth < scope.length) {
                            return scope[scope.length - 1 - depth];
                        } else if (depth === scope.length) {
                            return this.savedScope();
                        } else {
                            var s = this.savedScope();
                            var savedScopeDepth = depth - scope.length;
                            for (var i = 0; i < savedScopeDepth; i++) {
                                s = getJSPropertyWithState(this.state, s, "parent");
                            }
                            return s;
                        }
                    }
                    if (scope.length > 0) {
                        return top(scope);
                    }
                    return this.savedScope();
                };

                BlockBuilder.prototype.getGlobalScope = function () {
                    var ti = this.bc.ti;
                    if (ti && ti.object) {
                        return constant(ti.object);
                    }
                    return new Compiler.IR.ASGlobal(null, this.savedScope());
                };

                BlockBuilder.prototype.getScopeObject = function (scope) {
                    if (scope instanceof Compiler.IR.ASScope) {
                        return scope.object;
                    }
                    return getJSPropertyWithState(this.state, scope, "object");
                };

                BlockBuilder.prototype.findProperty = function (multiname, strict) {
                    var ti = this.bc.ti;
                    var slowPath = new Compiler.IR.ASFindProperty(this.region, this.state.store, this.topScope(), multiname, this.methodInfoConstant, strict);
                    if (ti) {
                        if (ti.object) {
                            if (ti.object instanceof Shumway.AVM2.Runtime.Global && !ti.object.isExecuting()) {
                                // If we find the property in a global whose script hasn't been executed yet
                                // we have to emit the slow path so it gets executed.
                                warn("Can't optimize findProperty " + multiname + ", global object is not yet executed or executing.");
                                return slowPath;
                            }
                            return constant(ti.object);
                        } else if (ti.scopeDepth !== undefined) {
                            return this.getScopeObject(this.topScope(ti.scopeDepth));
                        }
                    }
                    warn("Can't optimize findProperty " + multiname);
                    return slowPath;
                };

                BlockBuilder.prototype.coerce = function (multiname, value) {
                    // TODO: Try to do the coercion of constant values without causing classes to be
                    // loaded, as is the case when calling |asCoerceByMultiname|.
                    if (false && isConstant(value)) {
                        return constant(Runtime.asCoerceByMultiname(this.methodInfo, multiname, value.value));
                    } else {
                        var coercer = getCoercerForType(multiname);
                        if (coercer) {
                            return coercer(value);
                        }
                    }
                    if (emitCoerceNonPrimitive) {
                        return this.call(globalProperty("asCoerceByMultiname"), null, [this.methodInfoConstant, constant(multiname), value]);
                    }
                    return value;
                };

                /**
                * Marks the |node| as the active store node, with dependencies on all loads appearing after the
                * previous active store node.
                */
                BlockBuilder.prototype.store = function (node) {
                    var state = this.state;
                    state.store = new Projection(node, 3 /* STORE */);
                    node.loads = state.loads.slice(0);
                    state.loads.length = 0;
                    return node;
                };

                /**
                * Keeps track of the current set of loads.
                */
                BlockBuilder.prototype.load = function (node) {
                    var state = this.state;
                    state.loads.push(node);
                    return node;
                };

                BlockBuilder.prototype.call = function (callee, object, args) {
                    return this.store(new Call(this.region, this.state.store, callee, object, args, 4 /* PRISTINE */));
                };

                BlockBuilder.prototype.callCall = function (callee, object, args) {
                    return this.store(new Call(this.region, this.state.store, callee, object, args, 16 /* AS_CALL */));
                };

                BlockBuilder.prototype.callProperty = function (object, multiname, args, isLex) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti && ti.trait) {
                        if (ti.trait.isMethod()) {
                            var openQn;
                            if (ti.trait.holder instanceof InstanceInfo && ti.trait.holder.isInterface()) {
                                openQn = Multiname.getPublicQualifiedName(Multiname.getName(ti.trait.name));
                            } else {
                                openQn = Multiname.getQualifiedName(ti.trait.name);
                            }
                            openQn = Runtime.VM_OPEN_METHOD_PREFIX + openQn;
                            return this.store(new Compiler.IR.CallProperty(region, state.store, object, constant(openQn), args, 4 /* PRISTINE */));
                        } else if (ti.trait.isClass()) {
                            var constructor = getCallableConstructorForType(ti.trait.name);
                            if (constructor) {
                                return constructor(args[0]);
                            }
                            var qn = Multiname.getQualifiedName(ti.trait.name);
                            return this.store(new Compiler.IR.CallProperty(region, state.store, object, constant(qn), args, 16 /* AS_CALL */));
                        }
                    }
                    var mn = this.resolveMultinameGlobally(multiname);
                    if (mn) {
                        return this.store(new Compiler.IR.ASCallProperty(region, state.store, object, constant(Multiname.getQualifiedName(mn)), args, 4 /* PRISTINE */ | 2 /* RESOLVED */, isLex));
                    }
                    return this.store(new Compiler.IR.ASCallProperty(region, state.store, object, multiname, args, 4 /* PRISTINE */, isLex));
                };

                BlockBuilder.prototype.getProperty = function (object, multiname, getOpenMethod) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    release || assert(multiname instanceof Compiler.IR.ASMultiname);
                    getOpenMethod = !!getOpenMethod;
                    if (ti) {
                        if (ti.trait) {
                            if (ti.trait.isConst() && ti.trait.hasDefaultValue) {
                                return constant(ti.trait.value);
                            }
                            var get = new Compiler.IR.GetProperty(region, state.store, object, qualifiedNameConstant(ti.trait.name));
                            return ti.trait.isGetter() ? this.store(get) : this.load(get);
                        }
                    }
                    if (hasNumericType(multiname.name)) {
                        return this.store(new Compiler.IR.ASGetProperty(region, state.store, object, multiname, 1 /* NumericProperty */));
                    }
                    warn("Can't optimize getProperty " + multiname.name + " " + multiname.name.ty);
                    var qn = this.resolveMultinameGlobally(multiname);
                    if (qn) {
                        return this.store(new Compiler.IR.ASGetProperty(region, state.store, object, constant(Multiname.getQualifiedName(qn)), 2 /* RESOLVED */ | (getOpenMethod ? 8 /* IS_METHOD */ : 0)));
                    }
                    AVM2.countTimeline("Compiler: Slow ASGetProperty");
                    return this.store(new Compiler.IR.ASGetProperty(region, state.store, object, multiname, (getOpenMethod ? 8 /* IS_METHOD */ : 0)));
                };

                BlockBuilder.prototype.setProperty = function (object, multiname, value) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    release || assert(multiname instanceof Compiler.IR.ASMultiname);
                    if (ti) {
                        if (ti.trait) {
                            var coercer = ti.trait.typeName ? getCoercerForType(ti.trait.typeName) : null;
                            if (coercer) {
                                value = coercer(value);
                            }
                            this.store(new Compiler.IR.SetProperty(region, state.store, object, qualifiedNameConstant(ti.trait.name), value));
                            return;
                        }
                    }
                    if (hasNumericType(multiname.name)) {
                        return this.store(new Compiler.IR.ASSetProperty(region, state.store, object, multiname, value, 1 /* NumericProperty */));
                    }
                    warn("Can't optimize setProperty " + multiname);
                    var qn = this.resolveMultinameGlobally(multiname);
                    if (qn) {
                        // TODO: return store(new IR.SetProperty(region, state.store, object, constant(Multiname.getQualifiedName(qn)), value));
                    }
                    return this.store(new Compiler.IR.ASSetProperty(region, state.store, object, multiname, value, 0));
                };

                BlockBuilder.prototype.callSuper = function (scope, object, multiname, args) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti && ti.trait && ti.trait.isMethod() && ti.baseClass) {
                        var qn = Runtime.VM_OPEN_METHOD_PREFIX + Multiname.getQualifiedName(ti.trait.name);
                        var callee = this.getJSProperty(constant(ti.baseClass), "traitsPrototype." + qn);
                        return this.call(callee, object, args);
                    }
                    return this.store(new Compiler.IR.ASCallSuper(region, state.store, object, multiname, args, 4 /* PRISTINE */, scope));
                };

                BlockBuilder.prototype.getSuper = function (scope, object, multiname) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti && ti.trait && ti.trait.isGetter() && ti.baseClass) {
                        var qn = Runtime.VM_OPEN_GET_METHOD_PREFIX + Multiname.getQualifiedName(ti.trait.name);
                        var callee = this.getJSProperty(constant(ti.baseClass), "traitsPrototype." + qn);
                        return this.call(callee, object, []);
                    }
                    return this.store(new Compiler.IR.ASGetSuper(region, state.store, object, multiname, scope));
                };

                BlockBuilder.prototype.setSuper = function (scope, object, multiname, value) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti && ti.trait && ti.trait.isSetter() && ti.baseClass) {
                        var qn = Runtime.VM_OPEN_SET_METHOD_PREFIX + Multiname.getQualifiedName(ti.trait.name);
                        var callee = this.getJSProperty(constant(ti.baseClass), "traitsPrototype." + qn);
                        return this.call(callee, object, [value]);
                    }
                    return this.store(new Compiler.IR.ASSetSuper(region, state.store, object, multiname, value, scope));
                };

                BlockBuilder.prototype.constructSuper = function (scope, object, args) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti) {
                        if (ti.noCallSuperNeeded) {
                            return;
                        } else if (ti.baseClass) {
                            var callee = this.getJSProperty(constant(ti.baseClass), "instanceConstructorNoInitialize");
                            this.call(callee, object, args);
                            return;
                        }
                    }
                    callee = this.getJSProperty(scope, "object.baseClass.instanceConstructorNoInitialize");
                    this.call(callee, object, args);
                    return;
                };

                BlockBuilder.prototype.getSlot = function (object, index) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti) {
                        var trait = ti.trait;
                        if (trait) {
                            if (trait.isConst() && ti.trait.hasDefaultValue) {
                                return constant(trait.value);
                            }
                            var slotQn = Multiname.getQualifiedName(trait.name);
                            return this.store(new Compiler.IR.GetProperty(region, state.store, object, constant(slotQn)));
                        }
                    }
                    warn("Can't optimize getSlot " + index);
                    return this.store(new Compiler.IR.ASGetSlot(null, state.store, object, index));
                };

                BlockBuilder.prototype.setSlot = function (object, index, value) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    if (ti) {
                        var trait = ti.trait;
                        if (trait) {
                            var slotQn = Multiname.getQualifiedName(trait.name);
                            this.store(new Compiler.IR.SetProperty(region, state.store, object, constant(slotQn), value));
                            return;
                        }
                    }
                    warn("Can't optimize setSlot " + index);
                    this.store(new Compiler.IR.ASSetSlot(region, state.store, object, index, value));
                };

                BlockBuilder.prototype.resolveMultinameGlobally = function (multiname) {
                    var namespaces = multiname.namespaces;
                    var name = multiname.name;
                    if (!Shumway.AVM2.Runtime.globalMultinameAnalysis.value) {
                        return;
                    }
                    if (!isConstant(namespaces) || !isConstant(name) || multiname.isAttribute()) {
                        AVM2.countTimeline("GlobalMultinameResolver: Cannot resolve runtime multiname or attribute.");
                        return;
                    }
                    if (Shumway.isNumeric(name.value) || !Shumway.isString(name.value) || !name.value) {
                        AVM2.countTimeline("GlobalMultinameResolver: Cannot resolve numeric or any names.");
                        return;
                    }
                    return GlobalMultinameResolver.resolveMultiname(new Multiname(namespaces.value, name.value, multiname.flags));
                };

                BlockBuilder.prototype.getJSProperty = function (object, path) {
                    return getJSPropertyWithState(this.state, object, path);
                };

                BlockBuilder.prototype.setJSProperty = function (object, name, value) {
                    this.store(new Compiler.IR.SetProperty(null, this.state.store, object, constant(name), value));
                };

                BlockBuilder.prototype.simplifyName = function (name) {
                    if (isMultinameConstant(name) && Multiname.isQName(name.value)) {
                        return constant(Multiname.getQualifiedName(name.value));
                    }
                    return name;
                };

                BlockBuilder.prototype.getDescendants = function (object, name) {
                    var ti = this.bc.ti;
                    var region = this.region;
                    var state = this.state;
                    name = this.simplifyName(name);
                    return new Compiler.IR.ASGetDescendants(region, state.store, object, name);
                };

                BlockBuilder.prototype.truthyCondition = function (operator) {
                    var stack = this.state.stack;
                    var right;
                    if (operator.isBinary) {
                        right = stack.pop();
                    }
                    var left = stack.pop();
                    var node;
                    if (right) {
                        node = binary(operator, left, right);
                    } else {
                        node = unary(operator, left);
                    }
                    if (peepholeOptimizer) {
                        node = peepholeOptimizer.fold(node, true);
                    }
                    return node;
                };

                BlockBuilder.prototype.negatedTruthyCondition = function (operator) {
                    var node = unary(Operator.FALSE, this.truthyCondition(operator));
                    if (peepholeOptimizer) {
                        node = peepholeOptimizer.fold(node, true);
                    }
                    return node;
                };

                BlockBuilder.prototype.pushExpression = function (operator, toInt) {
                    var stack = this.state.stack;
                    var left, right;
                    if (operator.isBinary) {
                        right = stack.pop();
                        left = stack.pop();
                        if (toInt) {
                            right = coerceInt(right);
                            left = coerceInt(left);
                        }
                        this.push(binary(operator, left, right));
                    } else {
                        left = stack.pop();
                        if (toInt) {
                            left = coerceInt(left);
                        }
                        this.push(unary(operator, left));
                    }
                };

                BlockBuilder.prototype.push = function (x) {
                    var bc = this.bc;
                    release || assert(x instanceof Compiler.IR.Node);
                    if (bc.ti) {
                        if (x.ty) {
                            // release || assert (x.ty == bc.ti.type);
                        } else {
                            x.ty = bc.ti.type;
                        }
                    }
                    this.state.stack.push(x);
                };

                BlockBuilder.prototype.pushLocal = function (index) {
                    var local = this.state.local;
                    this.push(local[index]);
                };

                BlockBuilder.prototype.popLocal = function (index) {
                    var state = this.state;
                    state.local[index] = shouldNotFloat(state.stack.pop());
                };

                BlockBuilder.prototype.build = function () {
                    var block = this.block;
                    var state = this.state;
                    var local = this.state.local;
                    var stack = this.state.stack;
                    var scope = this.state.scope;
                    var region = this.region;
                    var bytecodes = this.bytecodes;

                    var left, right, index;
                    var value, object, callee;
                    var multiname, type, args;
                    var operator;

                    var push = this.push.bind(this);

                    function pop() {
                        return stack.pop();
                    }

                    function popMany(count) {
                        return Shumway.ArrayUtilities.popMany(stack, count);
                    }

                    this.stops = null;

                    if (this.traceBuilder) {
                        writer.writeLn("Processing Region: " + region + ", Block: " + block.bid);
                        writer.enter(("> state: " + region.entryState.toString()).padRight(' ', 100));
                    }

                    var bc;
                    for (var bci = block.position, end = block.end.position; bci <= end; bci++) {
                        this.bc = bc = bytecodes[bci];
                        var op = bc.op;
                        state.index = bci;
                        switch (op) {
                            case 3 /* throw */:
                                this.store(new Compiler.IR.Throw(region, pop()));
                                this.builder.stopPoints.push({
                                    region: region,
                                    store: state.store,
                                    value: Undefined
                                });
                                this.setThrowStop();
                                break;
                            case 98 /* getlocal */:
                                this.pushLocal(bc.index);
                                break;
                            case 208 /* getlocal0 */:
                            case 209 /* getlocal1 */:
                            case 210 /* getlocal2 */:
                            case 211 /* getlocal3 */:
                                this.pushLocal(op - 208 /* getlocal0 */);
                                break;
                            case 99 /* setlocal */:
                                this.popLocal(bc.index);
                                break;
                            case 212 /* setlocal0 */:
                            case 213 /* setlocal1 */:
                            case 214 /* setlocal2 */:
                            case 215 /* setlocal3 */:
                                this.popLocal(op - 212 /* setlocal0 */);
                                break;
                            case 28 /* pushwith */:
                            case 48 /* pushscope */:
                                scope.push(new Compiler.IR.ASScope(this.topScope(), pop(), op === 28 /* pushwith */));
                                break;
                            case 29 /* popscope */:
                                scope.pop();
                                break;
                            case 100 /* getglobalscope */:
                                push(this.getGlobalScope());
                                break;
                            case 101 /* getscopeobject */:
                                push(this.getScopeObject(state.scope[bc.index]));
                                break;
                            case 94 /* findproperty */:
                            case 93 /* findpropstrict */:
                                push(this.findProperty(this.popMultiname(), op === 93 /* findpropstrict */));
                                break;
                            case 102 /* getproperty */:
                                multiname = this.popMultiname();
                                object = pop();
                                push(this.getProperty(object, multiname, false));
                                break;
                            case 89 /* getdescendants */:
                                multiname = this.popMultiname();
                                object = pop();
                                push(this.getDescendants(object, multiname));
                                break;
                            case 96 /* getlex */:
                                multiname = this.popMultiname();
                                push(this.getProperty(this.findProperty(multiname, true), multiname, false));
                                break;
                            case 104 /* initproperty */:
                            case 97 /* setproperty */:
                                value = pop();
                                multiname = this.popMultiname();
                                object = pop();
                                this.setProperty(object, multiname, value);
                                break;
                            case 106 /* deleteproperty */:
                                multiname = this.popMultiname();
                                object = pop();
                                push(this.store(new Compiler.IR.ASDeleteProperty(region, state.store, object, multiname)));
                                break;
                            case 108 /* getslot */:
                                object = pop();
                                push(this.getSlot(object, constant(bc.index)));
                                break;
                            case 109 /* setslot */:
                                value = pop();
                                object = pop();
                                this.setSlot(object, constant(bc.index), value);
                                break;
                            case 4 /* getsuper */:
                                multiname = this.popMultiname();
                                object = pop();
                                push(this.getSuper(this.savedScope(), object, multiname));
                                break;
                            case 5 /* setsuper */:
                                value = pop();
                                multiname = this.popMultiname();
                                object = pop();
                                this.setSuper(this.savedScope(), object, multiname, value);
                                break;
                            case 241 /* debugfile */:
                            case 240 /* debugline */:
                                break;
                            case 64 /* newfunction */:
                                push(callPure(this.builder.createFunctionCallee, null, [constant(this.abc.methods[bc.index]), this.topScope(), constant(true)]));
                                break;
                            case 65 /* call */:
                                args = popMany(bc.argCount);
                                object = pop();
                                callee = pop();
                                push(this.callCall(callee, object, args));
                                break;
                            case 70 /* callproperty */:
                            case 79 /* callpropvoid */:
                            case 76 /* callproplex */:
                                args = popMany(bc.argCount);
                                multiname = this.popMultiname();
                                object = pop();
                                value = this.callProperty(object, multiname, args, op === 76 /* callproplex */);
                                if (op !== 79 /* callpropvoid */) {
                                    push(value);
                                }
                                break;
                            case 69 /* callsuper */:
                            case 78 /* callsupervoid */:
                                multiname = this.popMultiname();
                                args = popMany(bc.argCount);
                                object = pop();
                                value = this.callSuper(this.savedScope(), object, multiname, args);
                                if (op !== 78 /* callsupervoid */) {
                                    push(value);
                                }
                                break;
                            case 66 /* construct */:
                                args = popMany(bc.argCount);
                                object = pop();
                                push(this.store(new Compiler.IR.ASNew(region, state.store, object, args)));
                                break;
                            case 73 /* constructsuper */:
                                args = popMany(bc.argCount);
                                object = pop();
                                this.constructSuper(this.savedScope(), object, args);
                                break;
                            case 74 /* constructprop */:
                                args = popMany(bc.argCount);
                                multiname = this.popMultiname();
                                object = pop();
                                callee = this.getProperty(object, multiname, false);
                                push(this.store(new Compiler.IR.ASNew(region, state.store, callee, args)));
                                break;
                            case 128 /* coerce */:
                                if (bc.ti && bc.ti.noCoercionNeeded) {
                                    AVM2.countTimeline("Compiler: NoCoercionNeeded");
                                    break;
                                } else {
                                    AVM2.countTimeline("Compiler: CoercionNeeded");
                                }
                                value = pop();
                                push(this.coerce(this.constantPool.multinames[bc.index], value));
                                break;
                            case 131 /* coerce_i */:
                            case 115 /* convert_i */:
                                push(coerceInt(pop()));
                                break;
                            case 136 /* coerce_u */:
                            case 116 /* convert_u */:
                                push(coerceUint(pop()));
                                break;
                            case 132 /* coerce_d */:
                            case 117 /* convert_d */:
                                push(coerceNumber(pop()));
                                break;
                            case 129 /* coerce_b */:
                            case 118 /* convert_b */:
                                push(coerceBoolean(pop()));
                                break;
                            case 120 /* checkfilter */:
                                push(this.call(globalProperty("checkFilter"), null, [pop()]));
                                break;
                            case 130 /* coerce_a */:
                                break;
                            case 133 /* coerce_s */:
                                push(coerceString(pop()));
                                break;
                            case 112 /* convert_s */:
                                push(convertString(pop()));
                                break;
                            case 134 /* astype */:
                                if (bc.ti && bc.ti.noCoercionNeeded) {
                                    AVM2.countTimeline("Compiler: NoCoercionNeeded");
                                    break;
                                } else {
                                    AVM2.countTimeline("Compiler: CoercionNeeded");
                                }
                                if (emitAsType) {
                                    value = pop();
                                    var typeName = this.constantPool.multinames[bc.index];
                                    multiname = new Compiler.IR.ASMultiname(constant(typeName.namespaces), constant(typeName.name), typeName.flags);
                                    type = this.getProperty(this.findProperty(multiname, false), multiname);
                                    push(this.call(globalProperty("asAsType"), null, [type, value]));
                                }
                                break;
                            case 135 /* astypelate */:
                                type = pop();
                                if (emitAsTypeLate) {
                                    value = pop();
                                    push(this.call(globalProperty("asAsType"), null, [type, value]));
                                }
                                break;
                            case 72 /* returnvalue */:
                            case 71 /* returnvoid */:
                                value = Undefined;
                                if (op === 72 /* returnvalue */) {
                                    value = pop();
                                    if (this.methodInfo.returnType) {
                                        if (!(bc.ti && bc.ti.noCoercionNeeded)) {
                                            value = this.coerce(this.methodInfo.returnType, value);
                                        }
                                    }
                                }
                                this.builder.stopPoints.push({
                                    region: region,
                                    store: state.store,
                                    value: value
                                });
                                this.setReturnStop();
                                break;
                            case 30 /* nextname */:
                            case 35 /* nextvalue */:
                                index = pop();
                                object = pop();
                                push(new Compiler.IR.CallProperty(region, state.store, object, constant(op === 30 /* nextname */ ? "asNextName" : "asNextValue"), [index], 4 /* PRISTINE */));
                                break;
                            case 50 /* hasnext2 */:
                                var hasNext2 = new Compiler.IR.ASNewHasNext2();
                                this.setJSProperty(hasNext2, "object", local[bc.object]);
                                this.setJSProperty(hasNext2, "index", local[bc.index]);
                                this.store(new Compiler.IR.CallProperty(region, state.store, callObject(local[bc.object]), constant("asHasNext2"), [hasNext2], 4 /* PRISTINE */));

                                // this.store(new IR.SetProperty(region, state.store, hasNext2, qualifiedNameConstant(ti.trait.name), value));
                                // var temp = this.call(globalProperty("asHasNext2"), null, [local[bc.object], local[bc.index]]);
                                local[bc.object] = this.getJSProperty(hasNext2, "object");
                                push(local[bc.index] = this.getJSProperty(hasNext2, "index"));
                                break;
                            case 32 /* pushnull */:
                                push(Null);
                                break;
                            case 33 /* pushundefined */:
                                push(Undefined);
                                break;
                            case 38 /* pushtrue */:
                                push(True);
                                break;
                            case 39 /* pushfalse */:
                                push(False);
                                break;
                            case 40 /* pushnan */:
                                push(constant(NaN));
                                break;
                            case 34 /* pushfloat */:
                                notImplemented(String(bc));
                                break;
                            case 36 /* pushbyte */:
                            case 37 /* pushshort */:
                                push(constant(bc.value));
                                break;
                            case 44 /* pushstring */:
                                push(constant(this.constantPool.strings[bc.index]));
                                break;
                            case 45 /* pushint */:
                                push(constant(this.constantPool.ints[bc.index]));
                                break;
                            case 46 /* pushuint */:
                                push(constant(this.constantPool.uints[bc.index]));
                                break;
                            case 47 /* pushdouble */:
                                push(constant(this.constantPool.doubles[bc.index]));
                                break;
                            case 41 /* pop */:
                                pop();
                                break;
                            case 42 /* dup */:
                                value = shouldNotFloat(pop());
                                push(value);
                                push(value);
                                break;
                            case 43 /* swap */:
                                state.stack.push(pop(), pop());
                                break;
                            case 239 /* debug */:
                            case 240 /* debugline */:
                            case 241 /* debugfile */:
                                break;
                            case 16 /* jump */:
                                this.setJumpStop();
                                break;
                            case 12 /* ifnlt */:
                                this.setIfStops(this.negatedTruthyCondition(Operator.LT));
                                break;
                            case 15 /* ifnge */:
                                this.setIfStops(this.negatedTruthyCondition(Operator.GE));
                                break;
                            case 14 /* ifngt */:
                                this.setIfStops(this.negatedTruthyCondition(Operator.GT));
                                break;
                            case 13 /* ifnle */:
                                this.setIfStops(this.negatedTruthyCondition(Operator.LE));
                                break;
                            case 24 /* ifge */:
                            case 23 /* ifgt */:
                            case 22 /* ifle */:
                            case 21 /* iflt */:
                            case 17 /* iftrue */:
                            case 18 /* iffalse */:
                            case 19 /* ifeq */:
                            case 20 /* ifne */:
                            case 25 /* ifstricteq */:
                            case 26 /* ifstrictne */:
                                this.setIfStops(this.truthyCondition(operatorFromOP(op)));
                                break;
                            case 27 /* lookupswitch */:
                                this.setSwitchStops(pop());
                                break;
                            case 160 /* add */:
                                right = pop();
                                left = pop();
                                if (typesAreEqual(left, right)) {
                                    operator = Operator.ADD;
                                } else if (Shumway.AVM2.Runtime.useAsAdd) {
                                    operator = Operator.AS_ADD;
                                } else {
                                    operator = Operator.ADD;
                                }
                                push(binary(operator, left, right));
                                break;
                            case 161 /* subtract */:
                            case 162 /* multiply */:
                            case 163 /* divide */:
                            case 164 /* modulo */:
                            case 165 /* lshift */:
                            case 166 /* rshift */:
                            case 167 /* urshift */:
                            case 168 /* bitand */:
                            case 169 /* bitor */:
                            case 170 /* bitxor */:
                            case 171 /* equals */:
                            case 172 /* strictequals */:
                            case 173 /* lessthan */:
                            case 174 /* lessequals */:
                            case 175 /* greaterthan */:
                            case 176 /* greaterequals */:
                            case 144 /* negate */:
                            case 150 /* not */:
                            case 151 /* bitnot */:
                                this.pushExpression(operatorFromOP(op));
                                break;
                            case 196 /* negate_i */:
                            case 197 /* add_i */:
                            case 198 /* subtract_i */:
                            case 199 /* multiply_i */:
                                this.pushExpression(operatorFromOP(op), true);
                                break;
                            case 145 /* increment */:
                            case 192 /* increment_i */:
                            case 147 /* decrement */:
                            case 193 /* decrement_i */:
                                push(constant(1));
                                if (op === 145 /* increment */ || op === 147 /* decrement */) {
                                    push(coerceNumber(pop()));
                                } else {
                                    push(coerceInt(pop()));
                                }
                                if (op === 145 /* increment */ || op === 192 /* increment_i */) {
                                    this.pushExpression(Operator.ADD);
                                } else {
                                    this.pushExpression(Operator.SUB);
                                }
                                break;
                            case 146 /* inclocal */:
                            case 194 /* inclocal_i */:
                            case 148 /* declocal */:
                            case 195 /* declocal_i */:
                                push(constant(1));
                                if (op === 146 /* inclocal */ || op === 148 /* declocal */) {
                                    push(coerceNumber(local[bc.index]));
                                } else {
                                    push(coerceInt(local[bc.index]));
                                }
                                if (op === 146 /* inclocal */ || op === 194 /* inclocal_i */) {
                                    this.pushExpression(Operator.ADD);
                                } else {
                                    this.pushExpression(Operator.SUB);
                                }
                                this.popLocal(bc.index);
                                break;
                            case 177 /* instanceof */:
                                type = pop();
                                value = pop();
                                push(this.call(this.getJSProperty(type, "isInstanceOf"), null, [value]));
                                break;
                            case 178 /* istype */:
                                value = pop();
                                multiname = this.popMultiname();
                                type = this.getProperty(this.findProperty(multiname, false), multiname);
                                push(this.call(globalProperty("asIsType"), null, [type, value]));
                                break;
                            case 179 /* istypelate */:
                                type = pop();
                                value = pop();
                                push(this.call(globalProperty("asIsType"), null, [type, value]));
                                break;
                            case 180 /* in */:
                                object = pop();
                                value = pop();
                                multiname = new Compiler.IR.ASMultiname(Undefined, value, 0);
                                push(this.store(new Compiler.IR.ASHasProperty(region, state.store, object, multiname)));
                                break;
                            case 149 /* typeof */:
                                push(this.call(globalProperty("asTypeOf"), null, [pop()]));
                                break;
                            case 8 /* kill */:
                                push(Undefined);
                                this.popLocal(bc.index);
                                break;
                            case 83 /* applytype */:
                                args = popMany(bc.argCount);
                                type = pop();
                                callee = globalProperty("applyType");
                                push(this.call(callee, null, [this.methodInfoConstant, type, new NewArray(region, args)]));
                                break;
                            case 86 /* newarray */:
                                args = popMany(bc.argCount);
                                push(new NewArray(region, args));
                                break;
                            case 85 /* newobject */:
                                var properties = [];
                                for (var i = 0; i < bc.argCount; i++) {
                                    var value = pop();
                                    var key = pop();
                                    release || assert(isConstant(key) && Shumway.isString(key.value));
                                    key = constant(Multiname.getPublicQualifiedName(key.value));
                                    properties.push(new KeyValuePair(key, value));
                                }
                                push(new NewObject(region, properties));
                                break;
                            case 87 /* newactivation */:
                                push(new Compiler.IR.ASNewActivation(constant(this.methodInfo)));
                                break;
                            case 88 /* newclass */:
                                callee = globalProperty("createClass");
                                push(this.call(callee, null, [constant(this.abc.classes[bc.index]), pop(), this.topScope()]));
                                break;
                            default:
                                notImplemented(String(bc));
                        }
                        if (op === 239 /* debug */ || op === 241 /* debugfile */ || op === 240 /* debugline */) {
                            continue;
                        }
                        if (this.traceBuilder) {
                            writer.writeLn(("state: " + state.toString()).padRight(' ', 100) + " : " + bci + ", " + bc.toString(this.abc));
                        }
                    }
                    if (this.traceBuilder) {
                        writer.leave(("< state: " + state.toString()).padRight(' ', 100));
                    }
                };
                return BlockBuilder;
            })();

            var Builder = (function () {
                function Builder(methodInfo, scope, hasDynamicScope) {
                    release || assert(methodInfo && methodInfo.abc && scope);
                    this.abc = methodInfo.abc;
                    this.methodInfoConstant = new Constant(methodInfo);
                    this.scope = scope;
                    this.methodInfo = methodInfo;
                    this.hasDynamicScope = hasDynamicScope;
                    this.traceBuilder = Shumway.AVM2.Compiler.traceLevel.value > 2;
                    this.createFunctionCallee = globalProperty("createFunction");
                    this.stopPoints = [];
                    this.bytecodes = this.methodInfo.analysis.bytecodes;
                }
                Builder.prototype.buildStart = function (start) {
                    var mi = this.methodInfo;
                    var state = start.entryState = new State(0);

                    /**
                    * [dynamicScope] this parameters ... [arguments|rest] locals
                    */
                    /* First local is the |this| reference. */
                    state.local.push(new This(start));

                    var parameterIndexOffset = this.hasDynamicScope ? 1 : 0;
                    var parameterCount = mi.parameters.length;

                    for (var i = 0; i < parameterCount; i++) {
                        state.local.push(new Parameter(start, parameterIndexOffset + i, mi.parameters[i].name));
                    }

                    for (var i = parameterCount; i < mi.localCount; i++) {
                        state.local.push(Undefined);
                    }

                    state.store = new Projection(start, 3 /* STORE */);
                    if (this.hasDynamicScope) {
                        start.scope = new Parameter(start, 0, Runtime.SAVED_SCOPE_NAME);
                    } else {
                        start.scope = new Constant(this.scope);
                    }
                    state.saved = new Projection(start, 4 /* SCOPE */);

                    var args = new Compiler.IR.Arguments(start);

                    if (mi.needsRest() || mi.needsArguments()) {
                        var offset = constant(parameterIndexOffset + (mi.needsRest() ? parameterCount : 0));
                        state.local[parameterCount + 1] = new Call(start, state.store, globalProperty("sliceArguments"), null, [args, offset], 4 /* PRISTINE */);
                    }

                    var argumentsLength = getJSPropertyWithState(state, args, "length");

                    for (var i = 0; i < parameterCount; i++) {
                        var parameter = mi.parameters[i];
                        var index = i + 1;
                        var local = state.local[index];
                        if (parameter.value !== undefined) {
                            var condition;
                            if (useTypeOfForDefaultArgumentChecking) {
                                condition = new Compiler.IR.Binary(Operator.SEQ, new Compiler.IR.Unary(Operator.TYPE_OF, local), constant("undefined"));
                            } else {
                                condition = new Compiler.IR.Binary(Operator.LT, argumentsLength, constant(parameterIndexOffset + i + 1));
                            }
                            local = new Compiler.IR.Latch(null, condition, constant(parameter.value), local);
                        }
                        if (parameter.type && !parameter.type.isAnyName()) {
                            var coercer = getCoercerForType(parameter.type);
                            if (coercer) {
                                local = coercer(local);
                            } else if (emitCoerceNonPrimitiveParameters) {
                                local = new Call(start, state.store, globalProperty("asCoerceByMultiname"), null, [this.methodInfoConstant, constant(parameter.type), local], 0);
                            }
                        }
                        state.local[index] = local;
                    }

                    return start;
                };

                Builder.prototype.buildGraph = function () {
                    var analysis = this.methodInfo.analysis;
                    var blocks = analysis.blocks;
                    var methodInfo = this.methodInfo;
                    var traceBuilder = this.traceBuilder;

                    for (var i = 0; i < blocks.length; i++) {
                        blocks[i].bdo = i;
                        blocks[i].region = null;
                    }

                    var worklist = new Shumway.SortedList(function compare(a, b) {
                        return a.block.bdo - b.block.bdo;
                    });

                    var start = new Start();
                    this.buildStart(start);

                    worklist.push({ region: start, block: blocks[0] });

                    var next;
                    while ((next = worklist.pop())) {
                        this.buildBlock(next.region, next.block, next.region.entryState.clone()).forEach(function (stop) {
                            var target = stop.target;
                            var region = target.region;
                            if (region) {
                                traceBuilder && writer.enter("Merging into region: " + region + " @ " + target.position + ", block " + target.bid + " {");
                                traceBuilder && writer.writeLn("  R " + region.entryState);
                                traceBuilder && writer.writeLn("+ I " + stop.state);

                                region.entryState.merge(region, stop.state);
                                region.predecessors.push(stop.control);

                                traceBuilder && writer.writeLn("  = " + region.entryState);
                                traceBuilder && writer.leave("}");
                            } else {
                                region = target.region = new Region(stop.control);
                                var dirtyLocals = null;
                                if (target.loop) {
                                    dirtyLocals = Compiler.enableDirtyLocals.value && target.loop.getDirtyLocals();
                                    traceBuilder && writer.writeLn("Adding PHIs to loop region. " + dirtyLocals);
                                }
                                region.entryState = target.loop ? stop.state.makeLoopPhis(region, dirtyLocals) : stop.state.clone(target.position);
                                traceBuilder && writer.writeLn("Adding new region: " + region + " @ " + target.position + " to worklist.");
                                worklist.push({ region: region, block: target });
                            }
                        });

                        traceBuilder && writer.enter("Worklist: {");
                        worklist.forEach(function (item) {
                            traceBuilder && writer.writeLn(item.region + " " + item.block.bdo + " " + item.region.entryState);
                        });
                        traceBuilder && writer.leave("}");
                    }

                    traceBuilder && writer.writeLn("Done");

                    var stop;
                    if (this.stopPoints.length > 1) {
                        var stopRegion = new Region(null);
                        var stopValuePhi = new Phi(stopRegion, null);
                        var stopStorePhi = new Phi(stopRegion, null);
                        this.stopPoints.forEach(function (stopPoint) {
                            stopRegion.predecessors.push(stopPoint.region);
                            stopValuePhi.pushValue(stopPoint.value);
                            stopStorePhi.pushValue(stopPoint.store);
                        });
                        stop = new Stop(stopRegion, stopStorePhi, stopValuePhi);
                    } else {
                        stop = new Stop(this.stopPoints[0].region, this.stopPoints[0].store, this.stopPoints[0].value);
                    }

                    return new Compiler.IR.DFG(stop);
                };

                Builder.prototype.buildBlock = function (region, block, state) {
                    release || assert(region && block && state);
                    state.optimize();
                    var typeState = block.verifierEntryState;
                    if (typeState) {
                        this.traceBuilder && writer.writeLn("Type State: " + typeState);
                        for (var i = 0; i < typeState.local.length; i++) {
                            var type = typeState.local[i];
                            var local = state.local[i];
                            if (local.ty) {
                                // release || assert (type.isSubtypeOf(local.ty), local + " " + local.ty + " !== " + type + " " + type.merge(local.ty));
                            } else {
                                local.ty = type;
                            }
                        }
                    }

                    var blockBuilder = new BlockBuilder(this, region, block, state);
                    blockBuilder.build();

                    var stops = blockBuilder.stops;
                    if (!stops) {
                        stops = [];
                        if (blockBuilder.bc.position + 1 <= this.bytecodes.length) {
                            stops.push({
                                control: region,
                                target: this.bytecodes[blockBuilder.bc.position + 1],
                                state: state
                            });
                        }
                    }

                    return stops;
                };

                Builder.buildMethod = function (verifier, methodInfo, scope, hasDynamicScope) {
                    release || assert(scope);
                    release || assert(methodInfo.analysis);
                    release || assert(!methodInfo.hasExceptions());

                    AVM2.countTimeline("Compiler: Compiled Methods");

                    AVM2.enterTimeline("Compiler");
                    AVM2.enterTimeline("Mark Loops");
                    methodInfo.analysis.markLoops();
                    AVM2.leaveTimeline();

                    if (Shumway.AVM2.Verifier.enabled.value) {
                        // TODO: Can we verify even if |hadDynamicScope| is |true|?
                        AVM2.enterTimeline("Verify");
                        verifier.verifyMethod(methodInfo, scope);
                        AVM2.leaveTimeline();
                    }

                    var traceSource = Shumway.AVM2.Compiler.traceLevel.value > 0;
                    var traceIR = Shumway.AVM2.Compiler.traceLevel.value > 1;

                    AVM2.enterTimeline("Build IR");
                    Node.startNumbering();
                    var dfg = new Builder(methodInfo, scope, hasDynamicScope).buildGraph();
                    AVM2.leaveTimeline();

                    traceIR && dfg.trace(writer);

                    AVM2.enterTimeline("Build CFG");
                    var cfg = dfg.buildCFG();
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Optimize Phis");
                    cfg.optimizePhis();
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Schedule Nodes");
                    cfg.scheduleEarly();
                    AVM2.leaveTimeline();

                    traceIR && cfg.trace(writer);

                    AVM2.enterTimeline("Verify IR");
                    cfg.verify();
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Allocate Variables");
                    cfg.allocateVariables();
                    AVM2.leaveTimeline();

                    AVM2.enterTimeline("Generate Source");
                    var result = Shumway.AVM2.Compiler.Backend.generate(cfg);
                    AVM2.leaveTimeline();
                    traceSource && writer.writeLn(result.body);
                    Node.stopNumbering();
                    AVM2.leaveTimeline();

                    return result;
                };
                return Builder;
            })();

            var verifier = new Shumway.AVM2.Verifier.Verifier();
            function compileMethod(methodInfo, scope, hasDynamicScope) {
                return Builder.buildMethod(verifier, methodInfo, scope, hasDynamicScope);
            }
            Compiler.compileMethod = compileMethod;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/**
* Examples:
*
* Compiling individual player globals abcs.
*
* find ~/Workspaces/Shumway/build/playerglobal/flash -name "*.abc" | xargs js avm.js -a -verify {} >> player.as.js
*
* Compiling against a list of .abcs
*
* js avm.js -c -verify ../generated/builtin/builtin.abc ../generated/playerGlobal/playerGlobal.min.abc `find ~/Workspaces/Shumway/build/playerglobal/flash -name "*.abc"`  ~/Dropbox/shumway/games/min/MiningTruck.swf
*
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            var Scope = Shumway.AVM2.Runtime.Scope;

            var canCompile = Shumway.AVM2.Runtime.canCompile;

            var ensureFunctionIsInitialized = Shumway.AVM2.Runtime.ensureFunctionIsInitialized;
            var createCompiledFunction = Shumway.AVM2.Runtime.createCompiledFunction;
            var LazyInitializer = Shumway.AVM2.Runtime.LazyInitializer;

            /*
            * We pollute the JS global object with object constants used in compiled code.
            */
            /* OLD objectConstantName code, proabbly don't need anymore.
            var objectIDs = 0;
            var OBJECT_NAME = "Object Name";
            
            function objectConstantName(object) {
            if (object.hash) {
            return "$(" + object.hash + ")";
            } else if (object instanceof LazyInitializer) {
            return object.getName();
            }
            release || Shumway.Debug.assert(object);
            if (object.hasOwnProperty(OBJECT_NAME)) {
            return object[OBJECT_NAME];
            }
            var name, id = objectIDs++;
            if (object instanceof Global) {
            name = "$G" + id;
            } else if (object instanceof Multiname) {
            name = "$M" + id;
            } else if (object instanceof Shumway.AVM2.AS.ASClass) {
            name = "$C" + id;
            } else {
            name = "$O" + id;
            }
            Object.defineProperty(object, OBJECT_NAME, {value: name, writable: false, enumerable: false});
            jsGlobal[name] = object;
            return name;
            }
            */
            var hasUsedConstants = false;
            jsGlobal.objectConstantName = function (object) {
                if (object.hash) {
                    return "$(" + object.hash + ")";
                } else if (object instanceof LazyInitializer) {
                    return object.getName();
                } else {
                    hasUsedConstants = true;
                }
            };

            function compileAbc(abc, writer) {
                writer.enter("{");
                writer.enter("methods: {");
                for (var i = 0; i < abc.scripts.length; i++) {
                    compileScript(abc.scripts[i], writer);
                }
                writer.leave("}");
                writer.leave("}");
            }
            Compiler.compileAbc = compileAbc;

            function compileScript(script, writer) {
                var globalScope = new Scope(null, script);
                var domain = script.abc.applicationDomain;
                var closures = [];
                compileMethod(script.init, writer, globalScope, closures);
                script.traits.forEach(function (trait) {
                    if (trait.isClass()) {
                        var inheritance = [];
                        var current = trait.classInfo;
                        while (current) {
                            inheritance.unshift(current);
                            if (current.instanceInfo.superName) {
                                current = domain.findClassInfo(current.instanceInfo.superName);
                            } else {
                                break;
                            }
                        }
                        var classScope = globalScope;
                        inheritance.forEach(function (classInfo) {
                            classScope = new Scope(classScope, classInfo);
                        });
                        compileClass(trait.classInfo, writer, classScope, closures);
                    } else if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                        compileTrait(trait, writer, globalScope, closures);
                    }
                });
                closures.forEach(function (closure) {
                    compileMethod(closure.methodInfo, writer, closure.scope, null, true);
                });
            }

            function compileMethod(methodInfo, writer, scope, closures, hasDynamicScope) {
                if (typeof hasDynamicScope === "undefined") { hasDynamicScope = false; }
                if (canCompile(methodInfo)) {
                    ensureFunctionIsInitialized(methodInfo);
                    try  {
                        hasUsedConstants = false;
                        var method = createCompiledFunction(methodInfo, scope, hasDynamicScope, false, false);
                        writer.enter(methodInfo.index + ": ");
                        if (!hasUsedConstants) {
                            writer.writeLns(method.toSource());
                        } else {
                            // writer.writeLns(method.toSource());
                            // quit();
                            writer.writeLn("undefined");
                        }
                        writer.leave(",");
                        if (closures) {
                            scanMethod(methodInfo, writer, scope, closures);
                        }
                    } catch (x) {
                        writer.writeLn("// " + x);
                    }
                } else {
                    writer.writeLn("// Can't compile method: " + methodInfo.index);
                }
            }
            function scanMethod(methodInfo, writer, scope, innerMethods) {
                // writer.enter("Scanning: " + methodInfo + " {");
                var bytecodes = methodInfo.analysis.bytecodes;
                var methods = methodInfo.abc.methods;
                for (var i = 0; i < bytecodes.length; i++) {
                    var bc = bytecodes[i];

                    // writer.writeLn(bc);
                    if (bc.op === 64 /* newfunction */) {
                        var innerMethodInfo = methods[bc.index];
                        ensureFunctionIsInitialized(innerMethodInfo);
                        var innerScope = new Scope(scope, methodInfo);
                        innerMethods.push({
                            scope: innerScope,
                            methodInfo: innerMethodInfo
                        });
                        scanMethod(innerMethodInfo, writer, innerScope, innerMethods);
                    }
                }
                // writer.leave("}");
            }

            function compileTrait(trait, writer, scope, closures) {
                if (trait.isMethod() || trait.isGetter() || trait.isSetter()) {
                    if (trait.methodInfo.hasBody) {
                        writer.writeLn("// " + trait);
                        compileMethod(trait.methodInfo, writer, scope, closures);
                    }
                }
            }

            function compileTraits(traits, writer, scope, closures) {
                traits.forEach(function (trait) {
                    compileTrait(trait, writer, scope, closures);
                });
            }

            function compileClass(classInfo, writer, scope, closures) {
                compileMethod(classInfo.init, writer, scope, closures);
                compileTraits(classInfo.traits, writer, scope, closures);
                compileMethod(classInfo.instanceInfo.init, writer, scope, closures);
                compileTraits(classInfo.instanceInfo.traits, writer, scope, closures);
            }
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            /**
            * Like most JITs we don't need all the fancy AST serialization, this
            * is a quick and dirty AST writer.
            */
            (function (AST) {
                var notImplemented = Shumway.Debug.notImplemented;

                // The top part of this file is copied from escodegen.
                var json = false;
                var escapeless = false;
                var hexadecimal = false;
                var renumber = false;
                var quotes = "double";

                function stringToArray(str) {
                    var length = str.length, result = [], i;
                    for (i = 0; i < length; ++i) {
                        result[i] = str.charAt(i);
                    }
                    return result;
                }

                function escapeAllowedCharacter(ch, next) {
                    var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\';

                    switch (ch) {
                        case '\b':
                            result += 'b';
                            break;
                        case '\f':
                            result += 'f';
                            break;
                        case '\t':
                            result += 't';
                            break;
                        default:
                            if (json || code > 0xff) {
                                result += 'u' + '0000'.slice(hex.length) + hex;
                            } else if (ch === '\u0000' && '0123456789'.indexOf(next) < 0) {
                                result += '0';
                            } else if (ch === '\x0B') {
                                result += 'x0B';
                            } else {
                                result += 'x' + '00'.slice(hex.length) + hex;
                            }
                            break;
                    }

                    return result;
                }

                function escapeDisallowedCharacter(ch) {
                    var result = '\\';
                    switch (ch) {
                        case '\\':
                            result += '\\';
                            break;
                        case '\n':
                            result += 'n';
                            break;
                        case '\r':
                            result += 'r';
                            break;
                        case '\u2028':
                            result += 'u2028';
                            break;
                        case '\u2029':
                            result += 'u2029';
                            break;
                        default:
                            throw new Error('Incorrectly classified character');
                    }

                    return result;
                }

                var escapeStringCacheCount = 0;
                var escapeStringCache = Object.create(null);

                function escapeString(str) {
                    var result, i, len, ch, singleQuotes = 0, doubleQuotes = 0, single, original = str;
                    result = escapeStringCache[original];
                    if (result) {
                        return result;
                    }
                    if (escapeStringCacheCount === 1024) {
                        escapeStringCache = Object.create(null);
                        escapeStringCacheCount = 0;
                    }
                    result = '';

                    if (typeof str[0] === 'undefined') {
                        str = stringToArray(str);
                    }

                    for (i = 0, len = str.length; i < len; ++i) {
                        ch = str[i];
                        if (ch === '\'') {
                            ++singleQuotes;
                        } else if (ch === '"') {
                            ++doubleQuotes;
                        } else if (ch === '/' && json) {
                            result += '\\';
                        } else if ('\\\n\r\u2028\u2029'.indexOf(ch) >= 0) {
                            result += escapeDisallowedCharacter(ch);
                            continue;
                        } else if ((json && ch < ' ') || !(json || escapeless || (ch >= ' ' && ch <= '~'))) {
                            result += escapeAllowedCharacter(ch, str[i + 1]);
                            continue;
                        }
                        result += ch;
                    }

                    single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
                    str = result;
                    result = single ? '\'' : '"';

                    if (typeof str[0] === 'undefined') {
                        str = stringToArray(str);
                    }

                    for (i = 0, len = str.length; i < len; ++i) {
                        ch = str[i];
                        if ((ch === '\'' && single) || (ch === '"' && !single)) {
                            result += '\\';
                        }
                        result += ch;
                    }

                    result += (single ? '\'' : '"');
                    escapeStringCache[original] = result;
                    escapeStringCacheCount++;
                    return result;
                }

                var generateNumberCacheCount = 0;
                var generateNumberCache = Object.create(null);

                function generateNumber(value) {
                    var result, point, temp, exponent, pos;

                    if (value !== value) {
                        throw new Error('Numeric literal whose value is NaN');
                    }
                    if (value < 0 || (value === 0 && 1 / value < 0)) {
                        throw new Error('Numeric literal whose value is negative');
                    }

                    if (value === 1 / 0) {
                        return json ? 'null' : renumber ? '1e400' : '1e+400';
                    }

                    result = generateNumberCache[value];
                    if (result) {
                        return result;
                    }
                    if (generateNumberCacheCount === 1024) {
                        generateNumberCache = Object.create(null);
                        generateNumberCacheCount = 0;
                    }
                    result = '' + value;
                    if (!renumber || result.length < 3) {
                        generateNumberCache[value] = result;
                        generateNumberCacheCount++;
                        return result;
                    }

                    point = result.indexOf('.');
                    if (!json && result.charAt(0) === '0' && point === 1) {
                        point = 0;
                        result = result.slice(1);
                    }
                    temp = result;
                    result = result.replace('e+', 'e');
                    exponent = 0;
                    if ((pos = temp.indexOf('e')) > 0) {
                        exponent = +temp.slice(pos + 1);
                        temp = temp.slice(0, pos);
                    }
                    if (point >= 0) {
                        exponent -= temp.length - point - 1;
                        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
                    }
                    pos = 0;
                    while (temp.charAt(temp.length + pos - 1) === '0') {
                        --pos;
                    }
                    if (pos !== 0) {
                        exponent -= pos;
                        temp = temp.slice(0, pos);
                    }
                    if (exponent !== 0) {
                        temp += 'e' + exponent;
                    }
                    if ((temp.length < result.length || (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) && +temp === value) {
                        result = temp;
                    }
                    generateNumberCache[value] = result;
                    generateNumberCacheCount++;
                    return result;
                }

                var Precedence = {
                    Default: 0,
                    Sequence: 0,
                    Assignment: 1,
                    Conditional: 2,
                    ArrowFunction: 2,
                    LogicalOR: 3,
                    LogicalAND: 4,
                    BitwiseOR: 5,
                    BitwiseXOR: 6,
                    BitwiseAND: 7,
                    Equality: 8,
                    Relational: 9,
                    BitwiseSHIFT: 10,
                    Additive: 11,
                    Multiplicative: 12,
                    Unary: 13,
                    Postfix: 14,
                    Call: 15,
                    New: 16,
                    Member: 17,
                    Primary: 18
                };

                var BinaryPrecedence = {
                    '||': Precedence.LogicalOR,
                    '&&': Precedence.LogicalAND,
                    '|': Precedence.BitwiseOR,
                    '^': Precedence.BitwiseXOR,
                    '&': Precedence.BitwiseAND,
                    '==': Precedence.Equality,
                    '!=': Precedence.Equality,
                    '===': Precedence.Equality,
                    '!==': Precedence.Equality,
                    'is': Precedence.Equality,
                    'isnt': Precedence.Equality,
                    '<': Precedence.Relational,
                    '>': Precedence.Relational,
                    '<=': Precedence.Relational,
                    '>=': Precedence.Relational,
                    'in': Precedence.Relational,
                    'instanceof': Precedence.Relational,
                    '<<': Precedence.BitwiseSHIFT,
                    '>>': Precedence.BitwiseSHIFT,
                    '>>>': Precedence.BitwiseSHIFT,
                    '+': Precedence.Additive,
                    '-': Precedence.Additive,
                    '*': Precedence.Multiplicative,
                    '%': Precedence.Multiplicative,
                    '/': Precedence.Multiplicative
                };

                function toLiteralSource(value) {
                    if (value === null) {
                        return 'null';
                    }
                    if (typeof value === 'string') {
                        return escapeString(value);
                    }
                    if (typeof value === 'number') {
                        return generateNumber(value);
                    }
                    if (typeof value === 'boolean') {
                        return value ? 'true' : 'false';
                    }
                    notImplemented(value);
                }

                function nodesToSource(nodes, precedence, separator) {
                    var result = "";
                    for (var i = 0; i < nodes.length; i++) {
                        result += nodes[i].toSource(precedence);
                        if (separator && (i < nodes.length - 1)) {
                            result += separator;
                        }
                    }
                    return result;
                }

                function alwaysParenthesize(text) {
                    return '(' + text + ')';
                }

                function parenthesize(text, current, should) {
                    if (current < should) {
                        return '(' + text + ')';
                    }
                    return text;
                }

                var Node = (function () {
                    function Node() {
                    }
                    Node.prototype.toSource = function (precedence) {
                        notImplemented(this.type);
                        return "";
                    };
                    return Node;
                })();
                AST.Node = Node;

                var Statement = (function (_super) {
                    __extends(Statement, _super);
                    function Statement() {
                        _super.apply(this, arguments);
                    }
                    return Statement;
                })(Node);
                AST.Statement = Statement;

                var Expression = (function (_super) {
                    __extends(Expression, _super);
                    function Expression() {
                        _super.apply(this, arguments);
                    }
                    return Expression;
                })(Node);
                AST.Expression = Expression;

                var Program = (function (_super) {
                    __extends(Program, _super);
                    function Program(body) {
                        _super.call(this);
                        this.body = body;
                    }
                    return Program;
                })(Node);
                AST.Program = Program;

                var EmptyStatement = (function (_super) {
                    __extends(EmptyStatement, _super);
                    function EmptyStatement() {
                        _super.apply(this, arguments);
                    }
                    return EmptyStatement;
                })(Statement);
                AST.EmptyStatement = EmptyStatement;

                var BlockStatement = (function (_super) {
                    __extends(BlockStatement, _super);
                    function BlockStatement(body) {
                        _super.call(this);
                        this.body = body;
                    }
                    BlockStatement.prototype.toSource = function (precedence) {
                        return "{\n" + nodesToSource(this.body, precedence) + "}";
                    };
                    return BlockStatement;
                })(Statement);
                AST.BlockStatement = BlockStatement;

                var ExpressionStatement = (function (_super) {
                    __extends(ExpressionStatement, _super);
                    function ExpressionStatement(expression) {
                        _super.call(this);
                        this.expression = expression;
                    }
                    ExpressionStatement.prototype.toSource = function (precedence) {
                        return this.expression.toSource(Precedence.Sequence) + ";\n";
                    };
                    return ExpressionStatement;
                })(Statement);
                AST.ExpressionStatement = ExpressionStatement;

                var IfStatement = (function (_super) {
                    __extends(IfStatement, _super);
                    function IfStatement(test, consequent, alternate) {
                        _super.call(this);
                        this.test = test;
                        this.consequent = consequent;
                        this.alternate = alternate;
                    }
                    IfStatement.prototype.toSource = function (precedence) {
                        var result = "if(" + this.test.toSource(Precedence.Sequence) + "){" + this.consequent.toSource(Precedence.Sequence) + "}";
                        if (this.alternate) {
                            result += "else{" + this.alternate.toSource(Precedence.Sequence) + "}";
                        }
                        return result;
                    };
                    return IfStatement;
                })(Statement);
                AST.IfStatement = IfStatement;

                var LabeledStatement = (function (_super) {
                    __extends(LabeledStatement, _super);
                    function LabeledStatement(label, body) {
                        _super.call(this);
                        this.label = label;
                        this.body = body;
                    }
                    return LabeledStatement;
                })(Statement);
                AST.LabeledStatement = LabeledStatement;

                var BreakStatement = (function (_super) {
                    __extends(BreakStatement, _super);
                    function BreakStatement(label) {
                        _super.call(this);
                        this.label = label;
                    }
                    BreakStatement.prototype.toSource = function (precedence) {
                        var result = "break";
                        if (this.label) {
                            result += " " + this.label.toSource(Precedence.Default);
                        }
                        return result + ";";
                    };
                    return BreakStatement;
                })(Statement);
                AST.BreakStatement = BreakStatement;

                var ContinueStatement = (function (_super) {
                    __extends(ContinueStatement, _super);
                    function ContinueStatement(label) {
                        _super.call(this);
                        this.label = label;
                    }
                    ContinueStatement.prototype.toSource = function (precedence) {
                        var result = "continue";
                        if (this.label) {
                            result += " " + this.label.toSource(Precedence.Default);
                        }
                        return result + ";";
                    };
                    return ContinueStatement;
                })(Statement);
                AST.ContinueStatement = ContinueStatement;

                var WithStatement = (function (_super) {
                    __extends(WithStatement, _super);
                    function WithStatement(object, body) {
                        _super.call(this);
                        this.object = object;
                        this.body = body;
                    }
                    return WithStatement;
                })(Statement);
                AST.WithStatement = WithStatement;

                var SwitchStatement = (function (_super) {
                    __extends(SwitchStatement, _super);
                    function SwitchStatement(discriminant, cases, lexical) {
                        _super.call(this);
                        this.discriminant = discriminant;
                        this.cases = cases;
                        this.lexical = lexical;
                    }
                    SwitchStatement.prototype.toSource = function (precedence) {
                        return "switch(" + this.discriminant.toSource(Precedence.Sequence) + "){" + nodesToSource(this.cases, Precedence.Default, ";") + "};";
                    };
                    return SwitchStatement;
                })(Statement);
                AST.SwitchStatement = SwitchStatement;

                var ReturnStatement = (function (_super) {
                    __extends(ReturnStatement, _super);
                    function ReturnStatement(argument) {
                        _super.call(this);
                        this.argument = argument;
                    }
                    ReturnStatement.prototype.toSource = function (precedence) {
                        var result = "return ";
                        if (this.argument) {
                            result += this.argument.toSource(Precedence.Sequence);
                        }
                        return result + ";\n";
                    };
                    return ReturnStatement;
                })(Statement);
                AST.ReturnStatement = ReturnStatement;

                var ThrowStatement = (function (_super) {
                    __extends(ThrowStatement, _super);
                    function ThrowStatement(argument) {
                        _super.call(this);
                        this.argument = argument;
                    }
                    ThrowStatement.prototype.toSource = function (precedence) {
                        return "throw " + this.argument.toSource(Precedence.Sequence) + ";\n";
                    };
                    return ThrowStatement;
                })(Statement);
                AST.ThrowStatement = ThrowStatement;

                var TryStatement = (function (_super) {
                    __extends(TryStatement, _super);
                    function TryStatement(block, handlers, guardedHandlers, finalizer) {
                        _super.call(this);
                        this.block = block;
                        this.handlers = handlers;
                        this.guardedHandlers = guardedHandlers;
                        this.finalizer = finalizer;
                    }
                    return TryStatement;
                })(Statement);
                AST.TryStatement = TryStatement;

                var WhileStatement = (function (_super) {
                    __extends(WhileStatement, _super);
                    function WhileStatement(test, body) {
                        _super.call(this);
                        this.test = test;
                        this.body = body;
                    }
                    WhileStatement.prototype.toSource = function (precedence) {
                        return "while(" + this.test.toSource(Precedence.Sequence) + "){" + this.body.toSource(Precedence.Sequence) + "}";
                    };
                    return WhileStatement;
                })(Statement);
                AST.WhileStatement = WhileStatement;

                var DoWhileStatement = (function (_super) {
                    __extends(DoWhileStatement, _super);
                    function DoWhileStatement(body, test) {
                        _super.call(this);
                        this.body = body;
                        this.test = test;
                    }
                    return DoWhileStatement;
                })(Statement);
                AST.DoWhileStatement = DoWhileStatement;

                var ForStatement = (function (_super) {
                    __extends(ForStatement, _super);
                    function ForStatement(init, test, update, body) {
                        _super.call(this);
                        this.init = init;
                        this.test = test;
                        this.update = update;
                        this.body = body;
                    }
                    return ForStatement;
                })(Statement);
                AST.ForStatement = ForStatement;

                var ForInStatement = (function (_super) {
                    __extends(ForInStatement, _super);
                    function ForInStatement(left, right, body, each) {
                        _super.call(this);
                        this.left = left;
                        this.right = right;
                        this.body = body;
                        this.each = each;
                    }
                    return ForInStatement;
                })(Statement);
                AST.ForInStatement = ForInStatement;

                var DebuggerStatement = (function (_super) {
                    __extends(DebuggerStatement, _super);
                    function DebuggerStatement() {
                        _super.apply(this, arguments);
                    }
                    return DebuggerStatement;
                })(Statement);
                AST.DebuggerStatement = DebuggerStatement;

                var Declaration = (function (_super) {
                    __extends(Declaration, _super);
                    function Declaration() {
                        _super.apply(this, arguments);
                    }
                    return Declaration;
                })(Statement);
                AST.Declaration = Declaration;

                var FunctionDeclaration = (function (_super) {
                    __extends(FunctionDeclaration, _super);
                    function FunctionDeclaration(id, params, defaults, rest, body, generator, expression) {
                        _super.call(this);
                        this.id = id;
                        this.params = params;
                        this.defaults = defaults;
                        this.rest = rest;
                        this.body = body;
                        this.generator = generator;
                        this.expression = expression;
                    }
                    return FunctionDeclaration;
                })(Declaration);
                AST.FunctionDeclaration = FunctionDeclaration;

                var VariableDeclaration = (function (_super) {
                    __extends(VariableDeclaration, _super);
                    function VariableDeclaration(declarations, kind) {
                        _super.call(this);
                        this.declarations = declarations;
                        this.kind = kind;
                    }
                    VariableDeclaration.prototype.toSource = function (precedence) {
                        return this.kind + " " + nodesToSource(this.declarations, precedence, ",") + ";\n";
                    };
                    return VariableDeclaration;
                })(Declaration);
                AST.VariableDeclaration = VariableDeclaration;

                var VariableDeclarator = (function (_super) {
                    __extends(VariableDeclarator, _super);
                    function VariableDeclarator(id, init) {
                        _super.call(this);
                        this.id = id;
                        this.init = init;
                    }
                    VariableDeclarator.prototype.toSource = function (precedence) {
                        var result = this.id.toSource(Precedence.Assignment);
                        if (this.init) {
                            result += "=" + this.init.toSource(Precedence.Assignment);
                        }
                        return result;
                    };
                    return VariableDeclarator;
                })(Node);
                AST.VariableDeclarator = VariableDeclarator;

                var Identifier = (function (_super) {
                    __extends(Identifier, _super);
                    function Identifier(name) {
                        _super.call(this);
                        this.name = name;
                    }
                    Identifier.prototype.toSource = function (precedence) {
                        return this.name;
                    };
                    return Identifier;
                })(Expression);
                AST.Identifier = Identifier;

                var Literal = (function (_super) {
                    __extends(Literal, _super);
                    function Literal(value) {
                        _super.call(this);
                        this.value = value;
                    }
                    Literal.prototype.toSource = function (precedence) {
                        return toLiteralSource(this.value);
                    };
                    return Literal;
                })(Expression);
                AST.Literal = Literal;

                var ThisExpression = (function (_super) {
                    __extends(ThisExpression, _super);
                    function ThisExpression() {
                        _super.apply(this, arguments);
                    }
                    ThisExpression.prototype.toSource = function (precedence) {
                        return "this";
                    };
                    return ThisExpression;
                })(Expression);
                AST.ThisExpression = ThisExpression;

                var ArrayExpression = (function (_super) {
                    __extends(ArrayExpression, _super);
                    function ArrayExpression(elements) {
                        _super.call(this);
                        this.elements = elements;
                    }
                    ArrayExpression.prototype.toSource = function (precedence) {
                        return "[" + nodesToSource(this.elements, Precedence.Assignment, ",") + "]";
                    };
                    return ArrayExpression;
                })(Expression);
                AST.ArrayExpression = ArrayExpression;

                var ObjectExpression = (function (_super) {
                    __extends(ObjectExpression, _super);
                    function ObjectExpression(properties) {
                        _super.call(this);
                        this.properties = properties;
                    }
                    ObjectExpression.prototype.toSource = function (precedence) {
                        return "{" + nodesToSource(this.properties, Precedence.Sequence, ",") + "}";
                    };
                    return ObjectExpression;
                })(Expression);
                AST.ObjectExpression = ObjectExpression;

                var FunctionExpression = (function (_super) {
                    __extends(FunctionExpression, _super);
                    function FunctionExpression(id, params, defaults, rest, body, generator, expression) {
                        _super.call(this);
                        this.id = id;
                        this.params = params;
                        this.defaults = defaults;
                        this.rest = rest;
                        this.body = body;
                        this.generator = generator;
                        this.expression = expression;
                    }
                    return FunctionExpression;
                })(Expression);
                AST.FunctionExpression = FunctionExpression;

                var SequenceExpression = (function (_super) {
                    __extends(SequenceExpression, _super);
                    function SequenceExpression(expressions) {
                        _super.call(this);
                        this.expressions = expressions;
                    }
                    return SequenceExpression;
                })(Expression);
                AST.SequenceExpression = SequenceExpression;

                var UnaryExpression = (function (_super) {
                    __extends(UnaryExpression, _super);
                    function UnaryExpression(operator, prefix, argument) {
                        _super.call(this);
                        this.operator = operator;
                        this.prefix = prefix;
                        this.argument = argument;
                    }
                    UnaryExpression.prototype.toSource = function (precedence) {
                        var argument = this.argument.toSource(Precedence.Unary);
                        var result = this.prefix ? this.operator + argument : argument + this.operator;
                        result = " " + result;
                        result = parenthesize(result, Precedence.Unary, precedence);
                        return result;
                    };
                    return UnaryExpression;
                })(Expression);
                AST.UnaryExpression = UnaryExpression;

                var BinaryExpression = (function (_super) {
                    __extends(BinaryExpression, _super);
                    function BinaryExpression(operator, left, right) {
                        _super.call(this);
                        this.operator = operator;
                        this.left = left;
                        this.right = right;
                    }
                    BinaryExpression.prototype.toSource = function (precedence) {
                        var currentPrecedence = BinaryPrecedence[this.operator];
                        var result = this.left.toSource(currentPrecedence) + this.operator + this.right.toSource(currentPrecedence + 1);
                        return parenthesize(result, currentPrecedence, precedence);
                    };
                    return BinaryExpression;
                })(Expression);
                AST.BinaryExpression = BinaryExpression;

                var AssignmentExpression = (function (_super) {
                    __extends(AssignmentExpression, _super);
                    function AssignmentExpression(operator, left, right) {
                        _super.call(this);
                        this.operator = operator;
                        this.left = left;
                        this.right = right;
                    }
                    AssignmentExpression.prototype.toSource = function (precedence) {
                        var result = this.left.toSource(Precedence.Assignment) + this.operator + this.right.toSource(Precedence.Assignment);
                        return parenthesize(result, Precedence.Assignment, precedence);
                    };
                    return AssignmentExpression;
                })(Expression);
                AST.AssignmentExpression = AssignmentExpression;

                var UpdateExpression = (function (_super) {
                    __extends(UpdateExpression, _super);
                    function UpdateExpression(operator, argument, prefix) {
                        _super.call(this);
                        this.operator = operator;
                        this.argument = argument;
                        this.prefix = prefix;
                    }
                    return UpdateExpression;
                })(Expression);
                AST.UpdateExpression = UpdateExpression;

                var LogicalExpression = (function (_super) {
                    __extends(LogicalExpression, _super);
                    function LogicalExpression(operator, left, right) {
                        _super.call(this, operator, left, right);
                    }
                    return LogicalExpression;
                })(BinaryExpression);
                AST.LogicalExpression = LogicalExpression;

                var ConditionalExpression = (function (_super) {
                    __extends(ConditionalExpression, _super);
                    function ConditionalExpression(test, consequent, alternate) {
                        _super.call(this);
                        this.test = test;
                        this.consequent = consequent;
                        this.alternate = alternate;
                    }
                    ConditionalExpression.prototype.toSource = function (precedence) {
                        return this.test.toSource(Precedence.LogicalOR) + "?" + this.consequent.toSource(Precedence.Assignment) + ":" + this.alternate.toSource(Precedence.Assignment);
                    };
                    return ConditionalExpression;
                })(Expression);
                AST.ConditionalExpression = ConditionalExpression;

                var NewExpression = (function (_super) {
                    __extends(NewExpression, _super);
                    function NewExpression(callee, _arguments) {
                        _super.call(this);
                        this.callee = callee;
                        this.arguments = _arguments;
                    }
                    NewExpression.prototype.toSource = function (precedence) {
                        return "new " + this.callee.toSource(precedence) + "(" + nodesToSource(this.arguments, precedence, ",") + ")";
                    };
                    return NewExpression;
                })(Expression);
                AST.NewExpression = NewExpression;

                var CallExpression = (function (_super) {
                    __extends(CallExpression, _super);
                    function CallExpression(callee, _arguments) {
                        _super.call(this);
                        this.callee = callee;
                        this.arguments = _arguments;
                    }
                    CallExpression.prototype.toSource = function (precedence) {
                        return this.callee.toSource(precedence) + "(" + nodesToSource(this.arguments, precedence, ",") + ")";
                    };
                    return CallExpression;
                })(Expression);
                AST.CallExpression = CallExpression;

                var MemberExpression = (function (_super) {
                    __extends(MemberExpression, _super);
                    function MemberExpression(object, property, computed) {
                        _super.call(this);
                        this.object = object;
                        this.property = property;
                        this.computed = computed;
                    }
                    MemberExpression.prototype.toSource = function (precedence) {
                        var result = this.object.toSource(Precedence.Call);
                        if (this.object instanceof Literal) {
                            result = alwaysParenthesize(result);
                        }
                        var property = this.property.toSource(Precedence.Sequence);
                        if (this.computed) {
                            result += "[" + property + "]";
                        } else {
                            result += "." + property;
                        }
                        return parenthesize(result, Precedence.Member, precedence);
                    };
                    return MemberExpression;
                })(Expression);
                AST.MemberExpression = MemberExpression;

                var Property = (function (_super) {
                    __extends(Property, _super);
                    function Property(key, value, kind) {
                        _super.call(this);
                        this.key = key;
                        this.value = value;
                        this.kind = kind;
                    }
                    Property.prototype.toSource = function (precedence) {
                        return this.key.toSource(precedence) + ":" + this.value.toSource(precedence);
                    };
                    return Property;
                })(Node);
                AST.Property = Property;

                var SwitchCase = (function (_super) {
                    __extends(SwitchCase, _super);
                    function SwitchCase(test, consequent) {
                        _super.call(this);
                        this.test = test;
                        this.consequent = consequent;
                    }
                    SwitchCase.prototype.toSource = function (precedence) {
                        var result = this.test ? "case " + this.test.toSource(precedence) : "default";
                        return result + ": " + nodesToSource(this.consequent, precedence, ";");
                    };
                    return SwitchCase;
                })(Node);
                AST.SwitchCase = SwitchCase;

                var CatchClause = (function (_super) {
                    __extends(CatchClause, _super);
                    function CatchClause(param, guard, body) {
                        _super.call(this);
                        this.param = param;
                        this.guard = guard;
                        this.body = body;
                    }
                    return CatchClause;
                })(Node);
                AST.CatchClause = CatchClause;

                Node.prototype.type = "Node";
                Program.prototype.type = "Program";
                Statement.prototype.type = "Statement";
                EmptyStatement.prototype.type = "EmptyStatement";
                BlockStatement.prototype.type = "BlockStatement";
                ExpressionStatement.prototype.type = "ExpressionStatement";
                IfStatement.prototype.type = "IfStatement";
                LabeledStatement.prototype.type = "LabeledStatement";
                BreakStatement.prototype.type = "BreakStatement";
                ContinueStatement.prototype.type = "ContinueStatement";
                WithStatement.prototype.type = "WithStatement";
                SwitchStatement.prototype.type = "SwitchStatement";
                ReturnStatement.prototype.type = "ReturnStatement";
                ThrowStatement.prototype.type = "ThrowStatement";
                TryStatement.prototype.type = "TryStatement";
                WhileStatement.prototype.type = "WhileStatement";
                DoWhileStatement.prototype.type = "DoWhileStatement";
                ForStatement.prototype.type = "ForStatement";
                ForInStatement.prototype.type = "ForInStatement";
                DebuggerStatement.prototype.type = "DebuggerStatement";
                Declaration.prototype.type = "Declaration";
                FunctionDeclaration.prototype.type = "FunctionDeclaration";
                VariableDeclaration.prototype.type = "VariableDeclaration";
                VariableDeclarator.prototype.type = "VariableDeclarator";
                Expression.prototype.type = "Expression";
                Identifier.prototype.type = "Identifier";
                Literal.prototype.type = "Literal";
                ThisExpression.prototype.type = "ThisExpression";
                ArrayExpression.prototype.type = "ArrayExpression";
                ObjectExpression.prototype.type = "ObjectExpression";
                FunctionExpression.prototype.type = "FunctionExpression";
                SequenceExpression.prototype.type = "SequenceExpression";
                UnaryExpression.prototype.type = "UnaryExpression";
                BinaryExpression.prototype.type = "BinaryExpression";
                AssignmentExpression.prototype.type = "AssignmentExpression";
                UpdateExpression.prototype.type = "UpdateExpression";
                LogicalExpression.prototype.type = "LogicalExpression";
                ConditionalExpression.prototype.type = "ConditionalExpression";
                NewExpression.prototype.type = "NewExpression";
                CallExpression.prototype.type = "CallExpression";
                MemberExpression.prototype.type = "MemberExpression";
                Property.prototype.type = "Property";
                SwitchCase.prototype.type = "SwitchCase";
                CatchClause.prototype.type = "CatchClause";
            })(Compiler.AST || (Compiler.AST = {}));
            var AST = Compiler.AST;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            (function (IR) {
                var ASScope = (function (_super) {
                    __extends(ASScope, _super);
                    function ASScope(parent, object, isWith) {
                        _super.call(this);
                        this.parent = parent;
                        this.object = object;
                        this.isWith = isWith;
                    }
                    ASScope.prototype.visitInputs = function (visitor) {
                        visitor(this.parent);
                        visitor(this.object);
                    };
                    return ASScope;
                })(IR.Value);
                IR.ASScope = ASScope;
                ASScope.prototype.nodeName = "ASScope";

                var ASMultiname = (function (_super) {
                    __extends(ASMultiname, _super);
                    function ASMultiname(namespaces, name, flags) {
                        _super.call(this);
                        this.namespaces = namespaces;
                        this.name = name;
                        this.flags = flags;
                    }
                    ASMultiname.prototype.visitInputs = function (visitor) {
                        visitor(this.namespaces);
                        visitor(this.name);
                    };
                    return ASMultiname;
                })(IR.Value);
                IR.ASMultiname = ASMultiname;
                ASMultiname.prototype.mustFloat = true;
                ASMultiname.prototype.nodeName = "ASMultiname";

                var ASCallProperty = (function (_super) {
                    __extends(ASCallProperty, _super);
                    function ASCallProperty(control, store, object, name, args, flags, isLex) {
                        _super.call(this, control, store, object, name, args, flags);
                        this.isLex = isLex;
                    }
                    return ASCallProperty;
                })(IR.CallProperty);
                IR.ASCallProperty = ASCallProperty;
                ASCallProperty.prototype.nodeName = "ASCallProperty";

                var ASCallSuper = (function (_super) {
                    __extends(ASCallSuper, _super);
                    function ASCallSuper(control, store, object, name, args, flags, scope) {
                        _super.call(this, control, store, object, name, args, flags);
                        this.scope = scope;
                    }
                    ASCallSuper.prototype.visitInputs = function (visitor) {
                        _super.prototype.visitInputs.call(this, visitor);
                        visitor(this.scope);
                    };
                    return ASCallSuper;
                })(IR.CallProperty);
                IR.ASCallSuper = ASCallSuper;
                ASCallSuper.prototype.nodeName = "ASCallSuper";

                var ASNew = (function (_super) {
                    __extends(ASNew, _super);
                    function ASNew(control, store, callee, args) {
                        _super.call(this, control, store, callee, args);
                    }
                    return ASNew;
                })(IR.New);
                IR.ASNew = ASNew;
                ASNew.prototype.nodeName = "ASNew";

                var ASGetProperty = (function (_super) {
                    __extends(ASGetProperty, _super);
                    function ASGetProperty(control, store, object, name, flags) {
                        _super.call(this, control, store, object, name);
                        this.flags = flags;
                    }
                    return ASGetProperty;
                })(IR.GetProperty);
                IR.ASGetProperty = ASGetProperty;

                ASGetProperty.prototype.nodeName = "ASGetProperty";

                var ASGetDescendants = (function (_super) {
                    __extends(ASGetDescendants, _super);
                    function ASGetDescendants(control, store, object, name) {
                        _super.call(this, control, store, object, name);
                    }
                    return ASGetDescendants;
                })(IR.GetProperty);
                IR.ASGetDescendants = ASGetDescendants;
                ASGetDescendants.prototype.nodeName = "ASGetDescendants";

                var ASHasProperty = (function (_super) {
                    __extends(ASHasProperty, _super);
                    function ASHasProperty(control, store, object, name) {
                        _super.call(this, control, store, object, name);
                    }
                    return ASHasProperty;
                })(IR.GetProperty);
                IR.ASHasProperty = ASHasProperty;
                ASHasProperty.prototype.nodeName = "ASHasProperty";

                var ASGetSlot = (function (_super) {
                    __extends(ASGetSlot, _super);
                    function ASGetSlot(control, store, object, name) {
                        _super.call(this, control, store, object, name);
                    }
                    return ASGetSlot;
                })(IR.GetProperty);
                IR.ASGetSlot = ASGetSlot;
                ASGetSlot.prototype.nodeName = "ASGetSlot";

                var ASGetSuper = (function (_super) {
                    __extends(ASGetSuper, _super);
                    function ASGetSuper(control, store, object, name, scope) {
                        _super.call(this, control, store, object, name);
                        this.scope = scope;
                    }
                    ASGetSuper.prototype.visitInputs = function (visitor) {
                        _super.prototype.visitInputs.call(this, visitor);
                        visitor(this.scope);
                    };
                    return ASGetSuper;
                })(IR.GetProperty);
                IR.ASGetSuper = ASGetSuper;
                ASGetSuper.prototype.nodeName = "ASGetSuper";

                var ASSetProperty = (function (_super) {
                    __extends(ASSetProperty, _super);
                    function ASSetProperty(control, store, object, name, value, flags) {
                        _super.call(this, control, store, object, name, value);
                        this.flags = flags;
                    }
                    return ASSetProperty;
                })(IR.SetProperty);
                IR.ASSetProperty = ASSetProperty;
                ASSetProperty.prototype.nodeName = "ASSetProperty";

                var ASSetSlot = (function (_super) {
                    __extends(ASSetSlot, _super);
                    function ASSetSlot(control, store, object, name, value) {
                        _super.call(this, control, store, object, name, value);
                    }
                    return ASSetSlot;
                })(IR.SetProperty);
                IR.ASSetSlot = ASSetSlot;
                ASSetSlot.prototype.nodeName = "ASSetSlot";

                var ASSetSuper = (function (_super) {
                    __extends(ASSetSuper, _super);
                    function ASSetSuper(control, store, object, name, value, scope) {
                        _super.call(this, control, store, object, name, value);
                        this.scope = scope;
                    }
                    ASSetSuper.prototype.visitInputs = function (visitor) {
                        _super.prototype.visitInputs.call(this, visitor);
                        visitor(this.scope);
                    };
                    return ASSetSuper;
                })(IR.SetProperty);
                IR.ASSetSuper = ASSetSuper;
                ASSetSuper.prototype.nodeName = "ASSetSuper";

                var ASDeleteProperty = (function (_super) {
                    __extends(ASDeleteProperty, _super);
                    function ASDeleteProperty(control, store, object, name) {
                        _super.call(this, control, store, object, name);
                    }
                    return ASDeleteProperty;
                })(IR.DeleteProperty);
                IR.ASDeleteProperty = ASDeleteProperty;
                ASDeleteProperty.prototype.nodeName = "ASDeleteProperty";

                var ASFindProperty = (function (_super) {
                    __extends(ASFindProperty, _super);
                    function ASFindProperty(control, store, scope, name, methodInfo, strict) {
                        _super.call(this, control, store);
                        this.scope = scope;
                        this.name = name;
                        this.methodInfo = methodInfo;
                        this.strict = strict;
                    }
                    ASFindProperty.prototype.visitInputs = function (visitor) {
                        _super.prototype.visitInputs.call(this, visitor);
                        visitor(this.scope);
                        visitor(this.name);
                    };
                    return ASFindProperty;
                })(IR.StoreDependent);
                IR.ASFindProperty = ASFindProperty;

                ASFindProperty.prototype.nodeName = "ASFindProperty";

                var ASGlobal = (function (_super) {
                    __extends(ASGlobal, _super);
                    function ASGlobal(control, scope) {
                        _super.call(this);
                        this.control = control;
                        this.scope = scope;
                    }
                    ASGlobal.prototype.visitInputs = function (visitor) {
                        this.control && visitor(this.control);
                        visitor(this.scope);
                    };
                    return ASGlobal;
                })(IR.Value);
                IR.ASGlobal = ASGlobal;

                ASGlobal.prototype.nodeName = "ASGlobal";

                var ASNewActivation = (function (_super) {
                    __extends(ASNewActivation, _super);
                    function ASNewActivation(methodInfo) {
                        _super.call(this);
                        this.methodInfo = methodInfo;
                    }
                    return ASNewActivation;
                })(IR.Value);
                IR.ASNewActivation = ASNewActivation;

                ASNewActivation.prototype.nodeName = "ASNewActivation";

                var ASNewHasNext2 = (function (_super) {
                    __extends(ASNewHasNext2, _super);
                    function ASNewHasNext2() {
                        _super.call(this);
                    }
                    return ASNewHasNext2;
                })(IR.Value);
                IR.ASNewHasNext2 = ASNewHasNext2;

                ASNewActivation.prototype.nodeName = "ASNewHasNext2";
            })(Compiler.IR || (Compiler.IR = {}));
            var IR = Compiler.IR;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            (function (Looper) {
                var top = Shumway.ArrayUtilities.top;
                var peek = Shumway.ArrayUtilities.peek;

                var assert = Shumway.Debug.assert;

                (function (Control) {
                    (function (Kind) {
                        Kind[Kind["SEQ"] = 1] = "SEQ";
                        Kind[Kind["LOOP"] = 2] = "LOOP";
                        Kind[Kind["IF"] = 3] = "IF";
                        Kind[Kind["CASE"] = 4] = "CASE";
                        Kind[Kind["SWITCH"] = 5] = "SWITCH";
                        Kind[Kind["LABEL_CASE"] = 6] = "LABEL_CASE";
                        Kind[Kind["LABEL_SWITCH"] = 7] = "LABEL_SWITCH";
                        Kind[Kind["EXIT"] = 8] = "EXIT";
                        Kind[Kind["BREAK"] = 9] = "BREAK";
                        Kind[Kind["CONTINUE"] = 10] = "CONTINUE";
                        Kind[Kind["TRY"] = 11] = "TRY";
                        Kind[Kind["CATCH"] = 12] = "CATCH";
                    })(Control.Kind || (Control.Kind = {}));
                    var Kind = Control.Kind;

                    var ControlNode = (function () {
                        function ControlNode(kind) {
                            this.kind = kind;
                        }
                        return ControlNode;
                    })();
                    Control.ControlNode = ControlNode;

                    var Seq = (function (_super) {
                        __extends(Seq, _super);
                        function Seq(body) {
                            _super.call(this, 1 /* SEQ */);
                            this.body = body;
                        }
                        Seq.prototype.trace = function (writer) {
                            var body = this.body;
                            for (var i = 0, j = body.length; i < j; i++) {
                                body[i].trace(writer);
                            }
                        };

                        Seq.prototype.first = function () {
                            return this.body[0];
                        };

                        Seq.prototype.slice = function (begin, end) {
                            return new Seq(this.body.slice(begin, end));
                        };
                        return Seq;
                    })(ControlNode);
                    Control.Seq = Seq;

                    var Loop = (function (_super) {
                        __extends(Loop, _super);
                        function Loop(body) {
                            _super.call(this, 2 /* LOOP */);
                            this.body = body;
                        }
                        Loop.prototype.trace = function (writer) {
                            writer.enter("loop {");
                            this.body.trace(writer);
                            writer.leave("}");
                        };
                        return Loop;
                    })(ControlNode);
                    Control.Loop = Loop;

                    var If = (function (_super) {
                        __extends(If, _super);
                        function If(cond, then, els, nothingThrownLabel) {
                            _super.call(this, 3 /* IF */);
                            this.cond = cond;
                            this.then = then;
                            this.nothingThrownLabel = nothingThrownLabel;
                            this.negated = false;
                            this.else = els;
                        }
                        If.prototype.trace = function (writer) {
                            this.cond.trace(writer);
                            if (this.nothingThrownLabel) {
                                writer.enter("if (label is " + this.nothingThrownLabel + ") {");
                            }
                            writer.enter("if" + (this.negated ? " not" : "") + " {");
                            this.then && this.then.trace(writer);
                            if (this.else) {
                                writer.outdent();
                                writer.enter("} else {");
                                this.else.trace(writer);
                            }
                            writer.leave("}");
                            if (this.nothingThrownLabel) {
                                writer.leave("}");
                            }
                        };
                        return If;
                    })(ControlNode);
                    Control.If = If;

                    var Case = (function (_super) {
                        __extends(Case, _super);
                        function Case(index, body) {
                            _super.call(this, 4 /* CASE */);
                            this.index = index;
                            this.body = body;
                        }
                        Case.prototype.trace = function (writer) {
                            if (this.index >= 0) {
                                writer.writeLn("case " + this.index + ":");
                            } else {
                                writer.writeLn("default:");
                            }
                            writer.indent();
                            this.body && this.body.trace(writer);
                            writer.outdent();
                        };
                        return Case;
                    })(ControlNode);
                    Control.Case = Case;

                    var Switch = (function (_super) {
                        __extends(Switch, _super);
                        function Switch(determinant, cases, nothingThrownLabel) {
                            _super.call(this, 5 /* SWITCH */);
                            this.determinant = determinant;
                            this.cases = cases;
                            this.nothingThrownLabel = nothingThrownLabel;
                        }
                        Switch.prototype.trace = function (writer) {
                            if (this.nothingThrownLabel) {
                                writer.enter("if (label is " + this.nothingThrownLabel + ") {");
                            }
                            this.determinant.trace(writer);
                            writer.writeLn("switch {");
                            for (var i = 0, j = this.cases.length; i < j; i++) {
                                this.cases[i].trace(writer);
                            }
                            writer.writeLn("}");
                            if (this.nothingThrownLabel) {
                                writer.leave("}");
                            }
                        };
                        return Switch;
                    })(ControlNode);
                    Control.Switch = Switch;

                    var LabelCase = (function (_super) {
                        __extends(LabelCase, _super);
                        function LabelCase(labels, body) {
                            _super.call(this, 6 /* LABEL_CASE */);
                            this.labels = labels;
                            this.body = body;
                        }
                        LabelCase.prototype.trace = function (writer) {
                            writer.enter("if (label is " + this.labels.join(" or ") + ") {");
                            this.body && this.body.trace(writer);
                            writer.leave("}");
                        };
                        return LabelCase;
                    })(ControlNode);
                    Control.LabelCase = LabelCase;

                    var LabelSwitch = (function (_super) {
                        __extends(LabelSwitch, _super);
                        function LabelSwitch(cases) {
                            _super.call(this, 7 /* LABEL_SWITCH */);
                            this.cases = cases;
                            var labelMap = {};

                            for (var i = 0, j = cases.length; i < j; i++) {
                                var c = cases[i];
                                if (!c.labels) {
                                    // print(c.toSource());
                                }
                                for (var k = 0, l = c.labels.length; k < l; k++) {
                                    labelMap[c.labels[k]] = c;
                                }
                            }

                            this.labelMap = labelMap;
                        }
                        LabelSwitch.prototype.trace = function (writer) {
                            for (var i = 0, j = this.cases.length; i < j; i++) {
                                this.cases[i].trace(writer);
                            }
                        };
                        return LabelSwitch;
                    })(ControlNode);
                    Control.LabelSwitch = LabelSwitch;

                    var Exit = (function (_super) {
                        __extends(Exit, _super);
                        function Exit(label) {
                            _super.call(this, 8 /* EXIT */);
                            this.label = label;
                        }
                        Exit.prototype.trace = function (writer) {
                            writer.writeLn("label = " + this.label);
                        };
                        return Exit;
                    })(ControlNode);
                    Control.Exit = Exit;

                    var Break = (function (_super) {
                        __extends(Break, _super);
                        function Break(label, head) {
                            _super.call(this, 9 /* BREAK */);
                            this.label = label;
                            this.head = head;
                        }
                        Break.prototype.trace = function (writer) {
                            this.label && writer.writeLn("label = " + this.label);
                            writer.writeLn("break");
                        };
                        return Break;
                    })(ControlNode);
                    Control.Break = Break;

                    var Continue = (function (_super) {
                        __extends(Continue, _super);
                        function Continue(label, head) {
                            _super.call(this, 10 /* CONTINUE */);
                            this.label = label;
                            this.head = head;
                            this.necessary = true;
                        }
                        Continue.prototype.trace = function (writer) {
                            this.label && writer.writeLn("label = " + this.label);
                            this.necessary && writer.writeLn("continue");
                        };
                        return Continue;
                    })(ControlNode);
                    Control.Continue = Continue;

                    var Try = (function (_super) {
                        __extends(Try, _super);
                        function Try(body, catches) {
                            _super.call(this, 11 /* TRY */);
                            this.body = body;
                            this.catches = catches;
                        }
                        Try.prototype.trace = function (writer) {
                            writer.enter("try {");
                            this.body.trace(writer);
                            writer.writeLn("label = " + this.nothingThrownLabel);
                            for (var i = 0, j = this.catches.length; i < j; i++) {
                                this.catches[i].trace(writer);
                            }
                            writer.leave("}");
                        };
                        return Try;
                    })(ControlNode);
                    Control.Try = Try;

                    var Catch = (function (_super) {
                        __extends(Catch, _super);
                        function Catch(varName, typeName, body) {
                            _super.call(this, 12 /* CATCH */);
                            this.varName = varName;
                            this.typeName = typeName;
                            this.body = body;
                        }
                        Catch.prototype.trace = function (writer) {
                            writer.outdent();
                            writer.enter("} catch (" + (this.varName || "e") + (this.typeName ? (" : " + this.typeName) : "") + ") {");
                            this.body.trace(writer);
                        };
                        return Catch;
                    })(ControlNode);
                    Control.Catch = Catch;
                })(Looper.Control || (Looper.Control = {}));
                var Control = Looper.Control;

                var BITS_PER_WORD = Shumway.BitSets.BITS_PER_WORD;
                var ADDRESS_BITS_PER_WORD = Shumway.BitSets.ADDRESS_BITS_PER_WORD;
                var BIT_INDEX_MASK = Shumway.BitSets.BIT_INDEX_MASK;

                var BlockSet = (function (_super) {
                    __extends(BlockSet, _super);
                    function BlockSet(length, blockById) {
                        _super.call(this, length);
                        this.blockById = blockById;
                    }
                    BlockSet.prototype.forEachBlock = function (fn) {
                        release || assert(fn);
                        var byId = this.blockById;
                        var bits = this.bits;
                        for (var i = 0, j = bits.length; i < j; i++) {
                            var word = bits[i];
                            if (word) {
                                for (var k = 0; k < BITS_PER_WORD; k++) {
                                    if (word & (1 << k)) {
                                        fn(byId[i * BITS_PER_WORD + k]);
                                    }
                                }
                            }
                        }
                    };

                    BlockSet.prototype.choose = function () {
                        var byId = this.blockById;
                        var bits = this.bits;
                        for (var i = 0, j = bits.length; i < j; i++) {
                            var word = bits[i];
                            if (word) {
                                for (var k = 0; k < BITS_PER_WORD; k++) {
                                    if (word & (1 << k)) {
                                        return byId[i * BITS_PER_WORD + k];
                                    }
                                }
                            }
                        }
                    };

                    BlockSet.prototype.members = function () {
                        var byId = this.blockById;
                        var set = [];
                        var bits = this.bits;
                        for (var i = 0, j = bits.length; i < j; i++) {
                            var word = bits[i];
                            if (word) {
                                for (var k = 0; k < BITS_PER_WORD; k++) {
                                    if (word & (1 << k)) {
                                        set.push(byId[i * BITS_PER_WORD + k]);
                                    }
                                }
                            }
                        }
                        return set;
                    };

                    BlockSet.prototype.setBlocks = function (bs) {
                        var bits = this.bits;
                        for (var i = 0, j = bs.length; i < j; i++) {
                            var id = bs[i].id;
                            bits[id >> ADDRESS_BITS_PER_WORD] |= 1 << (id & BIT_INDEX_MASK);
                        }
                    };
                    return BlockSet;
                })(Shumway.BitSets.Uint32ArrayBitSet);
                Looper.BlockSet = BlockSet;

                var Analysis = (function () {
                    function Analysis(cfg) {
                        this.makeBlockSetFactory(cfg.blocks.length, cfg.blocks);
                        this.hasExceptions = false;
                        this.normalizeReachableBlocks(cfg.root);
                    }
                    Analysis.prototype.makeBlockSetFactory = function (length, blockById) {
                        release || assert(!this.boundBlockSet);
                        this.boundBlockSet = (function blockSet() {
                            return new BlockSet(length, blockById);
                        });
                    };

                    Analysis.prototype.normalizeReachableBlocks = function (root) {
                        // The root must not have preds!
                        release || assert(root.predecessors.length === 0);

                        var ONCE = 1;
                        var BUNCH_OF_TIMES = 2;
                        var BlockSet = this.boundBlockSet;

                        var blocks = [];
                        var visited = {};
                        var ancestors = {};
                        var worklist = [root];
                        var node;

                        ancestors[root.id] = true;
                        while ((node = top(worklist))) {
                            if (visited[node.id]) {
                                if (visited[node.id] === ONCE) {
                                    visited[node.id] = BUNCH_OF_TIMES;
                                    blocks.push(node);
                                    // Doubly link reachable blocks.
                                    // var successors = node.successors;
                                    // for (var i = 0, j = successors.length; i < j; i++) {
                                    //  successors[i].preds.push(node);
                                    // }
                                }

                                ancestors[node.id] = false;
                                worklist.pop();
                                continue;
                            }

                            visited[node.id] = ONCE;
                            ancestors[node.id] = true;

                            var successors = node.successors;
                            for (var i = 0, j = successors.length; i < j; i++) {
                                var s = successors[i];

                                if (ancestors[s.id]) {
                                    if (!node.spbacks) {
                                        node.spbacks = new BlockSet();
                                    }
                                    node.spbacks.set(s.id);
                                }
                                !visited[s.id] && worklist.push(s);
                            }
                        }

                        this.blocks = blocks.reverse();
                    };

                    //
                    // Calculate the dominance relation iteratively.
                    //
                    // Algorithm is from [1].
                    //
                    // [1] Cooper et al. "A Simple, Fast Dominance Algorithm"
                    //
                    Analysis.prototype.computeDominance = function () {
                        function intersectDominators(doms, b1, b2) {
                            var finger1 = b1;
                            var finger2 = b2;
                            while (finger1 !== finger2) {
                                while (finger1 > finger2) {
                                    finger1 = doms[finger1];
                                }
                                while (finger2 > finger1) {
                                    finger2 = doms[finger2];
                                }
                            }
                            return finger1;
                        }

                        var blocks = this.blocks;
                        var n = blocks.length;
                        var doms = new Array(n);
                        doms[0] = 0;

                        // Blocks must be given to us in reverse postorder.
                        var rpo = [];
                        for (var b = 0; b < n; b++) {
                            rpo[blocks[b].id] = b;
                            blocks[b].dominatees = [];
                        }

                        var changed = true;
                        while (changed) {
                            changed = false;

                            for (var b = 1; b < n; b++) {
                                var predecessors = blocks[b].predecessors;
                                var j = predecessors.length;

                                var newIdom = rpo[predecessors[0].id];

                                // Because 0 is falsy, have to use |in| here.
                                if (!(newIdom in doms)) {
                                    for (var i = 1; i < j; i++) {
                                        newIdom = rpo[predecessors[i].id];
                                        if (newIdom in doms) {
                                            break;
                                        }
                                    }
                                }
                                release || assert(newIdom in doms);

                                for (var i = 0; i < j; i++) {
                                    var p = rpo[predecessors[i].id];
                                    if (p === newIdom) {
                                        continue;
                                    }

                                    if (p in doms) {
                                        newIdom = intersectDominators(doms, p, newIdom);
                                    }
                                }

                                if (doms[b] !== newIdom) {
                                    doms[b] = newIdom;
                                    changed = true;
                                }
                            }
                        }

                        blocks[0].dominator = blocks[0];
                        var block;
                        for (var b = 1; b < n; b++) {
                            block = blocks[b];
                            var idom = blocks[doms[b]];

                            // Store the immediate dominator.
                            block.dominator = idom;
                            idom.dominatees.push(block);

                            block.npredecessors = block.predecessors.length;
                        }

                        // Assign dominator tree levels.
                        var worklist = [blocks[0]];
                        blocks[0].level || (blocks[0].level = 0);
                        while ((block = worklist.shift())) {
                            var dominatees = block.dominatees;
                            for (var i = 0; i < dominatees.length; i++) {
                                dominatees[i].level = block.level + 1;
                            }
                            worklist.push.apply(worklist, dominatees);
                        }
                    };

                    Analysis.prototype.computeFrontiers = function () {
                        var BlockSet = this.boundBlockSet;
                        var blocks = this.blocks;

                        for (var b = 0, n = blocks.length; b < n; b++) {
                            blocks[b].frontier = new BlockSet();
                        }

                        for (var b = 1, n = blocks.length; b < n; b++) {
                            var block = blocks[b];
                            var predecessors = block.predecessors;

                            if (predecessors.length >= 2) {
                                var idom = block.dominator;
                                for (var i = 0, j = predecessors.length; i < j; i++) {
                                    var runner = predecessors[i];

                                    while (runner !== idom) {
                                        runner.frontier.set(block.id);
                                        runner = runner.dominator;
                                    }
                                }
                            }
                        }
                    };

                    Analysis.prototype.analyzeControlFlow = function () {
                        this.computeDominance();
                        this.analyzedControlFlow = true;
                        return true;
                    };

                    Analysis.prototype.markLoops = function () {
                        if (!this.analyzedControlFlow && !this.analyzeControlFlow()) {
                            return false;
                        }

                        var BlockSet = this.boundBlockSet;

                        //
                        // Find all SCCs at or below the level of some root that are not already
                        // natural loops.
                        //
                        function findSCCs(root) {
                            var preorderId = 1;
                            var preorder = {};
                            var assigned = {};
                            var unconnectedNodes = [];
                            var pendingNodes = [];
                            var sccs = [];
                            var level = root.level + 1;
                            var worklist = [root];
                            var node;
                            var u, s;

                            while ((node = top(worklist))) {
                                if (preorder[node.id]) {
                                    if (peek(pendingNodes) === node) {
                                        pendingNodes.pop();

                                        var scc = [];
                                        do {
                                            u = unconnectedNodes.pop();
                                            assigned[u.id] = true;
                                            scc.push(u);
                                        } while(u !== node);

                                        if (scc.length > 1 || (u.spbacks && u.spbacks.get(u.id))) {
                                            sccs.push(scc);
                                        }
                                    }

                                    worklist.pop();
                                    continue;
                                }

                                preorder[node.id] = preorderId++;
                                unconnectedNodes.push(node);
                                pendingNodes.push(node);

                                var successors = node.successors;
                                for (var i = 0, j = successors.length; i < j; i++) {
                                    s = successors[i];
                                    if (s.level < level) {
                                        continue;
                                    }

                                    var sid = s.id;
                                    if (!preorder[sid]) {
                                        worklist.push(s);
                                    } else if (!assigned[sid]) {
                                        while (preorder[peek(pendingNodes).id] > preorder[sid]) {
                                            pendingNodes.pop();
                                        }
                                    }
                                }
                            }

                            return sccs;
                        }

                        function findLoopHeads(blocks) {
                            var heads = new BlockSet();

                            for (var i = 0, j = blocks.length; i < j; i++) {
                                var block = blocks[i];
                                var spbacks = block.spbacks;

                                if (!spbacks) {
                                    continue;
                                }

                                var successors = block.successors;
                                for (var k = 0, l = successors.length; k < l; k++) {
                                    var s = successors[k];
                                    if (spbacks.get(s.id)) {
                                        heads.set(s.dominator.id);
                                    }
                                }
                            }

                            return heads.members();
                        }

                        function LoopInfo(scc, loopId) {
                            var body = new BlockSet();
                            body.setBlocks(scc);
                            body.recount();

                            this.id = loopId;
                            this.body = body;
                            this.exit = new BlockSet();
                            this.save = {};
                            this.head = new BlockSet();
                            this.npredecessors = 0;
                        }

                        var heads = findLoopHeads(this.blocks);
                        if (heads.length <= 0) {
                            this.markedLoops = true;
                            return true;
                        }

                        var worklist = heads.sort(function (a, b) {
                            return a.level - b.level;
                        });
                        var loopId = 0;

                        for (var n = worklist.length - 1; n >= 0; n--) {
                            var t = worklist[n];
                            var sccs = findSCCs(t);
                            if (sccs.length === 0) {
                                continue;
                            }

                            for (var i = 0, j = sccs.length; i < j; i++) {
                                var scc = sccs[i];
                                var loop = new LoopInfo(scc, loopId++);
                                for (var k = 0, l = scc.length; k < l; k++) {
                                    var h = scc[k];
                                    if (h.level === t.level + 1 && !h.loop) {
                                        h.loop = loop;
                                        loop.head.set(h.id);

                                        var predecessors = h.predecessors;
                                        for (var pi = 0, pj = predecessors.length; pi < pj; pi++) {
                                            loop.body.get(predecessors[pi].id) && h.npredecessors--;
                                        }
                                        loop.npredecessors += h.npredecessors;
                                    }
                                }

                                for (var k = 0, l = scc.length; k < l; k++) {
                                    var h = scc[k];
                                    if (h.level === t.level + 1) {
                                        h.npredecessors = loop.npredecessors;
                                    }
                                }

                                loop.head.recount();
                            }
                        }

                        this.markedLoops = true;
                        return true;
                    };

                    Analysis.prototype.induceControlTree = function () {
                        var hasExceptions = this.hasExceptions;
                        var BlockSet = this.boundBlockSet;

                        function maybe(exit, save) {
                            exit.recount();
                            if (exit.count === 0) {
                                return null;
                            }
                            exit.save = save;
                            return exit;
                        }

                        var exceptionId = this.blocks.length;

                        //
                        // Based on emscripten's relooper algorithm.
                        // The algorithm is O(|E|) -- it visits every edge in the CFG once.
                        //
                        // Loop header detection is done separately, using an overlaid DJ graph.
                        //
                        // For a vertex v, let successor(v) denote its non-exceptional successoressors.
                        //
                        // Basic blocks can be restructured into 4 types of nodes:
                        //
                        //  1. Switch. |successor(v) > 2|
                        //  2. If.     |successor(v) = 2|
                        //  3. Plain.  |successor(v) = 1|
                        //  4. Loop.   marked as a loop header.
                        //
                        // The idea is fairly simple: start at a set of heads, induce all its
                        // successoressors recursively in that head's context, discharging the edges
                        // that we take. If a vertex no longer has any incoming edges when we
                        // visit it, emit the vertex, else emit a label marking that we need to
                        // go to that vertex and mark that vertex as an exit in the current
                        // context.
                        //
                        // The algorithm starts at the root, the first instruction.
                        //
                        // Exceptions are restructured via rewriting. AVM bytecode stores try
                        // blocks as a range of bytecode positions. Our basic blocks respects
                        // these range boundaries. Each basic block which is in one or more of
                        // such exception ranges have exceptional successoressors (jumps) to all
                        // matching catch blocks. We then restructure the entire basic block as
                        // a try and have the restructuring take care of the jumps to the actual
                        // catch blocks. Finally blocks fall out naturally, but are not emitted
                        // as JavaScript |finally|.
                        //
                        // Implementation Notes
                        // --------------------
                        //
                        // We discharge edges by keeping a property |npredecessors| on each block that
                        // says how many incoming edges we have _not yet_ discharged. We
                        // discharge edges as we recur on the tree, but in case we can't emit a
                        // block (i.e. its |npredecessors| > 0), we need to restore its |npredecessors| before
                        // we pop out. We do this via a |save| proeprty on each block that says
                        // how many predecessors we should restore.
                        //
                        // |exit| is the set of exits in the current context, i.e. the set of
                        // vertices that we visited but have not yet discharged every incoming
                        // edge.
                        //
                        // |save| is a mapping of block id -> save numbers.
                        //
                        // When setting an exit in the exit set, the save number must be set for
                        // it also in the save set.
                        //
                        function induce(head, exit, save, loop, inLoopHead, lookupSwitch, fallthrough) {
                            var v = [];

                            while (head) {
                                if (head.count > 1) {
                                    var exit2 = new BlockSet();
                                    var save2 = {};

                                    var cases = [];
                                    var heads = head.members();

                                    for (var i = 0, j = heads.length; i < j; i++) {
                                        var h = heads[i];
                                        var bid = h.id;
                                        var c;

                                        if (h.loop && head.contains(h.loop.head)) {
                                            var loop2 = h.loop;
                                            if (!loop2.induced) {
                                                var lheads = loop2.head.members();
                                                var lheadsave = 0;

                                                for (k = 0, l = lheads.length; k < l; k++) {
                                                    lheadsave += head.save[lheads[k].id];
                                                }

                                                if (h.npredecessors - lheadsave > 0) {
                                                    // Don't even enter the loop if we're just going to exit
                                                    // anyways.
                                                    h.npredecessors -= head.save[bid];
                                                    h.save = head.save[bid];
                                                    c = induce(h, exit2, save2, loop);
                                                    cases.push(new Control.LabelCase([bid], c));
                                                } else {
                                                    for (k = 0, l = lheads.length; k < l; k++) {
                                                        var lh = lheads[k];
                                                        lh.npredecessors -= lheadsave;
                                                        lh.save = lheadsave;
                                                    }
                                                    c = induce(h, exit2, save2, loop);
                                                    cases.push(new Control.LabelCase(loop2.head.toArray(), c));
                                                    loop2.induced = true;
                                                }
                                            }
                                        } else {
                                            h.npredecessors -= head.save[bid];
                                            h.save = head.save[bid];
                                            c = induce(h, exit2, save2, loop);
                                            cases.push(new Control.LabelCase([bid], c));
                                        }
                                    }

                                    var pruned = [];
                                    var k = 0;
                                    var c;
                                    for (var i = 0; i < cases.length; i++) {
                                        c = cases[i];
                                        var labels = c.labels;
                                        var lk = 0;
                                        for (var ln = 0, nlabels = labels.length; ln < nlabels; ln++) {
                                            var bid = labels[ln];
                                            if (exit2.get(bid) && heads[i].npredecessors - head.save[bid] > 0) {
                                                pruned.push(bid);
                                            } else {
                                                labels[lk++] = bid;
                                            }
                                        }
                                        labels.length = lk;

                                        // Prune the case unless it still has some entry labels.
                                        if (labels.length > 0) {
                                            cases[k++] = c;
                                        }
                                    }
                                    cases.length = k;

                                    if (cases.length === 0) {
                                        for (var i = 0; i < pruned.length; i++) {
                                            var bid = pruned[i];
                                            save[bid] = (save[bid] || 0) + head.save[bid];
                                            exit.set(bid);
                                        }
                                        break;
                                    }

                                    v.push(new Control.LabelSwitch(cases));

                                    head = maybe(exit2, save2);
                                    continue;
                                }

                                var h, bid, c;

                                if (head.count === 1) {
                                    h = head.choose();
                                    bid = h.id;
                                    h.npredecessors -= head.save[bid];
                                    h.save = head.save[bid];
                                } else {
                                    h = head;
                                    bid = h.id;
                                }

                                if (inLoopHead) {
                                    inLoopHead = false;
                                } else {
                                    if (loop && !loop.body.get(bid)) {
                                        h.npredecessors += h.save;
                                        loop.exit.set(bid);
                                        loop.save[bid] = (loop.save[bid] || 0) + h.save;
                                        v.push(new Control.Break(bid, loop));
                                        break;
                                    }

                                    if (loop && h.loop === loop) {
                                        h.npredecessors += h.save;
                                        v.push(new Control.Continue(bid, loop));
                                        break;
                                    }

                                    if (h === fallthrough) {
                                        break;
                                    }

                                    if (h.npredecessors > 0) {
                                        h.npredecessors += h.save;
                                        save[bid] = (save[bid] || 0) + h.save;
                                        exit.set(bid);
                                        v.push(lookupSwitch ? new Control.Break(bid, lookupSwitch) : new Control.Exit(bid));
                                        break;
                                    }

                                    if (h.loop) {
                                        var l = h.loop;

                                        var body;
                                        if (l.head.count === 1) {
                                            body = induce(l.head.choose(), null, null, l, true);
                                        } else {
                                            var lcases = [];
                                            var lheads = l.head.members();

                                            for (var i = 0, j = lheads.length; i < j; i++) {
                                                var lh = lheads[i];
                                                var lbid = lh.id;
                                                var c = induce(lh, null, null, l, true);
                                                lcases.push(new Control.LabelCase([lbid], c));
                                            }

                                            body = new Control.LabelSwitch(lcases);
                                        }

                                        v.push(new Control.Loop(body));
                                        head = maybe(l.exit, l.save);
                                        continue;
                                    }
                                }

                                var sv;
                                var successors;
                                var exit2 = new BlockSet();
                                var save2 = {};

                                if (hasExceptions && h.hasCatches) {
                                    var allsuccessors = h.successors;
                                    var catchsuccessors = [];
                                    successors = [];

                                    for (var i = 0, j = allsuccessors.length; i < j; i++) {
                                        var s = allsuccessors[i];
                                        (s.exception ? catchsuccessors : successors).push(s);
                                    }

                                    var catches = [];
                                    for (var i = 0; i < catchsuccessors.length; i++) {
                                        var t = catchsuccessors[i];
                                        t.npredecessors -= 1;
                                        t.save = 1;
                                        var c = induce(t, exit2, save2, loop);
                                        var ex = t.exception;
                                        catches.push(new Control.Catch(ex.varName, ex.typeName, c));
                                    }

                                    sv = new Control.Try(h, catches);
                                } else {
                                    successors = h.successors;
                                    sv = h;
                                }

                                /*
                                if (h.end.op === OP_lookupswitch) {
                                var cases = [];
                                var targets = h.end.targets;
                                
                                for (var i = targets.length - 1; i >= 0; i--) {
                                var t = targets[i];
                                t.npredecessors -= 1;
                                t.save = 1;
                                c = induce(t, exit2, save2, loop, null, h, targets[i + 1]);
                                cases.unshift(new Control.Case(i, c));
                                }
                                
                                // The last case is the default case.
                                cases.top().index = undefined;
                                
                                if (hasExceptions && h.hasCatches) {
                                sv.nothingThrownLabel = exceptionId;
                                sv = new Control.Switch(sv, cases, exceptionId++);
                                } else {
                                sv = new Control.Switch(sv, cases);
                                }
                                
                                head = maybe(exit2, save2);
                                } else
                                */
                                if (successors.length > 2) {
                                    var cases = [];
                                    var targets = successors;

                                    for (var i = targets.length - 1; i >= 0; i--) {
                                        var t = targets[i];
                                        t.npredecessors -= 1;
                                        t.save = 1;
                                        c = induce(t, exit2, save2, loop, null, h, targets[i + 1]);
                                        cases.unshift(new Control.Case(i, c));
                                    }

                                    // The last case is the default case.
                                    top(cases).index = undefined;

                                    if (hasExceptions && h.hasCatches) {
                                        sv.nothingThrownLabel = exceptionId;
                                        sv = new Control.Switch(sv, cases, exceptionId++);
                                    } else {
                                        sv = new Control.Switch(sv, cases);
                                    }

                                    head = maybe(exit2, save2);
                                } else if (successors.length === 2) {
                                    var branch1 = h.hasFlippedSuccessors ? successors[1] : successors[0];
                                    var branch2 = h.hasFlippedSuccessors ? successors[0] : successors[1];
                                    branch1.npredecessors -= 1;
                                    branch1.save = 1;
                                    var c1 = induce(branch1, exit2, save2, loop);

                                    branch2.npredecessors -= 1;
                                    branch2.save = 1;
                                    var c2 = induce(branch2, exit2, save2, loop);

                                    if (hasExceptions && h.hasCatches) {
                                        sv.nothingThrownLabel = exceptionId;
                                        sv = new Control.If(sv, c1, c2, exceptionId++);
                                    } else {
                                        sv = new Control.If(sv, c1, c2);
                                    }

                                    head = maybe(exit2, save2);
                                } else {
                                    c = successors[0];

                                    if (c) {
                                        if (hasExceptions && h.hasCatches) {
                                            sv.nothingThrownLabel = c.id;
                                            save2[c.id] = (save2[c.id] || 0) + 1;
                                            exit2.set(c.id);

                                            head = maybe(exit2, save2);
                                        } else {
                                            c.npredecessors -= 1;
                                            c.save = 1;
                                            head = c;
                                        }
                                    } else {
                                        if (hasExceptions && h.hasCatches) {
                                            sv.nothingThrownLabel = -1;
                                            head = maybe(exit2, save2);
                                        } else {
                                            head = c;
                                        }
                                    }
                                }

                                v.push(sv);
                            }

                            if (v.length > 1) {
                                return new Control.Seq(v);
                            }

                            return v[0];
                        }

                        var root = this.blocks[0];
                        this.controlTree = induce(root, new BlockSet(), {});
                    };

                    Analysis.prototype.restructureControlFlow = function () {
                        AVM2.enterTimeline("Restructure Control Flow");
                        if (!this.markedLoops && !this.markLoops()) {
                            AVM2.leaveTimeline();
                            return false;
                        }
                        this.induceControlTree();
                        this.restructuredControlFlow = true;
                        AVM2.leaveTimeline();
                        return true;
                    };
                    return Analysis;
                })();
                Looper.Analysis = Analysis;

                function analyze(cfg) {
                    var analysis = new Analysis(cfg);
                    analysis.restructureControlFlow();
                    return analysis.controlTree;
                }
                Looper.analyze = analyze;
            })(Compiler.Looper || (Compiler.Looper = {}));
            var Looper = Compiler.Looper;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Compiler) {
            (function (Backend) {
                var assert = Shumway.Debug.assert;
                var unexpected = Shumway.Debug.unexpected;
                var notImplemented = Shumway.Debug.notImplemented;
                var pushUnique = Shumway.ArrayUtilities.pushUnique;

                var AST = Shumway.AVM2.Compiler.AST;
                var Literal = Compiler.AST.Literal;
                var Identifier = Compiler.AST.Identifier;
                var VariableDeclaration = Compiler.AST.VariableDeclaration;
                var VariableDeclarator = Compiler.AST.VariableDeclarator;
                var MemberExpression = Compiler.AST.MemberExpression;
                var BinaryExpression = Compiler.AST.BinaryExpression;
                var CallExpression = Compiler.AST.CallExpression;
                var AssignmentExpression = Compiler.AST.AssignmentExpression;
                var ExpressionStatement = Compiler.AST.ExpressionStatement;
                var ReturnStatement = Compiler.AST.ReturnStatement;

                var ConditionalExpression = Compiler.AST.ConditionalExpression;
                var ObjectExpression = Compiler.AST.ObjectExpression;
                var ArrayExpression = Compiler.AST.ArrayExpression;
                var UnaryExpression = Compiler.AST.UnaryExpression;
                var NewExpression = Compiler.AST.NewExpression;
                var Property = Compiler.AST.Property;
                var BlockStatement = Compiler.AST.BlockStatement;
                var ThisExpression = Compiler.AST.ThisExpression;
                var ThrowStatement = Compiler.AST.ThrowStatement;
                var IfStatement = Compiler.AST.IfStatement;
                var WhileStatement = Compiler.AST.WhileStatement;
                var BreakStatement = Compiler.AST.BreakStatement;
                var ContinueStatement = Compiler.AST.ContinueStatement;
                var SwitchStatement = Compiler.AST.SwitchStatement;
                var SwitchCase = Compiler.AST.SwitchCase;

                var Start = Compiler.IR.Start;

                var Variable = Compiler.IR.Variable;
                var Constant = Compiler.IR.Constant;
                var Operator = Compiler.IR.Operator;

                var Looper = Shumway.AVM2.Compiler.Looper;
                var Control = Looper.Control;

                var last = Shumway.ArrayUtilities.last;

                Control.Break.prototype.compile = function (cx) {
                    return cx.compileBreak(this);
                };

                Control.Continue.prototype.compile = function (cx) {
                    return cx.compileContinue(this);
                };

                Control.Exit.prototype.compile = function (cx) {
                    return cx.compileExit(this);
                };

                Control.LabelSwitch.prototype.compile = function (cx) {
                    return cx.compileLabelSwitch(this);
                };

                Control.Seq.prototype.compile = function (cx) {
                    return cx.compileSequence(this);
                };

                Control.Loop.prototype.compile = function (cx) {
                    return cx.compileLoop(this);
                };

                Control.Switch.prototype.compile = function (cx) {
                    return cx.compileSwitch(this);
                };

                Control.If.prototype.compile = function (cx) {
                    return cx.compileIf(this);
                };

                Control.Try.prototype.compile = function (cx) {
                    notImplemented("try");
                    return null;
                };

                var F = new Identifier("$F");
                var C = new Identifier("$C");

                function isLazyConstant(value) {
                    return value instanceof Shumway.AVM2.Runtime.LazyInitializer;
                }

                function constant(value, cx) {
                    if (typeof value === "string" || value === null || value === true || value === false) {
                        return new Literal(value);
                    } else if (value === undefined) {
                        return new Identifier("undefined");
                    } else if (typeof value === "object" || typeof value === "function") {
                        if (isLazyConstant(value)) {
                            return call(property(F, "C"), [new Literal(cx.useConstant(value))]);
                        } else {
                            return new MemberExpression(C, new Literal(cx.useConstant(value)), true);
                        }
                    } else if (typeof value === "number" && isNaN(value)) {
                        return new Identifier("NaN");
                    } else if (value === Infinity) {
                        return new Identifier("Infinity");
                    } else if (value === -Infinity) {
                        return new UnaryExpression("-", true, new Identifier("Infinity"));
                    } else if (typeof value === "number" && (1 / value) < 0) {
                        return new UnaryExpression("-", true, new Literal(Math.abs(value)));
                    } else if (typeof value === "number") {
                        return new Literal(value);
                    } else {
                        unexpected("Cannot emit constant for value: " + value);
                    }
                }

                function id(name) {
                    release || assert(typeof name === "string");
                    return new Identifier(name);
                }

                function isIdentifierStart(c) {
                    return (c === '$') || (c === '_') || (c === '\\') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
                }

                function isIdentifierPart(c) {
                    return (c === '$') || (c === '_') || (c === '\\') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || ((c >= '0') && (c <= '9'));
                }

                function isIdentifierName(s) {
                    if (!isIdentifierStart(s[0])) {
                        return false;
                    }
                    for (var i = 1; i < s.length; i++) {
                        if (!isIdentifierPart(s[i])) {
                            return false;
                        }
                    }
                    return true;
                }

                function property(obj) {
                    var args = [];
                    for (var _i = 0; _i < (arguments.length - 1); _i++) {
                        args[_i] = arguments[_i + 1];
                    }
                    for (var i = 0; i < args.length; i++) {
                        var x = args[i];
                        if (typeof x === "string") {
                            if (isIdentifierName(x)) {
                                obj = new MemberExpression(obj, new Identifier(x), false);
                            } else {
                                obj = new MemberExpression(obj, new Literal(x), true);
                            }
                        } else if (x instanceof Literal && isIdentifierName(x.value)) {
                            obj = new MemberExpression(obj, new Identifier(x.value), false);
                        } else {
                            obj = new MemberExpression(obj, x, true);
                        }
                    }
                    return obj;
                }

                function call(callee, args) {
                    release || assert(args instanceof Array);
                    release || args.forEach(function (x) {
                        release || assert(!(x instanceof Array));
                        release || assert(x !== undefined);
                    });
                    return new CallExpression(callee, args);
                }

                function callAsCall(callee, object, args) {
                    return call(property(callee, "asCall"), [object].concat(args));
                }

                function callCall(callee, object, args) {
                    return call(property(callee, "call"), [object].concat(args));
                }

                function assignment(left, right) {
                    release || assert(left && right);
                    return new AssignmentExpression("=", left, right);
                }

                function variableDeclaration(declarations) {
                    return new VariableDeclaration(declarations, "var");
                }

                function negate(node) {
                    if (node instanceof Constant) {
                        if (node.value === true || node.value === false) {
                            return constant(!node.value);
                        }
                    } else if (node instanceof Identifier) {
                        return new UnaryExpression(Operator.FALSE.name, true, node);
                    }
                    release || assert(node instanceof BinaryExpression || node instanceof UnaryExpression, node);
                    var left = node instanceof BinaryExpression ? node.left : node.argument;
                    var right = node.right;
                    var operator = Operator.fromName(node.operator);
                    if (operator === Operator.EQ && right instanceof Literal && right.value === false) {
                        return left;
                    }
                    if (operator === Operator.FALSE) {
                        return left;
                    }
                    if (operator.not) {
                        if (node instanceof BinaryExpression) {
                            return new BinaryExpression(operator.not.name, left, right);
                        } else {
                            return new UnaryExpression(operator.not.name, true, left);
                        }
                    }
                    return new UnaryExpression(Operator.FALSE.name, true, node);
                }

                var Context = (function () {
                    function Context() {
                        this.label = new Variable("$L");
                        this.variables = [];
                        this.constants = [];
                        this.parameters = [];
                    }
                    Context.prototype.useConstant = function (constant) {
                        return pushUnique(this.constants, constant);
                    };

                    Context.prototype.useVariable = function (variable) {
                        release || assert(variable);
                        return pushUnique(this.variables, variable);
                    };

                    Context.prototype.useParameter = function (parameter) {
                        return this.parameters[parameter.index] = parameter;
                    };

                    Context.prototype.compileLabelBody = function (node) {
                        var body = [];
                        if (node.label !== undefined) {
                            this.useVariable(this.label);
                            body.push(new ExpressionStatement(assignment(id(this.label.name), new Literal(node.label))));
                        }
                        return body;
                    };

                    Context.prototype.compileBreak = function (node) {
                        var body = this.compileLabelBody(node);
                        body.push(new BreakStatement(null));
                        return new BlockStatement(body);
                    };

                    Context.prototype.compileContinue = function (node) {
                        var body = this.compileLabelBody(node);
                        body.push(new ContinueStatement(null));
                        return new BlockStatement(body);
                    };

                    Context.prototype.compileExit = function (node) {
                        return new BlockStatement(this.compileLabelBody(node));
                    };

                    Context.prototype.compileIf = function (node) {
                        var cr = node.cond.compile(this);
                        var tr = null, er = null;
                        if (node.then) {
                            tr = node.then.compile(this);
                        }
                        if (node.else) {
                            er = node.else.compile(this);
                        }
                        var condition = compileValue(cr.end.predicate, this);
                        condition = node.negated ? negate(condition) : condition;
                        cr.body.push(new IfStatement(condition, tr || new BlockStatement([]), er || null));
                        return cr;
                    };

                    Context.prototype.compileSwitch = function (node) {
                        var dr = node.determinant.compile(this);
                        var cases = [];
                        node.cases.forEach(function (x) {
                            var br;
                            if (x.body) {
                                br = x.body.compile(this);
                            }
                            var test = typeof x.index === "number" ? new Literal(x.index) : undefined;
                            cases.push(new SwitchCase(test, br ? [br] : []));
                        }, this);
                        var determinant = compileValue(dr.end.determinant, this);
                        dr.body.push(new SwitchStatement(determinant, cases, false));
                        return dr;
                    };

                    Context.prototype.compileLabelSwitch = function (node) {
                        var statement = null;
                        var labelName = id(this.label.name);

                        function compileLabelTest(labelID) {
                            release || assert(typeof labelID === "number");
                            return new BinaryExpression("===", labelName, new Literal(labelID));
                        }

                        for (var i = node.cases.length - 1; i >= 0; i--) {
                            var c = node.cases[i];
                            var labels = c.labels;

                            var labelTest = compileLabelTest(labels[0]);

                            for (var j = 1; j < labels.length; j++) {
                                labelTest = new BinaryExpression("||", labelTest, compileLabelTest(labels[j]));
                            }

                            statement = new IfStatement(labelTest, c.body ? c.body.compile(this) : new BlockStatement([]), statement);
                        }
                        return statement;
                    };

                    Context.prototype.compileLoop = function (node) {
                        var br = node.body.compile(this);
                        return new WhileStatement(constant(true), br);
                    };

                    Context.prototype.compileSequence = function (node) {
                        var cx = this;
                        var body = [];
                        node.body.forEach(function (x) {
                            var result = x.compile(cx);
                            if (result instanceof BlockStatement) {
                                body = body.concat(result.body);
                            } else {
                                body.push(result);
                            }
                        });
                        return new BlockStatement(body);
                    };

                    Context.prototype.compileBlock = function (block) {
                        var body = [];

                        for (var i = 1; i < block.nodes.length - 1; i++) {
                            var node = block.nodes[i];
                            var statement;
                            var to;
                            var from;

                            if (node instanceof Compiler.IR.Throw) {
                                statement = compileValue(node, this, true);
                            } else {
                                if (node instanceof Compiler.IR.Move) {
                                    to = id(node.to.name);
                                    this.useVariable(node.to);
                                    from = compileValue(node.from, this);
                                } else {
                                    if (node.variable) {
                                        to = id(node.variable.name);
                                        this.useVariable(node.variable);
                                    } else {
                                        to = null;
                                    }
                                    from = compileValue(node, this, true);
                                }
                                if (to) {
                                    statement = new ExpressionStatement(assignment(to, from));
                                } else {
                                    statement = new ExpressionStatement(from);
                                }
                            }
                            body.push(statement);
                        }
                        var end = last(block.nodes);
                        if (end instanceof Compiler.IR.Stop) {
                            body.push(new ReturnStatement(compileValue(end.argument, this)));
                        }
                        var result = new BlockStatement(body);
                        result.end = last(block.nodes);
                        release || assert(result.end instanceof Compiler.IR.End);

                        // print("Block: " + block + " -> " + generateSource(result));
                        return result;
                    };
                    return Context;
                })();
                Backend.Context = Context;

                function compileValue(value, cx, noVariable) {
                    release || assert(value);
                    release || assert(value.compile, "Implement |compile| for ", value, " (", value.nodeName + ")");
                    release || assert(cx instanceof Context);
                    release || assert(!isArray(value));
                    if (noVariable || !value.variable) {
                        var node = value.compile(cx);
                        return node;
                    }
                    release || assert(value.variable, "Value has no variable: ", value);
                    return id(value.variable.name);
                }

                function compileMultiname(name, cx) {
                    return [
                        compileValue(name.namespaces, cx),
                        compileValue(name.name, cx),
                        constant(name.flags)
                    ];
                }

                function isArray(array) {
                    return array instanceof Array;
                }

                function compileValues(values, cx) {
                    release || assert(isArray(values));
                    return values.map(function (value) {
                        return compileValue(value, cx);
                    });
                }

                Compiler.IR.Parameter.prototype.compile = function (cx) {
                    cx.useParameter(this);
                    return id(this.name);
                };

                Compiler.IR.Constant.prototype.compile = function (cx) {
                    return constant(this.value, cx);
                };

                Compiler.IR.Variable.prototype.compile = function (cx) {
                    return id(this.name);
                };

                Compiler.IR.Phi.prototype.compile = function (cx) {
                    release || assert(this.variable);
                    return compileValue(this.variable, cx);
                };

                Compiler.IR.ASScope.prototype.compile = function (cx) {
                    var parent = compileValue(this.parent, cx);
                    var object = compileValue(this.object, cx);
                    var isWith = new Literal(this.isWith);
                    return new NewExpression(id("Scope"), [parent, object, isWith]);
                };

                Compiler.IR.ASFindProperty.prototype.compile = function (cx) {
                    var scope = compileValue(this.scope, cx);
                    var name = compileMultiname(this.name, cx);
                    var methodInfo = compileValue(this.methodInfo, cx);
                    var strict = new Literal(this.strict);
                    return call(property(scope, "findScopeProperty"), name.concat([methodInfo, strict]));
                };

                Compiler.IR.ASGetProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    if (this.flags & 1 /* NumericProperty */) {
                        release || assert(!(this.flags & 8 /* IS_METHOD */));
                        return call(property(object, "asGetNumericProperty"), [compileValue(this.name.name, cx)]);
                    } else if (this.flags & 2 /* RESOLVED */) {
                        return call(property(object, "asGetResolvedStringProperty"), [compileValue(this.name, cx)]);
                    }
                    var name = compileMultiname(this.name, cx);
                    var isMethod = new Literal(this.flags & 8 /* IS_METHOD */);
                    return call(property(object, "asGetProperty"), name.concat(isMethod));
                };

                Compiler.IR.ASGetSuper.prototype.compile = function (cx) {
                    var scope = compileValue(this.scope, cx);
                    var object = compileValue(this.object, cx);
                    var name = compileMultiname(this.name, cx);
                    return call(property(object, "asGetSuper"), [scope].concat(name));
                };

                Compiler.IR.Latch.prototype.compile = function (cx) {
                    return new ConditionalExpression(compileValue(this.condition, cx), compileValue(this.left, cx), compileValue(this.right, cx));
                };

                Compiler.IR.Unary.prototype.compile = function (cx) {
                    return new UnaryExpression(this.operator.name, true, compileValue(this.argument, cx));
                };

                Compiler.IR.Copy.prototype.compile = function (cx) {
                    return compileValue(this.argument, cx);
                };

                Compiler.IR.Binary.prototype.compile = function (cx) {
                    var left = compileValue(this.left, cx);
                    var right = compileValue(this.right, cx);
                    if (this.operator === Compiler.IR.Operator.AS_ADD) {
                        return call(id("asAdd"), [left, right]);
                    }
                    return new BinaryExpression(this.operator.name, left, right);
                };

                Compiler.IR.CallProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileValue(this.name, cx);
                    var callee = property(object, name);
                    var args = this.args.map(function (arg) {
                        return compileValue(arg, cx);
                    });
                    if (this.flags & 16 /* AS_CALL */) {
                        return callAsCall(callee, object, args);
                    } else if (this.flags & 4 /* PRISTINE */) {
                        return call(callee, args);
                    } else {
                        return callCall(callee, object, args);
                    }
                };

                Compiler.IR.ASCallProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var args = this.args.map(function (arg) {
                        return compileValue(arg, cx);
                    });
                    if (this.flags & 2 /* RESOLVED */) {
                        return call(property(object, "asCallResolvedStringProperty"), [compileValue(this.name, cx), new Literal(this.isLex), new ArrayExpression(args)]);
                    }
                    var name = compileMultiname(this.name, cx);
                    return call(property(object, "asCallProperty"), name.concat([new Literal(this.isLex), new ArrayExpression(args)]));
                };

                Compiler.IR.ASCallSuper.prototype.compile = function (cx) {
                    var scope = compileValue(this.scope, cx);
                    var object = compileValue(this.object, cx);
                    var args = this.args.map(function (arg) {
                        return compileValue(arg, cx);
                    });
                    var name = compileMultiname(this.name, cx);
                    return call(property(object, "asCallSuper"), [scope].concat(name).concat(new ArrayExpression(args)));
                };

                Compiler.IR.Call.prototype.compile = function (cx) {
                    var args = this.args.map(function (arg) {
                        return compileValue(arg, cx);
                    });
                    var callee = compileValue(this.callee, cx);
                    var object;
                    if (this.object) {
                        object = compileValue(this.object, cx);
                    } else {
                        object = new Literal(null);
                    }
                    if (this.flags & 16 /* AS_CALL */) {
                        return callAsCall(callee, object, args);
                    } else if (false && this.pristine && (this.callee instanceof Compiler.IR.GetProperty && this.callee.object === this.object) || this.object === null) {
                        return call(callee, args);
                    } else {
                        return callCall(callee, object, args);
                    }
                };

                Compiler.IR.ASNew.prototype.compile = function (cx) {
                    var args = this.args.map(function (arg) {
                        return compileValue(arg, cx);
                    });
                    var callee = compileValue(this.callee, cx);
                    callee = property(callee, "instanceConstructor");
                    return new NewExpression(callee, args);
                };

                Compiler.IR.This.prototype.compile = function (cx) {
                    return new ThisExpression();
                };

                Compiler.IR.Throw.prototype.compile = function (cx) {
                    var argument = compileValue(this.argument, cx);
                    return new ThrowStatement(argument);
                };

                Compiler.IR.Arguments.prototype.compile = function (cx) {
                    return id("arguments");
                };

                Compiler.IR.ASGlobal.prototype.compile = function (cx) {
                    var scope = compileValue(this.scope, cx);
                    return property(scope, "global", "object");
                };

                Compiler.IR.ASSetProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var value = compileValue(this.value, cx);
                    if (this.flags & 1 /* NumericProperty */) {
                        return call(property(object, "asSetNumericProperty"), [compileValue(this.name.name, cx), value]);
                    }
                    var name = compileMultiname(this.name, cx);
                    return call(property(object, "asSetProperty"), name.concat(value));
                };

                Compiler.IR.ASSetSuper.prototype.compile = function (cx) {
                    var scope = compileValue(this.scope, cx);
                    var object = compileValue(this.object, cx);
                    var name = compileMultiname(this.name, cx);
                    var value = compileValue(this.value, cx);
                    return call(property(object, "asSetSuper"), [scope].concat(name).concat([value]));
                };

                Compiler.IR.ASDeleteProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileMultiname(this.name, cx);
                    return call(property(object, "asDeleteProperty"), name);
                };

                Compiler.IR.ASHasProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileMultiname(this.name, cx);
                    return call(property(object, "asHasProperty"), name);
                };

                Compiler.IR.GlobalProperty.prototype.compile = function (cx) {
                    return id(this.name);
                };

                Compiler.IR.GetProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileValue(this.name, cx);
                    return property(object, name);
                };

                Compiler.IR.SetProperty.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileValue(this.name, cx);
                    var value = compileValue(this.value, cx);
                    return assignment(property(object, name), value);
                };

                Compiler.IR.ASGetDescendants.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileValue(this.name, cx);
                    return call(id("getDescendants"), [object, name]);
                };

                Compiler.IR.ASSetSlot.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileValue(this.name, cx);
                    var value = compileValue(this.value, cx);
                    return (call(id("asSetSlot"), [object, name, value]));
                };

                Compiler.IR.ASGetSlot.prototype.compile = function (cx) {
                    var object = compileValue(this.object, cx);
                    var name = compileValue(this.name, cx);
                    return (call(id("asGetSlot"), [object, name]));
                };

                Compiler.IR.Projection.prototype.compile = function (cx) {
                    release || assert(this.type === 4 /* SCOPE */);
                    release || assert(this.argument instanceof Start);
                    return compileValue(this.argument.scope, cx);
                };

                Compiler.IR.NewArray.prototype.compile = function (cx) {
                    return new ArrayExpression(compileValues(this.elements, cx));
                };

                Compiler.IR.NewObject.prototype.compile = function (cx) {
                    var properties = this.properties.map(function (property) {
                        var key = compileValue(property.key, cx);
                        var value = compileValue(property.value, cx);
                        return new Property(key, value, "init");
                    });
                    return new ObjectExpression(properties);
                };

                Compiler.IR.ASNewActivation.prototype.compile = function (cx) {
                    var methodInfo = compileValue(this.methodInfo, cx);
                    return call(id("asCreateActivation"), [methodInfo]);
                };

                Compiler.IR.ASNewHasNext2.prototype.compile = function (cx) {
                    return new NewExpression(id("HasNext2Info"), []);
                };

                Compiler.IR.ASMultiname.prototype.compile = function (cx) {
                    var namespaces = compileValue(this.namespaces, cx);
                    var name = compileValue(this.name, cx);
                    return call(id("createName"), [namespaces, name]);
                };

                Compiler.IR.Block.prototype.compile = function (cx) {
                    return cx.compileBlock(this);
                };

                function generateSource(node) {
                    return node.toSource();
                }

                var Compilation = (function () {
                    function Compilation(parameters, body, constants) {
                        this.parameters = parameters;
                        this.body = body;
                        this.constants = constants;
                        // ...
                    }
                    /**
                    * Object references are stored on the compilation object in a property called |constants|. Some of
                    * these constants are |LazyInitializer|s and the backend makes sure to emit a call to a function
                    * named |C| that resolves them.
                    */
                    Compilation.prototype.C = function (index) {
                        var value = this.constants[index];

                        // TODO: Avoid using |instanceof| here since this can be called quite frequently.
                        if (value instanceof Shumway.AVM2.Runtime.LazyInitializer) {
                            this.constants[index] = value.resolve();
                        }
                        return this.constants[index];
                    };
                    Compilation.id = 0;
                    return Compilation;
                })();
                Backend.Compilation = Compilation;

                function generate(cfg) {
                    AVM2.enterTimeline("Looper");
                    var root = Looper.analyze(cfg);
                    AVM2.leaveTimeline();

                    var writer = new Shumway.IndentingWriter();

                    var cx = new Context();
                    AVM2.enterTimeline("Construct AST");
                    var code = root.compile(cx);
                    AVM2.leaveTimeline();

                    var parameters = [];
                    for (var i = 0; i < cx.parameters.length; i++) {
                        // Closure Compiler complains if the parameter names are the same even if they are not used,
                        // so we differentiate them here.
                        var name = cx.parameters[i] ? cx.parameters[i].name : "_" + i;
                        parameters.push(id(name));
                    }
                    var compilationId = Compilation.id++;
                    var compilationGlobalPropertyName = "$$F" + compilationId;
                    if (cx.constants.length) {
                        var compilation = new Identifier(compilationGlobalPropertyName);
                        var constants = new MemberExpression(compilation, new Identifier("constants"), false);
                        code.body.unshift(variableDeclaration([
                            new VariableDeclarator(id("$F"), compilation),
                            new VariableDeclarator(id("$C"), constants)
                        ]));
                    }
                    if (cx.variables.length) {
                        AVM2.countTimeline("Backend: Locals", cx.variables.length);
                        var variables = variableDeclaration(cx.variables.map(function (variable) {
                            return new VariableDeclarator(id(variable.name));
                        }));
                        code.body.unshift(variables);
                    }

                    AVM2.enterTimeline("Serialize AST");
                    var source = generateSource(code);
                    AVM2.leaveTimeline();

                    // Save compilation as a globa property name.
                    return jsGlobal[compilationGlobalPropertyName] = new Compilation(parameters.map(function (p) {
                        return p.name;
                    }), source, cx.constants);
                }
                Backend.generate = generate;
            })(Compiler.Backend || (Compiler.Backend = {}));
            var Backend = Compiler.Backend;
        })(AVM2.Compiler || (AVM2.Compiler = {}));
        var Compiler = AVM2.Compiler;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (_AVM2) {
        (function (Runtime) {
            var AbcFile = Shumway.AVM2.ABC.AbcFile;

            var Multiname = Shumway.AVM2.ABC.Multiname;

            var Callback = Shumway.Callback;

            var counter = Shumway.Metrics.Counter.instance;
            var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;
            var assert = Shumway.Debug.assert;
            var IndentingWriter = Shumway.IndentingWriter;

            function createNewCompartment() {
                return newGlobal('new-compartment');
            }

            function executeScript(script) {
                _AVM2.enterTimeline("executeScript", { name: script.name });
                var abc = script.abc;
                release || assert(!script.executing && !script.executed);
                var global = new Runtime.Global(script);
                if (abc.applicationDomain.allowNatives) {
                    global[Multiname.getPublicQualifiedName("unsafeJSNative")] = Shumway.AVM2.AS.getNative;
                }
                script.executing = true;
                var scope = new Runtime.Scope(null, script.global);

                // XXX interpreted methods populate stack with every call, compiled don't
                // pushing current runtime to the stack, so Runtime.currentDomain is successful
                Runtime.createFunction(script.init, scope, false).call(script.global, false);
                script.executed = true;
                _AVM2.leaveTimeline();
            }
            Runtime.executeScript = executeScript;

            function ensureScriptIsExecuted(script, reason) {
                if (typeof reason === "undefined") { reason = ""; }
                if (!script.executed && !script.executing) {
                    if (Shumway.AVM2.Runtime.traceExecution.value >= 2) {
                        log("Executing Script For: " + reason);
                    }
                    executeScript(script);
                }
            }
            Runtime.ensureScriptIsExecuted = ensureScriptIsExecuted;

            (function (Glue) {
                Glue[Glue["PUBLIC_PROPERTIES"] = 0x1] = "PUBLIC_PROPERTIES";
                Glue[Glue["PUBLIC_METHODS"] = 0x2] = "PUBLIC_METHODS";
                Glue[Glue["ALL"] = 1 /* PUBLIC_PROPERTIES */ | 2 /* PUBLIC_METHODS */] = "ALL";
            })(Runtime.Glue || (Runtime.Glue = {}));
            var Glue = Runtime.Glue;

            // TODO we don't need them here?
            Runtime.playerglobalLoadedPromise;
            Runtime.playerglobal;

            function grabAbc(abcName) {
                var entry = Runtime.playerglobal.scripts[abcName];
                if (!entry) {
                    return null;
                }
                var offset = entry.offset;
                var length = entry.length;
                return new AbcFile(new Uint8Array(Runtime.playerglobal.abcs, offset, length), abcName);
            }

            function findDefiningAbc(mn) {
                if (!Runtime.playerglobal) {
                    return null;
                }
                for (var i = 0; i < mn.namespaces.length; i++) {
                    var name = mn.namespaces[i].uri + ":" + mn.name;
                    var abcName = Runtime.playerglobal.map[name];
                    if (abcName) {
                        break;
                    }
                }
                if (abcName) {
                    return grabAbc(abcName);
                }
                return null;
            }

            function promiseFile(path, responseType) {
                return new Promise(function (resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', path);
                    xhr.responseType = responseType;
                    xhr.onload = function () {
                        var response = xhr.response;
                        if (response) {
                            if (responseType === 'json' && xhr.responseType !== 'json') {
                                // some browsers (e.g. Safari) have no idea what json is
                                response = JSON.parse(response);
                            }
                            resolve(response);
                        } else {
                            reject('Unable to load ' + path + ': ' + xhr.statusText);
                        }
                    };
                    xhr.send();
                });
            }

            var AVM2 = (function () {
                function AVM2(sysMode, appMode, loadAVM1) {
                    // TODO: this will change when we implement security domains.
                    this.systemDomain = new ApplicationDomain(this, null, sysMode, true);
                    this.applicationDomain = new ApplicationDomain(this, this.systemDomain, appMode, false);
                    this.findDefiningAbc = findDefiningAbc;

                    this._loadAVM1 = loadAVM1;
                    this._loadAVM1Promise = null;

                    /**
                    * All runtime exceptions are boxed in this object to tag them as having
                    * originated from within the VM.
                    */
                    this.exception = { value: undefined };
                    this.exceptions = [];

                    this.globals = createEmptyObject();
                }
                AVM2.initialize = function (sysMode, appMode, loadAVM1) {
                    if (typeof loadAVM1 === "undefined") { loadAVM1 = null; }
                    release || assert(!AVM2.instance);
                    AVM2.instance = new AVM2(sysMode, appMode, loadAVM1);
                };

                // We sometimes need to know where we came from, such as in
                // |ApplicationDomain.currentDomain|.
                AVM2.currentAbc = function () {
                    var caller = arguments.callee;
                    var maxDepth = 20;
                    var abc = null;
                    for (var i = 0; i < maxDepth && caller; i++) {
                        var mi = caller.methodInfo;
                        if (mi) {
                            abc = mi.abc;
                            break;
                        }
                        caller = caller.caller;
                    }
                    return abc;
                };

                AVM2.currentDomain = function () {
                    var abc = AVM2.currentAbc();

                    // If we can't find an abc just default to the current system domain.
                    if (abc === null) {
                        return AVM2.instance.systemDomain;
                    }
                    release || assert(abc && abc.applicationDomain, "No domain environment was found on the stack, increase STACK_DEPTH or " + "make sure that a compiled / interpreted function is on the call stack.");
                    return abc.applicationDomain;
                };

                AVM2.isPlayerglobalLoaded = function () {
                    return !!Runtime.playerglobal;
                };

                AVM2.prototype.loadAVM1 = function () {
                    var loadAVM1Callback = this._loadAVM1;
                    release || assert(loadAVM1Callback);

                    if (!this._loadAVM1Promise) {
                        this._loadAVM1Promise = new Promise(function (resolve) {
                            loadAVM1Callback(resolve);
                        });
                    }
                    return this._loadAVM1Promise;
                };

                AVM2.loadPlayerglobal = function (abcsPath, catalogPath) {
                    if (Runtime.playerglobalLoadedPromise) {
                        return Promise.reject('Playerglobal is already loaded');
                    }
                    Runtime.playerglobalLoadedPromise = Promise.all([promiseFile(abcsPath, 'arraybuffer'), promiseFile(catalogPath, 'json')]).then(function (result) {
                        Runtime.playerglobal = {
                            abcs: result[0],
                            map: Object.create(null),
                            scripts: Object.create(null)
                        };

                        // TODO: Clean this up, type it.
                        var catalog = result[1];
                        for (var i = 0; i < catalog.length; i++) {
                            var abc = catalog[i];
                            Runtime.playerglobal.scripts[abc.name] = abc;
                            if (typeof abc.defs === 'string') {
                                Runtime.playerglobal.map[abc.defs] = abc.name;
                            } else {
                                for (var j = 0; j < abc.defs.length; j++) {
                                    var def = abc.defs[j];
                                    Runtime.playerglobal.map[def] = abc.name;
                                }
                            }
                        }
                    }, function (e) {
                        console.error(e);
                    });
                    return Runtime.playerglobalLoadedPromise;
                };

                AVM2.prototype.notifyConstruct = function (instanceConstructor, args) {
                    // REMOVEME
                };

                AVM2.getStackTrace = function () {
                    Shumway.Debug.notImplemented("getStackTrace");
                    return;
                };
                return AVM2;
            })();
            Runtime.AVM2 = AVM2;

            var ApplicationDomain = (function () {
                function ApplicationDomain(vm, base, mode, allowNatives) {
                    release || assert(vm instanceof AVM2);
                    release || assert(Shumway.isNullOrUndefined(base) || base instanceof ApplicationDomain);

                    this.vm = vm;

                    // ABCs that belong to this domain.
                    this.abcs = [];

                    // ABCs that have been loaded
                    this.loadedAbcs = {};

                    // Classes that have been loaded.
                    this.loadedClasses = [];

                    // Classes cache.
                    this.classCache = createEmptyObject();

                    // Script cache.
                    this.scriptCache = createEmptyObject();

                    // Class Info cache.
                    this.classInfoCache = createEmptyObject();

                    // Our parent.
                    this.base = base;

                    // Do we allow natives?
                    this.allowNatives = allowNatives;

                    // Do we compile or interpret?
                    this.mode = mode;

                    this.onMessage = new Callback();

                    // If we are the system domain (the root), we should initialize the Class
                    // and MethodClosure classes.
                    if (base) {
                        this.system = base.system;
                    } else {
                        this.system = this;
                    }
                }
                ApplicationDomain.passthroughCallable = function (f) {
                    return {
                        call: function ($this) {
                            Array.prototype.shift.call(arguments);
                            return f.asApply($this, arguments);
                        },
                        apply: function ($this, args) {
                            return f.asApply($this, args);
                        }
                    };
                };

                ApplicationDomain.coerceCallable = function (type) {
                    return {
                        call: function ($this, value) {
                            return Runtime.asCoerce(type, value);
                        },
                        apply: function ($this, args) {
                            return Runtime.asCoerce(type, args[0]);
                        }
                    };
                };

                ApplicationDomain.prototype.getType = function (multiname) {
                    return this.getProperty(multiname, true, true);
                };

                ApplicationDomain.prototype.getProperty = function (multiname, strict, execute) {
                    var resolved = this.findDefiningScript(multiname, execute);
                    if (resolved) {
                        if (!resolved.script.executing) {
                            // console.info("Getting " + multiname + " but script is not executed");
                            return undefined;
                        }
                        return resolved.script.global[Multiname.getQualifiedName(resolved.trait.name)];
                    }
                    if (strict) {
                        return Shumway.Debug.unexpected("Cannot find property " + multiname);
                    }

                    return undefined;
                };

                ApplicationDomain.prototype.getClass = function (simpleName) {
                    var cache = this.classCache;
                    var c = cache[simpleName];
                    if (!c) {
                        c = cache[simpleName] = this.getProperty(Multiname.fromSimpleName(simpleName), true, true);
                    }
                    release || assert(c instanceof Shumway.AVM2.AS.ASClass);
                    return c;
                };

                ApplicationDomain.prototype.findClass = function (simpleName) {
                    if (simpleName in this.classCache) {
                        return true;
                    }
                    return this.findDomainProperty(Multiname.fromSimpleName(simpleName), false, true);
                };

                ApplicationDomain.prototype.findDomainProperty = function (multiname, strict, execute) {
                    if (Shumway.AVM2.Runtime.traceDomain.value) {
                        log("ApplicationDomain.findDomainProperty: " + multiname);
                    }
                    var resolved = this.findDefiningScript(multiname, execute);
                    if (resolved) {
                        return resolved.script.global;
                    }
                    if (strict) {
                        return Shumway.Debug.unexpected("Cannot find property " + multiname);
                    } else {
                        return undefined;
                    }
                    return undefined;
                };

                ApplicationDomain.prototype.findClassInfo = function (mn) {
                    var originalQn;
                    if (Multiname.isQName(mn)) {
                        // This deals with the case where mn is already a qn.
                        originalQn = Multiname.getQualifiedName(mn);
                        var ci = this.classInfoCache[originalQn];
                        if (ci) {
                            return ci;
                        }
                    } else {
                        var ci = this.classInfoCache[mn.runtimeId];
                        if (ci) {
                            return ci;
                        }
                    }
                    if (this.base) {
                        // Recurse with the mn as is.
                        ci = this.base.findClassInfo(mn);
                        if (ci) {
                            return ci;
                        }
                    }

                    // The class info may be among the loaded ABCs, go looking for it.
                    var abcs = this.abcs;
                    for (var i = 0; i < abcs.length; i++) {
                        var abc = abcs[i];
                        var scripts = abc.scripts;
                        for (var j = 0; j < scripts.length; j++) {
                            var script = scripts[j];
                            var traits = script.traits;
                            for (var k = 0; k < traits.length; k++) {
                                var trait = traits[k];
                                if (trait.isClass()) {
                                    var traitName = Multiname.getQualifiedName(trait.name);

                                    // So here mn is either a Multiname or a QName.
                                    if (originalQn) {
                                        if (traitName === originalQn) {
                                            return (this.classInfoCache[originalQn] = trait.classInfo);
                                        }
                                    } else {
                                        for (var m = 0, n = mn.namespaces.length; m < n; m++) {
                                            var qn = mn.getQName(m);
                                            if (traitName === Multiname.getQualifiedName(qn)) {
                                                return (this.classInfoCache[qn] = trait.classInfo);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Still no luck, so let's ask host to load the defining ABC and try again.
                    if (!this.base && this.vm.findDefiningAbc) {
                        var abc = this.vm.findDefiningAbc(mn);
                        if (abc !== null && !this.loadedAbcs[abc.name]) {
                            this.loadedAbcs[abc.name] = true;
                            this.loadAbc(abc);
                            return this.findClassInfo(mn);
                        }
                    }
                    return undefined;
                };

                /**
                * Find the first script that defines a multiname.
                *
                * ABCs are added to the list in load order, so a later loaded ABC with a
                * definition of conflicting name will never be resolved.
                */
                ApplicationDomain.prototype.findDefiningScript = function (mn, execute) {
                    var resolved = this.scriptCache[mn.runtimeId];
                    if (resolved && (resolved.script.executed || !execute)) {
                        return resolved;
                    }

                    if (this.base) {
                        resolved = this.base.findDefiningScript(mn, execute);
                        if (resolved) {
                            return resolved;
                        }
                    }

                    _AVM2.countTimeline("ApplicationDomain: findDefiningScript");

                    var abcs = this.abcs;
                    for (var i = 0; i < abcs.length; i++) {
                        var abc = abcs[i];
                        var scripts = abc.scripts;
                        for (var j = 0; j < scripts.length; j++) {
                            var script = scripts[j];
                            var traits = script.traits;
                            if (mn instanceof Multiname) {
                                for (var k = 0; k < traits.length; k++) {
                                    var trait = traits[k];
                                    if (mn.hasQName(trait.name)) {
                                        if (execute) {
                                            ensureScriptIsExecuted(script, String(trait.name));
                                        }
                                        return (this.scriptCache[mn.runtimeId] = { script: script, trait: trait });
                                    }
                                }
                            } else {
                                Shumway.Debug.unexpected();
                            }
                        }
                    }

                    // Ask host to execute the defining ABC
                    if (!this.base && this.vm.findDefiningAbc) {
                        var abc = this.vm.findDefiningAbc(mn);
                        if (abc !== null && !this.loadedAbcs[abc.name]) {
                            this.loadedAbcs[abc.name] = true;
                            this.loadAbc(abc);
                            return this.findDefiningScript(mn, execute);
                        }
                    }

                    return undefined;
                };

                ApplicationDomain.prototype.compileAbc = function (abc, writer) {
                    Shumway.AVM2.Compiler.compileAbc(abc, writer);
                };

                ApplicationDomain.prototype.executeAbc = function (abc) {
                    // console.time("Execute ABC: " + abc.name);
                    this.loadAbc(abc);
                    executeScript(abc.lastScript);
                    // console.timeEnd("Execute ABC: " + abc.name);
                };

                ApplicationDomain.prototype.loadAbc = function (abc) {
                    if (Shumway.AVM2.Runtime.traceExecution.value) {
                        log("Loading: " + abc.name);
                    }
                    abc.applicationDomain = this;
                    Runtime.GlobalMultinameResolver.loadAbc(abc);
                    this.abcs.push(abc);

                    if (!this.base) {
                        _AVM2.AS.initialize(this);
                        Shumway.AVM2.Verifier.Type.initializeTypes(this);
                    }
                };

                ApplicationDomain.prototype.broadcastMessage = function (type, message, origin) {
                    try  {
                        this.onMessage.notify1(type, {
                            data: message,
                            origin: origin,
                            source: this
                        });
                    } catch (e) {
                        var avm2 = AVM2.instance;
                        avm2.exceptions.push({
                            source: type, message: e.message,
                            stack: e.stack });
                        throw e;
                    }
                };

                ApplicationDomain.prototype.traceLoadedClasses = function (lastOnly) {
                    var writer = new IndentingWriter();
                    lastOnly || writer.enter("Loaded Classes And Interfaces");
                    var classes = lastOnly ? [Shumway.ArrayUtilities.last(this.loadedClasses)] : this.loadedClasses;
                    classes.forEach(function (cls) {
                        if (cls !== Shumway.AVM2.AS.ASClass) {
                            cls.trace(writer);
                        }
                    });
                    lastOnly || writer.leave("");
                };
                return ApplicationDomain;
            })();
            Runtime.ApplicationDomain = ApplicationDomain;

            var SecurityDomain = (function () {
                function SecurityDomain(compartmentPath) {
                    this.compartment = createNewCompartment();
                    this.compartment.homePath = homePath;
                    this.compartment.release = release;
                    this.compartment.eval(snarf(compartmentPath));
                }
                SecurityDomain.prototype.initializeShell = function (sysMode, appMode) {
                    var compartment = this.compartment;
                    compartment.AVM2.initialize(sysMode, appMode);
                    compartment.AVM2.instance.systemDomain.executeAbc(compartment.grabAbc(homePath + "src/avm2/generated/builtin/builtin.abc"));
                    compartment.AVM2.instance.systemDomain.executeAbc(compartment.grabAbc(homePath + "src/avm2/generated/shell/shell.abc"));

                    // compartment.avm2.systemDomain.executeAbc(compartment.grabAbc(homePath + "src/avm2/generated/avmplus/avmplus.abc"));
                    this.systemDomain = compartment.AVM2.instance.systemDomain;
                    this.applicationDomain = compartment.AVM2.instance.applicationDomain;
                };
                return SecurityDomain;
            })();
            Runtime.SecurityDomain = SecurityDomain;
        })(_AVM2.Runtime || (_AVM2.Runtime = {}));
        var Runtime = _AVM2.Runtime;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

var Glue = Shumway.AVM2.Runtime.Glue;
var ApplicationDomain = Shumway.AVM2.Runtime.ApplicationDomain;
var AVM2 = Shumway.AVM2.Runtime.AVM2;
var EXECUTION_MODE = Shumway.AVM2.Runtime.ExecutionMode;
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (Runtime) {
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var ClassInfo = Shumway.AVM2.ABC.ClassInfo;
            var InstanceInfo = Shumway.AVM2.ABC.InstanceInfo;

            var assert = Shumway.Debug.assert;

            var defineReadOnlyProperty = Shumway.ObjectUtilities.defineReadOnlyProperty;

            var bindSafely = Shumway.FunctionUtilities.bindSafely;

            var counter = Shumway.Metrics.Counter.instance;

            var vmNextTrampolineId = 1;
            var vmNextMemoizerId = 1;

            function getMethodOverrideKey(methodInfo) {
                var key;
                if (methodInfo.holder instanceof ClassInfo) {
                    key = "static " + methodInfo.holder.instanceInfo.name.getOriginalName() + "::" + methodInfo.name.getOriginalName();
                } else if (methodInfo.holder instanceof InstanceInfo) {
                    key = methodInfo.holder.name.getOriginalName() + "::" + methodInfo.name.getOriginalName();
                } else {
                    key = methodInfo.name.getOriginalName();
                }
                return key;
            }
            Runtime.getMethodOverrideKey = getMethodOverrideKey;

            function checkMethodOverrides(methodInfo) {
                if (methodInfo.name) {
                    var key = getMethodOverrideKey(methodInfo);
                    if (key in Runtime.VM_METHOD_OVERRIDES) {
                        Shumway.Debug.warning("Overriding Method: " + key);
                        return Runtime.VM_METHOD_OVERRIDES[key];
                    }
                }
            }
            Runtime.checkMethodOverrides = checkMethodOverrides;

            

            /**
            * Creates a trampoline function stub which calls the result of a |forward| callback. The forward
            * callback is only executed the first time the trampoline is executed and its result is cached in
            * the trampoline closure.
            */
            function makeTrampoline(forward, parameterLength, description) {
                release || assert(forward && typeof forward === "function");
                return (function trampolineContext() {
                    var target = null;

                    /**
                    * Triggers the trampoline and executes it.
                    */
                    var trampoline = function execute() {
                        if (Shumway.AVM2.Runtime.traceExecution.value >= 3) {
                            log("Trampolining");
                        }
                        AVM2.countTimeline("Executing Trampoline");
                        Shumway.AVM2.Runtime.traceCallExecution.value > 1 && callWriter.writeLn("Trampoline: " + description);
                        if (!target) {
                            target = forward(trampoline);
                            release || assert(target);
                        }
                        return target.asApply(this, arguments);
                    };

                    /**
                    * Just triggers the trampoline without executing it.
                    */
                    trampoline.trigger = function trigger() {
                        AVM2.countTimeline("Triggering Trampoline");
                        if (!target) {
                            target = forward(trampoline);
                            release || assert(target);
                        }
                    };
                    trampoline.isTrampoline = true;
                    trampoline.debugName = "Trampoline #" + vmNextTrampolineId++;

                    // Make sure that the length property of the trampoline matches the trait's number of
                    // parameters. However, since we can't redefine the |length| property of a function,
                    // we define a new hidden |VM_LENGTH| property to store this value.
                    defineReadOnlyProperty(trampoline, Runtime.VM_LENGTH, parameterLength);
                    return trampoline;
                })();
            }
            Runtime.makeTrampoline = makeTrampoline;

            function makeMemoizer(qn, target) {
                function memoizer() {
                    AVM2.countTimeline("Runtime: Memoizing");

                    // release || assert (!Object.prototype.hasOwnProperty.call(this, "class"), this);
                    if (Shumway.AVM2.Runtime.traceExecution.value >= 3) {
                        log("Memoizing: " + qn);
                    }
                    Shumway.AVM2.Runtime.traceCallExecution.value > 1 && callWriter.writeLn("Memoizing: " + qn);
                    if (Runtime.isNativePrototype(this)) {
                        AVM2.countTimeline("Runtime: Method Closures");
                        return bindSafely(target.value, this);
                    }
                    if (isTrampoline(target.value)) {
                        // If the memoizer target is a trampoline then we need to trigger it before we bind the memoizer
                        // target to |this|. Triggering the trampoline will patch the memoizer target but not actually
                        // call it.
                        target.value.trigger();
                    }
                    release || assert(!isTrampoline(target.value), "We should avoid binding trampolines.");
                    var mc = null;
                    if (this instanceof Shumway.AVM2.AS.ASClass) {
                        AVM2.countTimeline("Runtime: Static Method Closures");
                        mc = bindSafely(target.value, this);
                        defineReadOnlyProperty(this, qn, mc);
                        return mc;
                    }
                    if (Object.prototype.hasOwnProperty.call(this, qn)) {
                        var pd = Object.getOwnPropertyDescriptor(this, qn);
                        if (pd.get) {
                            AVM2.countTimeline("Runtime: Method Closures");
                            return bindSafely(target.value, this);
                        }
                        AVM2.countTimeline("Runtime: Unpatched Memoizer");
                        return this[qn];
                    }
                    mc = bindSafely(target.value, this);
                    mc.methodInfo = target.value.methodInfo;
                    defineReadOnlyProperty(mc, Multiname.getPublicQualifiedName("prototype"), null);
                    defineReadOnlyProperty(this, qn, mc);
                    return mc;
                }
                var m = memoizer;
                AVM2.countTimeline("Runtime: Memoizers");
                m.isMemoizer = true;
                m.debugName = "Memoizer #" + vmNextMemoizerId++;
                return m;
            }
            Runtime.makeMemoizer = makeMemoizer;

            function isTrampoline(fn) {
                release || assert(fn && typeof fn === "function");
                return fn.isTrampoline;
            }

            function isMemoizer(fn) {
                release || assert(fn && typeof fn === "function");
                return fn.isMemoizer;
            }
            Runtime.isMemoizer = isMemoizer;
        })(AVM2.Runtime || (AVM2.Runtime = {}));
        var Runtime = AVM2.Runtime;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        var Scope = Shumway.AVM2.Runtime.Scope;
        var asCoerceByMultiname = Shumway.AVM2.Runtime.asCoerceByMultiname;
        var asGetSlot = Shumway.AVM2.Runtime.asGetSlot;
        var asSetSlot = Shumway.AVM2.Runtime.asSetSlot;
        var asCoerce = Shumway.AVM2.Runtime.asCoerce;
        var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
        var asAsType = Shumway.AVM2.Runtime.asAsType;
        var asTypeOf = Shumway.AVM2.Runtime.asTypeOf;
        var asIsInstanceOf = Shumway.AVM2.Runtime.asIsInstanceOf;
        var asIsType = Shumway.AVM2.Runtime.asIsType;
        var applyType = Shumway.AVM2.Runtime.applyType;
        var createFunction = Shumway.AVM2.Runtime.createFunction;
        var createClass = Shumway.AVM2.Runtime.createClass;
        var getDescendants = Shumway.AVM2.Runtime.getDescendants;
        var checkFilter = Shumway.AVM2.Runtime.checkFilter;
        var asAdd = Shumway.AVM2.Runtime.asAdd;
        var translateError = Shumway.AVM2.Runtime.translateError;
        var asCreateActivation = Shumway.AVM2.Runtime.asCreateActivation;
        var sliceArguments = Shumway.AVM2.Runtime.sliceArguments;
        var boxValue = Shumway.ObjectUtilities.boxValue;
        var popManyInto = Shumway.ArrayUtilities.popManyInto;
        var construct = Shumway.AVM2.Runtime.construct;
        var Multiname = Shumway.AVM2.ABC.Multiname;
        var assert = Shumway.Debug.assert;
        var HasNext2Info = Shumway.AVM2.Runtime.HasNext2Info;

        var counter = Shumway.Metrics.Counter.instance;

        /**
        * Helps the interpreter allocate fewer Scope objects.
        */
        var ScopeStack = (function () {
            function ScopeStack(parent) {
                this.parent = parent;
                this.stack = [];
                this.isWith = [];
            }
            ScopeStack.prototype.push = function (object, isWith) {
                this.stack.push(object);
                this.isWith.push(!!isWith);
            };

            ScopeStack.prototype.get = function (index) {
                return this.stack[index];
            };

            ScopeStack.prototype.clear = function () {
                this.stack.length = 0;
                this.isWith.length = 0;
            };

            ScopeStack.prototype.pop = function () {
                this.isWith.pop();
                this.stack.pop();
            };

            ScopeStack.prototype.topScope = function () {
                if (!this.scopes) {
                    this.scopes = [];
                }
                var parent = this.parent;
                for (var i = 0; i < this.stack.length; i++) {
                    var object = this.stack[i], isWith = this.isWith[i], scope = this.scopes[i];
                    if (!scope || scope.parent !== parent || scope.object !== object || scope.isWith !== isWith) {
                        scope = this.scopes[i] = new Scope(parent, object, isWith);
                    }
                    parent = scope;
                }
                return parent;
            };
            return ScopeStack;
        })();

        function popNameInto(stack, mn, out) {
            out.flags = mn.flags;
            if (mn.isRuntimeName()) {
                out.name = stack.pop();
            } else {
                out.name = mn.name;
            }
            if (mn.isRuntimeNamespace()) {
                out.namespaces = [stack.pop()];
            } else {
                out.namespaces = mn.namespaces;
            }
        }

        var Interpreter = (function () {
            function Interpreter() {
            }
            Interpreter.interpretMethod = function ($this, method, savedScope, methodArgs) {
                release || assert(method.analysis);
                AVM2.countTimeline("Interpret Method");
                var abc = method.abc;
                var ints = abc.constantPool.ints;
                var uints = abc.constantPool.uints;
                var doubles = abc.constantPool.doubles;
                var strings = abc.constantPool.strings;
                var methods = abc.methods;
                var multinames = abc.constantPool.multinames;
                var domain = abc.applicationDomain;
                var exceptions = method.exceptions;

                var locals = [$this];
                var stack = [], scopeStack = new ScopeStack(savedScope);

                var parameterCount = method.parameters.length;
                var argCount = methodArgs.length;

                var value;
                for (var i = 0; i < parameterCount; i++) {
                    var parameter = method.parameters[i];
                    if (i < argCount) {
                        value = methodArgs[i];
                    } else {
                        value = parameter.value;
                    }
                    if (parameter.type && !parameter.type.isAnyName()) {
                        value = asCoerceByMultiname(method, parameter.type, value);
                    }
                    locals.push(value);
                }

                if (method.needsRest()) {
                    locals.push(sliceArguments(methodArgs, parameterCount));
                } else if (method.needsArguments()) {
                    locals.push(sliceArguments(methodArgs, 0));
                }

                var bytecodes = method.analysis.bytecodes;

                var object, index, multiname, result, a, b, args = [], mn = Multiname.TEMPORARY;
                var hasNext2Infos = [];
                interpretLabel:
                for (var pc = 0, end = bytecodes.length; pc < end;) {
                    try  {
                        var bc = bytecodes[pc];
                        var op = bc.op;
                        switch (op | 0) {
                            case 3 /* throw */:
                                throw stack.pop();
                            case 4 /* getsuper */:
                                popNameInto(stack, multinames[bc.index], mn);
                                stack.push(stack.pop().asGetSuper(savedScope, mn.namespaces, mn.name, mn.flags));
                                break;
                            case 5 /* setsuper */:
                                value = stack.pop();
                                popNameInto(stack, multinames[bc.index], mn);
                                stack.pop().asSetSuper(savedScope, mn.namespaces, mn.name, mn.flags, value);
                                break;
                            case 8 /* kill */:
                                locals[bc.index] = undefined;
                                break;
                            case 12 /* ifnlt */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = !(a < b) ? bc.offset : pc + 1;
                                continue;
                            case 24 /* ifge */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a >= b ? bc.offset : pc + 1;
                                continue;
                            case 13 /* ifnle */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = !(a <= b) ? bc.offset : pc + 1;
                                continue;
                            case 23 /* ifgt */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a > b ? bc.offset : pc + 1;
                                continue;
                            case 14 /* ifngt */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = !(a > b) ? bc.offset : pc + 1;
                                continue;
                            case 22 /* ifle */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a <= b ? bc.offset : pc + 1;
                                continue;
                            case 15 /* ifnge */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = !(a >= b) ? bc.offset : pc + 1;
                                continue;
                            case 21 /* iflt */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a < b ? bc.offset : pc + 1;
                                continue;
                            case 16 /* jump */:
                                pc = bc.offset;
                                continue;
                            case 17 /* iftrue */:
                                pc = !!stack.pop() ? bc.offset : pc + 1;
                                continue;
                            case 18 /* iffalse */:
                                pc = !stack.pop() ? bc.offset : pc + 1;
                                continue;
                            case 19 /* ifeq */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a == b ? bc.offset : pc + 1;
                                continue;
                            case 20 /* ifne */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a != b ? bc.offset : pc + 1;
                                continue;
                            case 25 /* ifstricteq */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a === b ? bc.offset : pc + 1;
                                continue;
                            case 26 /* ifstrictne */:
                                b = stack.pop();
                                a = stack.pop();
                                pc = a !== b ? bc.offset : pc + 1;
                                continue;
                            case 27 /* lookupswitch */:
                                index = stack.pop();
                                if (index < 0 || index >= bc.offsets.length) {
                                    index = bc.offsets.length - 1; // The last target is the default.
                                }
                                pc = bc.offsets[index];
                                continue;
                            case 28 /* pushwith */:
                                scopeStack.push(boxValue(stack.pop()), true);
                                break;
                            case 29 /* popscope */:
                                scopeStack.pop();
                                break;
                            case 30 /* nextname */:
                                index = stack.pop();
                                stack[stack.length - 1] = boxValue(stack[stack.length - 1]).asNextName(index);
                                break;
                            case 35 /* nextvalue */:
                                index = stack.pop();
                                stack[stack.length - 1] = boxValue(stack[stack.length - 1]).asNextValue(index);
                                break;
                            case 50 /* hasnext2 */:
                                var hasNext2Info = hasNext2Infos[pc] || (hasNext2Infos[pc] = new HasNext2Info(null, 0));
                                object = locals[bc.object];
                                index = locals[bc.index];
                                hasNext2Info.object = object;
                                hasNext2Info.index = index;
                                Object(object).asHasNext2(hasNext2Info);
                                locals[bc.object] = hasNext2Info.object;
                                locals[bc.index] = hasNext2Info.index;
                                stack.push(!!hasNext2Info.index);
                                break;
                            case 32 /* pushnull */:
                                stack.push(null);
                                break;
                            case 33 /* pushundefined */:
                                stack.push(undefined);
                                break;
                            case 36 /* pushbyte */:
                            case 37 /* pushshort */:
                                stack.push(bc.value);
                                break;
                            case 44 /* pushstring */:
                                stack.push(strings[bc.index]);
                                break;
                            case 45 /* pushint */:
                                stack.push(ints[bc.index]);
                                break;
                            case 46 /* pushuint */:
                                stack.push(uints[bc.index]);
                                break;
                            case 47 /* pushdouble */:
                                stack.push(doubles[bc.index]);
                                break;
                            case 38 /* pushtrue */:
                                stack.push(true);
                                break;
                            case 39 /* pushfalse */:
                                stack.push(false);
                                break;
                            case 40 /* pushnan */:
                                stack.push(NaN);
                                break;
                            case 41 /* pop */:
                                stack.pop();
                                break;
                            case 42 /* dup */:
                                stack.push(stack[stack.length - 1]);
                                break;
                            case 43 /* swap */:
                                object = stack[stack.length - 1];
                                stack[stack.length - 1] = stack[stack.length - 2];
                                stack[stack.length - 2] = object;
                                break;
                            case 48 /* pushscope */:
                                scopeStack.push(boxValue(stack.pop()), false);
                                break;
                            case 64 /* newfunction */:
                                stack.push(createFunction(methods[bc.index], scopeStack.topScope(), true));
                                break;
                            case 65 /* call */:
                                popManyInto(stack, bc.argCount, args);
                                object = stack.pop();
                                stack[stack.length - 1] = stack[stack.length - 1].asApply(object, args);
                                break;
                            case 66 /* construct */:
                                popManyInto(stack, bc.argCount, args);
                                stack[stack.length - 1] = construct(stack[stack.length - 1], args);
                                break;
                            case 71 /* returnvoid */:
                                return;
                            case 72 /* returnvalue */:
                                if (method.returnType) {
                                    return asCoerceByMultiname(method, method.returnType, stack.pop());
                                }
                                return stack.pop();
                            case 73 /* constructsuper */:
                                popManyInto(stack, bc.argCount, args);
                                object = stack.pop();
                                savedScope.object.baseClass.instanceConstructorNoInitialize.apply(object, args);
                                break;
                            case 74 /* constructprop */:
                                popManyInto(stack, bc.argCount, args);
                                popNameInto(stack, multinames[bc.index], mn);
                                object = boxValue(stack[stack.length - 1]);
                                object = object.asConstructProperty(mn.namespaces, mn.name, mn.flags, args);
                                stack[stack.length - 1] = object;
                                break;
                            case 75 /* callsuperid */:
                                Shumway.Debug.notImplemented("OP.callsuperid");
                                break;
                            case 76 /* callproplex */:
                            case 70 /* callproperty */:
                            case 79 /* callpropvoid */:
                                popManyInto(stack, bc.argCount, args);
                                popNameInto(stack, multinames[bc.index], mn);
                                result = boxValue(stack.pop()).asCallProperty(mn.namespaces, mn.name, mn.flags, op === 76 /* callproplex */, args);
                                if (op !== 79 /* callpropvoid */) {
                                    stack.push(result);
                                }
                                break;
                            case 69 /* callsuper */:
                            case 78 /* callsupervoid */:
                                popManyInto(stack, bc.argCount, args);
                                popNameInto(stack, multinames[bc.index], mn);
                                result = stack.pop().asCallSuper(savedScope, mn.namespaces, mn.name, mn.flags, args);
                                if (op !== 78 /* callsupervoid */) {
                                    stack.push(result);
                                }
                                break;
                            case 83 /* applytype */:
                                popManyInto(stack, bc.argCount, args);
                                stack[stack.length - 1] = applyType(method, stack[stack.length - 1], args);
                                break;
                            case 85 /* newobject */:
                                object = {};
                                for (var i = 0; i < bc.argCount; i++) {
                                    value = stack.pop();
                                    object[Multiname.getPublicQualifiedName(stack.pop())] = value;
                                }
                                stack.push(object);
                                break;
                            case 86 /* newarray */:
                                object = [];
                                popManyInto(stack, bc.argCount, args);
                                object.push.apply(object, args);
                                stack.push(object);
                                break;
                            case 87 /* newactivation */:
                                release || assert(method.needsActivation());
                                stack.push(asCreateActivation(method));
                                break;
                            case 88 /* newclass */:
                                stack[stack.length - 1] = createClass(abc.classes[bc.index], stack[stack.length - 1], scopeStack.topScope());
                                break;
                            case 89 /* getdescendants */:
                                popNameInto(stack, multinames[bc.index], mn);
                                stack.push(getDescendants(stack.pop(), mn));
                                break;
                            case 90 /* newcatch */:
                                release || assert(exceptions[bc.index].scopeObject);
                                stack.push(exceptions[bc.index].scopeObject);
                                break;
                            case 94 /* findproperty */:
                            case 93 /* findpropstrict */:
                                popNameInto(stack, multinames[bc.index], mn);
                                stack.push(scopeStack.topScope().findScopeProperty(mn.namespaces, mn.name, mn.flags, method, op === 93 /* findpropstrict */, false));
                                break;
                            case 96 /* getlex */:
                                multiname = multinames[bc.index];
                                object = scopeStack.topScope().findScopeProperty(multiname.namespaces, multiname.name, multiname.flags, method, true, false);
                                stack.push(object.asGetProperty(multiname.namespaces, multiname.name, multiname.flags));
                                break;
                            case 104 /* initproperty */:
                            case 97 /* setproperty */:
                                value = stack.pop();
                                popNameInto(stack, multinames[bc.index], mn);
                                boxValue(stack.pop()).asSetProperty(mn.namespaces, mn.name, mn.flags, value);
                                break;
                            case 98 /* getlocal */:
                                stack.push(locals[bc.index]);
                                break;
                            case 99 /* setlocal */:
                                locals[bc.index] = stack.pop();
                                break;
                            case 100 /* getglobalscope */:
                                stack.push(savedScope.global.object);
                                break;
                            case 101 /* getscopeobject */:
                                stack.push(scopeStack.get(bc.index));
                                break;
                            case 102 /* getproperty */:
                                popNameInto(stack, multinames[bc.index], mn);
                                stack[stack.length - 1] = boxValue(stack[stack.length - 1]).asGetProperty(mn.namespaces, mn.name, mn.flags);
                                break;
                            case 106 /* deleteproperty */:
                                popNameInto(stack, multinames[bc.index], mn);
                                stack[stack.length - 1] = boxValue(stack[stack.length - 1]).asDeleteProperty(mn.namespaces, mn.name, mn.flags);
                                break;
                            case 108 /* getslot */:
                                stack[stack.length - 1] = asGetSlot(stack[stack.length - 1], bc.index);
                                break;
                            case 109 /* setslot */:
                                value = stack.pop();
                                object = stack.pop();
                                asSetSlot(object, bc.index, value);
                                break;
                            case 112 /* convert_s */:
                                stack[stack.length - 1] = stack[stack.length - 1] + '';
                                break;
                            case 131 /* coerce_i */:
                            case 115 /* convert_i */:
                                stack[stack.length - 1] |= 0;
                                break;
                            case 136 /* coerce_u */:
                            case 116 /* convert_u */:
                                stack[stack.length - 1] >>>= 0;
                                break;
                            case 132 /* coerce_d */:
                            case 117 /* convert_d */:
                                stack[stack.length - 1] = +stack[stack.length - 1];
                                break;
                            case 129 /* coerce_b */:
                            case 118 /* convert_b */:
                                stack[stack.length - 1] = !!stack[stack.length - 1];
                                break;
                            case 120 /* checkfilter */:
                                stack[stack.length - 1] = checkFilter(stack[stack.length - 1]);
                                break;
                            case 128 /* coerce */:
                                stack[stack.length - 1] = asCoerce(domain.getType(multinames[bc.index]), stack[stack.length - 1]);
                                break;
                            case 130 /* coerce_a */:
                                break;
                            case 133 /* coerce_s */:
                                stack[stack.length - 1] = asCoerceString(stack[stack.length - 1]);
                                break;
                            case 134 /* astype */:
                                stack[stack.length - 2] = asAsType(domain.getType(multinames[bc.index]), stack[stack.length - 1]);
                                break;
                            case 135 /* astypelate */:
                                stack[stack.length - 2] = asAsType(stack.pop(), stack[stack.length - 1]);
                                break;
                            case 137 /* coerce_o */:
                                object = stack[stack.length - 1];
                                stack[stack.length - 1] = object == undefined ? null : object;
                                break;
                            case 144 /* negate */:
                                stack[stack.length - 1] = -stack[stack.length - 1];
                                break;
                            case 145 /* increment */:
                                ++stack[stack.length - 1];
                                break;
                            case 146 /* inclocal */:
                                ++locals[bc.index];
                                break;
                            case 147 /* decrement */:
                                --stack[stack.length - 1];
                                break;
                            case 148 /* declocal */:
                                --locals[bc.index];
                                break;
                            case 149 /* typeof */:
                                stack[stack.length - 1] = asTypeOf(stack[stack.length - 1]);
                                break;
                            case 150 /* not */:
                                stack[stack.length - 1] = !stack[stack.length - 1];
                                break;
                            case 151 /* bitnot */:
                                stack[stack.length - 1] = ~stack[stack.length - 1];
                                break;
                            case 160 /* add */:
                                stack[stack.length - 2] = asAdd(stack[stack.length - 2], stack.pop());
                                break;
                            case 161 /* subtract */:
                                stack[stack.length - 2] -= stack.pop();
                                break;
                            case 162 /* multiply */:
                                stack[stack.length - 2] *= stack.pop();
                                break;
                            case 163 /* divide */:
                                stack[stack.length - 2] /= stack.pop();
                                break;
                            case 164 /* modulo */:
                                stack[stack.length - 2] %= stack.pop();
                                break;
                            case 165 /* lshift */:
                                stack[stack.length - 2] <<= stack.pop();
                                break;
                            case 166 /* rshift */:
                                stack[stack.length - 2] >>= stack.pop();
                                break;
                            case 167 /* urshift */:
                                stack[stack.length - 2] >>>= stack.pop();
                                break;
                            case 168 /* bitand */:
                                stack[stack.length - 2] &= stack.pop();
                                break;
                            case 169 /* bitor */:
                                stack[stack.length - 2] |= stack.pop();
                                break;
                            case 170 /* bitxor */:
                                stack[stack.length - 2] ^= stack.pop();
                                break;
                            case 171 /* equals */:
                                stack[stack.length - 2] = stack[stack.length - 2] == stack.pop();
                                break;
                            case 172 /* strictequals */:
                                stack[stack.length - 2] = stack[stack.length - 2] === stack.pop();
                                break;
                            case 173 /* lessthan */:
                                stack[stack.length - 2] = stack[stack.length - 2] < stack.pop();
                                break;
                            case 174 /* lessequals */:
                                stack[stack.length - 2] = stack[stack.length - 2] <= stack.pop();
                                break;
                            case 175 /* greaterthan */:
                                stack[stack.length - 2] = stack[stack.length - 2] > stack.pop();
                                break;
                            case 176 /* greaterequals */:
                                stack[stack.length - 2] = stack[stack.length - 2] >= stack.pop();
                                break;
                            case 177 /* instanceof */:
                                stack[stack.length - 2] = asIsInstanceOf(stack.pop(), stack[stack.length - 1]);
                                break;
                            case 178 /* istype */:
                                stack[stack.length - 1] = asIsType(domain.getType(multinames[bc.index]), stack[stack.length - 1]);
                                break;
                            case 179 /* istypelate */:
                                stack[stack.length - 2] = asIsType(stack.pop(), stack[stack.length - 1]);
                                break;
                            case 180 /* in */:
                                stack[stack.length - 2] = boxValue(stack.pop()).asHasProperty(null, stack[stack.length - 1]);
                                break;
                            case 192 /* increment_i */:
                                stack[stack.length - 1] = (stack[stack.length - 1] | 0) + 1;
                                break;
                            case 193 /* decrement_i */:
                                stack[stack.length - 1] = (stack[stack.length - 1] | 0) - 1;
                                break;
                            case 194 /* inclocal_i */:
                                locals[bc.index] = (locals[bc.index] | 0) + 1;
                                break;
                            case 195 /* declocal_i */:
                                locals[bc.index] = (locals[bc.index] | 0) - 1;
                                break;
                            case 196 /* negate_i */:
                                // Negation entails casting to int
                                stack[stack.length - 1] = ~stack[stack.length - 1];
                                break;
                            case 197 /* add_i */:
                                stack[stack.length - 2] = stack[stack.length - 2] + stack.pop() | 0;
                                break;
                            case 198 /* subtract_i */:
                                stack[stack.length - 2] = stack[stack.length - 2] - stack.pop() | 0;
                                break;
                            case 199 /* multiply_i */:
                                stack[stack.length - 2] = stack[stack.length - 2] * stack.pop() | 0;
                                break;
                            case 208 /* getlocal0 */:
                            case 209 /* getlocal1 */:
                            case 210 /* getlocal2 */:
                            case 211 /* getlocal3 */:
                                stack.push(locals[op - 208 /* getlocal0 */]);
                                break;
                            case 212 /* setlocal0 */:
                            case 213 /* setlocal1 */:
                            case 214 /* setlocal2 */:
                            case 215 /* setlocal3 */:
                                locals[op - 212 /* setlocal0 */] = stack.pop();
                                break;
                            case 6 /* dxns */:
                                Shumway.AVM2.AS.ASXML.defaultNamespace = strings[bc.index];
                                break;
                            case 7 /* dxnslate */:
                                Shumway.AVM2.AS.ASXML.defaultNamespace = stack.pop();
                                break;
                            case 239 /* debug */:
                            case 240 /* debugline */:
                            case 241 /* debugfile */:
                                break;
                            default:
                                Shumway.Debug.notImplemented(Shumway.AVM2.opcodeName(op));
                        }
                        pc++;
                    } catch (e) {
                        if (exceptions.length < 1) {
                            throw e;
                        }

                        e = translateError(domain, e);
                        for (var i = 0, j = exceptions.length; i < j; i++) {
                            var handler = exceptions[i];
                            if (pc >= handler.start && pc <= handler.end && (!handler.typeName || domain.getType(handler.typeName).isType(e))) {
                                stack.length = 0;
                                stack.push(e);
                                scopeStack.clear();
                                pc = handler.offset;
                                continue interpretLabel;
                            }
                        }
                        throw e;
                    }
                }
            };
            return Interpreter;
        })();
        AVM2.Interpreter = Interpreter;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        /**
        * Random collection of Hacks to get demos work, this file should be empty.
        */
        (function (Runtime) {
            Runtime.VM_METHOD_OVERRIDES["static mochi.as3.MochiServices::connect"] = function () {
                return;
            };

            Runtime.VM_METHOD_OVERRIDES["static MochiBot::track"] = function () {
                return;
            };

            Runtime.VM_METHOD_OVERRIDES["com.midasplayer.debug.DebugLog::trace"] = function (msg) {
                log(msg);
            };

            Runtime.VM_METHOD_OVERRIDES["com.midasplayer.engine.comm.DebugGameComm::getGameData"] = function () {
                return '<gamedata randomseed="554884453" version="1">\n<musicOn>true</musicOn>\n<soundOn>true</soundOn>\n<isShortGame>false</isShortGame>\n<booster_1>0</booster_1>\n<booster_2>0</booster_2>\n<booster_3>0</booster_3>\n<booster_4>0</booster_4>\n<booster_5>0</booster_5>\n<bestScore>0</bestScore>\n<bestChain>0</bestChain>\n<bestLevel>0</bestLevel>\n<bestCrushed>0</bestCrushed>\n<bestMixed>0</bestMixed>\n<text id="outro.crushed">Candy crushed</text>\n<text id="outro.bestever">best ever</text>\n<text id="outro.trophy.two">scored {0} in one game</text>\n<text id="outro.combo_color_color">All Clear Created</text>\n<text id="outro.trophy.one">crushed {0} candy in one game</text>\n<text id="outro.score">Score</text>\n<text id="outro.opengame">Please register to play the full game</text>\n<text id="outro.chain">Longest chain</text>\n<text id="outro.time">Game ends in {0} seconds</text>\n<text id="outro.combo_color_line">Super Stripes Created</text>\n<text id="game.nomoves">No more moves!</text>\n<text id="outro.combo_wrapper_line">Mega-Candy Created</text>\n<text id="intro.time">Game starts in {0} seconds</text>\n<text id="outro.now">now</text>\n<text id="outro.level">Level reached</text>\n<text id="outro.title">Game Over</text>\n<text id="intro.info1">Match 3 Candy of the same colour to crush them. Matching 4 or 5 in different formations generates special sweets that are extra tasty.</text>\n<text id="intro.info2">You can also combine the special sweets for additional effects by switching them with each other. Try these combinations for a taste you will not forget: </text>\n<text id="outro.combo_color_wrapper">Double Colour Bombs Created</text>\n<text id="outro.trophy.three">made {0} combined candy in one game</text>\n<text id="intro.title">Play like this:</text>\n</gamedata>';
            };

            Runtime.VM_METHOD_OVERRIDES["com.antkarlov.Preloader::com.antkarlov:Preloader.isUrl"] = function () {
                return true;
            };

            Runtime.VM_METHOD_OVERRIDES["static com.demonsters.debugger.MonsterDebugger::initialize"] = function () {
                // Socket is not supported anyway
            };

            Runtime.VM_METHOD_OVERRIDES["com.spilgames.api.core.tracking.TrackConfig::getTrackers"] = function () {
                return [];
            };

            Runtime.VM_METHOD_OVERRIDES["com.spilgames.api.components.TextFields.AutoFitTextFieldEx::com.spilgames.api.components.TextFields:AutoFitTextFieldEx.updateProperties"] = Runtime.VM_METHOD_OVERRIDES["com.spilgames.api.components.TextFields.AutoFitTextFieldEx::com.spilgames.api.components.TextFields:AutoFitTextFieldEx.updateTextSize"] = function () {
                // flash.text.engine stuff
            };
        })(AVM2.Runtime || (AVM2.Runtime = {}));
        var Runtime = AVM2.Runtime;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        var Multiname = Shumway.AVM2.ABC.Multiname;

        var forEachPublicProperty = Shumway.AVM2.Runtime.forEachPublicProperty;

        (function (AMF0Marker) {
            AMF0Marker[AMF0Marker["NUMBER"] = 0x00] = "NUMBER";
            AMF0Marker[AMF0Marker["BOOLEAN"] = 0x01] = "BOOLEAN";
            AMF0Marker[AMF0Marker["STRING"] = 0x02] = "STRING";
            AMF0Marker[AMF0Marker["OBJECT"] = 0x03] = "OBJECT";
            AMF0Marker[AMF0Marker["NULL"] = 0x05] = "NULL";
            AMF0Marker[AMF0Marker["UNDEFINED"] = 0x06] = "UNDEFINED";
            AMF0Marker[AMF0Marker["REFERENCE"] = 0x07] = "REFERENCE";
            AMF0Marker[AMF0Marker["ECMA_ARRAY"] = 0x08] = "ECMA_ARRAY";
            AMF0Marker[AMF0Marker["OBJECT_END"] = 0x09] = "OBJECT_END";
            AMF0Marker[AMF0Marker["STRICT_ARRAY"] = 0x0A] = "STRICT_ARRAY";
            AMF0Marker[AMF0Marker["DATE"] = 0x0B] = "DATE";
            AMF0Marker[AMF0Marker["LONG_STRING"] = 0x0C] = "LONG_STRING";
            AMF0Marker[AMF0Marker["XML"] = 0x0F] = "XML";
            AMF0Marker[AMF0Marker["TYPED_OBJECT"] = 0x10] = "TYPED_OBJECT";
            AMF0Marker[AMF0Marker["AVMPLUS"] = 0x11] = "AVMPLUS";
        })(AVM2.AMF0Marker || (AVM2.AMF0Marker = {}));
        var AMF0Marker = AVM2.AMF0Marker;

        function writeString(ba, s) {
            if (s.length > 0xFFFF) {
                throw 'AMF short string exceeded';
            }
            if (!s.length) {
                ba.writeByte(0x00);
                ba.writeByte(0x00);
                return;
            }
            var bytes = Shumway.StringUtilities.utf8decode(s);
            ba.writeByte((bytes.length >> 8) & 255);
            ba.writeByte(bytes.length & 255);
            for (var i = 0; i < bytes.length; i++) {
                ba.writeByte(bytes[i]);
            }
        }

        function readString(ba) {
            var byteLength = (ba.readByte() << 8) | ba.readByte();
            if (!byteLength) {
                return '';
            }

            var buffer = new Uint8Array(byteLength);
            for (var i = 0; i < byteLength; i++) {
                buffer[i] = ba.readByte();
            }

            return Shumway.StringUtilities.utf8encode(buffer);
        }

        function writeDouble(ba, value) {
            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            view.setFloat64(0, value, false);
            for (var i = 0; i < buffer.byteLength; i++) {
                ba.writeByte(view.getUint8(i));
            }
        }

        function readDouble(ba) {
            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            for (var i = 0; i < buffer.byteLength; i++) {
                view.setUint8(i, ba.readByte());
            }
            return view.getFloat64(0, false);
        }

        function setAvmProperty(obj, propertyName, value) {
            obj.asSetPublicProperty(propertyName, value);
        }

        var AMF0 = (function () {
            function AMF0() {
            }
            AMF0.write = function (ba, obj) {
                switch (typeof obj) {
                    case 'boolean':
                        ba.writeByte(1 /* BOOLEAN */);
                        ba.writeByte(obj ? 0x01 : 0x00);
                        break;
                    case 'number':
                        ba.writeByte(0 /* NUMBER */);
                        writeDouble(ba, obj);
                        break;
                    case 'undefined':
                        ba.writeByte(6 /* UNDEFINED */);
                        break;
                    case 'string':
                        ba.writeByte(2 /* STRING */);
                        writeString(ba, obj);
                        break;
                    case 'object':
                        if (obj === null) {
                            ba.writeByte(5 /* NULL */);
                        } else if (Array.isArray(obj)) {
                            ba.writeByte(8 /* ECMA_ARRAY */);
                            ba.writeByte((obj.length >>> 24) & 255);
                            ba.writeByte((obj.length >> 16) & 255);
                            ba.writeByte((obj.length >> 8) & 255);
                            ba.writeByte(obj.length & 255);
                            forEachPublicProperty(obj, function (key, value) {
                                writeString(ba, key);
                                this.write(ba, value);
                            }, this);
                            ba.writeByte(0x00);
                            ba.writeByte(0x00);
                            ba.writeByte(9 /* OBJECT_END */);
                        } else {
                            ba.writeByte(3 /* OBJECT */);
                            forEachPublicProperty(obj, function (key, value) {
                                writeString(ba, key);
                                this.write(ba, value);
                            }, this);
                            ba.writeByte(0x00);
                            ba.writeByte(0x00);
                            ba.writeByte(9 /* OBJECT_END */);
                        }
                        return;
                }
            };

            AMF0.read = function (ba) {
                var marker = ba.readByte();
                switch (marker) {
                    case 0 /* NUMBER */:
                        return readDouble(ba);
                    case 1 /* BOOLEAN */:
                        return !!ba.readByte();
                    case 2 /* STRING */:
                        return readString(ba);
                    case 3 /* OBJECT */:
                        var obj = {};
                        while (true) {
                            var key = readString(ba);
                            if (!key.length)
                                break;
                            setAvmProperty(obj, key, this.read(ba));
                        }
                        if (ba.readByte() !== 9 /* OBJECT_END */) {
                            throw 'AMF0 End marker is not found';
                        }
                        return obj;
                    case 5 /* NULL */:
                        return null;
                    case 6 /* UNDEFINED */:
                        return undefined;
                    case 8 /* ECMA_ARRAY */:
                        var arr = [];
                        arr.length = (ba.readByte() << 24) | (ba.readByte() << 16) | (ba.readByte() << 8) | ba.readByte();
                        while (true) {
                            var key = readString(ba);
                            if (!key.length)
                                break;
                            setAvmProperty(arr, key, this.read(ba));
                        }
                        if (ba.readByte() !== 9 /* OBJECT_END */) {
                            throw 'AMF0 End marker is not found';
                        }
                        return arr;
                    case 10 /* STRICT_ARRAY */:
                        var arr = [];
                        arr.length = (ba.readByte() << 24) | (ba.readByte() << 16) | (ba.readByte() << 8) | ba.readByte();
                        for (var i = 0; i < arr.length; i++) {
                            arr[i] = this.read(ba);
                        }
                        return arr;
                    case 17 /* AVMPLUS */:
                        return readAmf3Data(ba, {});
                    default:
                        throw 'AMF0 Unknown marker ' + marker;
                }
            };
            return AMF0;
        })();
        AVM2.AMF0 = AMF0;

        (function (AMF3Marker) {
            AMF3Marker[AMF3Marker["UNDEFINED"] = 0x00] = "UNDEFINED";
            AMF3Marker[AMF3Marker["NULL"] = 0x01] = "NULL";
            AMF3Marker[AMF3Marker["FALSE"] = 0x02] = "FALSE";
            AMF3Marker[AMF3Marker["TRUE"] = 0x03] = "TRUE";
            AMF3Marker[AMF3Marker["INTEGER"] = 0x04] = "INTEGER";
            AMF3Marker[AMF3Marker["DOUBLE"] = 0x05] = "DOUBLE";
            AMF3Marker[AMF3Marker["STRING"] = 0x06] = "STRING";
            AMF3Marker[AMF3Marker["XML_DOC"] = 0x07] = "XML_DOC";
            AMF3Marker[AMF3Marker["DATE"] = 0x08] = "DATE";
            AMF3Marker[AMF3Marker["ARRAY"] = 0x09] = "ARRAY";
            AMF3Marker[AMF3Marker["OBJECT"] = 0x0A] = "OBJECT";
            AMF3Marker[AMF3Marker["XML"] = 0x0B] = "XML";
            AMF3Marker[AMF3Marker["BYTEARRAY"] = 0x0C] = "BYTEARRAY";
            AMF3Marker[AMF3Marker["VECTOR_INT"] = 0x0D] = "VECTOR_INT";
            AMF3Marker[AMF3Marker["VECTOR_UINT"] = 0x0E] = "VECTOR_UINT";
            AMF3Marker[AMF3Marker["VECTOR_DOUBLE"] = 0x0F] = "VECTOR_DOUBLE";
            AMF3Marker[AMF3Marker["VECTOR_OBJECT"] = 0x10] = "VECTOR_OBJECT";
            AMF3Marker[AMF3Marker["DICTIONARY"] = 0x11] = "DICTIONARY";
        })(AVM2.AMF3Marker || (AVM2.AMF3Marker = {}));
        var AMF3Marker = AVM2.AMF3Marker;

        function readU29(ba) {
            var b1 = ba.readByte();
            if ((b1 & 0x80) === 0) {
                return b1;
            }
            var b2 = ba.readByte();
            if ((b2 & 0x80) === 0) {
                return ((b1 & 0x7F) << 7) | b2;
            }
            var b3 = ba.readByte();
            if ((b3 & 0x80) === 0) {
                return ((b1 & 0x7F) << 14) | ((b2 & 0x7F) << 7) | b3;
            }
            var b4 = ba.readByte();
            return ((b1 & 0x7F) << 22) | ((b2 & 0x7F) << 15) | ((b3 & 0x7F) << 8) | b4;
        }

        function writeU29(ba, value) {
            if ((value & 0xFFFFFF80) === 0) {
                ba.writeByte(value & 0x7F);
            } else if ((value & 0xFFFFC000) === 0) {
                ba.writeByte(0x80 | ((value >> 7) & 0x7F));
                ba.writeByte(value & 0x7F);
            } else if ((value & 0xFFE00000) === 0) {
                ba.writeByte(0x80 | ((value >> 14) & 0x7F));
                ba.writeByte(0x80 | ((value >> 7) & 0x7F));
                ba.writeByte(value & 0x7F);
            } else if ((value & 0xC0000000) === 0) {
                ba.writeByte(0x80 | ((value >> 22) & 0x7F));
                ba.writeByte(0x80 | ((value >> 15) & 0x7F));
                ba.writeByte(0x80 | ((value >> 8) & 0x7F));
                ba.writeByte(value & 0xFF);
            } else {
                throw 'AMF3 U29 range';
            }
        }

        function readUTF8vr(ba, caches) {
            var u29s = readU29(ba);
            if (u29s === 0x01) {
                return '';
            }
            var stringsCache = caches.stringsCache || (caches.stringsCache = []);
            if ((u29s & 1) === 0) {
                return stringsCache[u29s >> 1];
            }

            var byteLength = u29s >> 1;
            var buffer = new Uint8Array(byteLength);
            for (var i = 0; i < byteLength; i++) {
                buffer[i] = ba.readByte();
            }
            var value = Shumway.StringUtilities.utf8encode(buffer);
            stringsCache.push(value);
            return value;
        }

        function writeUTF8vr(ba, value, caches) {
            if (value === '') {
                ba.writeByte(0x01); // empty string
                return;
            }

            var stringsCache = caches.stringsCache || (caches.stringsCache = []);
            var index = stringsCache.indexOf(value);
            if (index >= 0) {
                writeU29(ba, index << 1);
                return;
            }
            stringsCache.push(value);

            var bytes = Shumway.StringUtilities.utf8decode(value);
            writeU29(ba, 1 | (bytes.length << 1));
            for (var i = 0; i < bytes.length; i++) {
                ba.writeByte(bytes[i]);
            }
        }

        function readAmf3Data(ba, caches) {
            var marker = ba.readByte();
            switch (marker) {
                case 1 /* NULL */:
                    return null;
                case 0 /* UNDEFINED */:
                    return undefined;
                case 2 /* FALSE */:
                    return false;
                case 3 /* TRUE */:
                    return true;
                case 4 /* INTEGER */:
                    return readU29(ba);
                case 5 /* DOUBLE */:
                    return readDouble(ba);
                case 6 /* STRING */:
                    return readUTF8vr(ba, caches);
                case 8 /* DATE */:
                    return new Date(readDouble(ba));
                case 10 /* OBJECT */:
                    var u29o = readU29(ba);
                    if ((u29o & 1) === 0) {
                        return caches.objectsCache[u29o >> 1];
                    }
                    if ((u29o & 4) !== 0) {
                        throw 'AMF3 Traits-Ext is not supported';
                    }
                    var traits, objectClass;
                    if ((u29o & 2) === 0) {
                        traits = caches.traitsCache[u29o >> 2];
                        objectClass = traits.class;
                    } else {
                        traits = {};
                        var aliasName = readUTF8vr(ba, caches);
                        traits.className = aliasName;
                        objectClass = aliasName && aliasesCache.names[aliasName];
                        traits.class = objectClass;
                        traits.isDynamic = (u29o & 8) !== 0;
                        traits.members = [];
                        var slots = objectClass && objectClass.instanceBindings.slots;
                        for (var i = 0, j = u29o >> 4; i < j; i++) {
                            var traitName = readUTF8vr(ba, caches);
                            var slot = null;
                            for (var j = 1; slots && j < slots.length; j++) {
                                if (slots[j].name.name === traitName) {
                                    slot = slots[j];
                                    break;
                                }
                            }
                            traits.members.push(slot ? Multiname.getQualifiedName(slot.name) : Multiname.getPublicQualifiedName(traitName));
                        }
                        (caches.traitsCache || (caches.traitsCache = [])).push(traits);
                    }

                    var obj = objectClass ? objectClass.createInstance() : {};
                    (caches.objectsCache || (caches.objectsCache = [])).push(obj);
                    for (var i = 0; i < traits.members.length; i++) {
                        var value = readAmf3Data(ba, caches);
                        obj[traits.members[i]] = value;
                    }
                    if (traits.isDynamic) {
                        while (true) {
                            var key = readUTF8vr(ba, caches);
                            if (!key.length)
                                break;
                            var value = readAmf3Data(ba, caches);
                            setAvmProperty(obj, key, value);
                        }
                    }
                    return obj;
                case 9 /* ARRAY */:
                    var u29o = readU29(ba);
                    if ((u29o & 1) === 0) {
                        return caches.objectsCache[u29o >> 1];
                    }
                    var arr = [];
                    (caches.objectsCache || (caches.objectsCache = [])).push(arr);
                    var densePortionLength = u29o >> 1;
                    while (true) {
                        var key = readUTF8vr(ba, caches);
                        if (!key.length)
                            break;
                        var value = readAmf3Data(ba, caches);
                        setAvmProperty(arr, key, value);
                    }
                    for (var i = 0; i < densePortionLength; i++) {
                        var value = readAmf3Data(ba, caches);
                        setAvmProperty(arr, i, value);
                    }
                    return arr;
                default:
                    throw 'AMF3 Unknown marker ' + marker;
            }
        }

        function writeCachedReference(ba, obj, caches) {
            var objectsCache = caches.objectsCache || (caches.objectsCache = []);
            var index = objectsCache.indexOf(obj);
            if (index < 0) {
                objectsCache.push(obj);
                return false;
            }
            writeU29(ba, index << 1);
            return true;
        }

        function writeAmf3Data(ba, obj, caches) {
            switch (typeof obj) {
                case 'boolean':
                    ba.writeByte(obj ? 3 /* TRUE */ : 2 /* FALSE */);
                    break;
                case 'number':
                    if (obj === (obj | 0)) {
                        ba.writeByte(4 /* INTEGER */);
                        writeU29(ba, obj);
                    } else {
                        ba.writeByte(5 /* DOUBLE */);
                        writeDouble(ba, obj);
                    }
                    break;
                case 'undefined':
                    ba.writeByte(0 /* UNDEFINED */);
                    break;
                case 'string':
                    ba.writeByte(6 /* STRING */);
                    writeUTF8vr(ba, obj, caches);
                    break;
                case 'object':
                    if (obj === null) {
                        ba.writeByte(1 /* NULL */);
                    } else if (Array.isArray(obj)) {
                        ba.writeByte(9 /* ARRAY */);
                        if (writeCachedReference(ba, obj, caches))
                            break;
                        var densePortionLength = 0;
                        while (densePortionLength in obj) {
                            ++densePortionLength;
                        }
                        writeU29(ba, (densePortionLength << 1) | 1);
                        forEachPublicProperty(obj, function (i, value) {
                            if (Shumway.isNumeric(i) && i >= 0 && i < densePortionLength) {
                                return;
                            }
                            writeUTF8vr(ba, i, caches);
                            writeAmf3Data(ba, value, caches);
                        });
                        writeUTF8vr(ba, '', caches);
                        for (var j = 0; j < densePortionLength; j++) {
                            writeAmf3Data(ba, obj[j], caches);
                        }
                    } else if (obj instanceof Date) {
                        ba.writeByte(8 /* DATE */);
                        if (writeCachedReference(ba, obj, caches))
                            break;
                        writeU29(ba, 1);
                        writeDouble(ba, obj.valueOf());
                    } else {
                        // TODO Vector, Dictionary, ByteArray and XML support
                        ba.writeByte(10 /* OBJECT */);
                        if (writeCachedReference(ba, obj, caches))
                            break;

                        var isDynamic = true;

                        var objectClass = obj.class;
                        if (objectClass) {
                            isDynamic = !objectClass.classInfo.instanceInfo.isSealed();

                            var aliasName = aliasesCache.classes.get(objectClass) || '';

                            var traits, traitsCount;
                            var traitsCache = caches.traitsCache || (caches.traitsCache = []);
                            var traitsInfos = caches.traitsInfos || (caches.traitsInfos = []);
                            var traitsRef = traitsCache.indexOf(objectClass);
                            if (traitsRef < 0) {
                                var slots = objectClass.instanceBindings.slots;
                                traits = [];
                                var traitsNames = [];
                                for (var i = 1; i < slots.length; i++) {
                                    var slot = slots[i];
                                    if (!slot.name.getNamespace().isPublic()) {
                                        continue;
                                    }
                                    traits.push(Multiname.getQualifiedName(slot.name));
                                    traitsNames.push(slot.name.name);
                                }
                                traitsCache.push(objectClass);
                                traitsInfos.push(traits);
                                traitsCount = traitsNames.length;
                                writeU29(ba, (isDynamic ? 0x0B : 0x03) + (traitsCount << 4));
                                writeUTF8vr(ba, aliasName, caches);
                                for (var i = 0; i < traitsCount; i++) {
                                    writeUTF8vr(ba, traitsNames[i], caches);
                                }
                            } else {
                                traits = traitsInfos[traitsRef];
                                traitsCount = traits.length;
                                writeU29(ba, 0x01 + (traitsRef << 2));
                            }

                            for (var i = 0; i < traitsCount; i++) {
                                writeAmf3Data(ba, obj[traits[i]], caches);
                            }
                        } else {
                            // object with no class definition
                            writeU29(ba, 0x0B);
                            writeUTF8vr(ba, '', caches); // empty alias name
                        }

                        if (isDynamic) {
                            forEachPublicProperty(obj, function (i, value) {
                                writeUTF8vr(ba, i, caches);
                                writeAmf3Data(ba, value, caches);
                            });
                            writeUTF8vr(ba, '', caches);
                        }
                    }
                    return;
            }
        }

        var aliasesCache = {
            classes: new WeakMap(),
            names: Object.create(null)
        };

        var AMF3 = (function () {
            function AMF3() {
            }
            AMF3.write = function (ba, object) {
                writeAmf3Data(ba, object, {});
            };
            AMF3.read = function (ba) {
                return readAmf3Data(ba, {});
            };
            return AMF3;
        })();
        AVM2.AMF3 = AMF3;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
///<reference path='module.ts' />
///<reference path='errors.ts' />
///<reference path='abc/stream.ts' />
///<reference path='abc/parser.ts' />
///<reference path='abc/disassembler.ts' />
///<reference path='bytecode.ts' />
///<reference path='options.ts' />
///<reference path='runtime.ts' />
///<reference path='scope.ts' />
///<reference path='bindings.ts' />
///<reference path='xregexp.ts' />
///<reference path='natives/int32Vector.ts' />
///<reference path='natives/uint32Vector.ts' />
///<reference path='natives/float64Vector.ts' />
///<reference path='native.ts' />
///<reference path='natives/GenericVector.ts' />
///<reference path='natives/xml.ts' />
///<reference path='natives/describeType.ts' />
///<reference path='natives/dictionary.ts' />
///<reference path='natives/proxy.ts' />
///<reference path='natives/byteArray.ts' />
///<reference path='natives/system.ts' />
///<reference path='compiler/verifier.ts' />
///<reference path='compiler/c4/ir.ts' />
///<reference path='compiler/c4/optimizer.ts' />
///<reference path='compiler/builder.ts' />
///<reference path='compiler/aot.ts' />
///<reference path='compiler/c4/ast.ts' />
///<reference path='compiler/c4/as.ir.ts' />
///<reference path='compiler/c4/looper.ts' />
///<reference path='compiler/c4/backend.ts' />
///<reference path='domain.ts' />
///<reference path='trampoline.ts' />
///<reference path='interpreter.ts' />
///<reference path='hacks.ts' />
///<reference path='amf.ts' />
//# sourceMappingURL=avm2.js.map

console.timeEnd("Load AVM2 Dependencies");
console.time("Load Compiled Code Cache");
console.timeEnd("Load Compiled Code Cache");
// Load Flash TS Dependencies
console.time("Load Flash TS Dependencies");
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    /*
    * HTML Parser By John Resig (ejohn.org)
    * Original code by Erik Arvidsson, Mozilla Public License
    * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
    *
    * // Use like so:
    * HTMLParser(htmlString, {
    *     start: function(tag, attrs, unary) {},
    *     end: function(tag) {},
    *     chars: function(text) {},
    *     comment: function(text) {}
    * });
    *
    */
    // Regular Expressions for parsing tags and attributes
    var startTag = /^<([-A-Za-z0-9_]+)((?:\s+\w+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/, endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/, attr = /([-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;

    // Empty Elements - HTML 4.01
    var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");

    // Block Elements - HTML 4.01
    var block = makeMap("address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul");

    // Inline Elements - HTML 4.01
    var inline = makeMap("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");

    // Elements that you can, intentionally, leave open
    // (and which close themselves)
    var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

    // Attributes that have their values filled in disabled="disabled"
    var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");

    // Special Elements (can contain anything)
    var special = makeMap("script,style");

    function HTMLParser(html, handler) {
        var index, chars, match, stack = [], last = html;

        function top() {
            return this[this.length - 1];
        }

        while (html) {
            chars = true;

            // Make sure we're not in a script or style element
            if (!top() || !special[top()]) {
                // Comment
                if (html.indexOf("<!--") == 0) {
                    index = html.indexOf("-->");

                    if (index >= 0) {
                        if (handler.comment)
                            handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                    // end tag
                } else if (html.indexOf("</") == 0) {
                    match = html.match(endTag);

                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(endTag, parseEndTag);
                        chars = false;
                    }
                    // start tag
                } else if (html.indexOf("<") == 0) {
                    match = html.match(startTag);

                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(startTag, parseStartTag);
                        chars = false;
                    }
                }

                if (chars) {
                    index = html.indexOf("<");

                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);

                    if (handler.chars)
                        handler.chars(text);
                }
            } else {
                html = html.replace(new RegExp("(.*)<\/" + top() + "[^>]*>"), function (all, text) {
                    text = text.replace(/<!--(.*?)-->/g, "$1").replace(/<!\[CDATA\[(.*?)]]>/g, "$1");

                    if (handler.chars)
                        handler.chars(text);

                    return "";
                });

                parseEndTag("", top());
            }

            if (html == last)
                throw "Parse Error: " + html;
            last = html;
        }

        // Clean up any remaining tags
        parseEndTag();

        function parseStartTag(tag, tagName, rest, unary) {
            tagName = tagName.toLowerCase();

            if (block[tagName]) {
                while (top() && inline[top()]) {
                    parseEndTag("", top());
                }
            }

            if (closeSelf[tagName] && top() == tagName) {
                parseEndTag("", tagName);
            }

            unary = empty[tagName] || !!unary;

            if (!unary)
                stack.push(tagName);

            if (handler.start) {
                var attrs = Object.create(null);

                rest.replace(attr, function (match, name) {
                    name = name.toLowerCase();

                    var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : "";

                    attrs[name] = value;

                    return match;
                });

                if (handler.start)
                    handler.start(tagName, attrs, !!unary);
            }
        }

        function parseEndTag(tag, tagName) {
            // If no tag name is provided, clean shop
            if (!tagName)
                var pos = 0;
            else
                for (var pos = stack.length - 1; pos >= 0; pos--)
                    if (stack[pos] == tagName)
                        break;

            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--)
                    if (handler.end)
                        handler.end(stack[i]);

                // Remove the open elements from the stack
                stack.length = pos;
            }
        }
    }
    Shumway.HTMLParser = HTMLParser;
    ;

    function makeMap(str) {
        var obj = {}, items = str.split(",");
        for (var i = 0; i < items.length; i++)
            obj[items[i]] = true;
        return obj;
    }
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    var notImplemented = Shumway.Debug.notImplemented;
    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

    var Bounds = Shumway.Bounds;
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var ColorUtilities = Shumway.ColorUtilities;
    var flash = Shumway.AVM2.AS.flash;

    (function (TextContentFlags) {
        TextContentFlags[TextContentFlags["None"] = 0x0000] = "None";
        TextContentFlags[TextContentFlags["DirtyBounds"] = 0x0001] = "DirtyBounds";
        TextContentFlags[TextContentFlags["DirtyContent"] = 0x0002] = "DirtyContent";
        TextContentFlags[TextContentFlags["DirtyStyle"] = 0x0004] = "DirtyStyle";
        TextContentFlags[TextContentFlags["DirtyFlow"] = 0x0008] = "DirtyFlow";
        TextContentFlags[TextContentFlags["Dirty"] = TextContentFlags.DirtyBounds | TextContentFlags.DirtyContent | TextContentFlags.DirtyStyle | TextContentFlags.DirtyFlow] = "Dirty";
    })(Shumway.TextContentFlags || (Shumway.TextContentFlags = {}));
    var TextContentFlags = Shumway.TextContentFlags;

    var _decodeHTMLMap = {
        lt: '<',
        gt: '>',
        amp: '&',
        quot: '"',
        apos: "'"
    };

    /**
    * Decodes strings of the format:
    *
    * &#0000;
    * &#x0000;
    * &#x0000;
    * &amp;
    * &lthello
    *
    * This is complete enough to handle encoded HTML produced by the Flash IDE.
    */
    function decodeHTML(s) {
        var r = "";
        for (var i = 0; i < s.length; i++) {
            var c = s.charAt(i);
            if (c !== '&') {
                r += c;
            } else {
                // Look for the first '&' or ';', both of these can terminate
                // the current char code.
                var j = Shumway.StringUtilities.indexOfAny(s, ['&', ';'], i + 1);
                if (j > 0) {
                    var v = s.substring(i + 1, j);
                    if (v.length > 1 && v.charAt(0) === "#") {
                        var n = 0;
                        if (v.length > 2 && v.charAt(1) === "x") {
                            n = parseInt(v.substring(1));
                        } else {
                            n = parseInt(v.substring(2), 16);
                        }
                        r += String.fromCharCode(n);
                    } else {
                        if (_decodeHTMLMap[v] !== undefined) {
                            r += _decodeHTMLMap[v];
                        } else {
                            Shumway.Debug.unexpected(v);
                        }
                    }
                    i = j;
                } else {
                    for (var k in _decodeHTMLMap) {
                        if (s.indexOf(k, i + 1) === i + 1) {
                            r += _decodeHTMLMap[k];
                            i += k.length;
                            break;
                        }
                    }
                }
            }
        }
        return r;
    }

    var TextContent = (function () {
        function TextContent(defaultTextFormat) {
            this._id = flash.display.DisplayObject.getNextSyncID();
            this._bounds = new Bounds(0, 0, 0, 0);
            this._plainText = '';
            this._backgroundColor = 0;
            this._borderColor = 0;
            this._autoSize = 0;
            this._wordWrap = false;
            this.flags = 0 /* None */;
            this.defaultTextFormat = defaultTextFormat || new flash.text.TextFormat();
            this.textRuns = [];
            this.textRunData = new DataBuffer();
            this.matrix = null;
            this.coords = null;
        }
        TextContent.prototype.parseHtml = function (htmlText, multiline) {
            if (typeof multiline === "undefined") { multiline = false; }
            var plainText = '';
            var textRuns = this.textRuns;
            textRuns.length = 0;

            var beginIndex = 0;
            var endIndex = 0;
            var textFormat = this.defaultTextFormat.clone();
            var prevTextRun = null;
            var stack = [];

            var handler;
            Shumway.HTMLParser(htmlText, handler = {
                chars: function (text) {
                    text = decodeHTML(text);
                    plainText += text;
                    endIndex += text.length;
                    if (endIndex - beginIndex) {
                        if (prevTextRun && prevTextRun.textFormat.equals(textFormat)) {
                            prevTextRun.endIndex = endIndex;
                        } else {
                            prevTextRun = new flash.text.TextRun(beginIndex, endIndex, textFormat);
                            textRuns.push(prevTextRun);
                        }
                        beginIndex = endIndex;
                    }
                },
                start: function (tagName, attributes) {
                    switch (tagName) {
                        case 'a':
                            stack.push(textFormat);
                            somewhatImplemented('<a/>');
                            var target = attributes.target || textFormat.target;
                            var url = attributes.url || textFormat.url;
                            if (target !== textFormat.target || url !== textFormat.url) {
                                textFormat = textFormat.clone();
                                textFormat.target = target;
                                textFormat.url = url;
                            }
                            break;
                        case 'b':
                            stack.push(textFormat);
                            if (!textFormat.bold) {
                                textFormat = textFormat.clone();
                                textFormat.bold = true;
                            }
                            break;
                        case 'font':
                            stack.push(textFormat);
                            var color = ColorUtilities.isValidHexColor(attributes.color) ? ColorUtilities.hexToRGB(attributes.color) : textFormat.color;

                            // TODO: the value of the face property can be a string specifying a list of
                            // comma-delimited font names in which case the first available font should be used.
                            var font = attributes.face || textFormat.font;
                            var size = isNaN(attributes.size) ? textFormat.size : +attributes.size;
                            if (color !== textFormat.color || font !== textFormat.font || size !== textFormat.size) {
                                textFormat = textFormat.clone();
                                textFormat.color = color;
                                textFormat.font = font;
                                textFormat.size = size;
                            }
                            break;
                        case 'img':
                            notImplemented('<img/>');
                            break;
                        case 'i':
                            stack.push(textFormat);
                            if (!prevTextRun) {
                                textFormat = textFormat.clone();
                                textFormat.italic = true;
                            }
                            break;
                        case 'li':
                            stack.push(textFormat);
                            if (!textFormat.bullet) {
                                textFormat = textFormat.clone();
                                textFormat.bullet = true;
                            }
                            if (plainText[plainText.length - 1] === '\r') {
                                break;
                            }
                        case 'br':
                            if (multiline) {
                                handler.chars('\r');
                            }
                            break;
                        case 'p':
                            stack.push(textFormat);
                            var align = attributes.align;
                            if (flash.text.TextFormatAlign.toNumber(align) > -1 && align !== textFormat.align) {
                                textFormat = textFormat.clone();
                                textFormat.align = align;
                            }
                            break;
                        case 'span':
                            break;
                        case 'textformat':
                            stack.push(textFormat);
                            var blockIndent = isNaN(attributes.blockindent) ? textFormat.blockIndent : +attributes.blockindent;
                            var indent = isNaN(attributes.indent) ? textFormat.indent : +attributes.indent;
                            var leading = isNaN(attributes.leading) ? textFormat.leading : +attributes.leading;
                            var leftMargin = isNaN(attributes.leftmargin) ? textFormat.leftMargin : +attributes.leftmargin;
                            var rightMargin = isNaN(attributes.rightmargin) ? textFormat.rightMargin : +attributes.rightmargin;

                            //var tabStops = attributes.tabstops || textFormat.tabStops;
                            if (blockIndent !== textFormat.blockIndent || indent !== textFormat.indent || leading !== textFormat.leading || leftMargin !== textFormat.leftMargin || rightMargin !== textFormat.rightMargin) {
                                textFormat = textFormat.clone();
                                textFormat.blockIndent = blockIndent;
                                textFormat.indent = indent;
                                textFormat.leading = leading;
                                textFormat.leftMargin = leftMargin;
                                textFormat.rightMargin = rightMargin;
                                //textFormat.tabStops = tabStops;
                            }
                            break;
                        case 'u':
                            stack.push(textFormat);
                            if (!textFormat.underline) {
                                textFormat = textFormat.clone();
                                textFormat.underline = true;
                            }
                            break;
                    }
                },
                end: function (tagName) {
                    switch (tagName) {
                        case 'li':
                        case 'p':
                            if (multiline) {
                                handler.chars('\r');
                            }
                        case 'a':
                        case 'b':
                        case 'font':
                        case 'i':
                        case 'textformat':
                        case 'u':
                            textFormat = stack.pop();
                    }
                }
            });

            this._plainText = plainText;
            this.textRunData.clear();
            for (var i = 0; i < textRuns.length; i++) {
                this._writeTextRun(textRuns[i]);
            }
            this.flags |= 2 /* DirtyContent */;
        };

        Object.defineProperty(TextContent.prototype, "plainText", {
            get: function () {
                return this._plainText;
            },
            set: function (value) {
                this._plainText = value;
                this.textRuns.length = 0;
                var textRun = new flash.text.TextRun(0, value.length, this.defaultTextFormat);
                this.textRuns[0] = textRun;
                this.textRunData.clear();
                this._writeTextRun(textRun);
                this.flags |= 2 /* DirtyContent */;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextContent.prototype, "bounds", {
            get: function () {
                return this._bounds;
            },
            set: function (bounds) {
                this._bounds.copyFrom(bounds);
                this.flags |= 1 /* DirtyBounds */;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextContent.prototype, "autoSize", {
            get: function () {
                return this._autoSize;
            },
            set: function (value) {
                if (value === this._autoSize) {
                    return;
                }
                this._autoSize = value;
                if (this._plainText) {
                    this.flags |= 8 /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextContent.prototype, "wordWrap", {
            get: function () {
                return this._wordWrap;
            },
            set: function (value) {
                if (value === this._wordWrap) {
                    return;
                }
                this._wordWrap = value;
                if (this._plainText) {
                    this.flags |= 8 /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextContent.prototype, "backgroundColor", {
            get: function () {
                return this._backgroundColor;
            },
            set: function (value) {
                if (value === this._backgroundColor) {
                    return;
                }
                this._backgroundColor = value;
                this.flags |= 4 /* DirtyStyle */;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextContent.prototype, "borderColor", {
            get: function () {
                return this._borderColor;
            },
            set: function (value) {
                if (value === this._borderColor) {
                    return;
                }
                this._borderColor = value;
                this.flags |= 4 /* DirtyStyle */;
            },
            enumerable: true,
            configurable: true
        });


        TextContent.prototype._writeTextRun = function (textRun) {
            var textRunData = this.textRunData;

            textRunData.writeInt(textRun.beginIndex);
            textRunData.writeInt(textRun.endIndex);

            var textFormat = textRun.textFormat;

            var size = +textFormat.size;
            textRunData.writeInt(size);

            var font = flash.text.Font.getByName(textFormat.font) || flash.text.Font.getDefaultFont();
            if (font.fontType === flash.text.FontType.EMBEDDED) {
                textRunData.writeInt(font._id);
            } else {
                textRunData.writeInt(0);
                textRunData.writeUTF(flash.text.Font.resolveFontName(font.fontName));
            }
            textRunData.writeInt(font.ascent * size);
            textRunData.writeInt(font.descent * size);
            textRunData.writeInt(textFormat.leading === null ? font.leading * size : +textFormat.leading);
            var bold;
            var italic;
            if (textFormat.bold === null) {
                bold = font.fontStyle === flash.text.FontStyle.BOLD || font.fontType === flash.text.FontStyle.BOLD_ITALIC;
            } else {
                bold = !!textFormat.bold;
            }
            if (textFormat.italic === null) {
                italic = font.fontStyle === flash.text.FontStyle.ITALIC || font.fontType === flash.text.FontStyle.BOLD_ITALIC;
            } else {
                italic = !!textFormat.italic;
            }
            textRunData.writeBoolean(bold);
            textRunData.writeBoolean(italic);

            textRunData.writeInt(+textFormat.color);
            textRunData.writeInt(flash.text.TextFormatAlign.toNumber(textFormat.align));
            textRunData.writeBoolean(!!textFormat.bullet);

            //textRunData.writeInt(textFormat.display);
            textRunData.writeInt(+textFormat.indent);

            //textRunData.writeInt(textFormat.blockIndent);
            textRunData.writeInt(+textFormat.kerning);
            textRunData.writeInt(+textFormat.leftMargin);
            textRunData.writeInt(+textFormat.letterSpacing);
            textRunData.writeInt(+textFormat.rightMargin);

            //textRunData.writeInt(textFormat.tabStops);
            textRunData.writeBoolean(!!textFormat.underline);
        };
        return TextContent;
    })();
    Shumway.TextContent = TextContent;
})(Shumway || (Shumway = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Matrix
                (function (geom) {
                    var Matrix = (function (_super) {
                        __extends(Matrix, _super);
                        function Matrix(a, b, c, d, tx, ty) {
                            if (typeof a === "undefined") { a = 1; }
                            if (typeof b === "undefined") { b = 0; }
                            if (typeof c === "undefined") { c = 0; }
                            if (typeof d === "undefined") { d = 1; }
                            if (typeof tx === "undefined") { tx = 0; }
                            if (typeof ty === "undefined") { ty = 0; }
                            false && _super.call(this);
                            this.a = +a;
                            this.b = +b;
                            this.c = +c;
                            this.d = +d;
                            this.tx = +tx;
                            this.ty = +ty;
                        }
                        Matrix.FromUntyped = function (obj) {
                            return new flash.geom.Matrix(obj.a, obj.b, obj.c, obj.d, obj.tx, obj.ty);
                        };

                        // Keep in sync with writeExternal below!
                        Matrix.FromDataBuffer = function (input) {
                            return new flash.geom.Matrix(input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
                        };


                        Object.defineProperty(Matrix.prototype, "native_a", {
                            get: function () {
                                return this.a;
                            },
                            set: function (a) {
                                this.a = +a;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Matrix.prototype, "native_b", {
                            get: function () {
                                return this.b;
                            },
                            set: function (b) {
                                this.b = +b;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Matrix.prototype, "native_c", {
                            get: function () {
                                return this.c;
                            },
                            set: function (c) {
                                this.c = +c;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Matrix.prototype, "native_d", {
                            get: function () {
                                return this.d;
                            },
                            set: function (d) {
                                this.d = +d;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Matrix.prototype, "native_tx", {
                            get: function () {
                                return this.tx;
                            },
                            set: function (tx) {
                                this.tx = +tx;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Matrix.prototype, "native_ty", {
                            get: function () {
                                return this.ty;
                            },
                            set: function (ty) {
                                this.ty = +ty;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Matrix.prototype.Matrix = function (a, b, c, d, tx, ty) {
                            if (typeof a === "undefined") { a = 1; }
                            if (typeof b === "undefined") { b = 0; }
                            if (typeof c === "undefined") { c = 0; }
                            if (typeof d === "undefined") { d = 1; }
                            if (typeof tx === "undefined") { tx = 0; }
                            if (typeof ty === "undefined") { ty = 0; }
                            this.a = a;
                            this.b = b;
                            this.c = c;
                            this.d = d;
                            this.tx = tx;
                            this.ty = ty;
                        };

                        /**
                        * this = this * m
                        */
                        Matrix.prototype.concat = function (m) {
                            var a = this.a * m.a;
                            var b = 0.0;
                            var c = 0.0;
                            var d = this.d * m.d;
                            var tx = this.tx * m.a + m.tx;
                            var ty = this.ty * m.d + m.ty;

                            if (this.b !== 0.0 || this.c !== 0.0 || m.b !== 0.0 || m.c !== 0.0) {
                                a += this.b * m.c;
                                d += this.c * m.b;
                                b += this.a * m.b + this.b * m.d;
                                c += this.c * m.a + this.d * m.c;
                                tx += this.ty * m.c;
                                ty += this.tx * m.b;
                            }

                            this.a = a;
                            this.b = b;
                            this.c = c;
                            this.d = d;
                            this.tx = tx;
                            this.ty = ty;
                        };

                        /**
                        * this = m * this
                        */
                        Matrix.prototype.preMultiply = function (m) {
                            this.preMultiplyInto(m, this);
                        };

                        /**
                        * target = m * this
                        */
                        Matrix.prototype.preMultiplyInto = function (m, target) {
                            var a = m.a * this.a;
                            var b = 0.0;
                            var c = 0.0;
                            var d = m.d * this.d;
                            var tx = m.tx * this.a + this.tx;
                            var ty = m.ty * this.d + this.ty;

                            if (m.b !== 0.0 || m.c !== 0.0 || this.b !== 0.0 || this.c !== 0.0) {
                                a += m.b * this.c;
                                d += m.c * this.b;
                                b += m.a * this.b + m.b * this.d;
                                c += m.c * this.a + m.d * this.c;
                                tx += m.ty * this.c;
                                ty += m.tx * this.b;
                            }

                            target.a = a;
                            target.b = b;
                            target.c = c;
                            target.d = d;
                            target.tx = tx;
                            target.ty = ty;
                        };

                        Matrix.prototype.invert = function () {
                            this.invertInto(this);
                        };

                        Matrix.prototype.invertInto = function (target) {
                            var b = this.b;
                            var c = this.c;
                            var tx = this.tx;
                            var ty = this.ty;
                            if (b === 0 && c === 0) {
                                var a = target.a = 1 / this.a;
                                var d = target.d = 1 / this.d;
                                target.tx = -a * tx;
                                target.ty = -d * ty;
                                return;
                            }
                            var a = this.a;
                            var d = this.d;
                            var determinant = a * d - b * c;
                            if (determinant === 0) {
                                target.identity();
                                return;
                            }

                            /**
                            * Multiplying by reciprocal of the |determinant| is only accurate if the reciprocal is
                            * representable without loss of precision. This is usually only the case for powers of
                            * two: 1/2, 1/4 ...
                            */
                            determinant = 1 / determinant;
                            var t = 0;
                            t = target.a = d * determinant;
                            b = target.b = -b * determinant;
                            c = target.c = -c * determinant;
                            d = target.d = a * determinant;
                            target.tx = -(t * tx + c * ty);
                            target.ty = -(b * tx + d * ty);
                        };

                        Matrix.prototype.identity = function () {
                            this.a = this.d = 1;
                            this.b = this.c = this.tx = this.ty = 0;
                        };

                        Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
                            if (typeof rotation === "undefined") { rotation = 0; }
                            if (typeof tx === "undefined") { tx = 0; }
                            if (typeof ty === "undefined") { ty = 0; }
                            if (rotation !== 0) {
                                var u = Math.cos(rotation);
                                var v = Math.sin(rotation);
                                this.a = u * scaleX;
                                this.b = v * scaleY;
                                this.c = -v * scaleX;
                                this.d = u * scaleY;
                            } else {
                                this.a = scaleX;
                                this.b = 0;
                                this.c = 0;
                                this.d = scaleY;
                            }
                            this.tx = tx;
                            this.ty = ty;
                        };

                        Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
                            if (typeof rotation === "undefined") { rotation = 0; }
                            if (typeof tx === "undefined") { tx = 0; }
                            if (typeof ty === "undefined") { ty = 0; }
                            this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
                        };

                        Matrix.prototype.rotate = function (angle) {
                            angle = +angle;
                            if (angle !== 0) {
                                var u = Math.cos(angle);
                                var v = Math.sin(angle);
                                var ta = this.a;
                                var tb = this.b;
                                var tc = this.c;
                                var td = this.d;
                                var ttx = this.tx;
                                var tty = this.ty;
                                this.a = ta * u - tb * v;
                                this.b = ta * v + tb * u;
                                this.c = tc * u - td * v;
                                this.d = tc * v + td * u;
                                this.tx = ttx * u - tty * v;
                                this.ty = ttx * v + tty * u;
                            }
                        };

                        Matrix.prototype.translate = function (dx, dy) {
                            this.tx += dx;
                            this.ty += dy;
                        };

                        Matrix.prototype.scale = function (sx, sy) {
                            if (sx !== 1) {
                                this.a *= sx;
                                this.c *= sx;
                                this.tx *= sx;
                            }
                            if (sy !== 1) {
                                this.b *= sy;
                                this.d *= sy;
                                this.ty *= sy;
                            }
                        };

                        Matrix.prototype.deltaTransformPoint = function (point) {
                            return new geom.Point(this.a * point.x + this.c * point.y, this.b * point.x + this.d * point.y);
                        };

                        Matrix.prototype.transformX = function (x, y) {
                            return this.a * x + this.c * y + this.tx;
                        };

                        Matrix.prototype.transformY = function (x, y) {
                            return this.b * x + this.d * y + this.ty;
                        };

                        Matrix.prototype.transformPoint = function (point) {
                            return new geom.Point(this.a * point.x + this.c * point.y + this.tx, this.b * point.x + this.d * point.y + this.ty);
                        };

                        Matrix.prototype.transformPointInPlace = function (point) {
                            point.setTo(this.a * point.x + this.c * point.y + this.tx, this.b * point.x + this.d * point.y + this.ty);
                            return point;
                        };

                        Matrix.prototype.transformRectAABB = function (rectangle) {
                            var a = this.a;
                            var b = this.b;
                            var c = this.c;
                            var d = this.d;
                            var tx = this.tx;
                            var ty = this.ty;

                            var x = rectangle.x;
                            var y = rectangle.y;
                            var w = rectangle.width;
                            var h = rectangle.height;

                            var x0 = a * x + c * y + tx;
                            var y0 = b * x + d * y + ty;
                            var x1 = a * (x + w) + c * y + tx;
                            var y1 = b * (x + w) + d * y + ty;
                            var x2 = a * (x + w) + c * (y + h) + tx;
                            var y2 = b * (x + w) + d * (y + h) + ty;
                            var x3 = a * x + c * (y + h) + tx;
                            var y3 = b * x + d * (y + h) + ty;

                            var tmp = 0;

                            // Manual Min/Max is a lot faster than calling Math.min/max
                            // X Min-Max
                            if (x0 > x1) {
                                tmp = x0;
                                x0 = x1;
                                x1 = tmp;
                            }
                            if (x2 > x3) {
                                tmp = x2;
                                x2 = x3;
                                x3 = tmp;
                            }

                            rectangle.x = x0 < x2 ? x0 : x2;
                            rectangle.width = (x1 > x3 ? x1 : x3) - rectangle.x;

                            // Y Min-Max
                            if (y0 > y1) {
                                tmp = y0;
                                y0 = y1;
                                y1 = tmp;
                            }
                            if (y2 > y3) {
                                tmp = y2;
                                y2 = y3;
                                y3 = tmp;
                            }

                            rectangle.y = y0 < y2 ? y0 : y2;
                            rectangle.height = (y1 > y3 ? y1 : y3) - rectangle.y;
                            return rectangle;
                        };

                        Matrix.prototype.transformBounds = function (bounds) {
                            var a = this.a;
                            var b = this.b;
                            var c = this.c;
                            var d = this.d;
                            var tx = this.tx;
                            var ty = this.ty;

                            var x = bounds.xMin;
                            var y = bounds.yMin;
                            var w = bounds.width;
                            var h = bounds.height;

                            var x0 = (a * x + c * y + tx) | 0;
                            var y0 = (b * x + d * y + ty) | 0;
                            var x1 = (a * (x + w) + c * y + tx) | 0;
                            var y1 = (b * (x + w) + d * y + ty) | 0;
                            var x2 = (a * (x + w) + c * (y + h) + tx) | 0;
                            var y2 = (b * (x + w) + d * (y + h) + ty) | 0;
                            var x3 = (a * x + c * (y + h) + tx) | 0;
                            var y3 = (b * x + d * (y + h) + ty) | 0;

                            var tmp = 0;

                            // Manual Min/Max is a lot faster than calling Math.min/max
                            // X Min-Max
                            if (x0 > x1) {
                                tmp = x0;
                                x0 = x1;
                                x1 = tmp;
                            }
                            if (x2 > x3) {
                                tmp = x2;
                                x2 = x3;
                                x3 = tmp;
                            }

                            bounds.xMin = x0 < x2 ? x0 : x2;
                            bounds.xMax = x1 > x3 ? x1 : x3;

                            // Y Min-Max
                            if (y0 > y1) {
                                tmp = y0;
                                y0 = y1;
                                y1 = tmp;
                            }
                            if (y2 > y3) {
                                tmp = y2;
                                y2 = y3;
                                y3 = tmp;
                            }

                            bounds.yMin = y0 < y2 ? y0 : y2;
                            bounds.yMax = y1 > y3 ? y1 : y3;
                        };

                        Matrix.prototype.getScaleX = function () {
                            if (this.a === 1 && this.b === 0) {
                                return 1;
                            }
                            return Math.sqrt(this.a * this.a + this.b * this.b);
                        };

                        Matrix.prototype.getScaleY = function () {
                            if (this.c === 0 && this.d === 1) {
                                return 1;
                            }
                            var result = Math.sqrt(this.c * this.c + this.d * this.d);
                            var det = this.a * this.d - this.b * this.c;
                            return det < 0 ? -result : result;
                        };

                        Matrix.prototype.getAbsoluteScaleX = function () {
                            return Math.abs(this.getScaleX());
                        };

                        Matrix.prototype.getAbsoluteScaleY = function () {
                            return Math.abs(this.getScaleY());
                        };

                        Matrix.prototype.getRotation = function () {
                            return Math.atan2(this.b, this.a);
                        };

                        Matrix.prototype.copyFrom = function (sourceMatrix) {
                            this.a = sourceMatrix.a;
                            this.b = sourceMatrix.b;
                            this.c = sourceMatrix.c;
                            this.d = sourceMatrix.d;
                            this.tx = sourceMatrix.tx;
                            this.ty = sourceMatrix.ty;
                        };

                        Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
                            this.a = +a;
                            this.b = +b;
                            this.c = +c;
                            this.d = +d;
                            this.tx = +tx;
                            this.ty = +ty;
                        };

                        Matrix.prototype.toTwipsInPlace = function () {
                            this.tx = (this.tx * 20) | 0;
                            this.ty = (this.ty * 20) | 0;
                            return this;
                        };

                        Matrix.prototype.toPixelsInPlace = function () {
                            this.tx /= 20;
                            this.ty /= 20;
                            return this;
                        };

                        Matrix.prototype.copyRowTo = function (row, vector3D) {
                            row = row >>> 0;
                            if (row === 0) {
                                vector3D.x = this.a;
                                vector3D.y = this.c;
                                vector3D.z = this.tx;
                            } else if (row === 1) {
                                vector3D.x = this.b;
                                vector3D.y = this.d;
                                vector3D.z = this.ty;
                            } else if (row === 2) {
                                vector3D.x = 0;
                                vector3D.y = 0;
                                vector3D.z = 1;
                            }
                        };

                        Matrix.prototype.copyColumnTo = function (column, vector3D) {
                            column = column >>> 0;
                            if (column === 0) {
                                vector3D.x = this.a;
                                vector3D.y = this.b;
                                vector3D.z = 0;
                            } else if (column === 1) {
                                vector3D.x = this.c;
                                vector3D.y = this.d;
                                vector3D.z = 0;
                            } else if (column === 2) {
                                vector3D.x = this.tx;
                                vector3D.y = this.ty;
                                vector3D.z = 1;
                            }
                        };

                        Matrix.prototype.copyRowFrom = function (row, vector3D) {
                            row = row >>> 0;
                            if (row === 0) {
                                this.a = vector3D.x;
                                this.c = vector3D.y;
                                this.tx = vector3D.z;
                            } else if (row === 1) {
                                this.b = vector3D.x;
                                this.d = vector3D.y;
                                this.ty = vector3D.z;
                            }
                        };

                        Matrix.prototype.copyColumnFrom = function (column, vector3D) {
                            column = column >>> 0;
                            if (column === 0) {
                                this.a = vector3D.x;
                                this.c = vector3D.y;
                                this.tx = vector3D.z;
                            } else if (column === 1) {
                                this.b = vector3D.x;
                                this.d = vector3D.y;
                                this.ty = vector3D.z;
                            }
                        };

                        /**
                        * Updates the scale and skew componenets of the matrix.
                        */
                        Matrix.prototype.updateScaleAndRotation = function (scaleX, scaleY, rotation) {
                            // The common case.
                            if (rotation === 0 || rotation === 360) {
                                this.a = scaleX;
                                this.b = this.c = 0;
                                this.d = scaleY;
                                return;
                            }
                            var u = 0, v = 0;
                            switch (rotation) {
                                case 90:
                                case -270:
                                    u = 0, v = 1;
                                    break;
                                case 180:
                                case -180:
                                    u = -1, v = 0;
                                    break;
                                case 270:
                                case -90:
                                    u = 0, v = -1;
                                    break;
                                default:
                                    var angle = rotation / 180 * Math.PI;
                                    u = Math.cos(angle);
                                    v = Math.sin(angle);
                            }
                            this.a = u * scaleX;
                            this.b = v * scaleX;
                            this.c = -v * scaleY;
                            this.d = u * scaleY;
                        };

                        Matrix.prototype.clone = function () {
                            return new flash.geom.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
                        };

                        Matrix.prototype.equals = function (other) {
                            return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.tx === other.tx && this.ty === other.ty;
                        };

                        Matrix.prototype.toString = function () {
                            return "(a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
                        };

                        // Keep in sync with static FromDataBuffer above!
                        Matrix.prototype.writeExternal = function (output) {
                            output.writeFloat(this.a);
                            output.writeFloat(this.b);
                            output.writeFloat(this.c);
                            output.writeFloat(this.d);
                            output.writeFloat(this.tx);
                            output.writeFloat(this.ty);
                        };
                        Matrix.classInitializer = null;

                        Matrix.initializer = null;

                        Matrix.classSymbols = null;

                        Matrix.instanceSymbols = null;

                        Matrix.FROZEN_IDENTITY_MATRIX = Object.freeze(new Matrix());

                        Matrix.TEMP_MATRIX = new Matrix();
                        return Matrix;
                    })(AS.ASNative);
                    geom.Matrix = Matrix;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Matrix3D
                (function (geom) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    /*
                    * _matrix stores data by columns
                    *  | 0  4  8  12 |
                    *  | 1  5  9  13 |
                    *  | 2  6 10  14 |
                    *  | 3  7 11  15 |
                    */
                    var precision = 1e-7;

                    var transposeTransform = new Uint32Array([
                        0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15
                    ]);

                    function getRotationMatrix(theta, u, v, w, a, b, c) {
                        // http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/
                        var u2 = u * u, v2 = v * v, w2 = w * w;
                        var L2 = u2 + v2 + w2, L = Math.sqrt(L2);
                        u /= L;
                        v /= L;
                        w /= L;
                        u2 /= L2;
                        v2 /= L2;
                        w2 /= L2;
                        var cos = Math.cos(theta), sin = Math.sin(theta);

                        return new flash.geom.Matrix3D([
                            u2 + (v2 + w2) * cos,
                            u * v * (1 - cos) + w * sin,
                            u * w * (1 - cos) - v * sin,
                            0,
                            u * v * (1 - cos) - w * sin,
                            v2 + (u2 + w2) * cos,
                            v * w * (1 - cos) + u * sin,
                            0,
                            u * w * (1 - cos) + v * sin,
                            v * w * (1 - cos) - u * sin,
                            w2 + (u2 + v2) * cos,
                            0,
                            (a * (v2 + w2) - u * (b * v + c * w)) * (1 - cos) + (b * w - c * v) * sin,
                            (b * (u2 + w2) - v * (a * u + c * w)) * (1 - cos) + (c * u - a * w) * sin,
                            (c * (u2 + v2) - w * (a * u + b * v)) * (1 - cos) + (a * v - b * u) * sin,
                            1
                        ]);
                    }

                    var Matrix3D = (function (_super) {
                        __extends(Matrix3D, _super);
                        function Matrix3D(v) {
                            if (typeof v === "undefined") { v = null; }
                            false && _super.call(this);
                            this._matrix = new Float32Array(16);
                            if (v && v.length >= 16) {
                                this.copyRawDataFrom(v, 0, false);
                            } else {
                                this.identity();
                            }
                        }
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        Matrix3D.interpolate = function (thisMat, toMat, percent) {
                            thisMat = thisMat;
                            toMat = toMat;
                            percent = +percent;
                            notImplemented("public flash.geom.Matrix3D::static interpolate");
                            return;
                        };

                        Object.defineProperty(Matrix3D.prototype, "rawData", {
                            // _rawData: ASVector<any>;
                            // _position: flash.geom.Vector3D;
                            // _determinant: number;
                            get: function () {
                                var result = new AS.Float64Vector();
                                this.copyRawDataTo(result, 0, false);
                                return result;
                            },
                            set: function (v) {
                                this.copyRawDataFrom(v, 0, false);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix3D.prototype, "position", {
                            get: function () {
                                var m = this._matrix;
                                return new flash.geom.Vector3D(m[12], m[13], m[14]);
                            },
                            set: function (pos) {
                                var m = this._matrix;
                                m[12] = pos.x;
                                m[13] = pos.y;
                                m[14] = pos.z;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix3D.prototype, "determinant", {
                            get: function () {
                                var m = this._matrix;
                                var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                                var d;
                                d = m11 * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24)) - m21 * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14)) + m31 * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14)) - m41 * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                                return d;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Matrix3D.prototype.clone = function () {
                            return new flash.geom.Matrix3D(this._matrix);
                        };
                        Matrix3D.prototype.copyToMatrix3D = function (dest) {
                            dest = dest;
                            dest._matrix.set(this._matrix);
                        };
                        Matrix3D.prototype.append = function (lhs) {
                            var ma = lhs._matrix, mb = this._matrix, m = this._matrix;
                            var ma11 = ma[0], ma12 = ma[4], ma13 = ma[8], ma14 = ma[12], ma21 = ma[1], ma22 = ma[5], ma23 = ma[9], ma24 = ma[13], ma31 = ma[2], ma32 = ma[6], ma33 = ma[10], ma34 = ma[14], ma41 = ma[3], ma42 = ma[7], ma43 = ma[11], ma44 = ma[15];

                            var mb11 = mb[0], mb12 = mb[4], mb13 = mb[8], mb14 = mb[12], mb21 = mb[1], mb22 = mb[5], mb23 = mb[9], mb24 = mb[13], mb31 = mb[2], mb32 = mb[6], mb33 = mb[10], mb34 = mb[14], mb41 = mb[3], mb42 = mb[7], mb43 = mb[11], mb44 = mb[15];

                            m[0] = ma11 * mb11 + ma12 * mb21 + ma13 * mb31 + ma14 * mb41;
                            m[1] = ma21 * mb11 + ma22 * mb21 + ma23 * mb31 + ma24 * mb41;
                            m[2] = ma31 * mb11 + ma32 * mb21 + ma33 * mb31 + ma34 * mb41;
                            m[3] = ma41 * mb11 + ma42 * mb21 + ma43 * mb31 + ma44 * mb41;

                            m[4] = ma11 * mb12 + ma12 * mb22 + ma13 * mb32 + ma14 * mb42;
                            m[5] = ma21 * mb12 + ma22 * mb22 + ma23 * mb32 + ma24 * mb42;
                            m[6] = ma31 * mb12 + ma32 * mb22 + ma33 * mb32 + ma34 * mb42;
                            m[7] = ma41 * mb12 + ma42 * mb22 + ma43 * mb32 + ma44 * mb42;

                            m[8] = ma11 * mb13 + ma12 * mb23 + ma13 * mb33 + ma14 * mb43;
                            m[9] = ma21 * mb13 + ma22 * mb23 + ma23 * mb33 + ma24 * mb43;
                            m[10] = ma31 * mb13 + ma32 * mb23 + ma33 * mb33 + ma34 * mb43;
                            m[11] = ma41 * mb13 + ma42 * mb23 + ma43 * mb33 + ma44 * mb43;

                            m[12] = ma11 * mb14 + ma12 * mb24 + ma13 * mb34 + ma14 * mb44;
                            m[13] = ma21 * mb14 + ma22 * mb24 + ma23 * mb34 + ma24 * mb44;
                            m[14] = ma31 * mb14 + ma32 * mb24 + ma33 * mb34 + ma34 * mb44;
                            m[15] = ma41 * mb14 + ma42 * mb24 + ma43 * mb34 + ma44 * mb44;
                        };
                        Matrix3D.prototype.prepend = function (rhs) {
                            var ma = this._matrix, mb = rhs._matrix, m = this._matrix;
                            var ma11 = ma[0], ma12 = ma[4], ma13 = ma[8], ma14 = ma[12], ma21 = ma[1], ma22 = ma[5], ma23 = ma[9], ma24 = ma[13], ma31 = ma[2], ma32 = ma[6], ma33 = ma[10], ma34 = ma[14], ma41 = ma[3], ma42 = ma[7], ma43 = ma[11], ma44 = ma[15];
                            var mb11 = mb[0], mb12 = mb[4], mb13 = mb[8], mb14 = mb[12], mb21 = mb[1], mb22 = mb[5], mb23 = mb[9], mb24 = mb[13], mb31 = mb[2], mb32 = mb[6], mb33 = mb[10], mb34 = mb[14], mb41 = mb[3], mb42 = mb[7], mb43 = mb[11], mb44 = mb[15];

                            m[0] = ma11 * mb11 + ma12 * mb21 + ma13 * mb31 + ma14 * mb41;
                            m[1] = ma21 * mb11 + ma22 * mb21 + ma23 * mb31 + ma24 * mb41;
                            m[2] = ma31 * mb11 + ma32 * mb21 + ma33 * mb31 + ma34 * mb41;
                            m[3] = ma41 * mb11 + ma42 * mb21 + ma43 * mb31 + ma44 * mb41;

                            m[4] = ma11 * mb12 + ma12 * mb22 + ma13 * mb32 + ma14 * mb42;
                            m[5] = ma21 * mb12 + ma22 * mb22 + ma23 * mb32 + ma24 * mb42;
                            m[6] = ma31 * mb12 + ma32 * mb22 + ma33 * mb32 + ma34 * mb42;
                            m[7] = ma41 * mb12 + ma42 * mb22 + ma43 * mb32 + ma44 * mb42;

                            m[8] = ma11 * mb13 + ma12 * mb23 + ma13 * mb33 + ma14 * mb43;
                            m[9] = ma21 * mb13 + ma22 * mb23 + ma23 * mb33 + ma24 * mb43;
                            m[10] = ma31 * mb13 + ma32 * mb23 + ma33 * mb33 + ma34 * mb43;
                            m[11] = ma41 * mb13 + ma42 * mb23 + ma43 * mb33 + ma44 * mb43;

                            m[12] = ma11 * mb14 + ma12 * mb24 + ma13 * mb34 + ma14 * mb44;
                            m[13] = ma21 * mb14 + ma22 * mb24 + ma23 * mb34 + ma24 * mb44;
                            m[14] = ma31 * mb14 + ma32 * mb24 + ma33 * mb34 + ma34 * mb44;
                            m[15] = ma41 * mb14 + ma42 * mb24 + ma43 * mb34 + ma44 * mb44;
                        };
                        Matrix3D.prototype.invert = function () {
                            var d = this.determinant;
                            if (Math.abs(d) < precision) {
                                return false;
                            }

                            d = 1 / d;
                            var m = this._matrix;

                            // operating on transposed matrix
                            var m11 = m[0], m12 = m[1], m13 = m[2], m14 = m[3], m21 = m[4], m22 = m[5], m23 = m[6], m24 = m[7], m31 = m[8], m32 = m[9], m33 = m[10], m34 = m[11], m41 = m[12], m42 = m[13], m43 = m[14], m44 = m[15];

                            m[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                            m[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                            m[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                            m[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));

                            m[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                            m[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                            m[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                            m[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));

                            m[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                            m[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                            m[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                            m[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));

                            m[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                            m[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                            m[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                            m[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));

                            return true;
                        };
                        Matrix3D.prototype.identity = function () {
                            var m = this._matrix;
                            m[0] = m[5] = m[10] = m[15] = 1;
                            m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
                        };
                        Matrix3D.prototype.decompose = function (orientationStyle) {
                            if (typeof orientationStyle === "undefined") { orientationStyle = "eulerAngles"; }
                            orientationStyle = asCoerceString(orientationStyle);
                            notImplemented("public flash.geom.Matrix3D::decompose");
                            return;
                        };
                        Matrix3D.prototype.recompose = function (components, orientationStyle) {
                            if (typeof orientationStyle === "undefined") { orientationStyle = "eulerAngles"; }
                            orientationStyle = asCoerceString(orientationStyle);
                            notImplemented("public flash.geom.Matrix3D::recompose");
                            return;
                        };
                        Matrix3D.prototype.appendTranslation = function (x, y, z) {
                            x = +x;
                            y = +y;
                            z = +z;
                            var m = this._matrix;
                            var m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];

                            m[0] += x * m41;
                            m[1] += y * m41;
                            m[2] += z * m41;

                            m[4] += x * m42;
                            m[5] += y * m42;
                            m[6] += z * m42;

                            m[8] += x * m43;
                            m[9] += y * m43;
                            m[10] += z * m43;

                            m[12] += x * m44;
                            m[13] += y * m44;
                            m[14] += z * m44;
                        };
                        Matrix3D.prototype.appendRotation = function (degrees, axis, pivotPoint) {
                            if (typeof pivotPoint === "undefined") { pivotPoint = null; }
                            degrees = +degrees;
                            axis = axis;
                            pivotPoint = pivotPoint;
                            this.append(getRotationMatrix(degrees / 180 * Math.PI, axis.x, axis.y, axis.z, pivotPoint ? pivotPoint.x : 0, pivotPoint ? pivotPoint.y : 0, pivotPoint ? pivotPoint.z : 0));
                        };
                        Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
                            xScale = +xScale;
                            yScale = +yScale;
                            zScale = +zScale;
                            var m = this._matrix;

                            m[0] *= xScale;
                            m[1] *= yScale;
                            m[2] *= zScale;

                            m[4] *= xScale;
                            m[5] *= yScale;
                            m[6] *= zScale;

                            m[8] *= xScale;
                            m[9] *= yScale;
                            m[10] *= zScale;

                            m[12] *= xScale;
                            m[13] *= yScale;
                            m[14] *= zScale;
                        };
                        Matrix3D.prototype.prependTranslation = function (x, y, z) {
                            x = +x;
                            y = +y;
                            z = +z;
                            var m = this._matrix;
                            var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                            m[12] += m11 * x + m12 * y + m13 * z;
                            m[13] += m21 * x + m22 * y + m23 * z;
                            m[14] += m31 * x + m32 * y + m33 * z;
                            m[15] += m41 * x + m42 * y + m43 * z;
                        };
                        Matrix3D.prototype.prependRotation = function (degrees, axis, pivotPoint) {
                            if (typeof pivotPoint === "undefined") { pivotPoint = null; }
                            degrees = +degrees;
                            axis = axis;
                            pivotPoint = pivotPoint;
                            this.prepend(getRotationMatrix(degrees / 180 * Math.PI, axis.x, axis.y, axis.z, pivotPoint ? pivotPoint.x : 0, pivotPoint ? pivotPoint.y : 0, pivotPoint ? pivotPoint.z : 0));
                        };
                        Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
                            xScale = +xScale;
                            yScale = +yScale;
                            zScale = +zScale;
                            var m = this._matrix;

                            m[0] *= xScale;
                            m[1] *= xScale;
                            m[2] *= xScale;
                            m[3] *= xScale;

                            m[4] *= yScale;
                            m[5] *= yScale;
                            m[6] *= yScale;
                            m[7] *= yScale;

                            m[8] *= zScale;
                            m[9] *= zScale;
                            m[10] *= zScale;
                            m[11] *= zScale;
                        };
                        Matrix3D.prototype.transformVector = function (v) {
                            var m = this._matrix;
                            var x = v.x, y = v.y, z = v.z;
                            return new flash.geom.Vector3D(m[0] * x + m[4] * y + m[8] * z + m[12], m[1] * x + m[5] * y + m[9] * z + m[13], m[2] * x + m[6] * y + m[10] * z + m[14]);
                        };
                        Matrix3D.prototype.deltaTransformVector = function (v) {
                            var m = this._matrix;
                            var x = v.x, y = v.y, z = v.z;
                            return new flash.geom.Vector3D(m[0] * x + m[4] * y + m[8] * z, m[1] * x + m[5] * y + m[9] * z, m[2] * x + m[6] * y + m[10] * z);
                        };
                        Matrix3D.prototype.transformVectors = function (vin, vout) {
                            var m = this._matrix;
                            var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                            for (var i = 0; i < vin.length - 2; i += 3) {
                                var x = vin.asGetNumericProperty(i), y = vin.asGetNumericProperty(i + 1), z = vin.asGetNumericProperty(i + 2);
                                vout.push(m11 * x + m12 * y + m13 * z + m14);
                                vout.push(m21 * x + m22 * y + m23 * z + m24);
                                vout.push(m31 * x + m32 * y + m33 * z + m34);
                            }
                        };
                        Matrix3D.prototype.transpose = function () {
                            var m = this._matrix;
                            var tmp;
                            tmp = m[1];
                            m[1] = m[4];
                            m[4] = tmp;
                            tmp = m[2];
                            m[2] = m[8];
                            m[5] = tmp;
                            tmp = m[3];
                            m[3] = m[12];
                            m[12] = tmp;
                            tmp = m[6];
                            m[6] = m[9];
                            m[9] = tmp;
                            tmp = m[7];
                            m[7] = m[13];
                            m[13] = tmp;
                            tmp = m[11];
                            m[11] = m[14];
                            m[14] = tmp;
                        };
                        Matrix3D.prototype.pointAt = function (pos, at, up) {
                            if (typeof at === "undefined") { at = null; }
                            if (typeof up === "undefined") { up = null; }
                            pos = pos;
                            at = at;
                            up = up;
                            notImplemented("public flash.geom.Matrix3D::pointAt");
                            return;
                        };
                        Matrix3D.prototype.interpolateTo = function (toMat, percent) {
                            toMat = toMat;
                            percent = +percent;
                            notImplemented("public flash.geom.Matrix3D::interpolateTo");
                            return;
                        };
                        Matrix3D.prototype.copyFrom = function (sourceMatrix3D) {
                            sourceMatrix3D = sourceMatrix3D;
                            this._matrix.set(sourceMatrix3D._matrix);
                        };
                        Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
                            if (typeof index === "undefined") { index = 0; }
                            if (typeof transpose === "undefined") { transpose = false; }
                            vector = vector;
                            index = index >>> 0;
                            transpose = !!transpose;
                            var m = this._matrix;
                            if (transpose) {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    vector.asSetNumericProperty(j, m[transposeTransform[i]]);
                                }
                            } else {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    vector.asSetNumericProperty(j, m[i]);
                                }
                            }
                        };
                        Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
                            if (typeof index === "undefined") { index = 0; }
                            if (typeof transpose === "undefined") { transpose = false; }
                            vector = vector;
                            index = index >>> 0;
                            transpose = !!transpose;
                            var m = this._matrix;
                            if (transpose) {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    m[transposeTransform[i]] = vector.asGetNumericProperty(j) || 0; // removing NaN
                                }
                            } else {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    m[i] = vector.asGetNumericProperty(j) || 0; // removing NaN
                                }
                            }
                        };
                        Matrix3D.prototype.copyRowTo = function (row /*uint*/ , vector3D) {
                            row = row >>> 0;
                            vector3D = vector3D;
                            var offset = row | 0;
                            var m = this._matrix;
                            vector3D.x = m[offset];
                            vector3D.y = m[offset + 4];
                            vector3D.z = m[offset + 8];
                            vector3D.w = m[offset + 12];
                        };
                        Matrix3D.prototype.copyColumnTo = function (column /*uint*/ , vector3D) {
                            column = column >>> 0;
                            vector3D = vector3D;
                            var offset = column << 2;
                            var m = this._matrix;
                            vector3D.x = m[offset];
                            vector3D.y = m[offset + 1];
                            vector3D.z = m[offset + 2];
                            vector3D.w = m[offset + 3];
                        };
                        Matrix3D.prototype.copyRowFrom = function (row /*uint*/ , vector3D) {
                            row = row >>> 0;
                            vector3D = vector3D;
                            var offset = row | 0;
                            var m = this._matrix;
                            m[offset] = vector3D.x;
                            m[offset + 4] = vector3D.y;
                            m[offset + 8] = vector3D.z;
                            m[offset + 12] = vector3D.w;
                        };
                        Matrix3D.prototype.copyColumnFrom = function (column /*uint*/ , vector3D) {
                            column = column >>> 0;
                            vector3D = vector3D;
                            var offset = column << 2;
                            var m = this._matrix;
                            m[offset] = vector3D.x;
                            m[offset + 1] = vector3D.y;
                            m[offset + 2] = vector3D.z;
                            m[offset + 3] = vector3D.w;
                        };
                        Matrix3D.classInitializer = null;

                        Matrix3D.initializer = null;

                        Matrix3D.classSymbols = null;

                        Matrix3D.instanceSymbols = null;
                        return Matrix3D;
                    })(AS.ASNative);
                    geom.Matrix3D = Matrix3D;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Orientation3D
                (function (geom) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Orientation3D = (function (_super) {
                        __extends(Orientation3D, _super);
                        function Orientation3D() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.geom.Orientation3D");
                        }
                        Orientation3D.classInitializer = null;

                        Orientation3D.initializer = null;

                        Orientation3D.classSymbols = null;

                        Orientation3D.instanceSymbols = null;

                        Orientation3D.EULER_ANGLES = "eulerAngles";
                        Orientation3D.AXIS_ANGLE = "axisAngle";
                        Orientation3D.QUATERNION = "quaternion";
                        return Orientation3D;
                    })(AS.ASNative);
                    geom.Orientation3D = Orientation3D;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: PerspectiveProjection
                (function (geom) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var PerspectiveProjection = (function (_super) {
                        __extends(PerspectiveProjection, _super);
                        function PerspectiveProjection() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.geom.PerspectiveProjection");
                        }
                        Object.defineProperty(PerspectiveProjection.prototype, "fieldOfView", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _fieldOfView: number;
                            // _projectionCenter: flash.geom.Point;
                            // _focalLength: number;
                            get: function () {
                                notImplemented("public flash.geom.PerspectiveProjection::get fieldOfView");
                                return;
                                // return this._fieldOfView;
                            },
                            set: function (fieldOfViewAngleInDegrees) {
                                fieldOfViewAngleInDegrees = +fieldOfViewAngleInDegrees;
                                notImplemented("public flash.geom.PerspectiveProjection::set fieldOfView");
                                return;
                                // this._fieldOfView = fieldOfViewAngleInDegrees;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(PerspectiveProjection.prototype, "projectionCenter", {
                            get: function () {
                                notImplemented("public flash.geom.PerspectiveProjection::get projectionCenter");
                                return;
                                // return this._projectionCenter;
                            },
                            set: function (p) {
                                p = p;
                                notImplemented("public flash.geom.PerspectiveProjection::set projectionCenter");
                                return;
                                // this._projectionCenter = p;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(PerspectiveProjection.prototype, "focalLength", {
                            get: function () {
                                notImplemented("public flash.geom.PerspectiveProjection::get focalLength");
                                return;
                                // return this._focalLength;
                            },
                            set: function (value) {
                                value = +value;
                                notImplemented("public flash.geom.PerspectiveProjection::set focalLength");
                                return;
                                // this._focalLength = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        PerspectiveProjection.prototype.toMatrix3D = function () {
                            notImplemented("public flash.geom.PerspectiveProjection::toMatrix3D");
                            return;
                        };
                        PerspectiveProjection.classInitializer = null;

                        PerspectiveProjection.initializer = null;

                        PerspectiveProjection.classSymbols = null;

                        PerspectiveProjection.instanceSymbols = null;
                        return PerspectiveProjection;
                    })(AS.ASNative);
                    geom.PerspectiveProjection = PerspectiveProjection;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Point
                (function (geom) {
                    var Point = (function (_super) {
                        __extends(Point, _super);
                        function Point(x, y) {
                            if (typeof x === "undefined") { x = 0; }
                            if (typeof y === "undefined") { y = 0; }
                            false && _super.call(this);
                            this.x = +x;
                            this.y = +y;
                        }

                        Object.defineProperty(Point.prototype, "native_x", {
                            get: function () {
                                return this.x;
                            },
                            set: function (x) {
                                this.x = x;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Point.prototype, "native_y", {
                            get: function () {
                                return this.y;
                            },
                            set: function (y) {
                                this.y = y;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Point.prototype.Point = function (x, y) {
                            if (typeof x === "undefined") { x = 0; }
                            if (typeof y === "undefined") { y = 0; }
                            this.x = x;
                            this.y = y;
                        };

                        Object.defineProperty(Point.prototype, "length", {
                            get: function () {
                                return Math.sqrt(this.x * this.x + this.y * this.y);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Point.interpolate = function (p1, p2, f) {
                            var f1 = 1 - f;
                            return new Point(p1.x * f + p2.x * f1, p1.y * f + p2.y * f1);
                        };

                        Point.distance = function (p1, p2) {
                            var dx = p2.x - p1.x;
                            var dy = p2.y - p1.y;
                            return (dx === 0) ? Math.abs(dy) : (dy === 0) ? Math.abs(dx) : Math.sqrt(dx * dx + dy * dy);
                        };

                        Point.polar = function (length, angle) {
                            length = +length;
                            angle = +angle;
                            return new Point(length * Math.cos(angle), length * Math.sin(angle));
                        };

                        Point.prototype.clone = function () {
                            return new Point(this.x, this.y);
                        };

                        Point.prototype.offset = function (dx, dy) {
                            this.x += +dx;
                            this.y += +dy;
                        };

                        Point.prototype.equals = function (toCompare) {
                            return this.x === toCompare.x && this.y === toCompare.y;
                        };

                        Point.prototype.subtract = function (v) {
                            return new Point(this.x - v.x, this.y - v.y);
                        };

                        Point.prototype.add = function (v) {
                            return new Point(this.x + v.x, this.y + v.y);
                        };

                        Point.prototype.normalize = function (thickness) {
                            if (this.x !== 0 || this.y !== 0) {
                                var relativeThickness = +thickness / this.length;
                                this.x *= relativeThickness;
                                this.y *= relativeThickness;
                            }
                        };

                        Point.prototype.copyFrom = function (sourcePoint) {
                            this.x = sourcePoint.x;
                            this.y = sourcePoint.y;
                        };

                        Point.prototype.setTo = function (x, y) {
                            this.x = +x;
                            this.y = +y;
                        };

                        Point.prototype.toTwips = function () {
                            this.x = (this.x * 20) | 0;
                            this.y = (this.y * 20) | 0;
                            return this;
                        };

                        Point.prototype.toPixels = function () {
                            this.x /= 20;
                            this.y /= 20;
                            return this;
                        };

                        Point.prototype.round = function () {
                            this.x = Math.round(this.x);
                            this.y = Math.round(this.y);
                            return this;
                        };

                        Point.prototype.toString = function () {
                            return "(x=" + this.x + ", y=" + this.y + ")";
                        };
                        Point.classInitializer = null;

                        Point.initializer = null;

                        Point.classSymbols = null;

                        Point.instanceSymbols = null;
                        return Point;
                    })(AS.ASNative);
                    geom.Point = Point;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Rectangle
                (function (geom) {
                    var Rectangle = (function (_super) {
                        __extends(Rectangle, _super);
                        function Rectangle(x, y, width, height) {
                            if (typeof x === "undefined") { x = 0; }
                            if (typeof y === "undefined") { y = 0; }
                            if (typeof width === "undefined") { width = 0; }
                            if (typeof height === "undefined") { height = 0; }
                            false && _super.call(this);
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            this.x = x;
                            this.y = y;
                            this.width = width;
                            this.height = height;
                        }
                        Rectangle.FromBounds = function (bounds) {
                            var xMin = bounds.xMin;
                            var yMin = bounds.yMin;
                            return new Rectangle(xMin / 20, yMin / 20, (bounds.xMax - xMin) / 20, (bounds.yMax - yMin) / 20);
                        };


                        Object.defineProperty(Rectangle.prototype, "native_x", {
                            get: function () {
                                return this.x;
                            },
                            set: function (x) {
                                this.x = x;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "native_y", {
                            get: function () {
                                return this.y;
                            },
                            set: function (y) {
                                this.y = y;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "native_width", {
                            get: function () {
                                return this.width;
                            },
                            set: function (width) {
                                this.width = +width;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "native_height", {
                            get: function () {
                                return this.height;
                            },
                            set: function (height) {
                                this.height = +height;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Rectangle.prototype, "left", {
                            get: function () {
                                return this.x;
                            },
                            set: function (value) {
                                value = +value;
                                this.width += this.x - value;
                                this.x = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "right", {
                            get: function () {
                                return this.x + this.width;
                            },
                            set: function (value) {
                                value = +value;
                                this.width = value - this.x;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "top", {
                            get: function () {
                                return this.y;
                            },
                            set: function (value) {
                                value = +value;
                                this.height += this.y - value;
                                this.y = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "bottom", {
                            get: function () {
                                return this.y + this.height;
                            },
                            set: function (value) {
                                value = +value;
                                this.height = value - this.y;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "topLeft", {
                            get: function () {
                                return new geom.Point(this.left, this.top);
                            },
                            set: function (value) {
                                this.top = value.y;
                                this.left = value.x;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "bottomRight", {
                            get: function () {
                                return new geom.Point(this.right, this.bottom);
                            },
                            set: function (value) {
                                this.bottom = value.y;
                                this.right = value.x;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "size", {
                            get: function () {
                                return new geom.Point(this.width, this.height);
                            },
                            set: function (value) {
                                this.width = value.x;
                                this.height = value.y;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Rectangle.prototype, "area", {
                            get: function () {
                                return this.width * this.height;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Rectangle.prototype.clone = function () {
                            return new Rectangle(this.x, this.y, this.width, this.height);
                        };

                        Rectangle.prototype.isEmpty = function () {
                            return this.width <= 0 || this.height <= 0;
                        };

                        Rectangle.prototype.setEmpty = function () {
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                        };

                        Rectangle.prototype.inflate = function (dx, dy) {
                            dx = +dx;
                            dy = +dy;
                            this.x -= dx;
                            this.y -= dy;
                            this.width += (dx * 2);
                            this.height += (dy * 2);
                        };

                        Rectangle.prototype.inflatePoint = function (point) {
                            this.inflate(point.x, point.y);
                        };

                        Rectangle.prototype.offset = function (dx, dy) {
                            this.x += +dx;
                            this.y += +dy;
                        };

                        Rectangle.prototype.offsetPoint = function (point) {
                            this.offset(point.x, point.y);
                        };

                        Rectangle.prototype.contains = function (x, y) {
                            x = +x;
                            y = +y;
                            return x >= this.x && x < this.right && y >= this.y && y < this.bottom;
                        };

                        Rectangle.prototype.containsPoint = function (point) {
                            return this.contains(point.x, point.y);
                        };

                        Rectangle.prototype.containsRect = function (rect) {
                            var r1 = rect.x + rect.width;
                            var b1 = rect.y + rect.height;
                            var r2 = this.x + this.width;
                            var b2 = this.y + this.height;
                            return (rect.x >= this.x) && (rect.x < r2) && (rect.y >= this.y) && (rect.y < b2) && (r1 > this.x) && (r1 <= r2) && (b1 > this.y) && (b1 <= b2);
                        };

                        Rectangle.prototype.intersection = function (toIntersect) {
                            return this.clone().intersectInPlace(toIntersect);
                        };

                        Rectangle.prototype.intersects = function (toIntersect) {
                            return Math.max(this.x, toIntersect.x) <= Math.min(this.right, toIntersect.right) && Math.max(this.y, toIntersect.y) <= Math.min(this.bottom, toIntersect.bottom);
                        };

                        Rectangle.prototype.intersectInPlace = function (clipRect) {
                            var l = Math.max(this.x, clipRect.x);
                            var r = Math.min(this.right, clipRect.right);
                            if (l <= r) {
                                var t = Math.max(this.y, clipRect.y);
                                var b = Math.min(this.bottom, clipRect.bottom);
                                if (t <= b) {
                                    this.setTo(l, t, r - l, b - t);
                                    return this;
                                }
                            }
                            this.setEmpty();
                            return this;
                        };

                        Rectangle.prototype.union = function (toUnion) {
                            return this.clone().unionInPlace(toUnion);
                        };

                        Rectangle.prototype.unionInPlace = function (toUnion) {
                            if (toUnion.isEmpty()) {
                                return;
                            }
                            if (this.isEmpty()) {
                                this.copyFrom(toUnion);
                                return;
                            }
                            var l = Math.min(this.x, toUnion.x);
                            var t = Math.min(this.y, toUnion.y);
                            this.setTo(l, t, Math.max(this.right, toUnion.right) - l, Math.max(this.bottom, toUnion.bottom) - t);
                            return this;
                        };

                        Rectangle.prototype.equals = function (toCompare) {
                            return this.x === toCompare.x && this.y === toCompare.y && this.width === toCompare.width && this.height === toCompare.height;
                        };

                        Rectangle.prototype.copyFrom = function (sourceRect) {
                            this.x = sourceRect.x;
                            this.y = sourceRect.y;
                            this.width = sourceRect.width;
                            this.height = sourceRect.height;
                        };

                        Rectangle.prototype.setTo = function (x, y, width, height) {
                            this.x = +x;
                            this.y = +y;
                            this.width = +width;
                            this.height = +height;
                        };

                        Rectangle.prototype.toTwips = function () {
                            this.x = (this.x * 20) | 0;
                            this.y = (this.y * 20) | 0;
                            this.width = (this.width * 20) | 0;
                            this.height = (this.height * 20) | 0;
                            return this;
                        };

                        Rectangle.prototype.getBaseWidth = function (angle) {
                            var u = Math.abs(Math.cos(angle));
                            var v = Math.abs(Math.sin(angle));
                            return u * this.width + v * this.height;
                        };

                        Rectangle.prototype.getBaseHeight = function (angle) {
                            var u = Math.abs(Math.cos(angle));
                            var v = Math.abs(Math.sin(angle));
                            return v * this.width + u * this.height;
                        };

                        Rectangle.prototype.toPixels = function () {
                            this.x /= 20;
                            this.y /= 20;
                            this.width /= 20;
                            this.height /= 20;
                            return this;
                        };

                        Rectangle.prototype.snapInPlace = function () {
                            var x1 = Math.ceil(this.x + this.width);
                            var y1 = Math.ceil(this.y + this.height);
                            this.x = Math.floor(this.x);
                            this.y = Math.floor(this.y);
                            this.width = x1 - this.x;
                            this.height = y1 - this.y;
                            return this;
                        };

                        Rectangle.prototype.roundInPlace = function () {
                            var x1 = Math.round(this.x + this.width);
                            var y1 = Math.round(this.y + this.height);
                            this.x = Math.round(this.x);
                            this.y = Math.round(this.y);
                            this.width = x1 - this.x;
                            this.height = y1 - this.y;
                            return this;
                        };

                        Rectangle.prototype.toString = function () {
                            return "(x=" + this.x + ", y=" + this.y + ", w=" + this.width + ", h=" + this.height + ")";
                        };

                        Rectangle.prototype.writeExternal = function (output) {
                            output.writeFloat(this.x);
                            output.writeFloat(this.y);
                            output.writeFloat(this.width);
                            output.writeFloat(this.height);
                        };

                        Rectangle.prototype.readExternal = function (input) {
                            this.x = input.readFloat();
                            this.y = input.readFloat();
                            this.width = input.readFloat();
                            this.height = input.readFloat();
                        };
                        Rectangle.classInitializer = null;

                        Rectangle.initializer = null;

                        Rectangle.classSymbols = null;

                        Rectangle.instanceSymbols = null;
                        return Rectangle;
                    })(AS.ASNative);
                    geom.Rectangle = Rectangle;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Transform
                (function (geom) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var Errors = Shumway.AVM2.Errors;

                    var Transform = (function (_super) {
                        __extends(Transform, _super);
                        function Transform(displayObject) {
                            false && _super.call(this);
                            if (!displayObject) {
                                throwError("ArgumentError", Errors.NullPointerError, "displayObject");
                            }
                            this._displayObject = displayObject;
                        }
                        Object.defineProperty(Transform.prototype, "matrix", {
                            get: function () {
                                return this._displayObject._getMatrix().clone().toPixelsInPlace();
                            },
                            set: function (value) {
                                this._displayObject._setMatrix(value, true);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Transform.prototype, "colorTransform", {
                            get: function () {
                                return this._displayObject._colorTransform.clone();
                            },
                            set: function (value) {
                                this._displayObject._setColorTransform(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Transform.prototype, "concatenatedMatrix", {
                            get: function () {
                                var matrix = this._displayObject._getConcatenatedMatrix().clone().toPixelsInPlace();
                                if (!this._displayObject._stage) {
                                    matrix.scale(5, 5);
                                }
                                return matrix;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Transform.prototype, "concatenatedColorTransform", {
                            get: function () {
                                return this._displayObject._getConcatenatedColorTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Transform.prototype, "pixelBounds", {
                            get: function () {
                                notImplemented("public flash.geom.Transform::get pixelBounds");
                                return;
                                // return this._pixelBounds;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Transform.prototype, "matrix3D", {
                            get: function () {
                                var m = this._displayObject._matrix3D;
                                return m && m.clone();
                            },
                            set: function (m) {
                                if (!(geom.Matrix3D.isType(m))) {
                                    throwError('TypeError', Errors.CheckTypeFailedError, m, 'flash.geom.Matrix3D');
                                }

                                var raw = m.rawData;

                                // TODO why is this not a 3D matrix?
                                this.matrix = new flash.geom.Matrix(raw.asGetPublicProperty(0), raw.asGetPublicProperty(1), raw.asGetPublicProperty(4), raw.asGetPublicProperty(5), raw.asGetPublicProperty(12), raw.asGetPublicProperty(13));

                                // this.matrix will reset this._target._matrix3D
                                // TODO: Must make sure to also deal with the _rotateXYZ properties.
                                somewhatImplemented("public flash.geom.Transform::set matrix3D");
                                // this._displayObject._matrix3D = m;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Transform.prototype.getRelativeMatrix3D = function (relativeTo) {
                            relativeTo = relativeTo;
                            notImplemented("public flash.geom.Transform::getRelativeMatrix3D");
                            return;
                        };

                        Object.defineProperty(Transform.prototype, "perspectiveProjection", {
                            get: function () {
                                notImplemented("public flash.geom.Transform::get perspectiveProjection");
                                return;
                                // return this._perspectiveProjection;
                            },
                            set: function (pm) {
                                pm = pm;
                                notImplemented("public flash.geom.Transform::set perspectiveProjection");
                                return;
                                // this._perspectiveProjection = pm;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Transform.classInitializer = null;
                        Transform.initializer = null;
                        Transform.classSymbols = null;
                        Transform.instanceSymbols = null;
                        return Transform;
                    })(AS.ASNative);
                    geom.Transform = Transform;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Utils3D
                (function (geom) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Utils3D = (function (_super) {
                        __extends(Utils3D, _super);
                        function Utils3D() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.geom.Utils3D");
                        }
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        Utils3D.projectVector = function (m, v) {
                            m = m;
                            v = v;
                            notImplemented("public flash.geom.Utils3D::static projectVector");
                            return;
                        };
                        Utils3D.projectVectors = function (m, verts, projectedVerts, uvts) {
                            m = m;
                            verts = verts;
                            projectedVerts = projectedVerts;
                            uvts = uvts;
                            notImplemented("public flash.geom.Utils3D::static projectVectors");
                            return;
                        };
                        Utils3D.pointTowards = function (percent, mat, pos, at, up) {
                            if (typeof at === "undefined") { at = null; }
                            if (typeof up === "undefined") { up = null; }
                            percent = +percent;
                            mat = mat;
                            pos = pos;
                            at = at;
                            up = up;
                            notImplemented("public flash.geom.Utils3D::static pointTowards");
                            return;
                        };
                        Utils3D.classInitializer = null;

                        Utils3D.initializer = null;

                        Utils3D.classSymbols = null;

                        Utils3D.instanceSymbols = null;
                        return Utils3D;
                    })(AS.ASNative);
                    geom.Utils3D = Utils3D;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Vector3D
                (function (geom) {
                    var Vector3D = (function (_super) {
                        __extends(Vector3D, _super);
                        function Vector3D(x, y, z, w) {
                            if (typeof x === "undefined") { x = 0; }
                            if (typeof y === "undefined") { y = 0; }
                            if (typeof z === "undefined") { z = 0; }
                            if (typeof w === "undefined") { w = 0; }
                            false && _super.call(this);
                            this.x = +x;
                            this.y = +y;
                            this.z = +z;
                            this.w = +w;
                        }

                        Object.defineProperty(Vector3D.prototype, "native_x", {
                            get: function () {
                                return this.x;
                            },
                            set: function (x) {
                                this.x = x;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Vector3D.prototype, "native_y", {
                            get: function () {
                                return this.y;
                            },
                            set: function (y) {
                                this.y = y;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Vector3D.prototype, "native_z", {
                            get: function () {
                                return this.z;
                            },
                            set: function (z) {
                                this.z = z;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Vector3D.prototype, "native_w", {
                            get: function () {
                                return this.w;
                            },
                            set: function (w) {
                                this.w = w;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Vector3D.prototype, "length", {
                            get: function () {
                                return Math.sqrt(this.lengthSquared);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Vector3D.prototype, "lengthSquared", {
                            get: function () {
                                return this.x * this.x + this.y * this.y + this.z * this.z;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Vector3D.angleBetween = function (a, b) {
                            // http://chemistry.about.com/od/workedchemistryproblems/a/scalar-product-vectors-problem.htm
                            return Math.acos(a.dotProduct(b) / (a.length * b.length));
                        };

                        Vector3D.distance = function (pt1, pt2) {
                            // http://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions
                            return pt1.subtract(pt2).length;
                        };

                        Vector3D.prototype.dotProduct = function (a) {
                            return this.x * a.x + this.y * a.y + this.z * a.z;
                        };
                        Vector3D.prototype.crossProduct = function (a) {
                            return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1.0);
                        };
                        Vector3D.prototype.normalize = function () {
                            var length = this.length;
                            if (length !== 0) {
                                this.x /= length;
                                this.y /= length;
                                this.z /= length;
                            } else {
                                this.x = this.y = this.z = 0;
                            }
                            return length;
                        };
                        Vector3D.prototype.scaleBy = function (s) {
                            s = +s;
                            this.x *= s;
                            this.y *= s;
                            this.z *= s;
                        };
                        Vector3D.prototype.incrementBy = function (a) {
                            this.x += a.x;
                            this.y += a.y;
                            this.z += a.z;
                        };
                        Vector3D.prototype.decrementBy = function (a) {
                            this.x -= a.x;
                            this.y -= a.y;
                            this.z -= a.z;
                        };
                        Vector3D.prototype.add = function (a) {
                            return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z);
                        };
                        Vector3D.prototype.subtract = function (a) {
                            return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
                        };
                        Vector3D.prototype.negate = function () {
                            this.x = -this.x;
                            this.y = -this.y;
                            this.z = -this.z;
                        };
                        Vector3D.prototype.equals = function (toCompare, allFour) {
                            return (this.x === toCompare.x) && (this.y === toCompare.y) && (this.z === toCompare.z) && (!allFour || (this.w === toCompare.w));
                        };
                        Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
                            return (Math.abs(this.x - toCompare.x) < tolerance) && (Math.abs(this.y - toCompare.y) < tolerance) && (Math.abs(this.z - toCompare.z) < tolerance) && (!allFour || (Math.abs(this.w - toCompare.w) < tolerance));
                        };
                        Vector3D.prototype.project = function () {
                            this.x /= this.w;
                            this.y /= this.w;
                            this.z /= this.w;
                        };
                        Vector3D.prototype.copyFrom = function (sourceVector3D) {
                            this.x = sourceVector3D.x;
                            this.y = sourceVector3D.y;
                            this.z = sourceVector3D.z;
                        };
                        Vector3D.prototype.setTo = function (xa, ya, za) {
                            this.x = +xa;
                            this.y = +ya;
                            this.z = +za;
                        };
                        Vector3D.prototype.clone = function () {
                            return new Vector3D(this.x, this.y, this.z, this.w);
                        };
                        Vector3D.prototype.toString = function () {
                            return "Vector3D(" + this.x + ", " + this.y + ", " + this.z + ")";
                        };
                        Vector3D.classInitializer = null;
                        Vector3D.initializer = null;
                        Vector3D.classSymbols = null;
                        Vector3D.instanceSymbols = null;

                        Vector3D.X_AXIS = Object.freeze(new Vector3D(1, 0, 0));
                        Vector3D.Y_AXIS = Object.freeze(new Vector3D(0, 1, 0));
                        Vector3D.Z_AXIS = Object.freeze(new Vector3D(0, 0, 1));
                        return Vector3D;
                    })(AS.ASNative);
                    geom.Vector3D = Vector3D;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Accessibility
                (function (accessibility) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Accessibility = (function (_super) {
                        __extends(Accessibility, _super);
                        function Accessibility() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.accessibility.Accessibility");
                        }
                        Object.defineProperty(Accessibility, "active", {
                            get: function () {
                                notImplemented("public flash.accessibility.Accessibility::get active");
                                return Accessibility._active;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Accessibility.sendEvent = function (source, childID /*uint*/ , eventType /*uint*/ , nonHTML) {
                            if (typeof nonHTML === "undefined") { nonHTML = false; }
                            source = source;
                            childID = childID >>> 0;
                            eventType = eventType >>> 0;
                            nonHTML = !!nonHTML;
                            notImplemented("public flash.accessibility.Accessibility::static sendEvent");
                            return;
                        };
                        Accessibility.updateProperties = function () {
                            notImplemented("public flash.accessibility.Accessibility::static updateProperties");
                            return;
                        };
                        Accessibility.classInitializer = null;

                        Accessibility.initializer = null;

                        Accessibility.classSymbols = null;

                        Accessibility.instanceSymbols = null;

                        Accessibility._active = false;
                        return Accessibility;
                    })(AS.ASNative);
                    accessibility.Accessibility = Accessibility;
                })(flash.accessibility || (flash.accessibility = {}));
                var accessibility = flash.accessibility;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: AccessibilityImplementation
                (function (accessibility) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var AccessibilityImplementation = (function (_super) {
                        __extends(AccessibilityImplementation, _super);
                        function AccessibilityImplementation() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.accessibility.AccessibilityImplementation");
                        }
                        AccessibilityImplementation.classInitializer = null;

                        AccessibilityImplementation.initializer = null;

                        AccessibilityImplementation.classSymbols = null;

                        AccessibilityImplementation.instanceSymbols = null;
                        return AccessibilityImplementation;
                    })(AS.ASNative);
                    accessibility.AccessibilityImplementation = AccessibilityImplementation;
                })(flash.accessibility || (flash.accessibility = {}));
                var accessibility = flash.accessibility;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: AccessibilityProperties
                (function (accessibility) {
                    var AccessibilityProperties = (function (_super) {
                        __extends(AccessibilityProperties, _super);
                        function AccessibilityProperties() {
                            false && _super.call(this);
                        }
                        AccessibilityProperties.classInitializer = null;

                        AccessibilityProperties.initializer = null;

                        AccessibilityProperties.classSymbols = null;

                        AccessibilityProperties.instanceSymbols = null;
                        return AccessibilityProperties;
                    })(AS.ASNative);
                    accessibility.AccessibilityProperties = AccessibilityProperties;
                })(flash.accessibility || (flash.accessibility = {}));
                var accessibility = flash.accessibility;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Event
                (function (events) {
                    var assert = Shumway.Debug.assert;

                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var Event = (function (_super) {
                        __extends(Event, _super);
                        function Event(type, bubbles, cancelable) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            false && _super.call(this);
                            this._type = asCoerceString(type);
                            this._bubbles = !!bubbles;
                            this._cancelable = !!cancelable;

                            this._target = null;
                            this._currentTarget = null;
                            this._eventPhase = events.EventPhase.AT_TARGET;

                            this._stopPropagation = false;
                            this._stopImmediatePropagation = false;
                            this._isDefaultPrevented = false;
                        }
                        Event.getInstance = function (type, bubbles, cancelable) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            var instance = Event._instances[type];
                            if (!instance) {
                                instance = new Event(type, bubbles, cancelable);
                                Event._instances[type] = instance;
                            }
                            instance._bubbles = bubbles;
                            instance._cancelable = cancelable;
                            return instance;
                        };

                        Event.getBroadcastInstance = function (type, bubbles, cancelable) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            var instance = Event._instances[type];
                            if (!instance) {
                                instance = new Event(type, bubbles, cancelable);
                                Event._instances[type] = instance;

                                // Some events are documented as broadcast event in the AS3 docs. We can't set |_isBroadcastEvent| flag in the
                                // constructor because if you create custom events with these types they do capture and bubble.
                                release || assert(Event.isBroadcastEventType(type));
                            }
                            instance._isBroadcastEvent = true;
                            instance._bubbles = bubbles;
                            instance._cancelable = cancelable;
                            return instance;
                        };

                        /**
                        * http://stackoverflow.com/questions/16900176/as3enterframe-event-propagation-understanding-issue
                        */
                        Event.isBroadcastEventType = function (type) {
                            switch (type) {
                                case Event.ENTER_FRAME:
                                case Event.EXIT_FRAME:
                                case Event.FRAME_CONSTRUCTED:
                                case Event.RENDER:
                                case Event.ACTIVATE:
                                case Event.DEACTIVATE:
                                    return true;
                            }
                            return false;
                        };

                        Object.defineProperty(Event.prototype, "type", {
                            get: function () {
                                return this._type;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Event.prototype, "bubbles", {
                            get: function () {
                                return this._bubbles;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Event.prototype, "cancelable", {
                            get: function () {
                                return this._cancelable;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Event.prototype, "target", {
                            get: function () {
                                return this._target;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Event.prototype, "currentTarget", {
                            get: function () {
                                return this._currentTarget;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Event.prototype, "eventPhase", {
                            get: function () {
                                return this._eventPhase;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Event.prototype.stopPropagation = function () {
                            this._stopPropagation = true;
                        };

                        Event.prototype.stopImmediatePropagation = function () {
                            this._stopImmediatePropagation = this._stopPropagation = true;
                        };

                        Event.prototype.preventDefault = function () {
                            if (this._cancelable) {
                                this._isDefaultPrevented = true;
                            }
                        };

                        Event.prototype.isDefaultPrevented = function () {
                            return this._isDefaultPrevented;
                        };

                        Event.prototype.isBroadcastEvent = function () {
                            return !!this._isBroadcastEvent;
                        };
                        Event.classInitializer = function () {
                            Event._instances = Shumway.ObjectUtilities.createMap();
                        };

                        Event.initializer = null;

                        Event.classSymbols = null;
                        Event.instanceSymbols = ["clone!"];

                        Event.ACTIVATE = "activate";
                        Event.ADDED = "added";
                        Event.ADDED_TO_STAGE = "addedToStage";
                        Event.CANCEL = "cancel";
                        Event.CHANGE = "change";
                        Event.CLEAR = "clear";
                        Event.CLOSE = "close";
                        Event.COMPLETE = "complete";
                        Event.CONNECT = "connect";
                        Event.COPY = "copy";
                        Event.CUT = "cut";
                        Event.DEACTIVATE = "deactivate";
                        Event.ENTER_FRAME = "enterFrame";
                        Event.FRAME_CONSTRUCTED = "frameConstructed";
                        Event.EXIT_FRAME = "exitFrame";
                        Event.FRAME_LABEL = "frameLabel";
                        Event.ID3 = "id3";
                        Event.INIT = "init";
                        Event.MOUSE_LEAVE = "mouseLeave";
                        Event.OPEN = "open";
                        Event.PASTE = "paste";
                        Event.REMOVED = "removed";
                        Event.REMOVED_FROM_STAGE = "removedFromStage";
                        Event.RENDER = "render";
                        Event.RESIZE = "resize";
                        Event.SCROLL = "scroll";
                        Event.TEXT_INTERACTION_MODE_CHANGE = "textInteractionModeChange";
                        Event.SELECT = "select";
                        Event.SELECT_ALL = "selectAll";
                        Event.SOUND_COMPLETE = "soundComplete";
                        Event.TAB_CHILDREN_CHANGE = "tabChildrenChange";
                        Event.TAB_ENABLED_CHANGE = "tabEnabledChange";
                        Event.TAB_INDEX_CHANGE = "tabIndexChange";
                        Event.UNLOAD = "unload";
                        Event.FULLSCREEN = "fullScreen";
                        Event.CONTEXT3D_CREATE = "context3DCreate";
                        Event.TEXTURE_READY = "textureReady";
                        Event.VIDEO_FRAME = "videoFrame";
                        Event.SUSPEND = "suspend";
                        return Event;
                    })(AS.ASNative);
                    events.Event = Event;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: EventDispatcher
                (function (events) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;
                    var isFunction = Shumway.isFunction;
                    var isNullOrUndefined = Shumway.isNullOrUndefined;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var assert = Shumway.Debug.assert;

                    var EventListenerEntry = (function () {
                        function EventListenerEntry(listener, useCapture, priority) {
                            this.listener = listener;
                            this.useCapture = useCapture;
                            this.priority = priority;
                        }
                        return EventListenerEntry;
                    })();

                    /**
                    * Implements Copy-On-Write for event listener lists. Event handlers can add and/or remove
                    * event handlers while the events are processed. The easiest way to implement this is to
                    * clone the event listener list before executing the event listeners. This however can be
                    * wasteful, since most of the time, event handlers don't mutate the event list. Here we
                    * implement a simple copy-on-write strategy that clones the entry list if it's been
                    * snapshotted and it's about to be mutated.
                    */
                    var EventListenerList = (function () {
                        function EventListenerList() {
                            /**
                            * The number of times the current entry list has been aliased (or snapshotted).
                            */
                            this._aliasCount = 0;
                            this._entries = [];
                        }
                        EventListenerList.prototype.isEmpty = function () {
                            return this._entries.length === 0;
                        };

                        EventListenerList.prototype.insert = function (listener, useCapture, priority) {
                            var entries = this._entries;
                            var index = entries.length;
                            for (var i = index - 1; i >= 0; i--) {
                                var entry = entries[i];
                                if (entry.listener === listener) {
                                    return;
                                }
                                if (priority > entry.priority) {
                                    index = i;
                                } else {
                                    break;
                                }
                            }
                            entries = this.ensureNonAliasedEntries();
                            entries.splice(index, 0, new EventListenerEntry(listener, useCapture, priority));
                        };

                        /**
                        * Make sure we get a fresh list if it's been aliased.
                        */
                        EventListenerList.prototype.ensureNonAliasedEntries = function () {
                            var entries = this._entries;
                            if (this._aliasCount > 0) {
                                entries = this._entries = entries.slice();
                                this._aliasCount = 0;
                            }
                            return entries;
                        };

                        EventListenerList.prototype.remove = function (listener) {
                            var entries = this._entries;
                            for (var i = 0; i < entries.length; i++) {
                                var item = entries[i];
                                if (item.listener === listener) {
                                    this.ensureNonAliasedEntries().splice(i, 1);
                                    return;
                                }
                            }
                        };

                        /**
                        * Get a snapshot of the current entry list.
                        */
                        EventListenerList.prototype.snapshot = function () {
                            this._aliasCount++;
                            return this._entries;
                        };

                        /**
                        * Release the snapshot, hopefully no other mutations occured so we can reuse the entry list.
                        */
                        EventListenerList.prototype.releaseSnapshot = function (snapshot) {
                            // We ignore any non current snapshots.
                            if (this._entries !== snapshot) {
                                return;
                            }
                            if (this._aliasCount > 0) {
                                this._aliasCount--;
                            }
                        };
                        return EventListenerList;
                    })();

                    /**
                    * Broadcast Events
                    *
                    * The logic here is pretty much copied from: http://www.senocular.com/flash/tutorials/orderofoperations/
                    */
                    var BroadcastEventDispatchQueue = (function () {
                        function BroadcastEventDispatchQueue() {
                            this.reset();
                        }
                        BroadcastEventDispatchQueue.prototype.reset = function () {
                            this._queues = Shumway.ObjectUtilities.createEmptyObject();
                        };

                        BroadcastEventDispatchQueue.prototype.add = function (type, target) {
                            release || assert(events.Event.isBroadcastEventType(type), "Can only register broadcast events.");
                            var queue = this._queues[type] || (this._queues[type] = []);
                            if (queue.indexOf(target) >= 0) {
                                return;
                            }
                            queue.push(target);
                        };

                        BroadcastEventDispatchQueue.prototype.remove = function (type, target) {
                            release || assert(events.Event.isBroadcastEventType(type), "Can only unregister broadcast events.");
                            var queue = this._queues[type];
                            release || assert(queue, "There should already be a queue for this.");
                            var index = queue.indexOf(target);
                            release || assert(index >= 0, "Target should be somewhere in this queue.");
                            queue[index] = null;
                            release || assert(queue.indexOf(target) < 0, "Target shouldn't be in this queue anymore.");
                        };

                        BroadcastEventDispatchQueue.prototype.dispatchEvent = function (event) {
                            release || assert(event.isBroadcastEvent(), "Cannot dispatch non-broadcast events.");
                            var queue = this._queues[event.type];
                            if (!queue) {
                                return;
                            }
                            var nullCount = 0;
                            for (var i = 0; i < queue.length; i++) {
                                var target = queue[i];
                                if (target === null) {
                                    nullCount++;
                                } else {
                                    target.dispatchEvent(event);
                                }
                            }

                            // Compact the queue if there are too many holes in it.
                            if (nullCount > 16 && nullCount > (queue.length >> 1)) {
                                var compactedQueue = [];
                                for (var i = 0; i < queue.length; i++) {
                                    if (queue[i]) {
                                        compactedQueue.push(queue[i]);
                                    }
                                }
                                this._queues[event.type] = compactedQueue;
                            }
                        };

                        BroadcastEventDispatchQueue.prototype.getQueueLength = function (type) {
                            return this._queues[type] ? this._queues[type].length : 0;
                        };
                        return BroadcastEventDispatchQueue;
                    })();
                    events.BroadcastEventDispatchQueue = BroadcastEventDispatchQueue;

                    /**
                    * The EventDispatcher class is the base class for all classes that dispatch events.
                    * The EventDispatcher class implements the IEventDispatcher interface and is the base class for
                    * the DisplayObject class. The EventDispatcher class allows any object on the display list to be
                    * an event target and as such, to use the methods of the IEventDispatcher interface.
                    */
                    var EventDispatcher = (function (_super) {
                        __extends(EventDispatcher, _super);
                        function EventDispatcher(target) {
                            if (typeof target === "undefined") { target = null; }
                            false && _super.call(this);
                            this._target = target || this;
                        }
                        /**
                        * Don't lazily construct listener lists if all we're doing is looking for listener types that
                        * don't exist yet.
                        */
                        EventDispatcher.prototype._getListenersForType = function (useCapture, type) {
                            var listeners = useCapture ? this._captureListeners : this._targetOrBubblingListeners;
                            if (listeners) {
                                return listeners[type];
                            }
                            return null;
                        };

                        /**
                        * Lazily construct listeners lists to avoid object allocation.
                        */
                        EventDispatcher.prototype._getListeners = function (useCapture) {
                            if (useCapture) {
                                return this._captureListeners || (this._captureListeners = createEmptyObject());
                            }
                            return this._targetOrBubblingListeners || (this._targetOrBubblingListeners = createEmptyObject());
                        };

                        EventDispatcher.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                            if (typeof useCapture === "undefined") { useCapture = false; }
                            if (typeof priority === "undefined") { priority = 0; }
                            if (typeof useWeakReference === "undefined") { useWeakReference = false; }
                            // The error message always says "2", even though up to five arguments are valid.
                            if (arguments.length < 2 || arguments.length > 5) {
                                throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/addEventListener()", 2, arguments.length);
                            }

                            // The type of `listener` is checked before that of `type`.
                            if (!isFunction(listener)) {
                                // TODO: The Player unevals the `listener`. To some extend, we could, too.
                                throwError("TypeError", AVM2.Errors.CheckTypeFailedError, listener, "Function");
                            }
                            if (isNullOrUndefined(type)) {
                                throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                            }
                            type = asCoerceString(type);
                            useCapture = !!useCapture;
                            priority |= 0;
                            useWeakReference = !!useWeakReference;
                            var listeners = this._getListeners(useCapture);
                            var list = listeners[type] || (listeners[type] = new EventListenerList());
                            list.insert(listener, useCapture, priority);

                            // Notify the broadcast event queue. If |useCapture| is set then the Flash player
                            // doesn't seem to register this target.
                            if (!useCapture && events.Event.isBroadcastEventType(type)) {
                                EventDispatcher.broadcastEventDispatchQueue.add(type, this);
                            }
                        };

                        EventDispatcher.prototype.removeEventListener = function (type, listener, useCapture) {
                            if (typeof useCapture === "undefined") { useCapture = false; }
                            // The error message always says "2", even though 3 arguments are valid.
                            if (arguments.length < 2 || arguments.length > 3) {
                                throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/removeEventListener()", 2, arguments.length);
                            }

                            // The type of `listener` is checked before that of `type`.
                            if (!isFunction(listener)) {
                                // TODO: The Player unevals the `listener`. To some extend, we could, too.
                                throwError("TypeError", AVM2.Errors.CheckTypeFailedError, listener, "Function");
                            }
                            if (isNullOrUndefined(type)) {
                                throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                            }
                            type = asCoerceString(type);
                            var listeners = this._getListeners(!!useCapture);
                            var list = listeners[type];
                            if (list) {
                                list.remove(listener);
                                if (list.isEmpty()) {
                                    // Notify the broadcast event queue of the removal.
                                    if (!useCapture && events.Event.isBroadcastEventType(type)) {
                                        EventDispatcher.broadcastEventDispatchQueue.remove(type, this);
                                    }
                                    listeners[type] = null;
                                }
                            }
                        };

                        EventDispatcher.prototype._hasTargetOrBubblingEventListener = function (type) {
                            return !!(this._targetOrBubblingListeners && this._targetOrBubblingListeners[type]);
                        };

                        EventDispatcher.prototype._hasCaptureEventListener = function (type) {
                            return !!(this._captureListeners && this._captureListeners[type]);
                        };

                        /**
                        * Faster internal version of |hasEventListener| that doesn't do any argument checking.
                        */
                        EventDispatcher.prototype._hasEventListener = function (type) {
                            return this._hasTargetOrBubblingEventListener(type) || this._hasCaptureEventListener(type);
                        };

                        EventDispatcher.prototype.hasEventListener = function (type) {
                            if (arguments.length !== 1) {
                                throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/hasEventListener()", 1, arguments.length);
                            }
                            if (isNullOrUndefined(type)) {
                                throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                            }
                            type = asCoerceString(type);
                            return this._hasEventListener(type);
                        };

                        EventDispatcher.prototype.willTrigger = function (type) {
                            if (arguments.length !== 1) {
                                throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/hasEventListener()", 1, arguments.length);
                            }
                            if (isNullOrUndefined(type)) {
                                throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                            }
                            type = asCoerceString(type);
                            if (this._hasEventListener(type)) {
                                return true;
                            }
                            if (flash.display.DisplayObject.isType(this)) {
                                var node = this._parent;
                                do {
                                    if (node._hasEventListener(type)) {
                                        return true;
                                    }
                                } while((node = node._parent));
                            }
                            return false;
                        };

                        /**
                        * Check to see if we can skip event dispatching in case there are no event listeners
                        * for this |event|.
                        */
                        EventDispatcher.prototype._skipDispatchEvent = function (event) {
                            // Broadcast events don't have capturing or bubbling phases so it's a simple check.
                            if (event.isBroadcastEvent()) {
                                return !this._hasEventListener(event.type);
                            } else if (flash.display.DisplayObject.isType(this)) {
                                // Check to see if there are any event listeners on the path to the root.
                                var node = this;
                                while (node) {
                                    if (node._hasEventListener(event.type)) {
                                        return false;
                                    }
                                    node = node._parent;
                                }
                                return true;
                            }
                            return !this._hasEventListener(event.type);
                        };

                        EventDispatcher.prototype.dispatchEvent = function (event) {
                            if (this._skipDispatchEvent(event)) {
                                return true;
                            }

                            if (arguments.length !== 1) {
                                throwError("ArgumentError", AVM2.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/hasEventListener()", 1, arguments.length);
                            }

                            release || AVM2.counter.count("EventDispatcher::dispatchEvent");

                            var type = event._type;
                            var target = this._target;

                            release || AVM2.counter.count("EventDispatcher::dispatchEvent(" + type + ")");

                            /**
                            * 1. Capturing Phase
                            */
                            var keepPropagating = true;
                            var ancestors = [];

                            if (!event.isBroadcastEvent() && flash.display.DisplayObject.isType(this)) {
                                var node = this._parent;

                                while (node) {
                                    if (node._hasEventListener(type)) {
                                        ancestors.push(node);
                                    }
                                    node = node._parent;
                                }

                                for (var i = ancestors.length - 1; i >= 0 && keepPropagating; i--) {
                                    var ancestor = ancestors[i];
                                    if (!ancestor._hasCaptureEventListener(type)) {
                                        continue;
                                    }
                                    var list = ancestor._getListenersForType(true, type);
                                    release || assert(list);
                                    keepPropagating = EventDispatcher.callListeners(list, event, target, ancestor, events.EventPhase.CAPTURING_PHASE);
                                }
                            }

                            /**
                            * 2. At Target
                            */
                            if (keepPropagating) {
                                var list = this._getListenersForType(false, type);
                                if (list) {
                                    keepPropagating = EventDispatcher.callListeners(this._getListeners(false)[type], event, target, target, events.EventPhase.AT_TARGET);
                                }
                            }

                            /**
                            * 3. Bubbling Phase
                            */
                            if (!event.isBroadcastEvent() && keepPropagating && event.bubbles) {
                                for (var i = 0; i < ancestors.length && keepPropagating; i++) {
                                    var ancestor = ancestors[i];
                                    if (!ancestor._hasTargetOrBubblingEventListener(type)) {
                                        continue;
                                    }
                                    var list = ancestor._getListenersForType(false, type);
                                    keepPropagating = EventDispatcher.callListeners(list, event, target, ancestor, events.EventPhase.BUBBLING_PHASE);
                                }
                            }

                            return !event._isDefaultPrevented;
                        };

                        EventDispatcher.callListeners = function (list, event, target, currentTarget, eventPhase) {
                            if (list.isEmpty()) {
                                return true;
                            }

                            /**
                            * If the target is already set then we must clone the event. We can reuse the event object for
                            * all listener callbacks but not when bubbling.
                            */
                            if (event._target) {
                                event = event.clone();
                            }
                            var snapshot = list.snapshot();
                            for (var i = 0; i < snapshot.length; i++) {
                                var entry = snapshot[i];
                                event._target = target;
                                event._currentTarget = currentTarget;
                                event._eventPhase = eventPhase;
                                entry.listener(event);
                                if (event._stopImmediatePropagation) {
                                    break;
                                }
                            }
                            list.releaseSnapshot(snapshot);
                            return !event._stopPropagation;
                        };
                        EventDispatcher.classInitializer = function () {
                            EventDispatcher.broadcastEventDispatchQueue = new BroadcastEventDispatchQueue();
                        };

                        EventDispatcher.initializer = function () {
                            var self = this;

                            self._target = this;
                            self._captureListeners = null;
                            self._targetOrBubblingListeners = null;
                        };

                        EventDispatcher.classSymbols = null;

                        EventDispatcher.instanceSymbols = null;
                        return EventDispatcher;
                    })(AS.ASNative);
                    events.EventDispatcher = EventDispatcher;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: EventPhase
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var EventPhase = (function (_super) {
                        __extends(EventPhase, _super);
                        function EventPhase() {
                            _super.call(this);
                            notImplemented("Dummy Constructor: public flash.events.EventPhase");
                        }
                        EventPhase.classInitializer = null;
                        EventPhase.initializer = null;

                        EventPhase.classSymbols = null;
                        EventPhase.instanceSymbols = null;

                        EventPhase.CAPTURING_PHASE = 1;
                        EventPhase.AT_TARGET = 2;
                        EventPhase.BUBBLING_PHASE = 3;
                        return EventPhase;
                    })(AS.ASNative);
                    events.EventPhase = EventPhase;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var TextEvent = (function (_super) {
                        __extends(TextEvent, _super);
                        function TextEvent(type, bubbles, cancelable, text) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof text === "undefined") { text = ""; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.TextEvent");
                        }
                        TextEvent.prototype.copyNativeData = function (event) {
                            notImplemented("public flash.events.TextEvent::copyNativeData");
                        };
                        TextEvent.classInitializer = null;
                        TextEvent.initializer = null;

                        TextEvent.classSymbols = null;
                        TextEvent.instanceSymbols = null;

                        TextEvent.LINK = "link";
                        TextEvent.TEXT_INPUT = "textInput";
                        return TextEvent;
                    })(flash.events.Event);
                    events.TextEvent = TextEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ErrorEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var ErrorEvent = (function (_super) {
                        __extends(ErrorEvent, _super);
                        function ErrorEvent(type, bubbles, cancelable, text, id) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof text === "undefined") { text = ""; }
                            if (typeof id === "undefined") { id = 0; }
                            _super.call(this, undefined, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.ErrorEvent");
                        }
                        ErrorEvent.classInitializer = null;
                        ErrorEvent.initializer = null;

                        ErrorEvent.classSymbols = null;
                        ErrorEvent.instanceSymbols = null;

                        ErrorEvent.ERROR = "error";
                        return ErrorEvent;
                    })(flash.events.TextEvent);
                    events.ErrorEvent = ErrorEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInputEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var GameInputEvent = (function (_super) {
                        __extends(GameInputEvent, _super);
                        function GameInputEvent(type, bubbles, cancelable, device) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof device === "undefined") { device = null; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.GameInputEvent");
                        }
                        GameInputEvent.classInitializer = null;
                        GameInputEvent.initializer = null;

                        GameInputEvent.classSymbols = null;
                        GameInputEvent.instanceSymbols = null;

                        GameInputEvent.DEVICE_ADDED = "deviceAdded";
                        GameInputEvent.DEVICE_REMOVED = "deviceRemoved";
                        return GameInputEvent;
                    })(flash.events.Event);
                    events.GameInputEvent = GameInputEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GestureEvent
                (function (events) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var GestureEvent = (function (_super) {
                        __extends(GestureEvent, _super);
                        function GestureEvent(type, bubbles, cancelable, phase, localX, localY, ctrlKey, altKey, shiftKey) {
                            if (typeof bubbles === "undefined") { bubbles = true; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof phase === "undefined") { phase = null; }
                            if (typeof localX === "undefined") { localX = 0; }
                            if (typeof localY === "undefined") { localY = 0; }
                            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
                            if (typeof altKey === "undefined") { altKey = false; }
                            if (typeof shiftKey === "undefined") { shiftKey = false; }
                            false && _super.call(this, undefined, undefined, undefined);
                            events.Event.instanceConstructorNoInitialize.call(this);
                            this._phase = asCoerceString(phase);
                            this._localX = +localX;
                            this._localY = +localY;
                            this._ctrlKey = !!ctrlKey;
                            this._altKey = !!altKey;
                            this._shiftKey = !!shiftKey;
                        }
                        Object.defineProperty(GestureEvent.prototype, "localX", {
                            // AS -> JS Bindings
                            get: function () {
                                return this._localX;
                            },
                            set: function (value) {
                                this._localX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(GestureEvent.prototype, "localY", {
                            get: function () {
                                return this._localY;
                            },
                            set: function (value) {
                                this._localY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(GestureEvent.prototype, "stageX", {
                            get: function () {
                                somewhatImplemented("public flash.events.GestureEvent::stageX");
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GestureEvent.prototype, "stageY", {
                            get: function () {
                                somewhatImplemented("public flash.events.GestureEvent::stageY");
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GestureEvent.prototype, "ctrlKey", {
                            get: function () {
                                return this._ctrlKey;
                            },
                            set: function (value) {
                                this._ctrlKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GestureEvent.prototype, "altKey", {
                            get: function () {
                                return this._altKey;
                            },
                            set: function (value) {
                                this._altKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GestureEvent.prototype, "shiftKey", {
                            get: function () {
                                return this._shiftKey;
                            },
                            set: function (value) {
                                this._shiftKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        GestureEvent.prototype.updateAfterEvent = function () {
                            somewhatImplemented("public flash.events.GestureEvent::updateAfterEvent");
                            return;
                        };

                        GestureEvent.prototype.NativeCtor = function (phase, localX, localY, ctrlKey, altKey, shiftKey) {
                            if (typeof phase === "undefined") { phase = null; }
                            if (typeof localX === "undefined") { localX = 0; }
                            if (typeof localY === "undefined") { localY = 0; }
                            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
                            if (typeof altKey === "undefined") { altKey = false; }
                            if (typeof shiftKey === "undefined") { shiftKey = false; }
                            this._phase = asCoerceString(phase);
                            this._localX = +localX;
                            this._localY = +localY;
                            this._ctrlKey = !!ctrlKey;
                            this._altKey = !!altKey;
                            this._shiftKey = !!shiftKey;
                        };
                        GestureEvent.classInitializer = null;
                        GestureEvent.initializer = null;

                        GestureEvent.classSymbols = null;
                        GestureEvent.instanceSymbols = null;

                        GestureEvent.GESTURE_TWO_FINGER_TAP = "gestureTwoFingerTap";
                        return GestureEvent;
                    })(flash.events.Event);
                    events.GestureEvent = GestureEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: HTTPStatusEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var HTTPStatusEvent = (function (_super) {
                        __extends(HTTPStatusEvent, _super);
                        function HTTPStatusEvent(type, bubbles, cancelable, status) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof status === "undefined") { status = 0; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.HTTPStatusEvent");
                        }
                        HTTPStatusEvent.classInitializer = null;
                        HTTPStatusEvent.initializer = null;

                        HTTPStatusEvent.classSymbols = null;
                        HTTPStatusEvent.instanceSymbols = null;

                        HTTPStatusEvent.HTTP_STATUS = "httpStatus";
                        HTTPStatusEvent.HTTP_RESPONSE_STATUS = "httpResponseStatus";
                        return HTTPStatusEvent;
                    })(flash.events.Event);
                    events.HTTPStatusEvent = HTTPStatusEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IOErrorEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var IOErrorEvent = (function (_super) {
                        __extends(IOErrorEvent, _super);
                        function IOErrorEvent(type, bubbles, cancelable, text, id) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof text === "undefined") { text = ""; }
                            if (typeof id === "undefined") { id = 0; }
                            _super.call(this, undefined, undefined, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.IOErrorEvent");
                        }
                        IOErrorEvent.classInitializer = null;
                        IOErrorEvent.initializer = null;

                        IOErrorEvent.classSymbols = null;
                        IOErrorEvent.instanceSymbols = null;

                        IOErrorEvent.IO_ERROR = "ioError";
                        IOErrorEvent.NETWORK_ERROR = "networkError";
                        IOErrorEvent.DISK_ERROR = "diskError";
                        IOErrorEvent.VERIFY_ERROR = "verifyError";
                        return IOErrorEvent;
                    })(flash.events.ErrorEvent);
                    events.IOErrorEvent = IOErrorEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: KeyboardEvent
                (function (events) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var notImplemented = Shumway.Debug.notImplemented;

                    var KeyboardEvent = (function (_super) {
                        __extends(KeyboardEvent, _super);
                        function KeyboardEvent(type, bubbles, cancelable, charCodeValue, keyCodeValue, keyLocationValue, ctrlKeyValue, altKeyValue, shiftKeyValue) {
                            if (typeof bubbles === "undefined") { bubbles = true; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof charCodeValue === "undefined") { charCodeValue = 0; }
                            if (typeof keyCodeValue === "undefined") { keyCodeValue = 0; }
                            if (typeof keyLocationValue === "undefined") { keyLocationValue = 0; }
                            if (typeof ctrlKeyValue === "undefined") { ctrlKeyValue = false; }
                            if (typeof altKeyValue === "undefined") { altKeyValue = false; }
                            if (typeof shiftKeyValue === "undefined") { shiftKeyValue = false; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.KeyboardEvent");
                        }
                        // AS -> JS Bindings
                        KeyboardEvent.prototype.updateAfterEvent = function () {
                            somewhatImplemented("public flash.events.KeyboardEvent::updateAfterEvent");
                        };
                        KeyboardEvent.classInitializer = null;
                        KeyboardEvent.initializer = null;

                        KeyboardEvent.classSymbols = null;
                        KeyboardEvent.instanceSymbols = null;

                        KeyboardEvent.KEY_DOWN = "keyDown";
                        KeyboardEvent.KEY_UP = "keyUp";
                        return KeyboardEvent;
                    })(flash.events.Event);
                    events.KeyboardEvent = KeyboardEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MouseEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var MouseEvent = (function (_super) {
                        __extends(MouseEvent, _super);
                        function MouseEvent(type, bubbles, cancelable, localX, localY, relatedObject, ctrlKey, altKey, shiftKey, buttonDown, delta) {
                            if (typeof bubbles === "undefined") { bubbles = true; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof localX === "undefined") { localX = undefined; }
                            if (typeof localY === "undefined") { localY = undefined; }
                            if (typeof relatedObject === "undefined") { relatedObject = null; }
                            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
                            if (typeof altKey === "undefined") { altKey = false; }
                            if (typeof shiftKey === "undefined") { shiftKey = false; }
                            if (typeof buttonDown === "undefined") { buttonDown = false; }
                            if (typeof delta === "undefined") { delta = 0; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.MouseEvent");
                        }
                        /**
                        * AS3 mouse event names don't match DOM even names, so map them here.
                        */
                        MouseEvent.typeFromDOMType = function (name) {
                            switch (name) {
                                case "click":
                                    return MouseEvent.CLICK;
                                case "dblclick":
                                    return MouseEvent.DOUBLE_CLICK;
                                case "mousedown":
                                    return MouseEvent.MOUSE_DOWN;
                                case "mousemove":
                                    return MouseEvent.MOUSE_MOVE;

                                case "mouseup":
                                    return MouseEvent.MOUSE_UP;
                                default:
                                    notImplemented(name);
                            }
                        };

                        Object.defineProperty(MouseEvent.prototype, "localX", {
                            get: function () {
                                return (this._localX / 20) | 0;
                            },
                            set: function (value) {
                                this._localX = (value * 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(MouseEvent.prototype, "localY", {
                            get: function () {
                                return (this._localY / 20) | 0;
                            },
                            set: function (value) {
                                this._localY = (value * 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(MouseEvent.prototype, "movementX", {
                            get: function () {
                                somewhatImplemented("public flash.events.MouseEvent::set movementX");
                                return this._movementX || 0;
                            },
                            set: function (value) {
                                this._movementX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(MouseEvent.prototype, "movementY", {
                            get: function () {
                                somewhatImplemented("public flash.events.MouseEvent::set movementY");
                                return this._movementY || 0;
                            },
                            set: function (value) {
                                this._movementY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        MouseEvent.prototype.updateAfterEvent = function () {
                            Shumway.AVM2.Runtime.AVM2.instance.globals['Shumway.Player.Utils'].requestRendering();
                        };

                        MouseEvent.prototype._getGlobalPoint = function () {
                            var point = this._position;
                            if (!point) {
                                point = this._position = new flash.geom.Point();
                            }
                            if (this.target) {
                                point.setTo(this._localX, this._localY);
                                var m = this._target._getConcatenatedMatrix();
                                m.transformPointInPlace(point);
                            } else {
                                point.setTo(0, 0);
                            }
                            return point;
                        };

                        MouseEvent.prototype.getStageX = function () {
                            return (this._getGlobalPoint().x / 20) | 0;
                        };

                        MouseEvent.prototype.getStageY = function () {
                            return (this._getGlobalPoint().y / 20) | 0;
                        };
                        MouseEvent.classInitializer = null;
                        MouseEvent.initializer = null;

                        MouseEvent.classSymbols = null;
                        MouseEvent.instanceSymbols = null;

                        MouseEvent.CLICK = "click";
                        MouseEvent.DOUBLE_CLICK = "doubleClick";
                        MouseEvent.MOUSE_DOWN = "mouseDown";
                        MouseEvent.MOUSE_MOVE = "mouseMove";
                        MouseEvent.MOUSE_OUT = "mouseOut";
                        MouseEvent.MOUSE_OVER = "mouseOver";
                        MouseEvent.MOUSE_UP = "mouseUp";
                        MouseEvent.RELEASE_OUTSIDE = "releaseOutside";
                        MouseEvent.MOUSE_WHEEL = "mouseWheel";
                        MouseEvent.ROLL_OUT = "rollOut";
                        MouseEvent.ROLL_OVER = "rollOver";
                        MouseEvent.MIDDLE_CLICK = "middleClick";
                        MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
                        MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
                        MouseEvent.RIGHT_CLICK = "rightClick";
                        MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
                        MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
                        MouseEvent.CONTEXT_MENU = "contextMenu";
                        return MouseEvent;
                    })(flash.events.Event);
                    events.MouseEvent = MouseEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NetStatusEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var NetStatusEvent = (function (_super) {
                        __extends(NetStatusEvent, _super);
                        function NetStatusEvent(type, bubbles, cancelable, info) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof info === "undefined") { info = null; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.NetStatusEvent");
                        }
                        NetStatusEvent.classInitializer = null;
                        NetStatusEvent.initializer = null;

                        NetStatusEvent.classSymbols = null;
                        NetStatusEvent.instanceSymbols = null;

                        NetStatusEvent.NET_STATUS = "netStatus";
                        return NetStatusEvent;
                    })(flash.events.Event);
                    events.NetStatusEvent = NetStatusEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ProgressEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var ProgressEvent = (function (_super) {
                        __extends(ProgressEvent, _super);
                        function ProgressEvent(type, bubbles, cancelable, bytesLoaded, bytesTotal) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof bytesLoaded === "undefined") { bytesLoaded = 0; }
                            if (typeof bytesTotal === "undefined") { bytesTotal = 0; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.ProgressEvent");
                        }
                        ProgressEvent.classInitializer = null;
                        ProgressEvent.initializer = null;

                        ProgressEvent.classSymbols = null;
                        ProgressEvent.instanceSymbols = null;

                        ProgressEvent.PROGRESS = "progress";
                        ProgressEvent.SOCKET_DATA = "socketData";
                        return ProgressEvent;
                    })(flash.events.Event);
                    events.ProgressEvent = ProgressEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SecurityErrorEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var SecurityErrorEvent = (function (_super) {
                        __extends(SecurityErrorEvent, _super);
                        function SecurityErrorEvent(type, bubbles, cancelable, text, id) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof text === "undefined") { text = ""; }
                            if (typeof id === "undefined") { id = 0; }
                            _super.call(this, undefined, undefined, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.SecurityErrorEvent");
                        }
                        SecurityErrorEvent.classInitializer = null;
                        SecurityErrorEvent.initializer = null;

                        SecurityErrorEvent.classSymbols = null;
                        SecurityErrorEvent.instanceSymbols = null;

                        SecurityErrorEvent.SECURITY_ERROR = "securityError";
                        return SecurityErrorEvent;
                    })(flash.events.ErrorEvent);
                    events.SecurityErrorEvent = SecurityErrorEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TimerEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var TimerEvent = (function (_super) {
                        __extends(TimerEvent, _super);
                        function TimerEvent(type, bubbles, cancelable) {
                            if (typeof bubbles === "undefined") { bubbles = false; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.TimerEvent");
                        }
                        TimerEvent.prototype.updateAfterEvent = function () {
                            notImplemented("public flash.events.TimerEvent::updateAfterEvent");
                            return;
                        };
                        TimerEvent.classInitializer = null;
                        TimerEvent.initializer = null;

                        TimerEvent.classSymbols = null;
                        TimerEvent.instanceSymbols = null;

                        TimerEvent.TIMER = "timer";
                        TimerEvent.TIMER_COMPLETE = "timerComplete";
                        return TimerEvent;
                    })(flash.events.Event);
                    events.TimerEvent = TimerEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TouchEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var TouchEvent = (function (_super) {
                        __extends(TouchEvent, _super);
                        function TouchEvent(type, bubbles, cancelable, touchPointID, isPrimaryTouchPoint, localX, localY, sizeX, sizeY, pressure, relatedObject, ctrlKey, altKey, shiftKey) {
                            if (typeof bubbles === "undefined") { bubbles = true; }
                            if (typeof cancelable === "undefined") { cancelable = false; }
                            if (typeof touchPointID === "undefined") { touchPointID = 0; }
                            if (typeof isPrimaryTouchPoint === "undefined") { isPrimaryTouchPoint = false; }
                            if (typeof localX === "undefined") { localX = NaN; }
                            if (typeof localY === "undefined") { localY = NaN; }
                            if (typeof sizeX === "undefined") { sizeX = NaN; }
                            if (typeof sizeY === "undefined") { sizeY = NaN; }
                            if (typeof pressure === "undefined") { pressure = NaN; }
                            if (typeof relatedObject === "undefined") { relatedObject = null; }
                            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
                            if (typeof altKey === "undefined") { altKey = false; }
                            if (typeof shiftKey === "undefined") { shiftKey = false; }
                            _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.TouchEvent");
                        }
                        TouchEvent.prototype.updateAfterEvent = function () {
                            notImplemented("public flash.events.TouchEvent::updateAfterEvent");
                        };
                        TouchEvent.classInitializer = null;
                        TouchEvent.initializer = null;

                        TouchEvent.classSymbols = null;
                        TouchEvent.instanceSymbols = null;

                        TouchEvent.TOUCH_BEGIN = "touchBegin";
                        TouchEvent.TOUCH_END = "touchEnd";
                        TouchEvent.TOUCH_MOVE = "touchMove";
                        TouchEvent.TOUCH_OVER = "touchOver";
                        TouchEvent.TOUCH_OUT = "touchOut";
                        TouchEvent.TOUCH_ROLL_OVER = "touchRollOver";
                        TouchEvent.TOUCH_ROLL_OUT = "touchRollOut";
                        TouchEvent.TOUCH_TAP = "touchTap";
                        TouchEvent.PROXIMITY_BEGIN = "proximityBegin";
                        TouchEvent.PROXIMITY_END = "proximityEnd";
                        TouchEvent.PROXIMITY_MOVE = "proximityMove";
                        TouchEvent.PROXIMITY_OUT = "proximityOut";
                        TouchEvent.PROXIMITY_OVER = "proximityOver";
                        TouchEvent.PROXIMITY_ROLL_OUT = "proximityRollOut";
                        TouchEvent.PROXIMITY_ROLL_OVER = "proximityRollOver";
                        return TouchEvent;
                    })(flash.events.Event);
                    events.TouchEvent = TouchEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: UncaughtErrorEvent
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var UncaughtErrorEvent = (function (_super) {
                        __extends(UncaughtErrorEvent, _super);
                        function UncaughtErrorEvent(type, bubbles, cancelable, error_in) {
                            if (typeof type === "undefined") { type = "uncaughtError"; }
                            if (typeof bubbles === "undefined") { bubbles = true; }
                            if (typeof cancelable === "undefined") { cancelable = true; }
                            if (typeof error_in === "undefined") { error_in = null; }
                            _super.call(this, undefined, undefined, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.events.UncaughtErrorEvent");
                        }
                        UncaughtErrorEvent.classInitializer = null;
                        UncaughtErrorEvent.initializer = null;

                        UncaughtErrorEvent.classSymbols = null;
                        UncaughtErrorEvent.instanceSymbols = null;

                        UncaughtErrorEvent.UNCAUGHT_ERROR = "uncaughtError";
                        return UncaughtErrorEvent;
                    })(flash.events.ErrorEvent);
                    events.UncaughtErrorEvent = UncaughtErrorEvent;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: UncaughtErrorEvents
                (function (events) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var UncaughtErrorEvents = (function (_super) {
                        __extends(UncaughtErrorEvents, _super);
                        function UncaughtErrorEvents() {
                            _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.events.UncaughtErrorEvents");
                        }
                        UncaughtErrorEvents.classInitializer = null;
                        UncaughtErrorEvents.initializer = null;

                        UncaughtErrorEvents.classSymbols = null;
                        UncaughtErrorEvents.instanceSymbols = null;
                        return UncaughtErrorEvents;
                    })(flash.events.EventDispatcher);
                    events.UncaughtErrorEvents = UncaughtErrorEvents;
                })(flash.events || (flash.events = {}));
                var events = flash.events;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Flash bugs to keep in mind:
                *
                * http://aaronhardy.com/flex/displayobject-quirks-and-tips/
                * http://blog.anselmbradford.com/2009/02/12/flash-movie-clip-transformational-properties-explorer-x-y-width-height-more/
                * http://gskinner.com/blog/archives/2007/08/annoying_as3_bu.html
                * http://blog.dennisrobinson.name/getbounds-getrect-unexpected-results/
                *
                */
                // Class: DisplayObject
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var isNullOrUndefined = Shumway.isNullOrUndefined;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var assert = Shumway.Debug.assert;

                    var Bounds = Shumway.Bounds;
                    var geom = flash.geom;
                    var events = flash.events;

                    /*
                    * Invalid Bits:
                    *
                    * Invalid bits are used to mark path dependent properties of display objects as stale. To compute these properties we either have to
                    * walk the tree all the way the root, or visit all children.
                    *
                    *       +---+
                    *       | A |
                    *       +---+
                    *       /   \
                    *   +---+   +---+
                    *   | B |   | C |
                    *   +---+   +---+
                    *           /   \
                    *       +---+   +---+
                    *       | D |   | E |
                    *       +---+   +---+
                    *
                    * We use a combination of eager invalid bit propagation and lazy property evaluation. If a node becomes invalid because one of its
                    * local properties has changed, we mark all of its valid descendents as invalid. When computing dependent properties, we walk up
                    * the tree until we find a valid node and propagate the computation lazily downwards, marking all the nodes along the path as
                    * valid.
                    *
                    * Suppose we mark A as invalid, this causes nodes B, C, D, and E to become invalid. We then compute a path dependent property
                    * on E, causing A, and C to become valid. If we mark A as invalid again, A and C become invalid again. We don't need to mark
                    * parts of the tree that are already invalid.
                    *
                    *
                    * Dirty Bits:
                    *
                    * These are used to mark properties as having been changed.
                    */
                    (function (DisplayObjectFlags) {
                        DisplayObjectFlags[DisplayObjectFlags["None"] = 0x0000] = "None";

                        /**
                        * Display object is visible.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["Visible"] = 0x0001] = "Visible";

                        /**
                        * Display object has invalid line bounds.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidLineBounds"] = 0x0002] = "InvalidLineBounds";

                        /**
                        * Display object has invalid fill bounds.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidFillBounds"] = 0x0004] = "InvalidFillBounds";

                        /**
                        * Display object has an invalid matrix because one of its local properties: x, y, scaleX, ... has been mutated.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidMatrix"] = 0x0008] = "InvalidMatrix";

                        /**
                        * Display object has an invalid inverted matrix because its matrix has been mutated.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidInvertedMatrix"] = 0x0010] = "InvalidInvertedMatrix";

                        /**
                        * Display object has an invalid concatenated matrix because its matrix or one of its ancestor's matrices has been mutated.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidConcatenatedMatrix"] = 0x0020] = "InvalidConcatenatedMatrix";

                        /**
                        * Display object has an invalid inverted concatenated matrix because its matrix or one of its ancestor's matrices has been
                        * mutated. We don't always need to compute the inverted matrix. This is why we use a sepearete invalid flag for it and don't
                        * roll it under the |InvalidConcatenatedMatrix| flag.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidInvertedConcatenatedMatrix"] = 0x0040] = "InvalidInvertedConcatenatedMatrix";

                        /**
                        * Display object has an invalid concatenated color transform because its color transform or one of its ancestor's color
                        * transforms has been mutated.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["InvalidConcatenatedColorTransform"] = 0x0080] = "InvalidConcatenatedColorTransform";

                        /**
                        * The display object's constructor has been executed or any of the derived class constructors have executed. It may be
                        * that the derived class doesn't call super, in such cases this flag must be set manually elsewhere.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["Constructed"] = 0x0100] = "Constructed";

                        /**
                        * Display object has been removed by the timeline but it no longer recieves any event.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["Destroyed"] = 0x0200] = "Destroyed";

                        /**
                        * Display object is owned by the timeline, meaning that it is under the control of the timeline and that a reference
                        * to this object has not leaked into AS3 code via the DisplayObjectContainer methods |getChildAt|,  |getChildByName|
                        * or through the execution of the symbol class constructor.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["OwnedByTimeline"] = 0x0400] = "OwnedByTimeline";

                        /**
                        * Display object is animated by the timeline. It may no longer be owned by the timeline (|OwnedByTimeline|) but it
                        * is still animated by it. If AS3 code mutates any property on the display object, this flag is cleared and further
                        * timeline mutations are ignored.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["AnimatedByTimeline"] = 0x0800] = "AnimatedByTimeline";

                        /**
                        * MovieClip object has reached a frame with a frame script or ran a frame script that attached
                        * a new one to the current frame. To run the script, it has to be appended to the queue of
                        * scripts.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["HasFrameScriptPending"] = 0x1000] = "HasFrameScriptPending";

                        /**
                        * DisplayObjectContainer contains at least one descendant with the HasFrameScriptPending flag
                        * set.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["ContainsFrameScriptPendingChildren"] = 0x2000] = "ContainsFrameScriptPendingChildren";

                        /**
                        * Indicates whether this display object should be cached as a bitmap. The display object may be cached as bitmap even
                        * if this flag is not set, depending on whether any filters are applied or if the bitmap is too large or we've run out
                        * of memory.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["CacheAsBitmap"] = 0x4000] = "CacheAsBitmap";

                        /**
                        * Indicates whether this display object's matrix has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyMatrix"] = 0x100000] = "DirtyMatrix";

                        /**
                        * Indicates whether this display object's has dirty descendents. If this flag is not set then the subtree does not
                        * need to be synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyChildren"] = 0x200000] = "DirtyChildren";

                        /**
                        * Indicates whether this display object's graphics has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyGraphics"] = 0x400000] = "DirtyGraphics";

                        /**
                        * Indicates whether this display object's text content has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyTextContent"] = 0x800000] = "DirtyTextContent";

                        /**
                        * Indicates whether this display object's bitmap data has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyBitmapData"] = 0x1000000] = "DirtyBitmapData";

                        /**
                        * Indicates whether this display object's color transform has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyColorTransform"] = 0x2000000] = "DirtyColorTransform";

                        /**
                        * Indicates whether this display object's mask has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyMask"] = 0x4000000] = "DirtyMask";

                        /**
                        * Indicates whether this display object's clip depth has changed since the last time it was synchronized.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyClipDepth"] = 0x8000000] = "DirtyClipDepth";

                        /**
                        * Indicates whether this display object's other properties have changed. We need to split this up in multiple
                        * bits so we don't serialize as much:
                        *
                        * So far we only mark these properties here:
                        *
                        * blendMode,
                        * scale9Grid,
                        * cacheAsBitmap,
                        * filters,
                        * visible,
                        */
                        DisplayObjectFlags[DisplayObjectFlags["DirtyMiscellaneousProperties"] = 0x10000000] = "DirtyMiscellaneousProperties";

                        /**
                        * All synchronizable properties are dirty.
                        */
                        DisplayObjectFlags[DisplayObjectFlags["Dirty"] = DisplayObjectFlags.DirtyMatrix | DisplayObjectFlags.DirtyChildren | DisplayObjectFlags.DirtyGraphics | DisplayObjectFlags.DirtyTextContent | DisplayObjectFlags.DirtyBitmapData | DisplayObjectFlags.DirtyColorTransform | DisplayObjectFlags.DirtyMask | DisplayObjectFlags.DirtyClipDepth | DisplayObjectFlags.DirtyMiscellaneousProperties] = "Dirty";
                    })(display.DisplayObjectFlags || (display.DisplayObjectFlags = {}));
                    var DisplayObjectFlags = display.DisplayObjectFlags;

                    /**
                    * Controls how the visitor walks the display tree.
                    */
                    (function (VisitorFlags) {
                        /**
                        * None
                        */
                        VisitorFlags[VisitorFlags["None"] = 0] = "None";

                        /**
                        * Continue with normal traversal.
                        */
                        VisitorFlags[VisitorFlags["Continue"] = 0] = "Continue";

                        /**
                        * Not used yet, should probably just stop the visitor.
                        */
                        VisitorFlags[VisitorFlags["Stop"] = 0x01] = "Stop";

                        /**
                        * Skip processing current node.
                        */
                        VisitorFlags[VisitorFlags["Skip"] = 0x02] = "Skip";

                        /**
                        * Visit front to back.
                        */
                        VisitorFlags[VisitorFlags["FrontToBack"] = 0x08] = "FrontToBack";

                        /**
                        * Only visit the nodes matching a certain flag set.
                        */
                        VisitorFlags[VisitorFlags["Filter"] = 0x10] = "Filter";
                    })(display.VisitorFlags || (display.VisitorFlags = {}));
                    var VisitorFlags = display.VisitorFlags;

                    

                    var DisplayObject = (function (_super) {
                        __extends(DisplayObject, _super);
                        function DisplayObject() {
                            false && _super.call(this, undefined);
                            events.EventDispatcher.instanceConstructorNoInitialize.call(this);
                            this._addReference();
                            this._setFlags(256 /* Constructed */);
                        }
                        DisplayObject.getNextSyncID = function () {
                            return this._syncID++;
                        };

                        DisplayObject.reset = function () {
                            DisplayObject._advancableInstances = new Shumway.WeakList();
                        };

                        /**
                        * Creates a new display object from a symbol and initializes its animated display properties.
                        * Calling its constructor is optional at this point, since that can happen in a later frame
                        * phase.
                        */
                        DisplayObject.createAnimatedDisplayObject = function (state, callConstructor) {
                            var symbol = state.symbol;
                            var symbolClass = symbol.symbolClass;
                            var instance;
                            if (symbolClass.isSubtypeOf(flash.display.BitmapData)) {
                                instance = flash.display.Bitmap.initializeFrom(symbol);
                            } else {
                                instance = symbolClass.initializeFrom(symbol);
                            }
                            instance._setFlags(2048 /* AnimatedByTimeline */);
                            instance._setFlags(1024 /* OwnedByTimeline */);
                            instance._animate(state);
                            if (callConstructor) {
                                symbolClass.instanceConstructorNoInitialize.call(instance);
                            }
                            return instance;
                        };

                        /**
                        * Runs one full turn of the frame events cycle.
                        *
                        * Frame navigation methods on MovieClip can trigger nested frame events cycles. These nested
                        * cycles do everything the outermost cycle does, except for broadcasting the ENTER_FRAME
                        * event.
                        *
                        * If runScripts is true, no events are dispatched and Movieclip frame scripts are run. This
                        * is true for nested cycles, too. (We keep static state for that.)
                        */
                        DisplayObject.performFrameNavigation = function (stage, mainLoop, runScripts) {
                            if (mainLoop) {
                                var timelineData = { instances: 0 };
                                DisplayObject._runScripts = runScripts;
                                AVM2.enterTimeline("DisplayObject.performFrameNavigation", timelineData);
                            } else {
                                runScripts = DisplayObject._runScripts;
                            }

                            assert(DisplayObject._advancableInstances.length < 1024 * 16, "Too many advancable instances.");

                            // Step 1: Remove timeline objects that don't exist on new frame, update existing ones with
                            // new properties, and declare, but not create, new ones, update numChildren.
                            // NOTE: the Order Of Operations senocular article is wrong on this: timeline objects are
                            // removed from stage at the beginning of a frame, just as new objects are declared at that
                            // point.
                            // Also, changed properties of existing objects are updated here instead of during frame
                            // construction after ENTER_FRAME.
                            // Thus, all these can be done together.
                            DisplayObject._advancableInstances.forEach(function (value) {
                                value._initFrame(mainLoop);
                            });

                            // Step 2: Dispatch ENTER_FRAME, only called in outermost invocation.
                            if (mainLoop && runScripts) {
                                DisplayObject._broadcastFrameEvent(events.Event.ENTER_FRAME);
                            }

                            // Step 3: Create new timeline objects.
                            DisplayObject._advancableInstances.forEach(function (value) {
                                value._constructFrame();
                            });

                            // Step 4: Dispatch FRAME_CONSTRUCTED.
                            if (runScripts) {
                                DisplayObject._broadcastFrameEvent(events.Event.FRAME_CONSTRUCTED);

                                // Step 5: Run frame scripts
                                stage._enqueueFrameScripts();
                                display.MovieClip.runFrameScripts();

                                // Step 6: Dispatch EXIT_FRAME.
                                DisplayObject._broadcastFrameEvent(events.Event.EXIT_FRAME);
                            } else {
                                display.MovieClip.reset();
                            }
                            if (mainLoop) {
                                AVM2.leaveTimeline();
                                DisplayObject._runScripts = true;
                            }
                        };

                        /**
                        * Dispatches a frame event on all instances of DisplayObjects.
                        */
                        DisplayObject._broadcastFrameEvent = function (type) {
                            var event;
                            switch (type) {
                                case events.Event.ENTER_FRAME:
                                case events.Event.FRAME_CONSTRUCTED:
                                case events.Event.EXIT_FRAME:
                                case events.Event.RENDER:
                                    // TODO: Fire RENDER events only for objects on the display list.
                                    event = events.Event.getBroadcastInstance(type);
                            }
                            release || assert(event, "Invalid frame event.");
                            events.EventDispatcher.broadcastEventDispatchQueue.dispatchEvent(event);
                        };

                        DisplayObject.prototype._setParent = function (parent, depth) {
                            var oldParent = this._parent;
                            this._parent = parent;
                            this._depth = depth;
                            if (parent) {
                                this._addReference();
                            }
                            if (oldParent) {
                                this._removeReference();
                            }
                        };

                        DisplayObject.prototype._setFillAndLineBoundsFromWidthAndHeight = function (width, height) {
                            this._fillBounds.width = width;
                            this._fillBounds.height = height;
                            this._lineBounds.width = width;
                            this._lineBounds.height = height;
                            this._removeFlags(2 /* InvalidLineBounds */ | 4 /* InvalidFillBounds */);
                            this._invalidateParentFillAndLineBounds(true, true);
                        };

                        DisplayObject.prototype._setFillAndLineBoundsFromSymbol = function (symbol) {
                            release || assert(symbol.fillBounds || symbol.lineBounds, "Fill or Line bounds are not defined in the symbol.");
                            if (symbol.fillBounds) {
                                this._fillBounds.copyFrom(symbol.fillBounds);
                                this._removeFlags(4 /* InvalidFillBounds */);
                            }
                            if (symbol.lineBounds) {
                                this._lineBounds.copyFrom(symbol.lineBounds);
                                this._removeFlags(2 /* InvalidLineBounds */);
                            }
                            this._invalidateParentFillAndLineBounds(!!symbol.fillBounds, !!symbol.lineBounds);
                        };

                        DisplayObject.prototype._setFlags = function (flags) {
                            this._displayObjectFlags |= flags;
                        };

                        /**
                        * Use this to set dirty flags so that we can also propagate the dirty child bit.
                        */
                        DisplayObject.prototype._setDirtyFlags = function (flags) {
                            this._displayObjectFlags |= flags;
                            if (this._parent) {
                                this._parent._propagateFlagsUp(2097152 /* DirtyChildren */);
                            }
                        };

                        DisplayObject.prototype._toggleFlags = function (flags, on) {
                            if (on) {
                                this._displayObjectFlags |= flags;
                            } else {
                                this._displayObjectFlags &= ~flags;
                            }
                        };

                        DisplayObject.prototype._removeFlags = function (flags) {
                            this._displayObjectFlags &= ~flags;
                        };

                        DisplayObject.prototype._hasFlags = function (flags) {
                            return (this._displayObjectFlags & flags) === flags;
                        };

                        DisplayObject.prototype._hasAnyFlags = function (flags) {
                            return !!(this._displayObjectFlags & flags);
                        };

                        /**
                        * Propagates flags up the display list. Propagation stops if all flags are already set.
                        */
                        DisplayObject.prototype._propagateFlagsUp = function (flags) {
                            if (this._hasFlags(flags)) {
                                return;
                            }
                            this._setFlags(flags);
                            var parent = this._parent;
                            if (parent) {
                                parent._propagateFlagsUp(flags);
                            }
                        };

                        /**
                        * Propagates flags down the display list. Non-containers just set the flags on themselves.
                        *
                        * Overridden in DisplayObjectContainer.
                        */
                        DisplayObject.prototype._propagateFlagsDown = function (flags) {
                            this._setFlags(flags);
                        };

                        /**
                        * Finds the nearest ancestor with a given set of flags that are either turned on or off.
                        */
                        DisplayObject.prototype._findNearestAncestor = function (flags, on) {
                            var node = this;
                            while (node) {
                                if (node._hasFlags(flags) === on) {
                                    return node;
                                }
                                node = node._parent;
                            }
                            return null;
                        };

                        DisplayObject.prototype._findFurthestAncestorOrSelf = function () {
                            var node = this;
                            while (node) {
                                if (!node._parent) {
                                    return node;
                                }
                                node = node._parent;
                            }
                        };

                        /**
                        * Tests if this display object is an ancestor of the specified display object.
                        */
                        DisplayObject.prototype._isAncestor = function (child) {
                            var node = child;
                            while (node) {
                                if (node === this) {
                                    return true;
                                }
                                node = node._parent;
                            }
                            return false;
                        };

                        /**
                        * Clamps the rotation value to the range (-180, 180).
                        */
                        DisplayObject._clampRotation = function (value) {
                            value %= 360;
                            if (value > 180) {
                                value -= 360;
                            } else if (value < -180) {
                                value += 360;
                            }
                            return value;
                        };

                        /**
                        * Return's a list of ancestors excluding the |last|, the return list is reused.
                        */
                        DisplayObject._getAncestors = function (node, last) {
                            var path = DisplayObject._path;
                            path.length = 0;
                            while (node && node !== last) {
                                path.push(node);
                                node = node._parent;
                            }
                            release || assert(node === last, "Last ancestor is not an ancestor.");
                            return path;
                        };

                        /**
                        * Computes the combined transformation matrixes of this display object and all of its parents.
                        * It is not the same as |transform.concatenatedMatrix|, the latter also includes the screen
                        * space matrix.
                        */
                        DisplayObject.prototype._getConcatenatedMatrix = function () {
                            if (this._hasFlags(32 /* InvalidConcatenatedMatrix */)) {
                                if (this._parent) {
                                    this._parent._getConcatenatedMatrix().preMultiplyInto(this._getMatrix(), this._concatenatedMatrix);
                                } else {
                                    this._concatenatedMatrix.copyFrom(this._getMatrix());
                                }
                                this._removeFlags(32 /* InvalidConcatenatedMatrix */);
                            }
                            return this._concatenatedMatrix;
                        };

                        DisplayObject.prototype._getInvertedConcatenatedMatrix = function () {
                            if (this._hasFlags(64 /* InvalidInvertedConcatenatedMatrix */)) {
                                this._getConcatenatedMatrix().invertInto(this._invertedConcatenatedMatrix);
                                this._removeFlags(64 /* InvalidInvertedConcatenatedMatrix */);
                            }
                            return this._invertedConcatenatedMatrix;
                        };

                        DisplayObject.prototype._setMatrix = function (matrix, toTwips) {
                            if (!toTwips && this._matrix.equals(matrix)) {
                                // No need to dirty the matrix if it's equal to the current matrix.
                                return;
                            }
                            var m = this._matrix;
                            m.copyFrom(matrix);
                            if (toTwips) {
                                m.toTwipsInPlace();
                            }
                            this._scaleX = m.getScaleX();
                            this._scaleY = m.getScaleY();
                            this._rotation = DisplayObject._clampRotation(matrix.getRotation() * 180 / Math.PI);
                            this._removeFlags(8 /* InvalidMatrix */);
                            this._setFlags(16 /* InvalidInvertedMatrix */);
                            this._setDirtyFlags(1048576 /* DirtyMatrix */);
                            this._invalidatePosition();
                        };

                        /**
                        * Returns an updated matrix if the current one is invalid.
                        */
                        DisplayObject.prototype._getMatrix = function () {
                            if (this._hasFlags(8 /* InvalidMatrix */)) {
                                this._matrix.updateScaleAndRotation(this._scaleX, this._scaleY, this._rotation);
                                this._removeFlags(8 /* InvalidMatrix */);
                            }
                            return this._matrix;
                        };

                        DisplayObject.prototype._getInvertedMatrix = function () {
                            if (this._hasFlags(16 /* InvalidInvertedMatrix */)) {
                                this._getMatrix().invertInto(this._invertedMatrix);
                                this._removeFlags(16 /* InvalidInvertedMatrix */);
                            }
                            return this._invertedMatrix;
                        };

                        /**
                        * Computes the combined transformation color matrixes of this display object and all of its ancestors.
                        */
                        DisplayObject.prototype._getConcatenatedColorTransform = function () {
                            if (!this.stage) {
                                return this._colorTransform.clone();
                            }

                            // Compute the concatenated color transforms for this node and all of its ancestors.
                            if (this._hasFlags(128 /* InvalidConcatenatedColorTransform */)) {
                                var ancestor = this._findNearestAncestor(128 /* InvalidConcatenatedColorTransform */, false);
                                var path = DisplayObject._getAncestors(this, ancestor);
                                var i = path.length - 1;
                                if (flash.display.Stage.isType(path[i])) {
                                    i--;
                                }
                                var m = ancestor && !flash.display.Stage.isType(ancestor) ? ancestor._concatenatedColorTransform.clone() : new geom.ColorTransform();
                                while (i >= 0) {
                                    ancestor = path[i--];
                                    release || assert(ancestor._hasFlags(128 /* InvalidConcatenatedColorTransform */));
                                    m.preMultiply(ancestor._colorTransform);
                                    m.convertToFixedPoint();
                                    ancestor._concatenatedColorTransform.copyFrom(m);
                                    ancestor._removeFlags(128 /* InvalidConcatenatedColorTransform */);
                                }
                            }
                            return this._concatenatedColorTransform;
                        };

                        DisplayObject.prototype._setColorTransform = function (colorTransform) {
                            this._colorTransform.copyFrom(colorTransform);
                            this._colorTransform.convertToFixedPoint();
                            this._propagateFlagsDown(128 /* InvalidConcatenatedColorTransform */);
                            this._setDirtyFlags(33554432 /* DirtyColorTransform */);
                        };

                        /**
                        * Invalidates the fill- and lineBounds of this display object along with all of its ancestors.
                        */
                        DisplayObject.prototype._invalidateFillAndLineBounds = function (fill, line) {
                            /* TODO: We should only propagate this bit if the bounds are actually changed. We can do the
                            * bounds computation eagerly if the number of children is low. If there are no changes in the
                            * bounds we don't need to propagate the bit. */
                            this._propagateFlagsUp((line ? 2 /* InvalidLineBounds */ : 0) | (fill ? 4 /* InvalidFillBounds */ : 0));
                        };

                        DisplayObject.prototype._invalidateParentFillAndLineBounds = function (fill, line) {
                            if (this._parent) {
                                this._parent._invalidateFillAndLineBounds(fill, line);
                            }
                        };

                        /**
                        * Computes the bounding box for all of this display object's content, its graphics and all of its children.
                        */
                        DisplayObject.prototype._getContentBounds = function (includeStrokes) {
                            if (typeof includeStrokes === "undefined") { includeStrokes = true; }
                            // Tobias: What about filters?
                            var invalidFlag;
                            var bounds;
                            if (includeStrokes) {
                                invalidFlag = 2 /* InvalidLineBounds */;
                                bounds = this._lineBounds;
                            } else {
                                invalidFlag = 4 /* InvalidFillBounds */;
                                bounds = this._fillBounds;
                            }
                            if (this._hasFlags(invalidFlag)) {
                                var graphics = this._getGraphics();
                                if (graphics) {
                                    bounds.copyFrom(graphics._getContentBounds(includeStrokes));
                                } else {
                                    bounds.setEmpty();
                                }
                                if (display.DisplayObjectContainer.isType(this)) {
                                    var container = this;
                                    var children = container._children;
                                    for (var i = 0; i < children.length; i++) {
                                        bounds.unionInPlace(children[i]._getTransformedBounds(this, includeStrokes));
                                    }
                                }
                                this._removeFlags(invalidFlag);
                            }
                            return bounds;
                        };

                        /**
                        * Gets the bounds of this display object relative to another coordinate space. The transformation
                        * matrix from the local coordinate space to the target coordinate space is computed using:
                        *
                        *   this.concatenatedMatrix * inverse(target.concatenatedMatrix)
                        *
                        * If the |targetCoordinateSpace| is |null| then assume the identity coordinate space.
                        */
                        DisplayObject.prototype._getTransformedBounds = function (targetCoordinateSpace, includeStroke) {
                            var bounds = this._getContentBounds(includeStroke).clone();
                            if (targetCoordinateSpace === this || bounds.isEmpty()) {
                                return bounds;
                            }
                            var m;
                            if (targetCoordinateSpace) {
                                m = geom.Matrix.TEMP_MATRIX;
                                var invertedTargetMatrix = targetCoordinateSpace._getInvertedConcatenatedMatrix();
                                invertedTargetMatrix.preMultiplyInto(this._getConcatenatedMatrix(), m);
                            } else {
                                m = this._getConcatenatedMatrix();
                            }
                            m.transformBounds(bounds);
                            return bounds;
                        };

                        /**
                        * Detaches this object from being animated by the timeline. This happens whenever a display
                        * property of this object is changed by user code.
                        */
                        DisplayObject.prototype._stopTimelineAnimation = function () {
                            this._removeFlags(2048 /* AnimatedByTimeline */);
                        };

                        /**
                        * Marks this object as having its matrix changed.
                        *
                        * Propagates flags both up- and (via invalidatePosition) downwards, so is quite costly.
                        * TODO: check if we can usefully combine all upwards-propagated flags here.
                        */
                        DisplayObject.prototype._invalidateMatrix = function () {
                            this._setDirtyFlags(1048576 /* DirtyMatrix */);
                            this._setFlags(8 /* InvalidMatrix */ | 16 /* InvalidInvertedMatrix */);
                            this._invalidatePosition();
                        };

                        /**
                        * Marks this object as having been moved in its parent display object.
                        */
                        DisplayObject.prototype._invalidatePosition = function () {
                            this._propagateFlagsDown(32 /* InvalidConcatenatedMatrix */ | 64 /* InvalidInvertedConcatenatedMatrix */);
                            this._invalidateParentFillAndLineBounds(true, true);
                        };

                        /**
                        * Animates this object's display properties.
                        */
                        DisplayObject.prototype._animate = function (state) {
                            if (state.matrix) {
                                this._setMatrix(state.matrix, false);
                            }
                            if (state.colorTransform) {
                                this._setColorTransform(state.colorTransform);
                            }
                            this._ratio = state.ratio;
                            this._name = state.name;

                            // TODO: Not sure what is happening here, but state.clipDepth can be -1 after
                            // |this._clipDepth| is set to a value larger than zero. This shouldnt' happen.
                            // Tobias?? sbemaild50.swf
                            if (this._clipDepth !== state.clipDepth && state.clipDepth >= 0) {
                                this._clipDepth = state.clipDepth;
                                this._setDirtyFlags(134217728 /* DirtyClipDepth */);
                            }
                            this._filters = state.filters;
                            if (state.blendMode && state.blendMode !== this._blendMode) {
                                this._blendMode = state.blendMode;
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            }
                            if (state.cacheAsBitmap) {
                                this._setFlags(16384 /* CacheAsBitmap */);
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            }
                            if (state.visible !== this._hasFlags(1 /* Visible */)) {
                                this._toggleFlags(1 /* Visible */, state.visible);
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            }
                            // TODO: state.events
                        };

                        /**
                        * Dispatches an event on this object and all its descendants.
                        */
                        DisplayObject.prototype._propagateEvent = function (event) {
                            this.visit(function (node) {
                                node.dispatchEvent(event);
                                return 0 /* Continue */;
                            }, 0 /* None */);
                        };

                        Object.defineProperty(DisplayObject.prototype, "x", {
                            get: function () {
                                var value = this._matrix.tx;
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    value += bounds.xMin;
                                }
                                return value / 20;
                            },
                            set: function (value) {
                                value = (value * 20) | 0;
                                this._stopTimelineAnimation();
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    value -= bounds.xMin;
                                }
                                if (value === this._matrix.tx) {
                                    return;
                                }
                                this._matrix.tx = value;
                                this._invertedMatrix.tx = -value;
                                this._invalidatePosition();
                                this._setDirtyFlags(1048576 /* DirtyMatrix */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "y", {
                            get: function () {
                                var value = this._matrix.ty;
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    value += bounds.yMin;
                                }
                                return value / 20;
                            },
                            set: function (value) {
                                value = (value * 20) | 0;
                                this._stopTimelineAnimation();
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    value -= bounds.yMin;
                                }
                                if (value === this._matrix.ty) {
                                    return;
                                }
                                this._matrix.ty = value;
                                this._invertedMatrix.ty = -value;
                                this._invalidatePosition();
                                this._setDirtyFlags(1048576 /* DirtyMatrix */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "scaleX", {
                            get: function () {
                                return this._scaleX;
                            },
                            set: function (value) {
                                value = +value;
                                this._stopTimelineAnimation();
                                if (value === this._scaleX) {
                                    return;
                                }
                                this._scaleX = value;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "scaleY", {
                            get: function () {
                                return this._scaleY;
                            },
                            set: function (value) {
                                value = +value;
                                this._stopTimelineAnimation();
                                if (value === this._scaleY) {
                                    return;
                                }
                                this._scaleY = value;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "scaleZ", {
                            get: function () {
                                return this._scaleZ;
                            },
                            set: function (value) {
                                value = +value;
                                notImplemented("public DisplayObject::set scaleZ");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "rotation", {
                            get: function () {
                                return this._rotation;
                            },
                            set: function (value) {
                                value = +value;
                                this._stopTimelineAnimation();
                                value = DisplayObject._clampRotation(value);
                                if (value === this._rotation) {
                                    return;
                                }
                                this._rotation = value;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "rotationX", {
                            get: function () {
                                return this._rotationX;
                            },
                            set: function (value) {
                                value = +value;
                                notImplemented("public DisplayObject::set rotationX");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "rotationY", {
                            get: function () {
                                return this._rotationY;
                            },
                            set: function (value) {
                                value = +value;
                                notImplemented("public DisplayObject::set rotationY");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "rotationZ", {
                            get: function () {
                                return this._rotationZ;
                            },
                            set: function (value) {
                                value = +value;
                                notImplemented("public DisplayObject::set rotationZ");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "width", {
                            /**
                            * The width of this display object in its parent coordinate space.
                            */
                            get: function () {
                                var bounds = this._getTransformedBounds(this._parent, true);
                                return bounds.width / 20;
                            },
                            /**
                            * Attempts to change the width of this display object by changing its scaleX / scaleY
                            * properties. The scaleX property is set to the specified |width| value / baseWidth
                            * of the object in its parent cooridnate space with rotation applied.
                            */
                            set: function (value) {
                                value = (value * 20) | 0;
                                this._stopTimelineAnimation();
                                if (value < 0) {
                                    return;
                                }
                                var contentBounds = this._getContentBounds(true);
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    this._setFillAndLineBoundsFromWidthAndHeight(value, contentBounds.height);
                                    return;
                                }
                                var bounds = this._getTransformedBounds(this._parent, true);
                                var angle = this._rotation / 180 * Math.PI;
                                var baseWidth = contentBounds.getBaseWidth(angle);
                                if (!baseWidth) {
                                    return;
                                }
                                var baseHeight = contentBounds.getBaseHeight(angle);
                                this._scaleY = bounds.height / baseHeight;
                                this._scaleX = value / baseWidth;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "height", {
                            /**
                            * The height of this display object in its parent coordinate space.
                            */
                            get: function () {
                                var bounds = this._getTransformedBounds(this._parent, true);
                                return bounds.height / 20;
                            },
                            /**
                            * Attempts to change the height of this display object by changing its scaleY / scaleX
                            * properties. The scaleY property is set to the specified |height| value / baseHeight
                            * of the object in its parent cooridnate space with rotation applied.
                            */
                            set: function (value) {
                                value = (value * 20) | 0;
                                this._stopTimelineAnimation();
                                if (value < 0) {
                                    return;
                                }
                                var contentBounds = this._getContentBounds(true);
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    this._setFillAndLineBoundsFromWidthAndHeight(contentBounds.width, value);
                                    return;
                                }
                                var bounds = this._getTransformedBounds(this._parent, true);
                                var angle = this._rotation / 180 * Math.PI;
                                var baseHeight = contentBounds.getBaseHeight(angle);
                                if (!baseHeight) {
                                    return;
                                }
                                var baseWidth = contentBounds.getBaseWidth(angle);
                                this._scaleY = value / baseHeight;
                                this._scaleX = bounds.width / baseWidth;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "mask", {
                            get: function () {
                                return this._mask;
                            },
                            /**
                            * Sets the mask for this display object. This does not affect the bounds.
                            */
                            set: function (value) {
                                this._stopTimelineAnimation();
                                if (this._mask === value || value === this) {
                                    return;
                                }

                                if (value && value._maskedObject) {
                                    value._maskedObject.mask = null;
                                }
                                this._mask = value;
                                if (value) {
                                    value._maskedObject = this;
                                }
                                this._setDirtyFlags(67108864 /* DirtyMask */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "transform", {
                            get: function () {
                                return new flash.geom.Transform(this);
                            },
                            set: function (value) {
                                this._stopTimelineAnimation();
                                if (value.matrix3D) {
                                    this._matrix3D = value.matrix3D;
                                } else {
                                    this._setMatrix(value.matrix, true);
                                }
                                this._setColorTransform(value.colorTransform);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        DisplayObject.prototype.destroy = function () {
                            this._setFlags(512 /* Destroyed */);
                        };

                        Object.defineProperty(DisplayObject.prototype, "root", {
                            /**
                            * Walks up the tree to find this display object's root. An object is classified
                            * as a root if its _root property points to itself. Root objects are the Stage,
                            * the main timeline object and a Loader's content.
                            */
                            get: function () {
                                var node = this;
                                do {
                                    if (node._root === node) {
                                        return node;
                                    }
                                    node = node._parent;
                                } while(node);
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObject.prototype, "stage", {
                            /**
                            * Walks up the tree to find this display object's stage, the first object whose
                            * |_stage| property points to itself.
                            */
                            get: function () {
                                var node = this;
                                do {
                                    if (node._stage === node) {
                                        release || assert(flash.display.Stage.isType(node));
                                        return node;
                                    }
                                    node = node._parent;
                                } while(node);
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObject.prototype, "name", {
                            get: function () {
                                return this._name ? this._name : "";
                            },
                            set: function (value) {
                                this._name = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "parent", {
                            get: function () {
                                return this._parent;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObject.prototype, "visible", {
                            get: function () {
                                return this._hasFlags(1 /* Visible */);
                            },
                            /**
                            * Marks this display object as visible / invisible. This does not affect the bounds.
                            */
                            set: function (value) {
                                this._stopTimelineAnimation();
                                value = !!value;
                                if (value === this._hasFlags(1 /* Visible */)) {
                                    return;
                                }
                                this._toggleFlags(1 /* Visible */, value);
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObject.prototype, "alpha", {
                            get: function () {
                                return this._colorTransform.alphaMultiplier;
                            },
                            set: function (value) {
                                this._stopTimelineAnimation();
                                value = +value;
                                if (value === this._colorTransform.alphaMultiplier) {
                                    return;
                                }
                                this._colorTransform.alphaMultiplier = value;
                                this._colorTransform.convertToFixedPoint();
                                this._propagateFlagsDown(128 /* InvalidConcatenatedColorTransform */);
                                this._setDirtyFlags(33554432 /* DirtyColorTransform */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "blendMode", {
                            get: function () {
                                return this._blendMode;
                            },
                            set: function (value) {
                                this._stopTimelineAnimation();
                                value = asCoerceString(value);
                                if (value === this._blendMode) {
                                    return;
                                }
                                if (display.BlendMode.toNumber(value) < 0) {
                                    throwError("ArgumentError", AVM2.Errors.InvalidEnumError, "blendMode");
                                }
                                this._blendMode = value;
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "scale9Grid", {
                            get: function () {
                                return this._scale9Grid ? flash.geom.Rectangle.FromBounds(this._scale9Grid) : null;
                            },
                            set: function (innerRectangle) {
                                this._stopTimelineAnimation();
                                this._scale9Grid = Bounds.FromRectangle(innerRectangle);
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "cacheAsBitmap", {
                            get: function () {
                                return this._filters.length > 0 || this._hasFlags(16384 /* CacheAsBitmap */);
                            },
                            set: function (value) {
                                if (this._hasFlags(16384 /* CacheAsBitmap */)) {
                                    return;
                                }
                                this._toggleFlags(16384 /* CacheAsBitmap */, !!value);
                                this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "filters", {
                            /**
                            * References to the internal |_filters| array and its BitmapFilter objects are never leaked outside of this
                            * class. The get/set filters accessors always return deep clones of this array.
                            */
                            get: function () {
                                return this._filters.map(function (x) {
                                    return x.clone();
                                });
                            },
                            set: function (value) {
                                var changed = false;
                                if (isNullOrUndefined(value)) {
                                    changed = this.filters.length > 0;
                                    this._filters.length = 0;
                                } else {
                                    this._filters = value.map(function (x) {
                                        release || assert(flash.filters.BitmapFilter.isType(x));
                                        return x.clone();
                                    });
                                    changed = true;
                                }
                                if (changed) {
                                    this._setDirtyFlags(268435456 /* DirtyMiscellaneousProperties */);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });



                        Object.defineProperty(DisplayObject.prototype, "z", {
                            get: function () {
                                return this._z;
                            },
                            set: function (value) {
                                value = +value;
                                this._z = value;
                                notImplemented("public DisplayObject::set z");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
                            targetCoordinateSpace = targetCoordinateSpace || this;
                            return geom.Rectangle.FromBounds(this._getTransformedBounds(targetCoordinateSpace, true));
                        };

                        DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
                            targetCoordinateSpace = targetCoordinateSpace || this;
                            return geom.Rectangle.FromBounds(this._getTransformedBounds(targetCoordinateSpace, false));
                        };

                        /**
                        * Converts a point from the global coordinate space into the local coordinate space.
                        */
                        DisplayObject.prototype.globalToLocal = function (point) {
                            var m = this._getInvertedConcatenatedMatrix();
                            var p = m.transformPointInPlace(point.clone().toTwips()).round();
                            return p.toPixels();
                        };

                        /**
                        * Converts a point form the local coordinate sapce into the global coordinate space.
                        */
                        DisplayObject.prototype.localToGlobal = function (point) {
                            var m = this._getConcatenatedMatrix();
                            var p = m.transformPointInPlace(point.clone().toTwips()).round();
                            return p.toPixels();
                        };

                        /**
                        * Tree visitor that lets you skip nodes or return early.
                        */
                        DisplayObject.prototype.visit = function (visitor, visitorFlags, displayObjectFlags) {
                            if (typeof displayObjectFlags === "undefined") { displayObjectFlags = 0 /* None */; }
                            var stack;
                            var displayObject;
                            var displayObjectContainer;
                            var frontToBack = visitorFlags & 8 /* FrontToBack */;
                            stack = [this];
                            while (stack.length > 0) {
                                displayObject = stack.pop();
                                var flags = 0 /* None */;
                                if (visitorFlags & 16 /* Filter */ && !displayObject._hasAnyFlags(displayObjectFlags)) {
                                    flags = 2 /* Skip */;
                                } else {
                                    flags = visitor(displayObject);
                                }
                                if (flags === 0 /* Continue */) {
                                    var children = displayObject._children;
                                    if (children) {
                                        var length = children.length;
                                        for (var i = 0; i < length; i++) {
                                            var child = children[frontToBack ? i : length - 1 - i];
                                            stack.push(child);
                                        }
                                    }
                                } else if (flags === 1 /* Stop */) {
                                    return;
                                }
                            }
                        };

                        Object.defineProperty(DisplayObject.prototype, "loaderInfo", {
                            /**
                            * Returns the loader info for this display object's root.
                            */
                            get: function () {
                                var root = this.root;
                                if (root) {
                                    release || assert(root._loaderInfo, "No LoaderInfo object found on root.");
                                    return root._loaderInfo;
                                }
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        /**
                        * Only these objects can have graphics.
                        */
                        DisplayObject.prototype._canHaveGraphics = function () {
                            return false;
                        };

                        /**
                        * Gets the graphics object of this object. Shapes, MorphShapes, and Sprites override this.
                        */
                        DisplayObject.prototype._getGraphics = function () {
                            return null;
                        };

                        /**
                        * Only these objects can have text content.
                        */
                        DisplayObject.prototype._canHaveTextContent = function () {
                            return false;
                        };

                        /**
                        * Gets the text content of this object. StaticTexts and TextFields override this.
                        */
                        DisplayObject.prototype._getTextContent = function () {
                            return null;
                        };

                        /**
                        * Lazily construct a graphics object.
                        */
                        DisplayObject.prototype._ensureGraphics = function () {
                            release || assert(this._canHaveGraphics());
                            if (this._graphics) {
                                return this._graphics;
                            }
                            this._graphics = new flash.display.Graphics();
                            this._graphics._setParent(this);
                            this._invalidateFillAndLineBounds(true, true);
                            this._setDirtyFlags(4194304 /* DirtyGraphics */);
                            return this._graphics;
                        };

                        /**
                        * Sets this object's graphics or text content. Happens when an animated Shape or StaticText
                        * object is initialized from a symbol or replaced by a timeline command using the same symbol
                        * as this object was initialized from.
                        */
                        DisplayObject.prototype._setStaticContentFromSymbol = function (symbol) {
                            release || assert(!symbol.dynamic);
                            if (this._canHaveGraphics()) {
                                release || assert(symbol instanceof Shumway.Timeline.ShapeSymbol);
                                this._graphics = symbol.graphics;
                                this._setDirtyFlags(4194304 /* DirtyGraphics */);
                            } else if (flash.text.StaticText.isType(this)) {
                                release || assert(symbol instanceof Shumway.Timeline.TextSymbol);
                                var textSymbol = symbol;
                                this._textContent = textSymbol.textContent;
                                this._setDirtyFlags(8388608 /* DirtyTextContent */);
                            }
                            this._setFillAndLineBoundsFromSymbol(symbol);
                        };

                        /**
                        * Checks if the bounding boxes of two display objects overlap, this happens in the global
                        * coordinate coordinate space.
                        *
                        * Two objects overlap even if one or both are not on the stage, as long as their bounds
                        * in the global coordinate space overlap.
                        */
                        DisplayObject.prototype.hitTestObject = function (other) {
                            release || assert(other && DisplayObject.isType(other));
                            var a = this, b = other;
                            var aBounds = a._getContentBounds(false).clone();
                            var bBounds = b._getContentBounds(false).clone();
                            a._getConcatenatedMatrix().transformBounds(aBounds);
                            b._getConcatenatedMatrix().transformBounds(bBounds);
                            return aBounds.intersects(bBounds);
                        };

                        /**
                        * The |x| and |y| arguments are in global coordinates. The |shapeFlag| indicates whether
                        * the hit test should be on the actual pixels of the object |true| or just its bounding
                        * box |false|. Use the |ignoreChildren| to only test the display object's graphics and
                        * not its children.
                        *
                        * Note: shapeFlag and ignoreChildren are optional, but the type coercion will do the right
                        * thing for them, so we don't need to take the overhead from being explicit about that.
                        */
                        DisplayObject.prototype.hitTestPoint = function (x, y, shapeFlag, ignoreChildren, ignoreClipping) {
                            if (typeof ignoreClipping === "undefined") { ignoreClipping = true; }
                            x = +x * 20 | 0;
                            y = +y * 20 | 0;
                            shapeFlag = !!shapeFlag;
                            ignoreChildren = !!ignoreChildren;
                            ignoreClipping = !!ignoreClipping;
                            var matrix = this._getInvertedConcatenatedMatrix();
                            var localX = matrix.transformX(x, y);
                            var localY = matrix.transformY(x, y);
                            return this._containsPoint(localX, localY, shapeFlag, ignoreChildren, ignoreClipping);
                        };

                        /**
                        * Returns true if the given global coordinates hit the shape of this object.
                        *
                        * Overridden in SimpleButton.
                        */
                        DisplayObject.prototype._isUnderMouse = function (x, y) {
                            var matrix = this._getInvertedConcatenatedMatrix();
                            var localX = matrix.transformX(x, y);
                            var localY = matrix.transformY(x, y);
                            return this._containsPoint(localX, localY, true, false, false);
                        };

                        /**
                        * Same as |hitTestPoint| but the point is in local coordinate space and in twips.
                        */
                        DisplayObject.prototype._containsPoint = function (x, y, shapeFlag, ignoreChildren, ignoreClipping) {
                            if (!this._getContentBounds().contains(x, y)) {
                                return false;
                            }
                            if (!shapeFlag) {
                                return true;
                            }
                            if (this._mask) {
                                var matrix = this._mask._getInvertedMatrix();
                                var maskX = matrix.transformX(x, y);
                                var maskY = matrix.transformY(x, y);
                                if (!this._mask._containsPoint(maskX, maskY, shapeFlag, ignoreChildren, ignoreClipping)) {
                                    return false;
                                }
                            }

                            /* TODO: Figure out if we need to test against the graphics path first and exit early instead of
                            * going down the children list. Testing the path can be more expensive sometimes, more so than
                            * testing the children. */
                            if (!ignoreChildren && display.DisplayObjectContainer.isType(this)) {
                                var children = this._children;
                                for (var i = 0; i < children.length; i++) {
                                    var child = children[i];
                                    var matrix = child._getInvertedMatrix();
                                    var childX = matrix.transformX(x, y);
                                    var childY = matrix.transformY(x, y);
                                    var result = child._containsPoint(childX, childY, shapeFlag, ignoreChildren, ignoreClipping);
                                    if (!ignoreClipping && child._clipDepth >= 0 && child._parent) {
                                        if (!result) {
                                            i = child._parent.getClipDepthIndex(child._clipDepth);
                                        }
                                    } else if (result) {
                                        return true;
                                    }
                                }
                            }
                            var graphics = this._getGraphics();
                            if (graphics) {
                                // TODO: split this up into internal and external versions.
                                // The external one must include strokes, the internal shouldn't do the argument validation.
                                return graphics._containsPoint(x, y, true);
                            }
                            return false;
                        };
                        Object.defineProperty(DisplayObject.prototype, "scrollRect", {
                            get: function () {
                                return this._scrollRect ? this._scrollRect.clone() : null;
                            },
                            set: function (value) {
                                value = value;
                                this._scrollRect = value ? value.clone() : null;

                                /* TODO: Figure out how to deal with the bounds and hit testing when scroll rects are applied.
                                * The Flash implementation appears to be broken. */
                                notImplemented("public DisplayObject::set scrollRect");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObject.prototype, "opaqueBackground", {
                            get: function () {
                                return this._opaqueBackground;
                            },
                            /**
                            * Sets the opaque background color. By default this is |null|, which indicates that no opaque color is set.
                            * Otherwise this is an unsinged number.
                            */
                            set: function (value) {
                                release || assert(value === null || Shumway.isInteger(value));
                                this._opaqueBackground = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        /**
                        * Finds the furthest interactive ancestor (or self) to receive pointer events for this object.
                        */
                        DisplayObject.prototype.findFurthestInteractiveAncestorOrSelf = function () {
                            if (!this.visible) {
                                return null;
                            }
                            var find = display.InteractiveObject.isType(this) ? this : this._parent;
                            var self = this._parent;
                            while (self) {
                                if (!self.visible) {
                                    return null;
                                }
                                if (!self.mouseChildren) {
                                    find = self;
                                }
                                self = self._parent;
                            }
                            return find;
                        };

                        /**
                        * Returns the distance between this object and a given ancestor.
                        */
                        DisplayObject.prototype._getDistance = function (ancestor) {
                            var d = 0;
                            var node = this;
                            while (node !== ancestor) {
                                d++;
                                node = node._parent;
                            }
                            return d;
                        };

                        /**
                        * Finds the nearest common ancestor with a given node.
                        */
                        DisplayObject.prototype.findNearestCommonAncestor = function (node) {
                            if (!node) {
                                return null;
                            }
                            var ancestor = this;
                            var d1 = ancestor._getDistance(null);
                            var d2 = node._getDistance(null);
                            while (d1 > d2) {
                                ancestor = ancestor._parent;
                                d1--;
                            }
                            while (d2 > d1) {
                                node = node._parent;
                                d2--;
                            }
                            while (ancestor !== node) {
                                ancestor = ancestor._parent;
                                node = node._parent;
                            }
                            return ancestor;
                        };

                        Object.defineProperty(DisplayObject.prototype, "mouseX", {
                            get: function () {
                                return this.globalToLocal(flash.ui.Mouse._currentPosition).x;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObject.prototype, "mouseY", {
                            get: function () {
                                return this.globalToLocal(flash.ui.Mouse._currentPosition).y;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        DisplayObject.prototype.debugName = function () {
                            return this._id + " [" + this._depth + "]: (" + this._referenceCount + ") " + this;
                        };

                        DisplayObject.prototype.debugTrace = function (maxDistance, name) {
                            if (typeof maxDistance === "undefined") { maxDistance = 1024; }
                            if (typeof name === "undefined") { name = ""; }
                            var self = this;
                            var writer = new Shumway.IndentingWriter();
                            this.visit(function (node) {
                                var distance = node._getDistance(self);
                                if (distance > maxDistance) {
                                    return 2 /* Skip */;
                                }
                                var prefix = name + Shumway.StringUtilities.multiple(" ", distance);
                                writer.writeLn(prefix + node.debugName());
                                return 0 /* Continue */;
                            }, 0 /* None */);
                        };

                        DisplayObject.prototype._addReference = function () {
                            this._referenceCount++;
                        };

                        DisplayObject.prototype._removeReference = function () {
                            // TODO: Uncomment this assertion once we're sure reference counting works correctly.
                            // assert (this._referenceCount > 0);
                            this._referenceCount--;
                            if (this._referenceCount !== 0 || !this._children) {
                                return;
                            }
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                children[i]._removeReference();
                            }
                        };

                        Object.defineProperty(DisplayObject.prototype, "accessibilityProperties", {
                            get: function () {
                                return this._accessibilityProperties;
                            },
                            set: function (value) {
                                // In Flash this does not do copying.
                                this._accessibilityProperties = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        DisplayObject._syncID = 0;

                        DisplayObject.classInitializer = function () {
                            DisplayObject.reset();
                        };

                        DisplayObject.initializer = function (symbol) {
                            release || AVM2.counter.count("DisplayObject::initializer");

                            var self = this;

                            self._id = flash.display.DisplayObject.getNextSyncID();
                            self._displayObjectFlags = 1 /* Visible */ | 2 /* InvalidLineBounds */ | 4 /* InvalidFillBounds */ | 32 /* InvalidConcatenatedMatrix */ | 64 /* InvalidInvertedConcatenatedMatrix */ | 4194304 /* DirtyGraphics */ | 1048576 /* DirtyMatrix */ | 33554432 /* DirtyColorTransform */ | 67108864 /* DirtyMask */ | 134217728 /* DirtyClipDepth */ | 268435456 /* DirtyMiscellaneousProperties */;

                            self._root = null;
                            self._stage = null;
                            self._name = null;
                            self._parent = null;
                            self._mask = null;

                            self._z = 0;
                            self._scaleX = 1;
                            self._scaleY = 1;
                            self._scaleZ = 1;
                            self._rotation = 0;
                            self._rotationX = 0;
                            self._rotationY = 0;
                            self._rotationZ = 0;

                            self._width = 0;
                            self._height = 0;
                            self._opaqueBackground = null;
                            self._scrollRect = null;
                            self._filters = [];
                            self._blendMode = display.BlendMode.NORMAL;
                            release || assert(self._blendMode);
                            self._scale9Grid = null;
                            self._loaderInfo = null;
                            self._accessibilityProperties = null;

                            self._fillBounds = new Bounds(0, 0, 0, 0);
                            self._lineBounds = new Bounds(0, 0, 0, 0);
                            self._clipDepth = -1;

                            self._concatenatedMatrix = new geom.Matrix();
                            self._invertedConcatenatedMatrix = new geom.Matrix();
                            self._matrix = new geom.Matrix();
                            self._invertedMatrix = new geom.Matrix();
                            self._matrix3D = null;
                            self._colorTransform = new geom.ColorTransform();
                            self._concatenatedColorTransform = new geom.ColorTransform();

                            self._depth = -1;
                            self._ratio = 0;
                            self._index = -1;
                            self._maskedObject = null;

                            self._mouseOver = false;
                            self._mouseDown = false;

                            self._symbol = null;
                            self._graphics = null;
                            self._children = null;

                            self._referenceCount = 0;

                            if (symbol) {
                                if (symbol.scale9Grid) {
                                    // No need to take ownership: scale9Grid is never changed.
                                    self._scale9Grid = symbol.scale9Grid;
                                }
                                self._symbol = symbol;
                            }
                        };

                        DisplayObject.classSymbols = null;

                        DisplayObject.instanceSymbols = null;

                        DisplayObject._runScripts = true;

                        DisplayObject._path = [];
                        return DisplayObject;
                    })(flash.events.EventDispatcher);
                    display.DisplayObject = DisplayObject;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Bitmap
                (function (display) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var Bitmap = (function (_super) {
                        __extends(Bitmap, _super);
                        function Bitmap(bitmapData, pixelSnapping, smoothing) {
                            if (typeof bitmapData === "undefined") { bitmapData = null; }
                            if (typeof pixelSnapping === "undefined") { pixelSnapping = "auto"; }
                            if (typeof smoothing === "undefined") { smoothing = false; }
                            false && _super.call(this);
                            display.DisplayObject.instanceConstructorNoInitialize.call(this);
                            if (this._symbol) {
                                this._bitmapData.class.instanceConstructorNoInitialize.call(this._bitmapData);
                            } else {
                                this.bitmapData = bitmapData;
                            }
                            this._pixelSnapping = asCoerceString(pixelSnapping);
                            this._smoothing = !!smoothing;
                        }
                        Object.defineProperty(Bitmap.prototype, "pixelSnapping", {
                            get: function () {
                                return this._pixelSnapping;
                            },
                            set: function (value) {
                                if (display.PixelSnapping.toNumber(value) < 0) {
                                    throwError("ArgumentError", AVM2.Errors.InvalidEnumError, "pixelSnapping");
                                }
                                this._pixelSnapping = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Bitmap.prototype, "smoothing", {
                            get: function () {
                                return this._smoothing;
                            },
                            set: function (value) {
                                this._smoothing = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Bitmap.prototype, "bitmapData", {
                            get: function () {
                                return this._bitmapData;
                            },
                            set: function (value) {
                                if (this._bitmapData !== value) {
                                    if (this._bitmapData) {
                                        this._bitmapData._removeBitmapReferrer(this);
                                    }
                                    if (value) {
                                        value._addBitmapReferrer(this);
                                    }
                                }
                                this._bitmapData = value;
                                if (value) {
                                    this._setFillAndLineBoundsFromWidthAndHeight(value.width * 20 | 0, value.height * 20 | 0);
                                }
                                this._invalidateParentFillAndLineBounds(true, true);
                                this._setDirtyFlags(16777216 /* DirtyBitmapData */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Bitmap.prototype._getContentBounds = function (includeStrokes) {
                            if (typeof includeStrokes === "undefined") { includeStrokes = true; }
                            if (this._bitmapData) {
                                return this._bitmapData._getContentBounds();
                            }
                            return new Shumway.Bounds(0, 0, 0, 0);
                        };
                        Bitmap.classInitializer = null;

                        Bitmap.initializer = function (symbol) {
                            var self = this;

                            self._bitmapData = null;
                            self._pixelSnapping = null;
                            self._smoothing = null;

                            if (symbol) {
                                var symbolClass = symbol.symbolClass;

                                // If the symbol class inherits from Bitmap, we are already within its initializer.
                                // Make sure to create a BitmapData instance here to avoid recursively calling the
                                // initializer again.
                                if (symbolClass.isSubtypeOf(flash.display.Bitmap)) {
                                    symbolClass = flash.display.BitmapData;
                                }

                                // TODO: I don't think BitmapData symbol objects can change, so they don't need back
                                // references to this Bitmap.
                                self._bitmapData = symbolClass.initializeFrom(symbol);
                                self._setFillAndLineBoundsFromWidthAndHeight(symbol.width * 20 | 0, symbol.height * 20 | 0);
                            }
                        };

                        Bitmap.classSymbols = null;

                        Bitmap.instanceSymbols = null;
                        return Bitmap;
                    })(flash.display.DisplayObject);
                    display.Bitmap = Bitmap;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Shape
                (function (display) {
                    var Shape = (function (_super) {
                        __extends(Shape, _super);
                        function Shape() {
                            false && _super.call(this);
                            display.DisplayObject.instanceConstructorNoInitialize.call(this);
                        }
                        Shape.prototype._canHaveGraphics = function () {
                            return true;
                        };

                        Shape.prototype._getGraphics = function () {
                            return this._graphics;
                        };

                        Object.defineProperty(Shape.prototype, "graphics", {
                            get: function () {
                                return this._ensureGraphics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Shape.classSymbols = null;
                        Shape.instanceSymbols = null;

                        Shape.classInitializer = null;
                        Shape.initializer = function (symbol) {
                            var self = this;
                            self._graphics = null;
                            if (symbol) {
                                this._setStaticContentFromSymbol(symbol);
                                // TODO: Assert that the computed bounds of the graphics object in fact
                                // match those given by the symbol.
                            }
                        };
                        return Shape;
                    })(flash.display.DisplayObject);
                    display.Shape = Shape;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: InteractiveObject
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var DisplayObject = flash.display.DisplayObject;

                    var events = flash.events;

                    var InteractiveObject = (function (_super) {
                        __extends(InteractiveObject, _super);
                        function InteractiveObject() {
                            false && _super.call(this);
                            DisplayObject.instanceConstructorNoInitialize.call(this);
                        }
                        Object.defineProperty(InteractiveObject.prototype, "tabEnabled", {
                            get: function () {
                                return this._tabEnabled;
                            },
                            set: function (enabled) {
                                enabled = !!enabled;
                                var old = this._tabEnabled;
                                this._tabEnabled = enabled;
                                if (old !== enabled) {
                                    this.dispatchEvent(events.Event.getInstance(events.Event.TAB_ENABLED_CHANGE, true));
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "tabIndex", {
                            get: function () {
                                return this._tabIndex;
                            },
                            set: function (index /*int*/ ) {
                                index = index | 0;
                                var old = this._tabIndex;
                                this._tabIndex = index;
                                if (old !== index) {
                                    this.dispatchEvent(events.Event.getInstance(events.Event.TAB_INDEX_CHANGE, true));
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "focusRect", {
                            get: function () {
                                return this._focusRect;
                            },
                            set: function (focusRect) {
                                focusRect = focusRect;
                                notImplemented("public flash.display.InteractiveObject::set focusRect");
                                return;
                                // this._focusRect = focusRect;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "mouseEnabled", {
                            get: function () {
                                return this._mouseEnabled;
                            },
                            set: function (enabled) {
                                this._mouseEnabled = !!enabled;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "doubleClickEnabled", {
                            get: function () {
                                return this._doubleClickEnabled;
                            },
                            set: function (enabled) {
                                this._doubleClickEnabled = !!enabled;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "accessibilityImplementation", {
                            get: function () {
                                return this._accessibilityImplementation;
                            },
                            set: function (value) {
                                value = value;
                                notImplemented("public flash.display.InteractiveObject::set accessibilityImplementation");
                                return;
                                // this._accessibilityImplementation = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "softKeyboardInputAreaOfInterest", {
                            get: function () {
                                return this._softKeyboardInputAreaOfInterest;
                            },
                            set: function (value) {
                                value = value;
                                notImplemented("public flash.display.InteractiveObject::set softKeyboardInputAreaOfInterest");
                                return;
                                // this._softKeyboardInputAreaOfInterest = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "needsSoftKeyboard", {
                            get: function () {
                                return this._needsSoftKeyboard;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.display.InteractiveObject::set needsSoftKeyboard");
                                return;
                                // this._needsSoftKeyboard = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(InteractiveObject.prototype, "contextMenu", {
                            get: function () {
                                return this._contextMenu;
                            },
                            set: function (cm) {
                                cm = cm;
                                somewhatImplemented("public flash.display.InteractiveObject::set contextMenu");
                                this._contextMenu = cm;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        InteractiveObject.prototype.requestSoftKeyboard = function () {
                            notImplemented("public flash.display.InteractiveObject::requestSoftKeyboard");
                            return;
                        };
                        InteractiveObject.classInitializer = null;

                        InteractiveObject.initializer = function () {
                            var self = this;
                            self._tabEnabled = false;
                            self._tabIndex = -1;
                            self._focusRect = null;
                            self._mouseEnabled = true;
                            self._doubleClickEnabled = false;
                            self._accessibilityImplementation = null;
                            self._softKeyboardInputAreaOfInterest = null;
                            self._needsSoftKeyboard = false;
                            self._contextMenu = null;
                        };

                        InteractiveObject.classSymbols = null;

                        InteractiveObject.instanceSymbols = null;
                        return InteractiveObject;
                    })(flash.display.DisplayObject);
                    display.InteractiveObject = InteractiveObject;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SimpleButton
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var SimpleButton = (function (_super) {
                        __extends(SimpleButton, _super);
                        function SimpleButton(upState, overState, downState, hitTestState) {
                            if (typeof upState === "undefined") { upState = null; }
                            if (typeof overState === "undefined") { overState = null; }
                            if (typeof downState === "undefined") { downState = null; }
                            if (typeof hitTestState === "undefined") { hitTestState = null; }
                            upState = upState;
                            overState = overState;
                            downState = downState;
                            hitTestState = hitTestState;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.SimpleButton");
                        }
                        SimpleButton.prototype._initFrame = function (advance) {
                            if (advance) {
                                this._updateButton();
                            }
                        };

                        SimpleButton.prototype._constructFrame = function () {
                            // ...
                        };

                        Object.defineProperty(SimpleButton.prototype, "useHandCursor", {
                            get: function () {
                                return this._useHandCursor;
                            },
                            set: function (value) {
                                this._useHandCursor = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "enabled", {
                            get: function () {
                                return this._enabled;
                            },
                            set: function (value) {
                                this._enabled = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "trackAsMenu", {
                            get: function () {
                                return this._trackAsMenu;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.display.SimpleButton::set trackAsMenu");
                                return;
                                // this._trackAsMenu = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "upState", {
                            get: function () {
                                return this._upState;
                            },
                            set: function (value) {
                                //value = value;
                                var old = this._upState;
                                if (value._parent) {
                                    value._parent.removeChild(value);
                                }
                                this._upState = value;
                                if (this._currentState === old) {
                                    this._updateButton();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "overState", {
                            get: function () {
                                return this._overState;
                            },
                            set: function (value) {
                                //value = value;
                                var old = this._overState;
                                if (value._parent) {
                                    value._parent.removeChild(value);
                                }
                                this._overState = value;
                                if (this._currentState === old) {
                                    this._updateButton();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "downState", {
                            get: function () {
                                return this._downState;
                            },
                            set: function (value) {
                                //value = value;
                                var old = this._downState;
                                if (value._parent) {
                                    value._parent.removeChild(value);
                                }
                                this._downState = value;
                                if (this._currentState === old) {
                                    this._updateButton();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "hitTestState", {
                            get: function () {
                                return this._hitTestState;
                            },
                            set: function (value) {
                                //value = value;
                                this._hitTestState = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(SimpleButton.prototype, "soundTransform", {
                            get: function () {
                                notImplemented("public flash.display.SimpleButton::get soundTransform");
                                return;
                                // return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                sndTransform = sndTransform;
                                notImplemented("public flash.display.SimpleButton::set soundTransform");
                                return;
                                // this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        /**
                        * Override of DisplayObject#_isUnderMouse that applies the test on hitTestState if
                        * that is defined.
                        */
                        SimpleButton.prototype._isUnderMouse = function (x, y) {
                            var target = this.hitTestState;
                            if (!target) {
                                return false;
                            }
                            var matrix = this._getInvertedConcatenatedMatrix();
                            var localX = matrix.transformX(x, y);
                            var localY = matrix.transformY(x, y);

                            // As we observed by testing, the hitTestState's own matrix seems to be ignored if created from a symbol.
                            if (!this._symbol) {
                                matrix = target._getInvertedMatrix();
                                var tmpX = matrix.transformX(localX, localY);
                                localY = matrix.transformY(localX, localY);
                                localX = tmpX;
                            }
                            return target._containsPoint(localX, localY, true, false, false);
                        };

                        SimpleButton.prototype._updateButton = function () {
                            var state;
                            if (this._mouseOver) {
                                state = this._mouseDown ? this._downState : this._overState;
                            } else {
                                state = this._upState;
                            }
                            if (state === this._currentState) {
                                return;
                            }
                            if (this._currentState) {
                                // TODO dispatch removedFromStage event
                            }
                            this._currentState = state;
                            if (this._stage) {
                                // TODO dispatch addedToStage event
                            }
                            if (state) {
                                this._children[0] = state;
                            } else {
                                this._children.length = 0;
                            }
                            this._setDirtyFlags(2097152 /* DirtyChildren */);
                            this._invalidateFillAndLineBounds(true, true);
                        };
                        SimpleButton.classInitializer = null;

                        SimpleButton.initializer = function (symbol) {
                            var self = this;

                            display.DisplayObject._advancableInstances.push(self);

                            self._useHandCursor = true;
                            self._enabled = true;
                            self._trackAsMenu = false;
                            self._upState = null;
                            self._overState = null;
                            self._downState = null;
                            self._hitTestState = null;

                            self._currentState = null;
                            self._children = [];

                            self._symbol = symbol;

                            if (symbol) {
                                if (symbol.upState) {
                                    self._upState = display.DisplayObject.createAnimatedDisplayObject(symbol.upState, true);
                                }
                                if (symbol.overState) {
                                    self._overState = display.DisplayObject.createAnimatedDisplayObject(symbol.overState, true);
                                }
                                if (symbol.downState) {
                                    self._downState = display.DisplayObject.createAnimatedDisplayObject(symbol.downState, true);
                                }
                                if (symbol.hitTestState) {
                                    self._hitTestState = display.DisplayObject.createAnimatedDisplayObject(symbol.hitTestState, true);
                                }
                            }
                        };

                        SimpleButton.classSymbols = null;

                        SimpleButton.instanceSymbols = null;
                        return SimpleButton;
                    })(flash.display.InteractiveObject);
                    display.SimpleButton = SimpleButton;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                ///<reference path='../references.ts' />
                (function (display) {
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var clamp = Shumway.NumberUtilities.clamp;
                    var Multiname = Shumway.AVM2.ABC.Multiname;

                    var events = flash.events;
                    var VisitorFlags = flash.display.VisitorFlags;

                    var DisplayObjectContainer = (function (_super) {
                        __extends(DisplayObjectContainer, _super);
                        function DisplayObjectContainer() {
                            false && _super.call(this);
                            display.InteractiveObject.instanceConstructorNoInitialize.call(this);
                            this._setDirtyFlags(2097152 /* DirtyChildren */);
                        }
                        /**
                        * This object's children have changed.
                        */
                        DisplayObjectContainer.prototype._invalidateChildren = function () {
                            this._setDirtyFlags(2097152 /* DirtyChildren */);
                            this._invalidateFillAndLineBounds(true, true);
                        };

                        /**
                        * Propagates flags down the display list. Propagation stops if all flags are already set.
                        */
                        DisplayObjectContainer.prototype._propagateFlagsDown = function (flags) {
                            if (this._hasFlags(flags)) {
                                return;
                            }
                            this._setFlags(flags);
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                children[i]._propagateFlagsDown(flags);
                            }
                        };

                        /**
                        * Calls the constructors of new children placed by timeline commands.
                        */
                        DisplayObjectContainer.prototype._constructChildren = function () {
                            release || AVM2.counter.count("DisplayObjectContainer::_constructChildren");

                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (child._hasFlags(256 /* Constructed */)) {
                                    continue;
                                }
                                child.class.instanceConstructorNoInitialize.call(child);
                                child._removeReference();
                                if (child._name) {
                                    this[Multiname.getPublicQualifiedName(child._name)] = child;
                                    //child._addReference();
                                }
                                child._setFlags(256 /* Constructed */);

                                //if (!loader._isAvm2Enabled) {
                                //  this._initAvm1Bindings(instance, name, displayListItem.events,
                                //    's' + props.symbolId + 'c');
                                //  instance._dispatchEvent("init");
                                //  instance._dispatchEvent("construct");
                                //  instance._needLoadEvent = true;
                                //} else {
                                //  instance._dispatchEvent("load");
                                //}
                                child.dispatchEvent(events.Event.getInstance(events.Event.ADDED, true));
                                if (child.stage) {
                                    child.dispatchEvent(events.Event.getInstance(events.Event.ADDED_TO_STAGE));
                                }
                            }
                        };

                        DisplayObjectContainer.prototype._enqueueFrameScripts = function () {
                            if (this._hasFlags(8192 /* ContainsFrameScriptPendingChildren */)) {
                                this._removeFlags(8192 /* ContainsFrameScriptPendingChildren */);
                                var children = this._children;
                                for (var i = 0; i < children.length; i++) {
                                    var child = children[i];
                                    if (DisplayObjectContainer.isType(child)) {
                                        child._enqueueFrameScripts();
                                    }
                                }
                            }
                        };

                        Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
                            get: function () {
                                return this._children.length;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObjectContainer.prototype, "textSnapshot", {
                            get: function () {
                                notImplemented("public DisplayObjectContainer::get textSnapshot");
                                return;
                                // return this._textSnapshot;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplayObjectContainer.prototype, "tabChildren", {
                            get: function () {
                                return this._tabChildren;
                            },
                            set: function (enable) {
                                enable = !!enable;

                                var old = this._tabChildren;
                                this._tabChildren = enable;
                                if (old !== enable) {
                                    this.dispatchEvent(events.Event.getInstance(events.Event.TAB_CHILDREN_CHANGE, true));
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DisplayObjectContainer.prototype, "mouseChildren", {
                            get: function () {
                                return this._mouseChildren;
                            },
                            set: function (enable) {
                                this._mouseChildren = !!enable;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        DisplayObjectContainer.prototype.addChild = function (child) {
                            return this.addChildAt(child, this._children.length);
                        };

                        DisplayObjectContainer.prototype.addChildAt = function (child, index /*int*/ ) {
                            release || AVM2.counter.count("DisplayObjectContainer::addChildAt");

                            index = index | 0;

                            release || assert(child._hasFlags(256 /* Constructed */), "Child is not fully constructed.");
                            if (child === this) {
                                throwError('ArgumentError', AVM2.Errors.CantAddSelfError);
                            }
                            if (DisplayObjectContainer.isType(child) && child.contains(this)) {
                                throwError('ArgumentError', AVM2.Errors.CantAddParentError);
                            }
                            var children = this._children;
                            if (index < 0 || index > children.length) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }

                            if (child._parent === this) {
                                this.setChildIndex(child, index);
                                return child;
                            }

                            if (child._parent) {
                                child._parent.removeChild(child);

                                // The children list could have been mutated as a result of |removeChild|.
                                index = clamp(index, 0, children.length);
                            }
                            for (var i = children.length - 1; i >= index; i--) {
                                children[i]._index++;
                            }
                            children.splice(index, 0, child);
                            child._setParent(this, -1);
                            child._index = index;
                            child._invalidatePosition();
                            child.dispatchEvent(events.Event.getInstance(events.Event.ADDED, true));

                            // ADDED event handlers may remove the child from the stage, in such cases
                            // we should not dispatch the ADDED_TO_STAGE event.
                            if (child.stage) {
                                child._propagateEvent(events.Event.getInstance(events.Event.ADDED_TO_STAGE));
                            }
                            this._invalidateChildren();
                            child._addReference();
                            return child;
                        };

                        /**
                        * Adds a timeline object to this container. The new child is added after the last object that
                        * exists at a smaller depth, or before the first object that exists at a greater depth. If no
                        * other timeline object is found, the new child is added to the front(top) of all other children.
                        */
                        DisplayObjectContainer.prototype.addChildAtDepth = function (child, depth /*int*/ ) {
                            release || AVM2.counter.count("DisplayObjectContainer::addChildAtDepth");

                            depth = depth | 0;

                            var children = this._children;
                            var maxIndex = children.length - 1;
                            var index = maxIndex + 1;
                            for (var i = maxIndex; i >= 0; i--) {
                                var current = children[i];
                                if (current._depth) {
                                    if (current._depth < depth) {
                                        index = i + 1;
                                        break;
                                    }
                                    index = i;
                                }
                            }

                            if (index > maxIndex) {
                                children.push(child);
                                child._index = index;
                            } else {
                                children.splice(index, 0, child);
                                for (var i = index; i < children.length; i++) {
                                    children[i]._index = i;
                                }
                            }
                            child._setParent(this, depth);
                            child._invalidatePosition();
                            this._invalidateChildren();
                        };

                        DisplayObjectContainer.prototype.removeChild = function (child) {
                            return this.removeChildAt(this.getChildIndex(child));
                        };

                        DisplayObjectContainer.prototype.removeChildAt = function (index) {
                            release || AVM2.counter.count("DisplayObjectContainer::removeChildAt");

                            index = index | 0;

                            var children = this._children;
                            if (index < 0 || index >= children.length) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }

                            var child = children[index];
                            if (child._hasFlags(256 /* Constructed */)) {
                                child.dispatchEvent(events.Event.getInstance(events.Event.REMOVED, true));
                                if (this.stage) {
                                    child._propagateEvent(events.Event.getInstance(events.Event.REMOVED_FROM_STAGE));
                                }

                                // Children list might have been mutated by the REMOVED or REMOVED_FROM_STAGE event,
                                // we may need to operate on the new index of the child.
                                index = this.getChildIndex(child);
                            }

                            children.splice(index, 1);
                            for (var i = children.length - 1; i >= index; i--) {
                                children[i]._index--;
                            }
                            child._setParent(null, -1);
                            child._index = -1;
                            child._invalidatePosition();
                            this._invalidateChildren();
                            return child;
                        };

                        DisplayObjectContainer.prototype.getChildIndex = function (child) {
                            if (child._parent !== this) {
                                throwError('ArgumentError', AVM2.Errors.NotAChildError);
                            }
                            return child._index;
                        };

                        DisplayObjectContainer.prototype.setChildIndex = function (child, index /*int*/ ) {
                            index = index | 0;

                            var children = this._children;
                            if (index < 0 || index > children.length) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }
                            child._depth = -1;
                            var currentIndex = this.getChildIndex(child);
                            if (children.length === 1 || currentIndex === index) {
                                return;
                            }
                            if (index === currentIndex + 1 || index === currentIndex - 1) {
                                // We can't call |swapChildrenAt| here because we don't want to affect the depth value.
                                this._swapChildrenAt(currentIndex, index);
                            } else {
                                children.splice(currentIndex, 1);
                                children.splice(index, 0, child);
                                var i = currentIndex < index ? currentIndex : index;
                                while (i < children.length) {
                                    children[i]._index = i++;
                                }
                            }
                            this._invalidateChildren();
                        };

                        DisplayObjectContainer.prototype.getChildAt = function (index) {
                            index = index | 0;

                            var children = this._children;
                            if (index < 0 || index >= children.length) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }

                            var child = children[index];
                            if (!child._hasFlags(256 /* Constructed */)) {
                                return null;
                            }

                            child._addReference();
                            return child;
                        };

                        /**
                        * Returns the timeline object that exists at the specified depth.
                        */
                        DisplayObjectContainer.prototype.getChildAtDepth = function (depth /*int*/ ) {
                            depth = depth | 0;
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (child._depth > depth) {
                                    break;
                                }
                                if (child._depth === depth) {
                                    return child;
                                }
                            }
                            return null;
                        };

                        /**
                        * Returns the last child index that is covered by the clip depth.
                        */
                        DisplayObjectContainer.prototype.getClipDepthIndex = function (depth) {
                            depth = depth | 0;
                            var children = this._children;
                            var index = this._children.length - 1;
                            var first = true;
                            for (var i = index; i >= 0; i--) {
                                var child = children[i];

                                // Ignore children that don't have a depth value.
                                if (child._depth < 0) {
                                    continue;
                                }

                                // Usually we return the index of the first child that has a depth value less than or
                                // equal to the specified depth. However, Flash seems to clip all remaining children,
                                // including those that don't have a depth value if the clip appears at the end.
                                if (child._depth <= depth) {
                                    return first ? index : i;
                                }
                                first = false;
                            }
                            return 0;
                        };

                        DisplayObjectContainer.prototype.getChildByName = function (name) {
                            name = asCoerceString(name);

                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (!child._hasFlags(256 /* Constructed */)) {
                                    continue;
                                }
                                if (child.name === name) {
                                    child._addReference();
                                    return child;
                                }
                            }

                            return null;
                        };

                        /**
                        * Gets the objects under the specified point by walking the children of this display list. If a child's
                        * bounds doesn't include the given point then we skip it and all of its children.
                        */
                        DisplayObjectContainer.prototype.getObjectsUnderPoint = function (globalPoint) {
                            release || AVM2.counter.count("DisplayObjectContainer::getObjectsUnderPoint");

                            var objectsUnderPoint = [];
                            this.visit(function (displayObject) {
                                if (displayObject.hitTestPoint(globalPoint.x, globalPoint.y, false, true)) {
                                    // Only include the objects whose shape is under the specified point.
                                    if (displayObject.hitTestPoint(globalPoint.x, globalPoint.y, true, true)) {
                                        objectsUnderPoint.push(displayObject);
                                        displayObject._addReference();
                                    }
                                } else {
                                    // TODO: Exclude inaccessible objects, not sure what these are.
                                    return 2 /* Skip */;
                                }
                                return 0 /* Continue */;
                            }, 0 /* None */);
                            return objectsUnderPoint;
                        };

                        DisplayObjectContainer.prototype.areInaccessibleObjectsUnderPoint = function (point) {
                            point = point;
                            notImplemented("public DisplayObjectContainer::areInaccessibleObjectsUnderPoint");
                            return;
                        };

                        DisplayObjectContainer.prototype.contains = function (child) {
                            return this._isAncestor(child);
                        };

                        DisplayObjectContainer.prototype.swapChildrenAt = function (index1 /*int*/ , index2 /*int*/ ) {
                            index1 = index1 | 0;
                            index2 = index2 | 0;

                            var children = this._children;
                            if (index1 < 0 || index1 >= children.length || index2 < 0 || index2 >= children.length) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }

                            if (index1 === index2) {
                                return;
                            }

                            this._swapChildrenAt(index1, index2);
                            this._invalidateChildren();
                        };

                        DisplayObjectContainer.prototype._swapChildrenAt = function (index1, index2) {
                            var children = this._children;
                            var child1 = children[index1];
                            var child2 = children[index2];
                            children[index2] = child1;
                            child1._depth = -1;
                            child1._index = index2;
                            children[index1] = child2;
                            child2._depth = -1;
                            child2._index = index1;
                        };

                        DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
                            this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
                        };

                        DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
                            if (typeof beginIndex === "undefined") { beginIndex = 0; }
                            if (typeof endIndex === "undefined") { endIndex = 2147483647; }
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;

                            if (beginIndex < 0 || endIndex < 0 || endIndex < beginIndex || endIndex >= this._children.length) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }

                            var count = endIndex - beginIndex + 1;
                            if (count > 0) {
                                while (count--) {
                                    this.removeChildAt(beginIndex);
                                }
                            }
                        };
                        DisplayObjectContainer.bindings = null;
                        DisplayObjectContainer.classSymbols = null;
                        DisplayObjectContainer.classInitializer = null;

                        DisplayObjectContainer.initializer = function () {
                            var self = this;
                            self._tabChildren = true;
                            self._mouseChildren = true;
                            self._children = [];
                        };
                        return DisplayObjectContainer;
                    })(flash.display.InteractiveObject);
                    display.DisplayObjectContainer = DisplayObjectContainer;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: JointStyle
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var JointStyle = (function (_super) {
                        __extends(JointStyle, _super);
                        function JointStyle() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.JointStyle");
                        }
                        // AS -> JS Bindings
                        JointStyle.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return JointStyle.ROUND;
                                case 1:
                                    return JointStyle.BEVEL;
                                case 2:
                                    return JointStyle.MITER;
                                default:
                                    return null;
                            }
                        };

                        JointStyle.toNumber = function (value) {
                            switch (value) {
                                case JointStyle.ROUND:
                                    return 0;
                                case JointStyle.BEVEL:
                                    return 1;
                                case JointStyle.MITER:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        JointStyle.classInitializer = null;

                        JointStyle.initializer = null;

                        JointStyle.classSymbols = null;

                        JointStyle.instanceSymbols = null;

                        JointStyle.ROUND = "round";
                        JointStyle.BEVEL = "bevel";
                        JointStyle.MITER = "miter";
                        return JointStyle;
                    })(AS.ASNative);
                    display.JointStyle = JointStyle;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: CapsStyle
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var CapsStyle = (function (_super) {
                        __extends(CapsStyle, _super);
                        function CapsStyle() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.CapsStyle");
                        }
                        // AS -> JS Bindings
                        CapsStyle.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return CapsStyle.ROUND;
                                case 1:
                                    return CapsStyle.NONE;
                                case 2:
                                    return CapsStyle.SQUARE;
                                default:
                                    return null;
                            }
                        };

                        CapsStyle.toNumber = function (value) {
                            switch (value) {
                                case CapsStyle.ROUND:
                                    return 0;
                                case CapsStyle.NONE:
                                    return 1;
                                case CapsStyle.SQUARE:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        CapsStyle.classInitializer = null;

                        CapsStyle.initializer = null;

                        CapsStyle.classSymbols = null;

                        CapsStyle.instanceSymbols = null;

                        CapsStyle.ROUND = "round";
                        CapsStyle.NONE = "none";
                        CapsStyle.SQUARE = "square";
                        return CapsStyle;
                    })(AS.ASNative);
                    display.CapsStyle = CapsStyle;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: LineScaleMode
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var LineScaleMode = (function (_super) {
                        __extends(LineScaleMode, _super);
                        function LineScaleMode() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.LineScaleMode");
                        }
                        // AS -> JS Bindings
                        LineScaleMode.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return LineScaleMode.NONE;
                                case 1:
                                    return LineScaleMode.NORMAL;
                                case 2:
                                    return LineScaleMode.VERTICAL;
                                case 3:
                                    return LineScaleMode.HORIZONTAL;
                                default:
                                    return null;
                            }
                        };

                        LineScaleMode.toNumber = function (value) {
                            switch (value) {
                                case LineScaleMode.NONE:
                                    return 0;
                                case LineScaleMode.NORMAL:
                                    return 1;
                                case LineScaleMode.VERTICAL:
                                    return 2;
                                case LineScaleMode.HORIZONTAL:
                                    return 3;
                                default:
                                    return -1;
                            }
                        };
                        LineScaleMode.classInitializer = null;

                        LineScaleMode.initializer = null;

                        LineScaleMode.classSymbols = null;

                        LineScaleMode.instanceSymbols = null;

                        LineScaleMode.NORMAL = "normal";
                        LineScaleMode.VERTICAL = "vertical";
                        LineScaleMode.HORIZONTAL = "horizontal";
                        LineScaleMode.NONE = "none";
                        return LineScaleMode;
                    })(AS.ASNative);
                    display.LineScaleMode = LineScaleMode;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GradientType
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var GradientType = (function (_super) {
                        __extends(GradientType, _super);
                        function GradientType() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.GradientType");
                        }
                        // AS -> JS Bindings
                        GradientType.fromNumber = function (n) {
                            switch (n) {
                                case 16 /* Linear */:
                                    return GradientType.LINEAR;
                                case 18 /* Radial */:
                                    return GradientType.RADIAL;
                                default:
                                    return null;
                            }
                        };

                        GradientType.toNumber = function (value) {
                            switch (value) {
                                case GradientType.LINEAR:
                                    return 16 /* Linear */;
                                case GradientType.RADIAL:
                                    return 18 /* Radial */;
                                default:
                                    return -1;
                            }
                        };
                        GradientType.classInitializer = null;
                        GradientType.initializer = null;
                        GradientType.classSymbols = null;
                        GradientType.instanceSymbols = null;

                        GradientType.LINEAR = "linear";
                        GradientType.RADIAL = "radial";
                        return GradientType;
                    })(AS.ASNative);
                    display.GradientType = GradientType;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SpreadMethod
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var GradientSpreadMethod = Shumway.GradientSpreadMethod;
                    var SpreadMethod = (function (_super) {
                        __extends(SpreadMethod, _super);
                        function SpreadMethod() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.SpreadMethod");
                        }
                        // AS -> JS Bindings
                        SpreadMethod.fromNumber = function (n) {
                            switch (n) {
                                case 0 /* Pad */:
                                    return SpreadMethod.PAD;
                                case 1 /* Reflect */:
                                    return SpreadMethod.REFLECT;
                                case 2 /* Repeat */:
                                    return SpreadMethod.REPEAT;
                                default:
                                    return null;
                            }
                        };

                        SpreadMethod.toNumber = function (value) {
                            switch (value) {
                                case SpreadMethod.PAD:
                                    return 0 /* Pad */;
                                case SpreadMethod.REFLECT:
                                    return 1 /* Reflect */;
                                case SpreadMethod.REPEAT:
                                    return 2 /* Repeat */;
                                default:
                                    return -1;
                            }
                        };
                        SpreadMethod.classInitializer = null;
                        SpreadMethod.initializer = null;
                        SpreadMethod.classSymbols = null;
                        SpreadMethod.instanceSymbols = null;

                        SpreadMethod.PAD = "pad";
                        SpreadMethod.REFLECT = "reflect";
                        SpreadMethod.REPEAT = "repeat";
                        return SpreadMethod;
                    })(AS.ASNative);
                    display.SpreadMethod = SpreadMethod;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: InterpolationMethod
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var GradientInterpolationMethod = Shumway.GradientInterpolationMethod;
                    var InterpolationMethod = (function (_super) {
                        __extends(InterpolationMethod, _super);
                        function InterpolationMethod() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.InterpolationMethod");
                        }
                        // AS -> JS Bindings
                        InterpolationMethod.fromNumber = function (n) {
                            switch (n) {
                                case 0 /* RGB */:
                                    return InterpolationMethod.RGB;
                                case 1 /* LinearRGB */:
                                    return InterpolationMethod.LINEAR_RGB;
                                default:
                                    return null;
                            }
                        };

                        InterpolationMethod.toNumber = function (value) {
                            switch (value) {
                                case InterpolationMethod.RGB:
                                    return 0 /* RGB */;
                                case InterpolationMethod.LINEAR_RGB:
                                    return 1 /* LinearRGB */;
                                default:
                                    return -1;
                            }
                        };
                        InterpolationMethod.classInitializer = null;
                        InterpolationMethod.initializer = null;
                        InterpolationMethod.classSymbols = null;
                        InterpolationMethod.instanceSymbols = null;

                        InterpolationMethod.RGB = "rgb";
                        InterpolationMethod.LINEAR_RGB = "linearRGB";
                        return InterpolationMethod;
                    })(AS.ASNative);
                    display.InterpolationMethod = InterpolationMethod;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsBitmapFill
                (function (display) {
                    var GraphicsBitmapFill = (function (_super) {
                        __extends(GraphicsBitmapFill, _super);
                        function GraphicsBitmapFill(bitmapData, matrix, repeat, smooth) {
                            if (typeof bitmapData === "undefined") { bitmapData = null; }
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof repeat === "undefined") { repeat = true; }
                            if (typeof smooth === "undefined") { smooth = false; }
                            false && _super.call(this);
                            this.bitmapData = bitmapData;
                            this.matrix = matrix;
                            this.repeat = !!repeat;
                            this.smooth = !!smooth;
                        }
                        GraphicsBitmapFill.classInitializer = null;

                        GraphicsBitmapFill.initializer = null;

                        GraphicsBitmapFill.classSymbols = null;

                        GraphicsBitmapFill.instanceSymbols = null;
                        return GraphicsBitmapFill;
                    })(AS.ASNative);
                    display.GraphicsBitmapFill = GraphicsBitmapFill;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsEndFill
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GraphicsEndFill = (function (_super) {
                        __extends(GraphicsEndFill, _super);
                        function GraphicsEndFill() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.GraphicsEndFill");
                        }
                        GraphicsEndFill.classInitializer = null;

                        GraphicsEndFill.initializer = null;

                        GraphicsEndFill.classSymbols = null;

                        GraphicsEndFill.instanceSymbols = null;
                        return GraphicsEndFill;
                    })(AS.ASNative);
                    display.GraphicsEndFill = GraphicsEndFill;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsGradientFill
                (function (display) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var GraphicsGradientFill = (function (_super) {
                        __extends(GraphicsGradientFill, _super);
                        function GraphicsGradientFill(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                            if (typeof type === "undefined") { type = "linear"; }
                            if (typeof colors === "undefined") { colors = null; }
                            if (typeof alphas === "undefined") { alphas = null; }
                            if (typeof ratios === "undefined") { ratios = null; }
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof spreadMethod === "undefined") { spreadMethod = "pad"; }
                            if (typeof interpolationMethod === "undefined") { interpolationMethod = "rgb"; }
                            if (typeof focalPointRatio === "undefined") { focalPointRatio = 0; }
                            false && _super.call(this);
                            this.type = asCoerceString(type);
                            this.colors = colors;
                            this.alphas = alphas;
                            this.ratios = ratios;
                            this.matrix = matrix;
                            this.spreadMethod = spreadMethod;
                            this.interpolationMethod = asCoerceString(interpolationMethod);
                            this.focalPointRatio = +focalPointRatio;
                        }
                        GraphicsGradientFill.classInitializer = null;

                        GraphicsGradientFill.initializer = null;

                        GraphicsGradientFill.classSymbols = null;

                        GraphicsGradientFill.instanceSymbols = null;
                        return GraphicsGradientFill;
                    })(AS.ASNative);
                    display.GraphicsGradientFill = GraphicsGradientFill;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsPath
                (function (display) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var GraphicsPath = (function (_super) {
                        __extends(GraphicsPath, _super);
                        function GraphicsPath(commands, data, winding) {
                            if (typeof commands === "undefined") { commands = null; }
                            if (typeof data === "undefined") { data = null; }
                            if (typeof winding === "undefined") { winding = "evenOdd"; }
                            false && _super.call(this);
                            this.commands = commands;
                            this.data = data;
                            this.winding = asCoerceString(winding);
                        }
                        GraphicsPath.classInitializer = null;

                        GraphicsPath.initializer = null;

                        GraphicsPath.classSymbols = null;

                        GraphicsPath.instanceSymbols = null;
                        return GraphicsPath;
                    })(AS.ASNative);
                    display.GraphicsPath = GraphicsPath;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsPathCommand
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GraphicsPathCommand = (function (_super) {
                        __extends(GraphicsPathCommand, _super);
                        function GraphicsPathCommand() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.GraphicsPathCommand");
                        }
                        GraphicsPathCommand.classInitializer = null;

                        GraphicsPathCommand.initializer = null;

                        GraphicsPathCommand.classSymbols = null;

                        GraphicsPathCommand.instanceSymbols = null;

                        GraphicsPathCommand.NO_OP = undefined;
                        GraphicsPathCommand.MOVE_TO = 1;
                        GraphicsPathCommand.LINE_TO = 2;
                        GraphicsPathCommand.CURVE_TO = 3;
                        GraphicsPathCommand.WIDE_MOVE_TO = 4;
                        GraphicsPathCommand.WIDE_LINE_TO = 5;
                        GraphicsPathCommand.CUBIC_CURVE_TO = 6;
                        return GraphicsPathCommand;
                    })(AS.ASNative);
                    display.GraphicsPathCommand = GraphicsPathCommand;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsPathWinding
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GraphicsPathWinding = (function (_super) {
                        __extends(GraphicsPathWinding, _super);
                        function GraphicsPathWinding() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.GraphicsPathWinding");
                        }
                        GraphicsPathWinding.classInitializer = null;

                        GraphicsPathWinding.initializer = null;

                        GraphicsPathWinding.classSymbols = null;

                        GraphicsPathWinding.instanceSymbols = null;

                        GraphicsPathWinding.EVEN_ODD = "evenOdd";
                        GraphicsPathWinding.NON_ZERO = "nonZero";
                        return GraphicsPathWinding;
                    })(AS.ASNative);
                    display.GraphicsPathWinding = GraphicsPathWinding;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsSolidFill
                (function (display) {
                    var GraphicsSolidFill = (function (_super) {
                        __extends(GraphicsSolidFill, _super);
                        function GraphicsSolidFill(color, alpha) {
                            if (typeof color === "undefined") { color = 0; }
                            if (typeof alpha === "undefined") { alpha = 1; }
                            false && _super.call(this);
                            this.color = color >>> 0;
                            this.alpha = +alpha;
                        }
                        GraphicsSolidFill.classInitializer = null;

                        GraphicsSolidFill.initializer = null;

                        GraphicsSolidFill.classSymbols = null;

                        GraphicsSolidFill.instanceSymbols = null;
                        return GraphicsSolidFill;
                    })(AS.ASNative);
                    display.GraphicsSolidFill = GraphicsSolidFill;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsStroke
                (function (display) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var GraphicsStroke = (function (_super) {
                        __extends(GraphicsStroke, _super);
                        function GraphicsStroke(thickness, pixelHinting, scaleMode, caps, joints, miterLimit, fill) {
                            if (typeof thickness === "undefined") { thickness = NaN; }
                            if (typeof pixelHinting === "undefined") { pixelHinting = false; }
                            if (typeof scaleMode === "undefined") { scaleMode = "normal"; }
                            if (typeof caps === "undefined") { caps = "none"; }
                            if (typeof joints === "undefined") { joints = "round"; }
                            if (typeof miterLimit === "undefined") { miterLimit = 3; }
                            if (typeof fill === "undefined") { fill = null; }
                            false && _super.call(this);
                            this.thickness = +thickness;
                            this.pixelHinting = !!pixelHinting;
                            this.scaleMode = asCoerceString(scaleMode);
                            this.caps = asCoerceString(caps);
                            this.joints = asCoerceString(joints);
                            this.miterLimit = +miterLimit;
                            this.fill = fill;
                        }
                        GraphicsStroke.classInitializer = null;

                        GraphicsStroke.initializer = null;

                        GraphicsStroke.classSymbols = null;

                        GraphicsStroke.instanceSymbols = null;
                        return GraphicsStroke;
                    })(AS.ASNative);
                    display.GraphicsStroke = GraphicsStroke;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GraphicsTrianglePath
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var GraphicsTrianglePath = (function (_super) {
                        __extends(GraphicsTrianglePath, _super);
                        function GraphicsTrianglePath(vertices, indices, uvtData, culling) {
                            if (typeof vertices === "undefined") { vertices = null; }
                            if (typeof indices === "undefined") { indices = null; }
                            if (typeof uvtData === "undefined") { uvtData = null; }
                            if (typeof culling === "undefined") { culling = "none"; }
                            vertices = vertices;
                            indices = indices;
                            uvtData = uvtData;
                            culling = asCoerceString(culling);
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.GraphicsTrianglePath");
                        }
                        GraphicsTrianglePath.classInitializer = null;

                        GraphicsTrianglePath.initializer = null;

                        GraphicsTrianglePath.classSymbols = null;

                        GraphicsTrianglePath.instanceSymbols = null;
                        return GraphicsTrianglePath;
                    })(AS.ASNative);
                    display.GraphicsTrianglePath = GraphicsTrianglePath;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IDrawCommand
                (function (display) {
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IGraphicsData
                (function (display) {
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IGraphicsFill
                (function (display) {
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IGraphicsPath
                (function (display) {
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IGraphicsStroke
                (function (display) {
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                // Class: Graphics
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var clamp = Shumway.NumberUtilities.clamp;
                    var Bounds = Shumway.Bounds;
                    var assert = Shumway.Debug.assert;
                    var assertUnreachable = Shumway.Debug.assertUnreachable;

                    var GradientType = flash.display.GradientType;
                    var SpreadMethod = flash.display.SpreadMethod;
                    var InterpolationMethod = flash.display.InterpolationMethod;
                    var LineScaleMode = flash.display.LineScaleMode;
                    var CapsStyle = flash.display.CapsStyle;
                    var JointStyle = flash.display.JointStyle;
                    var PathCommand = Shumway.PathCommand;
                    var ShapeData = Shumway.ShapeData;

                    // TODO duplicate refactor to remove duplication code from GFX geometry.ts
                    //import quadraticBezierExtreme = Shumway.GFX.Geometry.quadraticBezierExtreme;
                    //import cubicBezierExtremes = Shumway.GFX.Geometry.cubicBezierExtremes;
                    function distanceSq(x1, y1, x2, y2) {
                        var dX = x2 - x1;
                        var dY = y2 - y1;
                        return dX * dX + dY * dY;
                    }

                    function quadraticBezier(from, cp, to, t) {
                        var inverseT = 1 - t;
                        return from * inverseT * inverseT + 2 * cp * inverseT * t + to * t * t;
                    }
                    function quadraticBezierExtreme(from, cp, to) {
                        var t = (from - cp) / (from - 2 * cp + to);
                        if (t < 0) {
                            return from;
                        }
                        if (t > 1) {
                            return to;
                        }
                        return quadraticBezier(from, cp, to, t);
                    }
                    function cubicBezier(from, cp, cp2, to, t) {
                        var tSq = t * t;
                        var inverseT = 1 - t;
                        var inverseTSq = inverseT * inverseT;
                        return from * inverseT * inverseTSq + 3 * cp * t * inverseTSq + 3 * cp2 * inverseT * tSq + to * t * tSq;
                    }

                    function cubicBezierExtremes(from, cp, cp2, to) {
                        var d1 = cp - from;
                        var d2 = cp2 - cp;

                        // We only ever need d2 * 2
                        d2 *= 2;
                        var d3 = to - cp2;

                        // Prevent division by zero by very slightly changing d3 if that would happen
                        if (d1 + d3 === d2) {
                            d3 *= 1.0001;
                        }
                        var fHead = 2 * d1 - d2;
                        var part1 = d2 - 2 * d1;
                        var fCenter = Math.sqrt(part1 * part1 - 4 * d1 * (d1 - d2 + d3));
                        var fTail = 2 * (d1 - d2 + d3);
                        var t1 = (fHead + fCenter) / fTail;
                        var t2 = (fHead - fCenter) / fTail;
                        var result = [];
                        if (t1 >= 0 && t1 <= 1) {
                            result.push(cubicBezier(from, cp, cp2, to, t1));
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            result.push(cubicBezier(from, cp, cp2, to, t2));
                        }
                        return result;
                    }

                    function cubicXAtY(x0, y0, cx, cy, cx1, cy1, x1, y1, y) {
                        var dX = 3.0 * (cx - x0);
                        var dY = 3.0 * (cy - y0);

                        var bX = 3.0 * (cx1 - cx) - dX;
                        var bY = 3.0 * (cy1 - cy) - dY;

                        var c3X = x1 - x0 - dX - bX;
                        var c3Y = y1 - y0 - dY - bY;

                        // Find one root - any root - then factor out (t-r) to get a quadratic poly.
                        function f(t) {
                            return t * (dY + t * (bY + t * c3Y)) + y0 - y;
                        }
                        function pointAt(t) {
                            if (t < 0) {
                                t = 0;
                            } else if (t > 1) {
                                t = 1;
                            }

                            return x0 + t * (dX + t * (bX + t * c3X));
                        }

                        // Bisect the specified range to isolate an interval with a root.
                        function bisectCubicBezierRange(f, l, r, limit) {
                            if (Math.abs(r - l) <= limit) {
                                return;
                            }

                            var middle = 0.5 * (l + r);
                            if (f(l) * f(r) <= 0) {
                                left = l;
                                right = r;
                                return;
                            }
                            bisectCubicBezierRange(f, l, middle, limit);
                            bisectCubicBezierRange(f, middle, r, limit);
                        }

                        // some curves that loop around on themselves may require bisection
                        var left = 0;
                        var right = 1;
                        bisectCubicBezierRange(f, 0, 1, 0.05);

                        // experiment with tolerance - but not too tight :)
                        var t0 = findRoot(left, right, f, 50, 0.000001);
                        var evalResult = Math.abs(f(t0));
                        if (evalResult > 0.00001) {
                            return [];
                        }

                        var result = [];
                        if (t0 <= 1) {
                            result.push(pointAt(t0));
                        }

                        // Factor theorem: t-r is a factor of the cubic polynomial if r is a root.
                        // Use this to reduce to a quadratic poly. using synthetic division
                        var a = c3Y;
                        var b = t0 * a + bY;
                        var c = t0 * b + dY;

                        // Process the quadratic for the remaining two possible roots
                        var d = b * b - 4 * a * c;
                        if (d < 0) {
                            return result;
                        }

                        d = Math.sqrt(d);
                        a = 1 / (a + a);
                        var t1 = (d - b) * a;
                        var t2 = (-b - d) * a;

                        if (t1 >= 0 && t1 <= 1) {
                            result.push(pointAt(t1));
                        }

                        if (t2 >= 0 && t2 <= 1) {
                            result.push(pointAt(t2));
                        }

                        return result;
                    }

                    function findRoot(x0, x2, f, maxIterations, epsilon) {
                        var x1;
                        var y0;
                        var y1;
                        var y2;
                        var b;
                        var c;
                        var y10;
                        var y20;
                        var y21;
                        var xm;
                        var ym;
                        var temp;

                        var xmlast = x0;
                        y0 = f(x0);

                        if (y0 === 0) {
                            return x0;
                        }

                        y2 = f(x2);
                        if (y2 === 0) {
                            return x2;
                        }

                        if (y2 * y0 > 0) {
                            // dispatchEvent( new Event(ERROR) );
                            return x0;
                        }

                        var __iter = 0;
                        for (var i = 0; i < maxIterations; ++i) {
                            __iter++;

                            x1 = 0.5 * (x2 + x0);
                            y1 = f(x1);
                            if (y1 === 0) {
                                return x1;
                            }

                            if (Math.abs(x1 - x0) < epsilon) {
                                return x1;
                            }

                            if (y1 * y0 > 0) {
                                temp = x0;
                                x0 = x2;
                                x2 = temp;
                                temp = y0;
                                y0 = y2;
                                y2 = temp;
                            }

                            y10 = y1 - y0;
                            y21 = y2 - y1;
                            y20 = y2 - y0;
                            if (y2 * y20 < 2 * y1 * y10) {
                                x2 = x1;
                                y2 = y1;
                            } else {
                                b = (x1 - x0) / y10;
                                c = (y10 - y21) / (y21 * y20);
                                xm = x0 - b * y0 * (1 - c * y1);
                                ym = f(xm);
                                if (ym === 0) {
                                    return xm;
                                }

                                if (Math.abs(xm - xmlast) < epsilon) {
                                    return xm;
                                }

                                xmlast = xm;
                                if (ym * y0 < 0) {
                                    x2 = xm;
                                    y2 = ym;
                                } else {
                                    x0 = xm;
                                    y0 = ym;
                                    x2 = x1;
                                    y2 = y1;
                                }
                            }
                        }
                        return x1;
                    }

                    // See http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                    function rayIntersectsLine(x, y, x1, y1, x2, y2) {
                        return (y2 > y) !== (y1 > y) && x < (x1 - x2) * (y - y2) / (y1 - y2) + x2;
                    }

                    function rayFullyCrossesCurve(x, y, fromX, fromY, cpX, cpY, toX, toY) {
                        if ((cpY > y) === (fromY > y) && (toY > y) === (fromY > y)) {
                            return false;
                        }
                        if (fromX >= x && cpX >= x && toX >= x) {
                            return true;
                        }

                        // Finding the intersections with our ray means solving a quadratic
                        // equation of the form y = ax^2 + bx + c for y.
                        // See http://en.wikipedia.org/wiki/Quadratic_equation and
                        // http://code.google.com/p/degrafa/source/browse/trunk/Degrafa/com/degrafa/geometry/AdvancedQuadraticBezier.as?r=613#394
                        var a = fromY - 2 * cpY + toY;
                        var c = fromY - y;
                        var b = 2 * (cpY - fromY);

                        var d = b * b - 4 * a * c;
                        if (d < 0) {
                            return false;
                        }

                        d = Math.sqrt(d);
                        a = 1 / (a + a);
                        var t1 = (d - b) * a;
                        var t2 = (-b - d) * a;

                        var crosses = false;
                        if (t1 >= 0 && t1 <= 1 && quadraticBezier(fromX, cpX, toX, t1) > x) {
                            crosses = !crosses;
                        }

                        if (t2 >= 0 && t2 <= 1 && quadraticBezier(fromX, cpX, toX, t2) > x) {
                            crosses = !crosses;
                        }
                        return crosses;
                    }

                    function rayFullyCrossesCubicCurve(x, y, fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY) {
                        var curveStartsAfterY = fromY > y;
                        if ((cpY > y) === curveStartsAfterY && (cp2Y > y) === curveStartsAfterY && (toY > y) === curveStartsAfterY) {
                            return false;
                        }
                        if (fromX < x && cpX < x && cp2X < x && toX < x) {
                            return false;
                        }
                        var crosses = false;
                        var roots = cubicXAtY(fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY, y);
                        for (var i = roots.length; i; i--) {
                            if (roots[i] >= x) {
                                crosses = !crosses;
                            }
                        }
                        return crosses;
                    }

                    // end of GFX geometry.ts
                    var Graphics = (function (_super) {
                        __extends(Graphics, _super);
                        function Graphics() {
                            false && _super.call(this);
                            this._id = flash.display.DisplayObject.getNextSyncID();
                            this._graphicsData = new ShapeData();
                            this._textures = [];
                            this._hasFills = this._hasLines = false;
                            this._fillBounds = new Bounds(0x8000000, 0x8000000, 0x8000000, 0x8000000);
                            this._lineBounds = new Bounds(0x8000000, 0x8000000, 0x8000000, 0x8000000);
                            this._lastX = this._lastY = 0;
                            this._boundsIncludeLastCoordinates = false;
                            this._parent = null;

                            this._topLeftStrokeWidth = this._bottomRightStrokeWidth = 0;
                            this._isDirty = true;
                        }
                        Graphics.FromData = function (data) {
                            var graphics = new flash.display.Graphics();
                            graphics._graphicsData = ShapeData.FromPlainObject(data.shape);
                            graphics._hasFills = data.hasFills;
                            graphics._hasLines = data.hasLines;
                            if (data.lineBounds) {
                                graphics._lineBounds.copyFrom(data.lineBounds);
                                graphics._fillBounds.copyFrom(data.fillBounds || data.lineBounds);
                            }
                            return graphics;
                        };

                        Graphics.prototype.getGraphicsData = function () {
                            return this._graphicsData;
                        };

                        Graphics.prototype.getUsedTextures = function () {
                            return this._textures;
                        };

                        /**
                        * Flash special-cases lines that are 1px and 3px wide.
                        * They're offset by 0.5px to the bottom-right.
                        */
                        Graphics.prototype._setStrokeWidth = function (width) {
                            switch (width) {
                                case 1:
                                    this._topLeftStrokeWidth = 0;
                                    this._bottomRightStrokeWidth = 1;
                                    break;
                                case 3:
                                    this._topLeftStrokeWidth = 1;
                                    this._bottomRightStrokeWidth = 2;
                                    break;
                                default:
                                    var half = Math.ceil(width * 0.5) | 0;
                                    this._topLeftStrokeWidth = half;
                                    this._bottomRightStrokeWidth = half;
                                    break;
                            }
                        };

                        Graphics.prototype._setParent = function (parent) {
                            release || assert(!this._parent);
                            this._parent = parent;
                        };

                        Graphics.prototype._invalidateParent = function () {
                            release || assert(this._parent, "Graphics instances must have a parent.");
                            this._parent._invalidateFillAndLineBounds(true, true);
                            this._parent._setDirtyFlags(4194304 /* DirtyGraphics */);
                        };

                        Graphics.prototype._invalidate = function () {
                            this._invalidateParent();
                            this._isDirty = true;
                        };

                        Graphics.prototype._getContentBounds = function (includeStrokes) {
                            if (typeof includeStrokes === "undefined") { includeStrokes = true; }
                            return includeStrokes ? this._lineBounds : this._fillBounds;
                        };

                        Graphics.prototype.clear = function () {
                            if (this._graphicsData.isEmpty()) {
                                return;
                            }
                            this._graphicsData.clear();
                            this._textures.length = 0;
                            this._fillBounds.setToSentinels();
                            this._lineBounds.setToSentinels();
                            this._lastX = this._lastY = 0;
                            this._boundsIncludeLastCoordinates = false;
                            this._invalidate();
                        };

                        /**
                        * Sets a solid color and opacity as the fill for subsequent drawing commands.
                        *
                        * @see http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/display/Graphics.html#beginFill%28%29
                        * @param color
                        * @param alpha While any Number is a valid input, the value is clamped to [0,1] and then scaled
                        * to an integer in the interval [0,0xff].
                        */
                        Graphics.prototype.beginFill = function (color /*uint*/ , alpha) {
                            if (typeof alpha === "undefined") { alpha = 1; }
                            color = color >>> 0 & 0xffffff;
                            alpha = Math.round(clamp(+alpha, -1, 1) * 0xff) | 0;
                            this._graphicsData.beginFill((color << 8) | alpha);
                            this._hasFills = true;
                        };

                        Graphics.prototype.beginGradientFill = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof spreadMethod === "undefined") { spreadMethod = "pad"; }
                            if (typeof interpolationMethod === "undefined") { interpolationMethod = "rgb"; }
                            if (typeof focalPointRatio === "undefined") { focalPointRatio = 0; }
                            this._writeGradientStyle(2 /* BeginGradientFill */, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, false);
                            this._hasFills = true;
                        };

                        Graphics.prototype.beginBitmapFill = function (bitmap, matrix, repeat, smooth) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof repeat === "undefined") { repeat = true; }
                            if (typeof smooth === "undefined") { smooth = false; }
                            this._writeBitmapStyle(3 /* BeginBitmapFill */, bitmap, matrix, repeat, smooth, false);
                            this._hasFills = true;
                        };

                        Graphics.prototype.endFill = function () {
                            this._graphicsData.endFill();
                        };

                        //    beginShaderFill(shader: flash.display.Shader, matrix: flash.geom.Matrix = null): void {
                        //      //shader = shader; matrix = matrix;
                        //      notImplemented("public flash.display.Graphics::beginShaderFill"); return;
                        //    }
                        Graphics.prototype.lineStyle = function (thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
                            if (typeof color === "undefined") { color = 0; }
                            if (typeof alpha === "undefined") { alpha = 1; }
                            if (typeof pixelHinting === "undefined") { pixelHinting = false; }
                            if (typeof scaleMode === "undefined") { scaleMode = "normal"; }
                            if (typeof caps === "undefined") { caps = null; }
                            if (typeof joints === "undefined") { joints = null; }
                            if (typeof miterLimit === "undefined") { miterLimit = 3; }
                            thickness = +thickness;
                            color = color >>> 0 & 0xffffff;
                            alpha = Math.round(clamp(+alpha, -1, 1) * 0xff);
                            pixelHinting = !!pixelHinting;
                            scaleMode = asCoerceString(scaleMode);
                            caps = asCoerceString(caps);
                            joints = asCoerceString(joints);
                            miterLimit = clamp(+miterLimit | 0, 0, 0xff);

                            // Flash stops drawing strokes whenever a thickness is supplied that can't be coerced to a
                            // number.
                            if (isNaN(thickness)) {
                                this._setStrokeWidth(0);
                                this._graphicsData.endLine();
                                return;
                            }
                            thickness = clamp(+thickness, 0, 0xff) * 20 | 0;
                            this._setStrokeWidth(thickness);

                            // If `scaleMode` is invalid, "normal" is used.
                            var lineScaleMode = LineScaleMode.toNumber(asCoerceString(scaleMode));
                            if (lineScaleMode < 0) {
                                lineScaleMode = LineScaleMode.toNumber(LineScaleMode.NORMAL);
                            }

                            // If `caps` is invalid, "normal" is used.
                            var capsStyle = CapsStyle.toNumber(asCoerceString(caps));
                            if (capsStyle < 0) {
                                capsStyle = CapsStyle.toNumber(CapsStyle.ROUND);
                            }

                            // If `joints` is invalid, "normal" is used.
                            var jointStyle = JointStyle.toNumber(asCoerceString(joints));
                            if (jointStyle < 0) {
                                jointStyle = JointStyle.toNumber(JointStyle.ROUND);
                            }

                            this._graphicsData.lineStyle(thickness, (color << 8) | alpha, pixelHinting, lineScaleMode, capsStyle, jointStyle, miterLimit);
                            this._hasLines = true;
                        };

                        Graphics.prototype.lineGradientStyle = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof spreadMethod === "undefined") { spreadMethod = "pad"; }
                            if (typeof interpolationMethod === "undefined") { interpolationMethod = "rgb"; }
                            if (typeof focalPointRatio === "undefined") { focalPointRatio = 0; }
                            this._writeGradientStyle(6 /* LineStyleGradient */, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, !this._hasLines);
                        };

                        Graphics.prototype.lineBitmapStyle = function (bitmap, matrix, repeat, smooth) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof repeat === "undefined") { repeat = true; }
                            if (typeof smooth === "undefined") { smooth = false; }
                            this._writeBitmapStyle(7 /* LineStyleBitmap */, bitmap, matrix, repeat, smooth, !this._hasLines);
                        };

                        Graphics.prototype.drawRect = function (x, y, width, height) {
                            x = x * 20 | 0;
                            y = y * 20 | 0;
                            var x2 = x + (width * 20 | 0);
                            var y2 = y + (height * 20 | 0);

                            if (x !== this._lastX || y !== this._lastY) {
                                this._graphicsData.moveTo(x, y);
                            }
                            this._graphicsData.lineTo(x2, y);
                            this._graphicsData.lineTo(x2, y2);
                            this._graphicsData.lineTo(x, y2);
                            this._graphicsData.lineTo(x, y);

                            this._extendBoundsByPoint(x2, y2);
                            this._applyLastCoordinates(x, y);

                            this._invalidate();
                        };

                        Graphics.prototype.drawRoundRect = function (x, y, width, height, ellipseWidth, ellipseHeight) {
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            ellipseWidth = +ellipseWidth;
                            ellipseHeight = +ellipseHeight;

                            if (!ellipseHeight || !ellipseWidth) {
                                this.drawRect(x, y, width, height);
                                return;
                            }

                            var radiusX = (ellipseWidth / 2) | 0;
                            var radiusY = (ellipseHeight / 2) | 0;
                            var hw = width / 2;
                            var hh = height / 2;
                            if (radiusX > hw) {
                                radiusX = hw;
                            }
                            if (radiusY > hh) {
                                radiusY = hh;
                            }
                            if (hw === radiusX && hh === radiusY) {
                                if (radiusX === radiusY) {
                                    this.drawCircle(x + radiusX, y + radiusY, radiusX);
                                } else {
                                    this.drawEllipse(x, y, radiusX * 2, radiusY * 2);
                                }
                                return;
                            }

                            //    A-----B
                            //  H         C
                            //  G         D
                            //    F-----E
                            //
                            // Drawing starts and stops at `D`. This is visible when the drawn shape forms part of a
                            // larger shape, with which it is then connected at `D`.
                            var right = x + width;
                            var bottom = y + height;
                            var xlw = x + radiusX;
                            var xrw = right - radiusX;
                            var ytw = y + radiusY;
                            var ybw = bottom - radiusY;
                            this.moveTo(right, ybw);
                            this.curveTo(right, bottom, xrw, bottom);
                            this.lineTo(xlw, bottom);
                            this.curveTo(x, bottom, x, ybw);
                            this.lineTo(x, ytw);
                            this.curveTo(x, y, xlw, y);
                            this.lineTo(xrw, y);
                            this.curveTo(right, y, right, ytw);
                            this.lineTo(right, ybw);
                        };

                        Graphics.prototype.drawRoundRectComplex = function (x, y, width, height, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            topLeftRadius = +topLeftRadius;
                            topRightRadius = +topRightRadius;
                            bottomLeftRadius = +bottomLeftRadius;
                            bottomRightRadius = +bottomRightRadius;

                            if (!(topLeftRadius | topRightRadius | bottomLeftRadius | bottomRightRadius)) {
                                this.drawRect(x, y, width, height);
                                return;
                            }

                            var right = x + width;
                            var bottom = y + height;
                            var xtl = x + topLeftRadius;
                            this.moveTo(right, bottom - bottomRightRadius);
                            this.curveTo(right, bottom, right - bottomRightRadius, bottom);
                            this.lineTo(x + bottomLeftRadius, bottom);
                            this.curveTo(x, bottom, x, bottom - bottomLeftRadius);
                            this.lineTo(x, y + topLeftRadius);
                            this.curveTo(x, y, xtl, y);
                            this.lineTo(right - topRightRadius, y);
                            this.curveTo(right, y, right, y + topRightRadius);
                            this.lineTo(right, bottom - bottomRightRadius);
                        };

                        Graphics.prototype.drawCircle = function (x, y, radius) {
                            // TODO: Implement these using arcs not ellipses. The latter is not
                            // visually correct when the stroke is very thick and the circle is
                            // very small.
                            radius = +radius;
                            this.drawEllipse(+x - radius, +y - radius, radius * 2, radius * 2);
                        };

                        /**
                        * Here x and y are the top-left coordinates of the bounding box of the
                        * ellipse not the center as is the case for circles.
                        */
                        Graphics.prototype.drawEllipse = function (x, y, width, height) {
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;

                            /*
                            *          , - ~ 3 ~ - ,
                            *      , '               ' ,
                            *    ,                       ,
                            *   ,                         ,
                            *  ,                           ,
                            *  2             o             0
                            *  ,                           ,
                            *   ,                         ,
                            *    ,                       ,
                            *      ,                  , '
                            *        ' - , _ 1 _ ,  '
                            */
                            var rx = width / 2;
                            var ry = height / 2;

                            // Move x, y to the middle of the ellipse.
                            x += rx;
                            y += ry;
                            var currentX = x + rx;
                            var currentY = y;
                            this.moveTo(currentX, currentY); // 0
                            var startAngle = 0;
                            var u = 1;
                            var v = 0;
                            for (var i = 0; i < 4; i++) {
                                var endAngle = startAngle + Math.PI / 2;
                                var kappa = (4 / 3) * Math.tan((endAngle - startAngle) / 4);
                                var cp1x = currentX - v * kappa * rx;
                                var cp1y = currentY + u * kappa * ry;
                                u = Math.cos(endAngle);
                                v = Math.sin(endAngle);
                                currentX = x + u * rx;
                                currentY = y + v * ry;
                                var cp2x = currentX + v * kappa * rx;
                                var cp2y = currentY - u * kappa * ry;
                                this.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, currentX, currentY);
                                startAngle = endAngle;
                            }
                        };

                        Graphics.prototype.moveTo = function (x, y) {
                            x = x * 20 | 0;
                            y = y * 20 | 0;

                            this._graphicsData.moveTo(x, y);

                            // Don't use _applyLastCoordinates because that extends the bounds objects, too.
                            this._lastX = x;
                            this._lastY = y;
                            this._boundsIncludeLastCoordinates = false;
                        };

                        Graphics.prototype.lineTo = function (x, y) {
                            x = x * 20 | 0;
                            y = y * 20 | 0;

                            this._graphicsData.lineTo(x, y);
                            this._applyLastCoordinates(x, y);
                            this._invalidate();
                        };

                        Graphics.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
                            controlX = controlX * 20 | 0;
                            controlY = controlY * 20 | 0;
                            anchorX = anchorX * 20 | 0;
                            anchorY = anchorY * 20 | 0;

                            this._graphicsData.curveTo(controlX, controlY, anchorX, anchorY);

                            if (controlX < this._lastX || controlX > anchorX) {
                                this._extendBoundsByX(quadraticBezierExtreme(this._lastX, controlX, anchorX) | 0);
                            }
                            if (controlY < this._lastY || controlY > anchorY) {
                                this._extendBoundsByY(quadraticBezierExtreme(this._lastY, controlY, anchorY) | 0);
                            }
                            this._applyLastCoordinates(anchorX, anchorY);

                            this._invalidate();
                        };

                        Graphics.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
                            controlX1 = controlX1 * 20 | 0;
                            controlY1 = controlY1 * 20 | 0;
                            controlX2 = controlX2 * 20 | 0;
                            controlY2 = controlY2 * 20 | 0;
                            anchorX = anchorX * 20 | 0;
                            anchorY = anchorY * 20 | 0;

                            this._graphicsData.cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY);

                            var extremes;
                            var i;
                            var fromX = this._lastX;
                            var fromY = this._lastY;
                            if (controlX1 < fromX || controlX2 < fromX || controlX1 > anchorX || controlX2 > anchorX) {
                                extremes = cubicBezierExtremes(fromX, controlX1, controlX2, anchorX);
                                for (i = extremes.length; i; i--) {
                                    this._extendBoundsByX(extremes[i] | 0);
                                }
                            }
                            if (controlY1 < fromY || controlY2 < fromY || controlY1 > anchorY || controlY2 > anchorY) {
                                extremes = cubicBezierExtremes(fromY, controlY1, controlY2, anchorY);
                                for (i = extremes.length; i; i--) {
                                    this._extendBoundsByY(extremes[i] | 0);
                                }
                            }
                            this._applyLastCoordinates(anchorX, anchorY);

                            this._invalidate();
                        };

                        Graphics.prototype.copyFrom = function (sourceGraphics) {
                            this._graphicsData = sourceGraphics._graphicsData.clone();
                            this._fillBounds = sourceGraphics._fillBounds.clone();
                            this._lineBounds = sourceGraphics._lineBounds.clone();
                            this._textures = sourceGraphics._textures.concat();
                            this._lastX = sourceGraphics._lastX;
                            this._lastY = sourceGraphics._lastY;
                            this._boundsIncludeLastCoordinates = sourceGraphics._boundsIncludeLastCoordinates;
                            this._invalidate();
                        };

                        //    lineShaderStyle(shader: flash.display.Shader, matrix: flash.geom.Matrix = null): void {
                        //      //shader = shader; matrix = matrix;
                        //      notImplemented("public flash.display.Graphics::lineShaderStyle"); return;
                        //    }
                        Graphics.prototype.drawPath = function (commands, data, winding) {
                            if (typeof winding === "undefined") { winding = "evenOdd"; }
                            commands = commands;
                            data = data;
                            winding = asCoerceString(winding);
                            notImplemented("public flash.display.Graphics::drawPath");
                            return;
                        };

                        Graphics.prototype.drawTriangles = function (vertices, indices, uvtData, culling) {
                            if (typeof indices === "undefined") { indices = null; }
                            if (typeof uvtData === "undefined") { uvtData = null; }
                            if (typeof culling === "undefined") { culling = "none"; }
                            vertices = vertices;
                            indices = indices;
                            uvtData = uvtData;
                            culling = asCoerceString(culling);
                            notImplemented("public flash.display.Graphics::drawTriangles");
                            return;
                        };

                        Graphics.prototype.drawGraphicsData = function (graphicsData) {
                            graphicsData = graphicsData;
                            notImplemented("public flash.display.Graphics::drawGraphicsData");
                            return;
                        };

                        /**
                        * Tests if the specified point is within this graphics path.
                        */
                        Graphics.prototype._containsPoint = function (x, y, includeLines) {
                            var hasLines = this._hasLines;
                            if (!(includeLines && hasLines ? this._lineBounds : this._fillBounds).contains(x, y)) {
                                return false;
                            }

                            //      enterTimeline("Graphics._containsPoint");
                            var containsPoint = false;

                            // If we have any fills at all, tt's vastly more likely that the point is in a fill,
                            // so test that first.
                            if (this._hasFills) {
                                containsPoint = this._fillContainsPoint(x, y);
                            } else {
                                release || assert(hasLines, "Can't have non-empty bounds without line or fill set.");
                            }
                            if (!containsPoint && includeLines) {
                                containsPoint = this._linesContainsPoint(x, y);
                            }

                            //      leaveTimeline();
                            return containsPoint;
                        };

                        Graphics.prototype._fillContainsPoint = function (x, y) {
                            //      enterTimeline("Graphics._fillContainsPoint");
                            var data = this._graphicsData;
                            var commands = data.commands;
                            var commandsCount = data.commandsPosition;
                            var coordinates = data.coordinates;
                            var coordinatesIndex = 0;

                            var fromX = 0;
                            var fromY = 0;
                            var toX = 0;
                            var toY = 0;
                            var cpX;
                            var cpY;
                            var formOpen = false;
                            var fillActive = false;
                            var formOpenX = 0;
                            var formOpenY = 0;
                            var inside = false;

                            for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                                var command = commands[commandIndex];
                                switch (command) {
                                    case 9 /* MoveTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                        if (formOpen && fillActive && rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                            inside = !inside;
                                        }
                                        formOpen = true;
                                        fromX = formOpenX = coordinates[coordinatesIndex++];
                                        fromY = formOpenY = coordinates[coordinatesIndex++];

                                        continue;
                                    case 10 /* LineTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                        toX = coordinates[coordinatesIndex++];
                                        toY = coordinates[coordinatesIndex++];
                                        if (fillActive && rayIntersectsLine(x, y, fromX, fromY, toX, toY)) {
                                            inside = !inside;
                                        }
                                        break;
                                    case 11 /* CurveTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                                        cpX = coordinates[coordinatesIndex++];
                                        cpY = coordinates[coordinatesIndex++];
                                        toX = coordinates[coordinatesIndex++];
                                        toY = coordinates[coordinatesIndex++];
                                        if (fillActive && rayFullyCrossesCurve(x, y, fromX, fromY, cpX, cpY, toX, toY)) {
                                            inside = !inside;
                                        }
                                        break;
                                    case 12 /* CubicCurveTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                                        cpX = coordinates[coordinatesIndex++];
                                        cpY = coordinates[coordinatesIndex++];
                                        var cp2X = coordinates[coordinatesIndex++];
                                        var cp2Y = coordinates[coordinatesIndex++];
                                        toX = coordinates[coordinatesIndex++];
                                        toY = coordinates[coordinatesIndex++];
                                        if (fillActive && rayFullyCrossesCubicCurve(x, y, fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY)) {
                                            inside = !inside;
                                        }
                                        break;
                                    case 1 /* BeginSolidFill */:
                                    case 2 /* BeginGradientFill */:
                                    case 3 /* BeginBitmapFill */:
                                    case 4 /* EndFill */:
                                        if (formOpen && fillActive && rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                            inside = !inside;
                                        }
                                        formOpen = false;
                                        fillActive = command !== 4 /* EndFill */;
                                        break;
                                    case 5 /* LineStyleSolid */:
                                        coordinatesIndex++; // Skip thickness
                                        break;
                                    case 6 /* LineStyleGradient */:
                                    case 7 /* LineStyleBitmap */:
                                    case 8 /* LineEnd */:
                                        break;
                                    default:
                                        release || assertUnreachable('Invalid command ' + command + ' encountered at index' + (commandIndex - 1) + ' of ' + commandsCount);
                                }
                                fromX = toX;
                                fromY = toY;
                            }
                            release || assert(commandIndex === commandsCount);
                            release || assert(coordinatesIndex === data.coordinatesPosition);
                            if (formOpen && fillActive && rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                inside = !inside;
                            }

                            //      leaveTimeline();
                            return inside;
                        };

                        Graphics.prototype._linesContainsPoint = function (x, y) {
                            //      enterTimeline("Graphics._lineContainsPoint");
                            var data = this._graphicsData;
                            var commands = data.commands;
                            var commandsCount = data.commandsPosition;
                            var coordinates = data.coordinates;
                            var coordinatesIndex = 0;

                            var fromX = 0;
                            var fromY = 0;
                            var toX = 0;
                            var toY = 0;
                            var cpX;
                            var cpY;
                            var curveX;
                            var curveY;
                            var t;

                            var width = 0;
                            var halfWidth = 0;
                            var halfWidthSq = 0;
                            var minX = 0;
                            var maxX = 0;
                            var minY = 0;
                            var maxY = 0;

                            for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                                var command = commands[commandIndex];
                                switch (command) {
                                    case 9 /* MoveTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                        fromX = coordinates[coordinatesIndex++];
                                        fromY = coordinates[coordinatesIndex++];

                                        continue;
                                    case 10 /* LineTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                        if (width === 0) {
                                            fromX = coordinates[coordinatesIndex++];
                                            fromX = coordinates[coordinatesIndex++];
                                            continue;
                                        }
                                        toX = coordinates[coordinatesIndex++];
                                        toY = coordinates[coordinatesIndex++];

                                        // Lines with length == 0 aren't rendered.
                                        if (fromX === toX && fromY === toY) {
                                            break;
                                        }

                                        // Eliminate based on bounds.
                                        if (maxX < fromX && maxX < toX || minX > fromX && minX > toX || maxY < fromY && maxY < toY || minY > fromY && minY > toY) {
                                            break;
                                        }

                                        // Vertical and horizontal lines are a certain hit at this point
                                        if (toX === fromX || toY === fromY) {
                                            return true;
                                        }

                                        // http://stackoverflow.com/a/1501725/517791
                                        t = ((x - fromX) * (toX - fromX) + (y - fromY) * (toY - fromY)) / distanceSq(fromX, fromY, toX, toY);
                                        if (t < 0) {
                                            if (distanceSq(x, y, fromX, fromY) <= halfWidthSq) {
                                                return true;
                                            }
                                            break;
                                        }
                                        if (t > 1) {
                                            if (distanceSq(x, y, toX, toY) <= halfWidthSq) {
                                                return true;
                                            }
                                            break;
                                        }
                                        if (distanceSq(x, y, fromX + t * (toX - fromX), fromY + t * (toY - fromY)) <= halfWidthSq) {
                                            return true;
                                        }
                                        break;
                                    case 11 /* CurveTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                                        if (width === 0) {
                                            coordinatesIndex += 2;
                                            fromX = coordinates[coordinatesIndex++];
                                            fromX = coordinates[coordinatesIndex++];
                                            continue;
                                        }
                                        cpX = coordinates[coordinatesIndex++];
                                        cpY = coordinates[coordinatesIndex++];
                                        toX = coordinates[coordinatesIndex++];
                                        toY = coordinates[coordinatesIndex++];

                                        // Eliminate based on bounds
                                        var extremeX = quadraticBezierExtreme(fromX, cpX, toX);
                                        if (maxX < fromX && maxX < extremeX && maxX < toX || minX > fromX && minX > extremeX && minX > toX) {
                                            break;
                                        }
                                        var extremeY = quadraticBezierExtreme(fromY, cpY, toY);
                                        if (maxY < fromY && maxY < extremeY && maxY < toY || minY > fromY && minY > extremeY && minY > toY) {
                                            break;
                                        }

                                        for (t = 0; t < 1; t += 0.02) {
                                            curveX = quadraticBezier(fromX, cpX, toX, t);
                                            if (curveX < minX || curveX > maxX) {
                                                continue;
                                            }
                                            curveY = quadraticBezier(fromY, cpY, toY, t);
                                            if (curveY < minY || curveY > maxY) {
                                                continue;
                                            }
                                            if ((x - curveX) * (x - curveX) + (y - curveY) * (y - curveY) < halfWidthSq) {
                                                return true;
                                            }
                                        }
                                        break;
                                    case 12 /* CubicCurveTo */:
                                        release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                                        if (width === 0) {
                                            coordinatesIndex += 4;
                                            fromX = coordinates[coordinatesIndex++];
                                            fromX = coordinates[coordinatesIndex++];
                                            continue;
                                        }
                                        cpX = coordinates[coordinatesIndex++];
                                        cpY = coordinates[coordinatesIndex++];
                                        var cp2X = coordinates[coordinatesIndex++];
                                        var cp2Y = coordinates[coordinatesIndex++];
                                        toX = coordinates[coordinatesIndex++];
                                        toY = coordinates[coordinatesIndex++];

                                        // Eliminate based on bounds
                                        var extremesX = cubicBezierExtremes(fromX, cpX, cp2X, toX);
                                        while (extremesX.length < 2) {
                                            extremesX.push(toX);
                                        }
                                        if (maxX < fromX && maxX < toX && maxX < extremesX[0] && maxX < extremesX[1] || minX > fromX && minX > toX && minX > extremesX[0] && minX > extremesX[1]) {
                                            break;
                                        }
                                        var extremesY = cubicBezierExtremes(fromY, cpY, cp2Y, toY);
                                        while (extremesY.length < 2) {
                                            extremesY.push(toY);
                                        }
                                        if (maxY < fromY && maxY < toY && maxY < extremesY[0] && maxY < extremesY[1] || minY > fromY && minY > toY && minY > extremesY[0] && minY > extremesY[1]) {
                                            break;
                                        }

                                        for (t = 0; t < 1; t += 0.02) {
                                            curveX = cubicBezier(fromX, cpX, cp2X, toX, t);
                                            if (curveX < minX || curveX > maxX) {
                                                continue;
                                            }
                                            curveY = cubicBezier(fromY, cpY, cp2Y, toY, t);
                                            if (curveY < minY || curveY > maxY) {
                                                continue;
                                            }
                                            if ((x - curveX) * (x - curveX) + (y - curveY) * (y - curveY) < halfWidthSq) {
                                                return true;
                                            }
                                        }
                                        break;
                                    case 5 /* LineStyleSolid */:
                                        width = coordinates[++coordinatesIndex] * 20;
                                        halfWidth = width >> 2;
                                        halfWidthSq = halfWidth * halfWidth;
                                        minX = x - halfWidth;
                                        maxX = x + halfWidth;
                                        minY = y - halfWidth;
                                        maxY = y + halfWidth;
                                        break;
                                    case 1 /* BeginSolidFill */:
                                    case 2 /* BeginGradientFill */:
                                    case 3 /* BeginBitmapFill */:
                                    case 4 /* EndFill */:
                                    case 6 /* LineStyleGradient */:
                                    case 7 /* LineStyleBitmap */:
                                    case 8 /* LineEnd */:
                                        break;
                                    default:
                                        release || assertUnreachable('Invalid command ' + command + ' encountered at index' + (commandIndex - 1) + ' of ' + commandsCount);
                                }
                                fromX = toX;
                                fromY = toY;
                            }
                            release || assert(commandIndex === commandsCount);
                            release || assert(coordinatesIndex === data.coordinatesPosition);

                            //      leaveTimeline();
                            return false;
                        };

                        /**
                        * Bitmaps are specified the same for fills and strokes, so we only need to serialize them
                        * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
                        * be one of PathCommand.BeginBitmapFill and PathCommand.LineStyleBitmap.
                        *
                        * This method doesn't actually write anything if the `skipWrite` argument is true. In that
                        * case, it only does arguments checks so the right exceptions are thrown.
                        */
                        Graphics.prototype._writeBitmapStyle = function (pathCommand, bitmap, matrix, repeat, smooth, skipWrite) {
                            if (Shumway.isNullOrUndefined(bitmap)) {
                                throwError('TypeError', AVM2.Errors.NullPointerError, 'bitmap');
                            } else if (!(flash.display.BitmapData.isType(bitmap))) {
                                throwError('TypeError', AVM2.Errors.CheckTypeFailedError, 'bitmap', 'flash.display.BitmapData');
                            }
                            if (Shumway.isNullOrUndefined(matrix)) {
                                matrix = flash.geom.Matrix.FROZEN_IDENTITY_MATRIX;
                            } else if (!(flash.geom.Matrix.isType(matrix))) {
                                throwError('TypeError', AVM2.Errors.CheckTypeFailedError, 'matrix', 'flash.geom.Matrix');
                            }
                            repeat = !!repeat;
                            smooth = !!smooth;

                            if (skipWrite) {
                                return;
                            }

                            var index = this._textures.length;
                            this._textures.push(bitmap);
                            this._graphicsData.beginBitmap(pathCommand, index, matrix, repeat, smooth);
                        };

                        /**
                        * Gradients are specified the same for fills and strokes, so we only need to serialize them
                        * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
                        * be one of PathCommand.BeginGradientFill and PathCommand.LineStyleGradient.
                        *
                        * This method doesn't actually write anything if the `skipWrite` argument is true. In that
                        * case, it only does arguments checks so the right exceptions are thrown.
                        */
                        Graphics.prototype._writeGradientStyle = function (pathCommand, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, skipWrite) {
                            if (Shumway.isNullOrUndefined(type)) {
                                throwError('TypeError', AVM2.Errors.NullPointerError, 'type');
                            }
                            var gradientType = GradientType.toNumber(asCoerceString(type));
                            if (gradientType < 0) {
                                throwError("ArgumentError", AVM2.Errors.InvalidEnumError, "type");
                            }

                            if (Shumway.isNullOrUndefined(colors)) {
                                throwError('TypeError', AVM2.Errors.NullPointerError, 'colors');
                            }
                            if (!(colors instanceof Array)) {
                                throwError('TypeError', AVM2.Errors.CheckTypeFailedError, 'colors', 'Array');
                            }

                            if (!(alphas instanceof Array)) {
                                throwError('TypeError', AVM2.Errors.CheckTypeFailedError, 'alphas', 'Array');
                            }
                            if (Shumway.isNullOrUndefined(alphas)) {
                                throwError('TypeError', AVM2.Errors.NullPointerError, 'alphas');
                            }

                            if (!(ratios instanceof Array)) {
                                throwError('TypeError', AVM2.Errors.CheckTypeFailedError, 'ratios', 'Array');
                            }
                            if (Shumway.isNullOrUndefined(ratios)) {
                                throwError('TypeError', AVM2.Errors.NullPointerError, 'ratios');
                            }

                            var colorsRGBA = [];
                            var coercedRatios = [];
                            var colorStops = colors.length;
                            var recordsValid = colorStops === alphas.length && colorStops === ratios.length;
                            if (recordsValid) {
                                for (var i = 0; i < colorStops; i++) {
                                    var ratio = +ratios[i];
                                    if (ratio > 0xff || ratio < 0) {
                                        recordsValid = false;
                                        break;
                                    }
                                    colorsRGBA[i] = (colors[i] << 8 & 0xffffff00) | clamp(+alphas[i], 0, 1) * 0xff;
                                    coercedRatios[i] = ratio;
                                }
                            }

                            // If the colors, alphas and ratios arrays don't all have the same length or if any of the
                            // given ratios falls outside [0,0xff], Flash just ignores the gradient style.
                            if (!recordsValid) {
                                return;
                            }

                            if (Shumway.isNullOrUndefined(matrix)) {
                                matrix = flash.geom.Matrix.FROZEN_IDENTITY_MATRIX;
                            } else if (!(flash.geom.Matrix.isType(matrix))) {
                                throwError('TypeError', AVM2.Errors.CheckTypeFailedError, 'matrix', 'flash.geom.Matrix');
                            }

                            if (skipWrite) {
                                return;
                            }

                            // If `spreadMethod` is invalid, "pad" is used.
                            var spread = SpreadMethod.toNumber(asCoerceString(spreadMethod));
                            if (spread < 0) {
                                spread = SpreadMethod.toNumber(SpreadMethod.PAD);
                            }

                            // If `interpolationMethod` is invalid, "rgb" is used.
                            var interpolation = InterpolationMethod.toNumber(asCoerceString(interpolationMethod));
                            if (interpolation < 0) {
                                interpolation = InterpolationMethod.toNumber(InterpolationMethod.RGB);
                            }

                            // Focal point is scaled by 0xff, divided by 2, rounded and stored as a signed short.
                            focalPointRatio = clamp(+focalPointRatio, -1, 1) / 2 * 0xff | 0;
                            this._graphicsData.beginGradient(pathCommand, colorsRGBA, coercedRatios, gradientType, matrix, spread, interpolation, focalPointRatio);
                        };

                        Graphics.prototype._extendBoundsByPoint = function (x, y) {
                            this._extendBoundsByX(x);
                            this._extendBoundsByY(y);
                        };

                        Graphics.prototype._extendBoundsByX = function (x) {
                            this._fillBounds.extendByX(x);

                            var bounds = this._lineBounds;
                            if (bounds.xMin === 0x8000000) {
                                bounds.xMin = x - this._topLeftStrokeWidth;
                                bounds.xMax = x + this._bottomRightStrokeWidth;
                            } else {
                                bounds.xMin = Math.min(x - this._topLeftStrokeWidth, bounds.xMin);
                                bounds.xMax = Math.max(x + this._bottomRightStrokeWidth, bounds.xMax);
                            }
                        };

                        Graphics.prototype._extendBoundsByY = function (y) {
                            this._fillBounds.extendByY(y);

                            var bounds = this._lineBounds;
                            if (bounds.yMin === 0x8000000) {
                                bounds.yMin = y - this._topLeftStrokeWidth;
                                bounds.yMax = y + this._bottomRightStrokeWidth;
                            } else {
                                bounds.yMin = Math.min(y - this._topLeftStrokeWidth, bounds.yMin);
                                bounds.yMax = Math.max(y + this._bottomRightStrokeWidth, bounds.yMax);
                            }
                        };

                        Graphics.prototype._applyLastCoordinates = function (x, y) {
                            if (!this._boundsIncludeLastCoordinates) {
                                this._extendBoundsByPoint(this._lastX, this._lastY);
                            }
                            this._boundsIncludeLastCoordinates = true;
                            this._lastX = x;
                            this._lastY = y;
                            this._extendBoundsByPoint(x, y);
                        };
                        Graphics.classInitializer = null;
                        Graphics.initializer = null;

                        Graphics.classSymbols = null;
                        Graphics.instanceSymbols = null;
                        return Graphics;
                    })(AS.ASNative);
                    display.Graphics = Graphics;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Sprite
                (function (display) {
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Sprite = (function (_super) {
                        __extends(Sprite, _super);
                        function Sprite() {
                            false && _super.call(this);
                            display.DisplayObjectContainer.instanceConstructorNoInitialize.call(this);
                            this._constructChildren();
                        }
                        Sprite.prototype._initializeChildren = function (frame) {
                            for (var depth in frame.stateAtDepth) {
                                var state = frame.stateAtDepth[depth];
                                if (state) {
                                    var character = display.DisplayObject.createAnimatedDisplayObject(state, false);
                                    this.addChildAtDepth(character, state.depth);
                                    if (state.symbol.isAS2Object) {
                                        this._initAvm1Bindings(character, state);
                                    }
                                }
                            }
                        };

                        Sprite.prototype._initAvm1Bindings = function (instance, state) {
                            var instanceAS2Object = Shumway.AVM1.getAS2Object(instance);
                            assert(instanceAS2Object);

                            if (state.variableName) {
                                instanceAS2Object.asSetPublicProperty('variable', state.variableName);
                            }

                            var events = state.events;
                            if (events) {
                                var eventsBound = [];
                                for (var i = 0; i < events.length; i++) {
                                    var event = events[i];
                                    var eventNames = event.eventNames;
                                    var fn = event.handler.bind(instance);
                                    for (var j = 0; j < eventNames.length; j++) {
                                        var eventName = eventNames[j];
                                        var avm2EventTarget = instance;
                                        if (eventName === 'mouseDown' || eventName === 'mouseUp' || eventName === 'mouseMove') {
                                            avm2EventTarget = instance.stage;
                                        }
                                        avm2EventTarget.addEventListener(eventName, fn, false);
                                        eventsBound.push({ eventName: eventName, fn: fn, target: avm2EventTarget });
                                    }
                                }
                                if (eventsBound.length > 0) {
                                    instance.addEventListener('removed', function (eventsBound) {
                                        for (var i = 0; i < eventsBound.length; i++) {
                                            eventsBound[i].target.removeEventListener(eventsBound[i].eventName, eventsBound[i].fn, false);
                                        }
                                    }.bind(instance, eventsBound), false);
                                }
                            }

                            // Only set the name property for display objects that have AS2
                            // reflections. Some SWFs contain AS2 names for things like Shapes.
                            if (state.name) {
                                var parentAS2Object = Shumway.AVM1.getAS2Object(this);
                                parentAS2Object.asSetPublicProperty(state.name, instanceAS2Object);
                            }
                        };

                        Sprite.prototype._canHaveGraphics = function () {
                            return true;
                        };

                        Sprite.prototype._getGraphics = function () {
                            return this._graphics;
                        };

                        Object.defineProperty(Sprite.prototype, "graphics", {
                            get: function () {
                                return this._ensureGraphics();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Sprite.prototype, "buttonMode", {
                            get: function () {
                                return this._buttonMode;
                            },
                            set: function (value) {
                                this._buttonMode = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Sprite.prototype, "dropTarget", {
                            get: function () {
                                notImplemented("public flash.display.Sprite::get dropTarget");
                                return;
                                // return this._dropTarget;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Sprite.prototype, "hitArea", {
                            get: function () {
                                return this._hitArea;
                            },
                            set: function (value) {
                                value = value;
                                if (this._hitArea === value) {
                                    return;
                                }
                                if (value && value._hitTarget) {
                                    value._hitTarget._hitArea = null;
                                }
                                this._hitArea = value;
                                if (value) {
                                    value._hitTarget = this;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Sprite.prototype, "useHandCursor", {
                            get: function () {
                                return this._useHandCursor;
                            },
                            set: function (value) {
                                this._useHandCursor = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Sprite.prototype, "soundTransform", {
                            get: function () {
                                notImplemented("public flash.display.Sprite::get soundTransform");
                                return;
                                // return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                sndTransform = sndTransform;
                                notImplemented("public flash.display.Sprite::set soundTransform");
                                return;
                                // this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Sprite.prototype.startDrag = function (lockCenter, bounds) {
                            if (typeof lockCenter === "undefined") { lockCenter = false; }
                            if (typeof bounds === "undefined") { bounds = null; }
                            lockCenter = !!lockCenter;
                            bounds = bounds;
                            notImplemented("public flash.display.Sprite::startDrag");
                            return;
                        };
                        Sprite.prototype.stopDrag = function () {
                            notImplemented("public flash.display.Sprite::stopDrag");
                            return;
                        };
                        Sprite.prototype.startTouchDrag = function (touchPointID /*int*/ , lockCenter, bounds) {
                            if (typeof lockCenter === "undefined") { lockCenter = false; }
                            if (typeof bounds === "undefined") { bounds = null; }
                            touchPointID = touchPointID | 0;
                            lockCenter = !!lockCenter;
                            bounds = bounds;
                            notImplemented("public flash.display.Sprite::startTouchDrag");
                            return;
                        };
                        Sprite.prototype.stopTouchDrag = function (touchPointID /*int*/ ) {
                            touchPointID = touchPointID | 0;
                            notImplemented("public flash.display.Sprite::stopTouchDrag");
                            return;
                        };
                        Sprite.classInitializer = null;

                        Sprite.initializer = function (symbol) {
                            var self = this;

                            self._graphics = null;
                            self._buttonMode = false;
                            self._dropTarget = null;
                            self._hitArea = null;
                            self._useHandCursor = true;

                            self._hitTarget = null;

                            if (symbol) {
                                if (symbol.isRoot) {
                                    self._root = self;
                                }
                                if (symbol.numFrames) {
                                    release || assert(symbol.frames.length >= 1, "Sprites have at least one frame.");
                                    var frame = symbol.frames[0];
                                    release || assert(frame, "Initial frame is not defined.");
                                    self._initializeChildren(frame);
                                }
                            }
                        };

                        Sprite.classSymbols = null;

                        Sprite.instanceSymbols = null;
                        return Sprite;
                    })(flash.display.DisplayObjectContainer);
                    display.Sprite = Sprite;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MovieClip
                (function (display) {
                    var assert = Shumway.Debug.assert;
                    var assertUnreachable = Shumway.Debug.assertUnreachable;

                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var throwError = Shumway.AVM2.Runtime.throwError;

                    var Telemetry = Shumway.Telemetry;

                    var Multiname = Shumway.AVM2.ABC.Multiname;

                    var MovieClipSoundsManager = (function () {
                        function MovieClipSoundsManager(mc) {
                            this._mc = mc;
                            this._startSoundRegistrations = null;
                            this._soundStream = null;
                        }
                        MovieClipSoundsManager.prototype.registerStartSounds = function (frameNum, soundStartInfo) {
                            if (this._startSoundRegistrations === null) {
                                this._startSoundRegistrations = {};
                            }
                            this._startSoundRegistrations[frameNum] = soundStartInfo;
                        };

                        MovieClipSoundsManager.prototype.initSoundStream = function (streamInfo) {
                            this._soundStream = new display.MovieClipSoundStream(streamInfo, this._mc);
                        };

                        MovieClipSoundsManager.prototype.addSoundStreamBlock = function (frameNum, streamBlock) {
                            this._soundStream.appendBlock(frameNum, streamBlock);
                        };

                        MovieClipSoundsManager.prototype._startSounds = function (frameNum) {
                            var starts = this._startSoundRegistrations[frameNum];
                            if (starts) {
                                var sounds = this._soundClips || (this._soundClips = {});
                                var loaderInfo = this._mc.loaderInfo;
                                for (var i = 0; i < starts.length; i++) {
                                    var start = starts[i];
                                    var symbolId = start.soundId;
                                    var info = start.soundInfo;
                                    var sound = sounds[symbolId];
                                    if (!sound) {
                                        var symbolInfo = loaderInfo.getSymbolById(symbolId);
                                        if (!symbolInfo) {
                                            continue;
                                        }

                                        var symbolClass = symbolInfo.symbolClass;
                                        var soundObj = symbolClass.initializeFrom(symbolInfo);
                                        symbolClass.instanceConstructorNoInitialize.call(soundObj);
                                        sounds[symbolId] = sound = { object: soundObj };
                                    }
                                    if (sound.channel) {
                                        sound.channel.stop();
                                        sound.channel = null;
                                    }
                                    if (!info.stop) {
                                        // TODO envelope, in/out point
                                        var loops = info.hasLoops ? info.loopCount : 0;
                                        sound.channel = sound.object.play(0, loops);
                                    }
                                }
                            }
                        };

                        MovieClipSoundsManager.prototype.syncSounds = function (frameNum) {
                            if (this._startSoundRegistrations !== null) {
                                this._startSounds(frameNum);
                            }
                            if (this._soundStream) {
                                this._soundStream.playFrame(frameNum);
                            }
                        };
                        return MovieClipSoundsManager;
                    })();

                    var MovieClip = (function (_super) {
                        __extends(MovieClip, _super);
                        function MovieClip() {
                            false && _super.call(this);
                            display.Sprite.instanceConstructorNoInitialize.call(this);
                        }
                        MovieClip.reset = function () {
                            MovieClip._callQueue = [];
                        };

                        MovieClip.runFrameScripts = function () {
                            AVM2.enterTimeline("MovieClip.executeFrame");
                            var queue = MovieClip._callQueue.concat();
                            MovieClip._callQueue.length = 0;
                            for (var i = 0; i < queue.length; i++) {
                                var instance = queue[i];

                                instance._allowFrameNavigation = false;
                                instance.callFrame(instance._currentFrame);
                                instance._allowFrameNavigation = true;

                                // Frame navigation is only triggered if the MovieClip is on stage.
                                if (instance._nextFrame !== instance._currentFrame && instance.stage) {
                                    display.DisplayObject.performFrameNavigation(instance.stage, false, true);
                                }
                            }
                            AVM2.leaveTimeline();
                        };

                        MovieClip.prototype._setParent = function (parent, depth) {
                            _super.prototype._setParent.call(this, parent, depth);
                            if (parent && this._hasAnyFlags(4096 /* HasFrameScriptPending */ | 8192 /* ContainsFrameScriptPendingChildren */)) {
                                parent._propagateFlagsUp(8192 /* ContainsFrameScriptPendingChildren */);
                            }
                        };

                        MovieClip.prototype._initFrame = function (advance) {
                            if (advance && this.buttonMode) {
                                var state = null;
                                if (this._mouseOver) {
                                    state = this._mouseDown ? '_down' : '_over';
                                } else if (this._currentButtonState !== null) {
                                    state = '_up';
                                }
                                if (state !== this._currentButtonState && this._buttonFrames[state]) {
                                    this.stop();
                                    this._gotoFrame(state, null);
                                    this._currentButtonState = state;
                                    this._advanceFrame();
                                    return;
                                }
                            }
                            if (advance) {
                                if (this._totalFrames > 1 && !this._stopped && this._hasFlags(256 /* Constructed */)) {
                                    this._nextFrame++;
                                }
                            }
                            this._advanceFrame();
                        };

                        MovieClip.prototype._constructFrame = function () {
                            this._constructChildren();
                        };

                        MovieClip.prototype._enqueueFrameScripts = function () {
                            if (this._hasFlags(4096 /* HasFrameScriptPending */)) {
                                this._removeFlags(4096 /* HasFrameScriptPending */);
                                MovieClip._callQueue.push(this);
                            }
                            _super.prototype._enqueueFrameScripts.call(this);
                        };

                        Object.defineProperty(MovieClip.prototype, "currentFrame", {
                            get: function () {
                                return this._currentFrame - this._sceneForFrameIndex(this._currentFrame).offset;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "framesLoaded", {
                            get: function () {
                                return this._frames.length;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "totalFrames", {
                            get: function () {
                                return this._totalFrames;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "trackAsMenu", {
                            get: function () {
                                return this._trackAsMenu;
                            },
                            set: function (value) {
                                this._trackAsMenu = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(MovieClip.prototype, "scenes", {
                            get: function () {
                                return this._scenes.map(function (scene) {
                                    return scene.clone();
                                });
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "currentScene", {
                            get: function () {
                                var scene = this._sceneForFrameIndex(this._currentFrame);
                                return scene.clone();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "currentLabel", {
                            get: function () {
                                var label = this._labelForFrame(this.currentFrame);
                                return label ? label.name : null;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "currentFrameLabel", {
                            get: function () {
                                var currentFrame = this.currentFrame;
                                var label = this._labelForFrame(currentFrame);
                                return label && label.frame === currentFrame ? label.name : null;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(MovieClip.prototype, "enabled", {
                            get: function () {
                                return this._enabled;
                            },
                            set: function (value) {
                                this._enabled = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(MovieClip.prototype, "isPlaying", {
                            get: function () {
                                return this._isPlaying;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        MovieClip.prototype.play = function () {
                            if (this._totalFrames > 1) {
                                this._isPlaying = true;
                            }
                            this._stopped = false;
                        };

                        MovieClip.prototype.stop = function () {
                            this._isPlaying = false;
                            this._stopped = true;
                        };

                        /**
                        * Implementation for both gotoAndPlay and gotoAndStop.
                        *
                        * Technically, we should throw all errors from those functions directly so the stack is
                        * correct.
                        * We might at some point do that by explicitly inlining this function using some build step.
                        */
                        MovieClip.prototype._gotoFrame = function (frame, sceneName) {
                            var scene;
                            if (sceneName !== null) {
                                sceneName = asCoerceString(sceneName);
                                var scenes = this._scenes;
                                release || assert(scenes.length, "There should be at least one scene defined.");
                                for (var i = 0; i < scenes.length; i++) {
                                    scene = scenes[i];
                                    if (scene.name === sceneName) {
                                        break;
                                    }
                                }
                                if (i === scenes.length) {
                                    throwError('ArgumentError', AVM2.Errors.SceneNotFoundError, sceneName);
                                }
                            } else {
                                scene = this._sceneForFrameIndex(this._currentFrame);
                            }

                            // Amazingly, the `frame` argument, while first coerced to string, is then interpreted as a
                            // frame index even if a label with the same name exists.
                            /* tslint:disable */
                            var frameNum = parseInt(frame, 10);
                            if (frameNum != frame) {
                                var labels = scene.labels;
                                for (var i = 0; i < labels.length; i++) {
                                    var label = labels[i];
                                    if (label.name === frame) {
                                        frameNum = label.frame;
                                        break;
                                    }
                                }
                                if (i === labels.length) {
                                    throwError('ArgumentError', AVM2.Errors.FrameLabelNotFoundError, frame, sceneName);
                                }
                            }

                            /* tslint:enable */
                            this._gotoFrameAbs(scene.offset + frameNum);
                        };

                        MovieClip.prototype._gotoFrameAbs = function (frame) {
                            if (frame < 1) {
                                frame = 1;
                            } else if (frame > this._totalFrames) {
                                frame = this._totalFrames;
                            }
                            if (frame === this._nextFrame) {
                                return;
                            }

                            this._nextFrame = frame;

                            // Frame navigation is only triggered if the MovieClip is on stage.
                            if (this._allowFrameNavigation && this.stage) {
                                // TODO test inter-frame navigation behaviour for SWF versions < 10
                                display.DisplayObject.performFrameNavigation(this.stage, false, true);
                            }
                        };

                        MovieClip.prototype._advanceFrame = function () {
                            var currentFrame = this._currentFrame;
                            var nextFrame = this._nextFrame;

                            if (nextFrame > this._totalFrames) {
                                nextFrame = 1;
                            }

                            if (currentFrame === nextFrame) {
                                // If nextFrame was > this._totalFrames, it has to be written back here, otherwise it'll
                                // just be incremented ever further.
                                this._nextFrame = nextFrame;
                                return;
                            }

                            if (nextFrame > this.framesLoaded) {
                                // If nextFrame was > this._totalFrames, it has to be written back here, otherwise it'll
                                // just be incremented ever further.
                                this._nextFrame = nextFrame;

                                // TODO
                                return;
                            }

                            var frames = this._frames;
                            var startIndex = currentFrame;
                            if (nextFrame < currentFrame) {
                                var frame = frames[0];
                                release || assert(frame, "FrameDelta is not defined.");
                                var stateAtDepth = frame.stateAtDepth;
                                var children = this._children.slice();
                                for (var i = 0; i < children.length; i++) {
                                    var child = children[i];
                                    if (child._depth) {
                                        var state = stateAtDepth[child._depth];
                                        if (!state || !state.canBeAnimated(child)) {
                                            this._removeAnimatedChild(child);
                                        }
                                    }
                                }
                                startIndex = 0;
                            }
                            for (var i = startIndex; i < nextFrame; i++) {
                                var frame = frames[i];
                                release || assert(frame, "FrameDelta is not defined.");
                                var stateAtDepth = frame.stateAtDepth;
                                for (var depth in stateAtDepth) {
                                    var child = this.getChildAtDepth(depth | 0);
                                    var state = stateAtDepth[depth];
                                    if (child) {
                                        if (state && state.canBeAnimated(child)) {
                                            if (state.symbol && !state.symbol.dynamic) {
                                                // TODO: Handle http://wahlers.com.br/claus/blog/hacking-swf-2-placeobject-and-ratio/.
                                                child._setStaticContentFromSymbol(state.symbol);
                                            }
                                            child._animate(state);
                                            continue;
                                        }
                                        this._removeAnimatedChild(child);
                                    }
                                    if (state && state.symbol) {
                                        var character = display.DisplayObject.createAnimatedDisplayObject(state, false);
                                        this.addChildAtDepth(character, state.depth);
                                        if (state.symbol.isAS2Object) {
                                            this._initAvm1Bindings(character, state);
                                        }
                                    }
                                }
                            }

                            if (this._frameScripts[nextFrame]) {
                                this._setFlags(4096 /* HasFrameScriptPending */);
                                this._parent && this._propagateFlagsUp(8192 /* ContainsFrameScriptPendingChildren */);
                            }

                            this._currentFrame = this._nextFrame = nextFrame;

                            this._syncSounds(nextFrame);
                        };

                        /**
                        * Because that's how it's mostly used, the current frame is stored as an offset into the
                        * entire timeline. Sometimes, we need to know which scene it falls into. This utility
                        * function answers that.
                        */
                        MovieClip.prototype._sceneForFrameIndex = function (frameIndex) {
                            var scenes = this._scenes;

                            // A gotoAnd* might be invoked by script before the first advanceFrame call. In that case,
                            // _currentFrame is 0, which means this function is called with frameIndex being 0.
                            // We just return the first scene in that case.
                            if (frameIndex === 0) {
                                return scenes[0];
                            }
                            for (var i = 0; i < scenes.length; i++) {
                                var scene = scenes[i];
                                if (scene.offset < frameIndex && scene.offset + scene.numFrames >= frameIndex) {
                                    return scene;
                                }
                            }
                            release || assertUnreachable("Must have at least one scene covering all frames.");
                        };

                        /**
                        * Frame indices are stored as offsets into the entire timline, whereas labels are stored
                        * in their scenes. This utility function iterates over scenes and their labels to find
                        * the label clostest to, but not after the target frame.
                        */
                        MovieClip.prototype._labelForFrame = function (frame) {
                            var scenes = this._scenes;
                            var label = null;
                            for (var i = 0; i < scenes.length; i++) {
                                var scene = scenes[i];
                                if (scene.offset > frame) {
                                    return label;
                                }
                                var labels = scene.labels;
                                for (var j = 0; j < labels.length; j++) {
                                    var currentLabel = labels[j];
                                    if (currentLabel.frame > frame - scene.offset) {
                                        return label;
                                    }
                                    label = currentLabel;
                                }
                            }
                            return label;
                        };

                        MovieClip.prototype._removeAnimatedChild = function (child) {
                            this.removeChild(child);
                            if (child._name) {
                                var mn = Multiname.getPublicQualifiedName(child._name);
                                if (this[mn] === child) {
                                    this[mn] = null;
                                }
                                //child._removeReference();
                            }
                        };

                        MovieClip.prototype.callFrame = function (frame) {
                            frame = frame | 0;
                            var frameScript = this._frameScripts[frame];
                            if (!frameScript) {
                                return;
                            }
                            try  {
                                frameScript.call(this);
                            } catch (e) {
                                Telemetry.instance.reportTelemetry({ topic: 'error', error: 2 /* AVM2_ERROR */ });

                                //if ($DEBUG) {
                                //  console.error('error ' + e + ', stack: \n' + e.stack);
                                //}
                                this.stop();
                                throw e;
                            }
                        };

                        MovieClip.prototype.nextFrame = function () {
                            this.gotoAndStop(this._currentFrame + 1);
                        };

                        MovieClip.prototype.prevFrame = function () {
                            this.gotoAndStop(this._currentFrame - 1);
                        };

                        MovieClip.prototype.gotoAndPlay = function (frame, scene) {
                            if (typeof scene === "undefined") { scene = null; }
                            // Argument handling for gotoAnd* is a bit peculiar:
                            // - too many arguments throw just as too few do
                            // - the `sceneName` argument is coerced first
                            // - the `frame` argument is coerced to string, but `undefined` results in `"null"`
                            if (arguments.length === 0 || arguments.length > 2) {
                                throwError('ArgumentError', AVM2.Errors.WrongArgumentCountError, 'flash.display::MovieClip/gotoAndPlay()', 1, arguments.length);
                            }
                            scene = asCoerceString(scene);
                            frame = asCoerceString(frame) + ''; // The asCoerceString returns `null` for `undefined`.
                            this.play();
                            this._gotoFrame(frame, scene);
                        };

                        MovieClip.prototype.gotoAndStop = function (frame, scene) {
                            if (typeof scene === "undefined") { scene = null; }
                            // See comment in gotoAndPlay for an explanation of the arguments handling stuff.
                            if (arguments.length === 0 || arguments.length > 2) {
                                throwError('ArgumentError', AVM2.Errors.WrongArgumentCountError, 'flash.display::MovieClip/gotoAndPlay()', 1, arguments.length);
                            }
                            scene = asCoerceString(scene);
                            frame = asCoerceString(frame) + ''; // The asCoerceString returns `null` for `undefined`.
                            this.stop();
                            this._gotoFrame(frame, scene);
                        };

                        /**
                        * Takes pairs of `frameIndex`, `script` arguments and adds the `script`s to the `_frameScripts`
                        * Array.
                        *
                        * Undocumented method used to implement the old timeline concept in AS3.
                        */
                        MovieClip.prototype.addFrameScript = function (frameIndex, script /*, ...*/ ) {
                            if (!this._currentFrame) {
                                return;
                            }

                            // arguments are pairs of frameIndex and script/function
                            // frameIndex is in range 0..totalFrames-1
                            var numArgs = arguments.length;
                            if (numArgs & 1) {
                                throwError('ArgumentError', AVM2.Errors.TooFewArgumentsError, numArgs, numArgs + 1);
                            }
                            var frameScripts = this._frameScripts;
                            var totalFrames = this._totalFrames;
                            for (var i = 0; i < numArgs; i += 2) {
                                var frameNum = (arguments[i] | 0) + 1;
                                if (frameNum < 1 || frameNum > totalFrames) {
                                    continue;
                                }
                                frameScripts[frameNum] = arguments[i + 1];
                                if (frameNum === this._currentFrame) {
                                    this._setFlags(4096 /* HasFrameScriptPending */);
                                    this._parent && this._propagateFlagsUp(8192 /* ContainsFrameScriptPendingChildren */);
                                }
                            }
                        };

                        MovieClip.prototype.addAS2FrameScript = function (frameIndex, actionsBlock) {
                            var frameScripts = this._as2FrameScripts;
                            if (!frameScripts) {
                                release || assert(!this._boundExecuteAS2FrameScripts);
                                this._boundExecuteAS2FrameScripts = this._executeAS2FrameScripts.bind(this);
                                frameScripts = this._as2FrameScripts = [];
                            }
                            var scripts = frameScripts[frameIndex + 1];
                            if (!scripts) {
                                scripts = frameScripts[frameIndex + 1] = [];
                                this.addFrameScript(frameIndex, this._boundExecuteAS2FrameScripts);
                            }
                            var actionsData = new Shumway.AVM1.AS2ActionsData(actionsBlock, 'f' + frameIndex + 'i' + scripts.length);
                            scripts.push(actionsData);
                        };

                        /**
                        * InitActionBlocks are executed once, before the children are initialized for a frame.
                        * That matches AS3's enterFrame event, so we can add an event listener that just bails
                        * as long as the target frame isn't reached, and executes the InitActionBlock once it is.
                        *
                        * After that, the listener removes itself.
                        */
                        MovieClip.prototype.addAS2InitActionBlock = function (frameIndex, actionsBlock) {
                            var self = this;
                            function listener(e) {
                                if (self._currentFrame !== frameIndex + 1) {
                                    return;
                                }
                                self.removeEventListener('enterFrame', listener);

                                var avm1Context = self.loaderInfo._avm1Context;
                                var as2Object = Shumway.AVM1.getAS2Object(self);
                                var stage = self.stage;
                                var actionsData = new Shumway.AVM1.AS2ActionsData(actionsBlock.actionsData, 'f' + frameIndex);
                                avm1Context.executeActions(actionsData, stage, as2Object);
                            }
                            this.addEventListener('enterFrame', listener);
                        };

                        MovieClip.prototype._executeAS2FrameScripts = function () {
                            var avm1Context = this.loaderInfo._avm1Context;
                            var as2Object = Shumway.AVM1.getAS2Object(this);
                            var scripts = this._as2FrameScripts[this._currentFrame];
                            release || assert(scripts && scripts.length);
                            for (var i = 0; i < scripts.length; i++) {
                                var actionsData = scripts[i];
                                avm1Context.executeActions(actionsData, this.stage, as2Object);
                            }
                        };

                        Object.defineProperty(MovieClip.prototype, "_isFullyLoaded", {
                            get: function () {
                                return this.framesLoaded >= this.totalFrames;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        MovieClip.prototype._registerStartSounds = function (frameNum, soundStartInfo) {
                            if (this._sounds === null) {
                                this._sounds = new MovieClipSoundsManager(this);
                            }
                            this._sounds.registerStartSounds(frameNum, soundStartInfo);
                        };

                        MovieClip.prototype._initSoundStream = function (streamInfo) {
                            if (this._sounds === null) {
                                this._sounds = new MovieClipSoundsManager(this);
                            }
                            this._sounds.initSoundStream(streamInfo);
                        };

                        MovieClip.prototype._addSoundStreamBlock = function (frameIndex, streamBlock) {
                            this._sounds.addSoundStreamBlock(frameIndex + 1, streamBlock);
                        };

                        MovieClip.prototype._syncSounds = function (frameNum) {
                            if (this._sounds !== null) {
                                this._sounds.syncSounds(frameNum + 1);
                            }
                        };

                        MovieClip.prototype.addScene = function (name, labels, offset, numFrames) {
                            this._scenes.push(new display.Scene(name, labels, offset, numFrames));
                        };

                        MovieClip.prototype.addFrameLabel = function (name, frame) {
                            this._sceneForFrameIndex(frame)._labels.push(new flash.display.FrameLabel(name, frame));
                        };

                        MovieClip.prototype.prevScene = function () {
                            var currentScene = this._sceneForFrameIndex(this._currentFrame);
                            if (currentScene.offset === 0) {
                                return;
                            }

                            // Since scene offsets are 0-based, the current scene's offset, treated as a frame index,
                            // is the previous scene's last frame.
                            this._gotoFrameAbs(this._sceneForFrameIndex(currentScene.offset).offset + 1);
                        };

                        MovieClip.prototype.nextScene = function () {
                            var currentScene = this._sceneForFrameIndex(this._currentFrame);
                            this._gotoFrameAbs(currentScene.offset + currentScene.numFrames + 1);
                        };
                        MovieClip.classInitializer = function () {
                            MovieClip.reset();
                        };

                        MovieClip.initializer = function (symbol) {
                            var self = this;

                            display.DisplayObject._advancableInstances.push(self);

                            self._currentFrame = 0;
                            self._totalFrames = 1;
                            self._trackAsMenu = false;
                            self._scenes = [];
                            self._enabled = true;
                            self._isPlaying = false;

                            self._frames = [];
                            self._frameScripts = [];
                            self._nextFrame = 1;
                            self._stopped = false;
                            self._allowFrameNavigation = true;

                            self._sounds = null;

                            self._buttonFrames = Object.create(null);
                            self._currentButtonState = null;

                            if (symbol) {
                                self._totalFrames = symbol.numFrames;
                                self._currentFrame = 1;
                                if (!symbol.isRoot) {
                                    self.addScene('', symbol.labels, 0, symbol.numFrames);
                                }
                                self._frames = symbol.frames;
                                if (symbol.isAS2Object) {
                                    this._mouseEnabled = false;
                                    if (symbol.frameScripts) {
                                        var data = symbol.frameScripts;
                                        for (var i = 0; i < data.length; i += 2) {
                                            self.addAS2FrameScript(data[i], data[i + 1]);
                                        }
                                    }
                                }
                                if (symbol.initActionBlock) {
                                    this.addAS2InitActionBlock(0, symbol.initActionBlock);
                                }
                            } else {
                                self.addScene('', [], 0, self._totalFrames);
                            }
                        };

                        MovieClip.classSymbols = null;

                        MovieClip.instanceSymbols = null;
                        return MovieClip;
                    })(flash.display.Sprite);
                    display.MovieClip = MovieClip;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MovieClip
                (function (display) {
                    var MP3_MIME_TYPE = 'audio/mpeg';

                    function openMediaSource(soundStream, mediaSource) {
                        var sourceBuffer;
                        try  {
                            sourceBuffer = mediaSource.addSourceBuffer(MP3_MIME_TYPE);
                            soundStream.mediaSource = mediaSource;
                            soundStream.sourceBuffer = sourceBuffer;

                            // cannot issue multiple appendBuffer in a row, flattening frames into
                            // one array
                            var rawFramesLength = 0;
                            soundStream.rawFrames.forEach(function (frameData) {
                                rawFramesLength += frameData.length;
                            });
                            if (rawFramesLength !== 0) {
                                var data = new Uint8Array(rawFramesLength), offset = 0;
                                soundStream.rawFrames.forEach(function (frameData) {
                                    data.set(frameData, offset);
                                    offset += frameData.length;
                                });
                                sourceBuffer.appendBuffer(data);
                            }
                            soundStream.rawFrames = null;
                        } catch (e) {
                            console.error('MediaSource mp3 playback is not supported: ' + e);
                        }
                    }

                    function syncTime(element, movieClip) {
                        var initialized = false;
                        var startMediaTime, startRealTime;
                        element.addEventListener('timeupdate', function (e) {
                            if (!initialized) {
                                startMediaTime = element.currentTime;
                                startRealTime = performance.now();
                                initialized = true;

                                //movieClip._stage._frameScheduler.startTrackDelta();
                                return;
                            }
                            var mediaDelta = element.currentTime - startMediaTime;
                            var realDelta = performance.now() - startRealTime;
                            //movieClip._stage._frameScheduler.setDelta(realDelta - mediaDelta * 1000);
                        });
                        element.addEventListener('pause', function (e) {
                            //movieClip._stage._frameScheduler.endTrackDelta();
                            initialized = false;
                        });
                        element.addEventListener('seeking', function (e) {
                            //movieClip._stage._frameScheduler.endTrackDelta();
                            initialized = false;
                        });
                    }

                    var PLAY_USING_AUDIO_TAG = true;

                    var MovieClipSoundStream = (function () {
                        function MovieClipSoundStream(streamInfo, movieClip) {
                            this.movieClip = movieClip;
                            this.data = {
                                sampleRate: streamInfo.sampleRate,
                                channels: streamInfo.channels
                            };
                            this.seekIndex = [];
                            this.position = 0;
                            var isMP3 = streamInfo.format === 'mp3';
                            if (isMP3 && PLAY_USING_AUDIO_TAG) {
                                var element = document.createElement('audio');
                                element.preload = 'metadata'; // for mobile devices
                                element.loop = false;
                                syncTime(element, movieClip);
                                if (element.canPlayType(MP3_MIME_TYPE)) {
                                    this.element = element;
                                    if (typeof MediaSource !== 'undefined') {
                                        var mediaSource = new MediaSource();
                                        mediaSource.addEventListener('sourceopen', openMediaSource.bind(null, this, mediaSource));
                                        element.src = URL.createObjectURL(mediaSource);
                                    } else {
                                        console.warn('MediaSource is not supported');
                                    }
                                    this.rawFrames = [];
                                    return;
                                }
                            }
                            var totalSamples = streamInfo.samplesCount * streamInfo.channels;
                            this.data.pcm = new Float32Array(totalSamples);
                            if (isMP3) {
                                var soundStream = this;
                                soundStream.decoderPosition = 0;
                                soundStream.decoderSession = new MP3DecoderSession();
                                soundStream.decoderSession.onframedata = function (frameData) {
                                    var position = soundStream.decoderPosition;
                                    soundStream.data.pcm.set(frameData, position);
                                    soundStream.decoderPosition = position + frameData.length;
                                }.bind(this);
                                soundStream.decoderSession.onerror = function (error) {
                                    console.error('ERROR: MP3DecoderSession: ' + error);
                                };
                                // TODO close the session somewhere
                            }
                        }
                        MovieClipSoundStream.prototype.appendBlock = function (frameNum, streamBlock) {
                            var streamPosition = this.position;
                            this.seekIndex[frameNum] = streamPosition + streamBlock.seek * this.data.channels;
                            this.position = streamPosition + streamBlock.samplesCount * this.data.channels;

                            if (this.sourceBuffer) {
                                this.sourceBuffer.appendBuffer(streamBlock.data);
                                return;
                            }
                            if (this.rawFrames) {
                                this.rawFrames.push(streamBlock.data);
                                return;
                            }

                            var decoderSession = this.decoderSession;
                            if (decoderSession) {
                                decoderSession.pushAsync(streamBlock.data);
                            } else {
                                this.data.pcm.set(streamBlock.pcm, streamPosition);
                            }
                        };

                        MovieClipSoundStream.prototype.playFrame = function (frameNum) {
                            if (isNaN(this.seekIndex[frameNum])) {
                                return;
                            }

                            var PAUSE_WHEN_OF_SYNC_GREATER = 1.0;
                            var PLAYBACK_ADJUSTMENT = 0.25;
                            var element = this.element;
                            if (element) {
                                var soundStreamData = this.data;
                                var time = this.seekIndex[frameNum] / soundStreamData.sampleRate / soundStreamData.channels;
                                if (!this.channel && (this.movieClip._isFullyLoaded || this.sourceBuffer)) {
                                    if (!this.sourceBuffer) {
                                        var blob = new Blob(this.rawFrames);
                                        element.src = URL.createObjectURL(blob);
                                    }

                                    var channel = flash.media.SoundChannel.initializeFrom({ element: element });
                                    this.channel = channel;
                                    this.expectedFrame = 0;
                                    this.waitFor = 0;
                                } else if (this.sourceBuffer || !isNaN(element.duration)) {
                                    if (this.mediaSource && this.movieClip._isFullyLoaded) {
                                        this.mediaSource.endOfStream();
                                        this.mediaSource = null;
                                    }
                                    var elementTime = element.currentTime;
                                    if (this.expectedFrame !== frameNum) {
                                        if (element.paused) {
                                            element.play();
                                            element.addEventListener('playing', function setTime(e) {
                                                element.removeEventListener('playing', setTime);
                                                element.currentTime = time;
                                            });
                                        } else {
                                            element.currentTime = time;
                                        }
                                    } else if (this.waitFor > 0) {
                                        if (this.waitFor <= time) {
                                            if (element.paused) {
                                                element.play();
                                            }
                                            this.waitFor = 0;
                                        }
                                    } else if (elementTime - time > PAUSE_WHEN_OF_SYNC_GREATER) {
                                        console.warn('Sound is faster than frames by ' + (elementTime - time));
                                        this.waitFor = elementTime - PLAYBACK_ADJUSTMENT;
                                        element.pause();
                                    } else if (time - elementTime > PAUSE_WHEN_OF_SYNC_GREATER) {
                                        console.warn('Sound is slower than frames by ' + (time - elementTime));
                                        element.currentTime = time + PLAYBACK_ADJUSTMENT;
                                    }
                                    this.expectedFrame = frameNum + 1;
                                }
                            } else if (!this.sound) {
                                // Start from some seek offset, stopping
                                var sound = flash.media.Sound.initializeFrom(this.data);
                                var channel = sound.play();
                                this.sound = sound;
                                this.channel = channel;
                            }
                        };
                        return MovieClipSoundStream;
                    })();
                    display.MovieClipSoundStream = MovieClipSoundStream;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Stage
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;

                    var Stage = (function (_super) {
                        __extends(Stage, _super);
                        function Stage() {
                            false && _super.call(this);
                            display.DisplayObjectContainer.instanceConstructorNoInitialize.call(this);
                            this._root = this;
                            this._stage = this;
                            this._frameRate = 24;
                            this._scaleMode = display.StageScaleMode.SHOW_ALL;
                            this._align = "";
                            this._stageWidth = 0;
                            this._stageHeight = 0;
                            this._showDefaultContextMenu = true;
                            this._focus = null;
                            this._colorCorrection = display.ColorCorrection.DEFAULT;
                            this._colorCorrectionSupport = display.ColorCorrectionSupport.DEFAULT_OFF;
                            this._stageFocusRect = true;
                            this._quality = display.StageQuality.HIGH;
                            this._displayState = null;
                            this._fullScreenSourceRect = null;
                            this._mouseLock = false;
                            this._stageVideos = null; // TODO
                            this._stage3Ds = null; // TODO
                            this._colorARGB = 0xFFFFFFFF;
                            this._fullScreenWidth = 0;
                            this._fullScreenHeight = 0;
                            this._wmodeGPU = false;
                            this._softKeyboardRect = new flash.geom.Rectangle();
                            this._allowsFullScreen = false;
                            this._allowsFullScreenInteractive = false;
                            this._contentsScaleFactor = 1;
                            this._displayContextInfo = null;

                            this._timeout = -1;

                            /**
                            * Indicates if a Render event was requested by calling the |invalid| function.
                            */
                            this._invalidated = false;
                        }
                        Object.defineProperty(Stage.prototype, "frameRate", {
                            get: function () {
                                return this._frameRate;
                            },
                            set: function (value) {
                                this._frameRate = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "scaleMode", {
                            get: function () {
                                return this._scaleMode;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                if (flash.display.StageScaleMode.toNumber(value) < 0) {
                                    throwError("ArgumentError", AVM2.Errors.InvalidEnumError, "scaleMode");
                                }
                                this._scaleMode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "align", {
                            get: function () {
                                return this._align;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                var n = flash.display.StageAlign.toNumber(value);
                                release || assert(n >= 0);
                                this._align = flash.display.StageAlign.fromNumber(n);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "stageWidth", {
                            get: function () {
                                return (this._stageWidth / 20) | 0;
                            },
                            set: function (value /*int*/ ) {
                                this._stageWidth = (value * 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "stageHeight", {
                            get: function () {
                                return (this._stageHeight / 20) | 0;
                            },
                            set: function (value /*int*/ ) {
                                this._stageHeight = (value * 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "showDefaultContextMenu", {
                            get: function () {
                                return this._showDefaultContextMenu;
                            },
                            set: function (value) {
                                this._showDefaultContextMenu = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "focus", {
                            get: function () {
                                return this._focus;
                            },
                            set: function (newFocus) {
                                this._focus = newFocus;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "colorCorrection", {
                            get: function () {
                                return this._colorCorrection;
                            },
                            set: function (value) {
                                //this._colorCorrection = asCoerceString(value);
                                notImplemented("public flash.display.Stage::set colorCorrection");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "colorCorrectionSupport", {
                            get: function () {
                                return this._colorCorrectionSupport;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "stageFocusRect", {
                            get: function () {
                                return this._stageFocusRect;
                            },
                            set: function (on) {
                                this._stageFocusRect = !!on;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "quality", {
                            get: function () {
                                return this._quality.toUpperCase();
                            },
                            set: function (value) {
                                // TODO: The *linear versions return just *, stripping the "linear" part
                                // Value is compared case-insensitively, and has default handling, so '' is ok.
                                value = (asCoerceString(value) || '').toLowerCase();
                                if (flash.display.StageQuality.toNumber(value) < 0) {
                                    value = flash.display.StageQuality.HIGH;
                                }
                                this._quality = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "displayState", {
                            get: function () {
                                return this._displayState;
                            },
                            set: function (value) {
                                //this._displayState = asCoerceString(value);
                                notImplemented("public flash.display.Stage::set displayState");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "fullScreenSourceRect", {
                            get: function () {
                                return this._fullScreenSourceRect;
                            },
                            set: function (value) {
                                //this._fullScreenSourceRect = value;
                                notImplemented("public flash.display.Stage::set fullScreenSourceRect");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "mouseLock", {
                            get: function () {
                                return this._mouseLock;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.display.Stage::set mouseLock");
                                this._mouseLock = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Stage.prototype, "stageVideos", {
                            get: function () {
                                notImplemented("public flash.display.Stage::get stageVideos");
                                return;
                                // return this._stageVideos;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, "stage3Ds", {
                            get: function () {
                                notImplemented("public flash.display.Stage::get stage3Ds");
                                return;
                                // return this._stage3Ds;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "color", {
                            get: function () {
                                return this._colorARGB;
                            },
                            set: function (rgb /*uint*/ ) {
                                // Flash player forces the alpha channel to 0xff.
                                this._colorARGB = rgb | 0xff000000;
                            },
                            enumerable: true,
                            configurable: true
                        });



                        Object.defineProperty(Stage.prototype, "alpha", {
                            get: function () {
                                return this._colorTransform.alphaMultiplier;
                            },
                            set: function (alpha) {
                                throwError("Error", AVM2.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "fullScreenWidth", {
                            get: function () {
                                return this._fullScreenWidth;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "fullScreenHeight", {
                            get: function () {
                                return this._fullScreenHeight;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "wmodeGPU", {
                            get: function () {
                                return this._wmodeGPU;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "softKeyboardRect", {
                            get: function () {
                                return this._softKeyboardRect;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "allowsFullScreen", {
                            get: function () {
                                return this._allowsFullScreen;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "allowsFullScreenInteractive", {
                            get: function () {
                                return this._allowsFullScreenInteractive;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "contentsScaleFactor", {
                            get: function () {
                                return this._contentsScaleFactor;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Stage.prototype, "displayContextInfo", {
                            get: function () {
                                return this._displayContextInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        /*
                        removeChildAt(index: number): flash.display.DisplayObject {
                        index = index | 0;
                        notImplemented("public flash.display.Stage::removeChildAt"); return;
                        }
                        */
                        Stage.prototype.swapChildrenAt = function (index1 /*int*/ , index2 /*int*/ ) {
                            index1 = index1 | 0;
                            index2 = index2 | 0;
                            notImplemented("public flash.display.Stage::swapChildrenAt");
                            return;
                        };

                        Stage.prototype.invalidate = function () {
                            this._invalidated = true;
                        };

                        Stage.prototype.isInvalidated = function () {
                            return this._invalidated;
                        };

                        Stage.prototype.isFocusInaccessible = function () {
                            notImplemented("public flash.display.Stage::isFocusInaccessible");
                            return;
                        };
                        Stage.prototype.requireOwnerPermissions = function () {
                            somewhatImplemented("public flash.display.Stage::requireOwnerPermissions");
                            return;
                        };

                        Stage.prototype.render = function () {
                            if (!this._invalidated) {
                                return;
                            }
                            display.DisplayObject._broadcastFrameEvent(flash.events.Event.RENDER);
                            this._invalidated = false;
                        };

                        /**
                        * Gets the objects under the current mouse position. The main difference to DisplayObjectObjectContainer's
                        * getObjectsUnderPoint is that it reroutes the hit test to a Button's hitTestState or a Sprite's
                        * hitArea, if specified.
                        */
                        Stage.prototype.getObjectsUnderMouse = function (globalPoint) {
                            var objectsUnderPoint = [];
                            this.visit(function (displayObject) {
                                var isUnderMouse = false;
                                if (!display.Sprite.isType(displayObject) || !displayObject.hitArea) {
                                    isUnderMouse = displayObject._isUnderMouse(globalPoint.x * 20, globalPoint.y * 20);
                                }
                                if (isUnderMouse) {
                                    objectsUnderPoint.push(displayObject);
                                }
                                return 0 /* Continue */;
                            }, 0 /* None */);
                            return objectsUnderPoint;
                        };
                        Stage.classInitializer = null;

                        Stage.classSymbols = null;
                        Stage.instanceSymbols = null;
                        Stage.initializer = null;
                        return Stage;
                    })(flash.display.DisplayObjectContainer);
                    display.Stage = Stage;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ActionScriptVersion
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ActionScriptVersion = (function (_super) {
                        __extends(ActionScriptVersion, _super);
                        function ActionScriptVersion() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.ActionScriptVersion");
                        }
                        ActionScriptVersion.classInitializer = null;

                        ActionScriptVersion.initializer = null;

                        ActionScriptVersion.classSymbols = null;

                        ActionScriptVersion.instanceSymbols = null;

                        ActionScriptVersion.ACTIONSCRIPT2 = 2;
                        ActionScriptVersion.ACTIONSCRIPT3 = 3;
                        return ActionScriptVersion;
                    })(AS.ASNative);
                    display.ActionScriptVersion = ActionScriptVersion;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BlendMode
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var BlendMode = (function (_super) {
                        __extends(BlendMode, _super);
                        function BlendMode() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.BlendMode");
                        }
                        /**
                        * Returns the blend mode string from the numeric value that appears in the
                        * swf file.
                        */
                        BlendMode.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                case 1:
                                    return BlendMode.NORMAL;
                                case 2:
                                    return BlendMode.LAYER;
                                case 3:
                                    return BlendMode.MULTIPLY;
                                case 4:
                                    return BlendMode.SCREEN;
                                case 5:
                                    return BlendMode.LIGHTEN;
                                case 6:
                                    return BlendMode.DARKEN;
                                case 7:
                                    return BlendMode.DIFFERENCE;
                                case 8:
                                    return BlendMode.ADD;
                                case 9:
                                    return BlendMode.SUBTRACT;
                                case 10:
                                    return BlendMode.INVERT;
                                case 11:
                                    return BlendMode.ALPHA;
                                case 12:
                                    return BlendMode.ERASE;
                                case 13:
                                    return BlendMode.OVERLAY;
                                case 14:
                                    return BlendMode.HARDLIGHT;
                                default:
                                    return null;
                            }
                        };

                        BlendMode.toNumber = function (value) {
                            switch (value) {
                                case BlendMode.NORMAL:
                                    return 1;
                                case BlendMode.LAYER:
                                    return 2;
                                case BlendMode.MULTIPLY:
                                    return 3;
                                case BlendMode.SCREEN:
                                    return 4;
                                case BlendMode.LIGHTEN:
                                    return 5;
                                case BlendMode.DARKEN:
                                    return 6;
                                case BlendMode.DIFFERENCE:
                                    return 7;
                                case BlendMode.ADD:
                                    return 8;
                                case BlendMode.SUBTRACT:
                                    return 9;
                                case BlendMode.INVERT:
                                    return 10;
                                case BlendMode.ALPHA:
                                    return 11;
                                case BlendMode.ERASE:
                                    return 12;
                                case BlendMode.OVERLAY:
                                    return 13;
                                case BlendMode.HARDLIGHT:
                                    return 14;
                                default:
                                    return -1;
                            }
                        };
                        BlendMode.classInitializer = null;

                        BlendMode.initializer = null;

                        BlendMode.classSymbols = null;

                        BlendMode.instanceSymbols = null;

                        BlendMode.NORMAL = "normal";
                        BlendMode.LAYER = "layer";
                        BlendMode.MULTIPLY = "multiply";
                        BlendMode.SCREEN = "screen";
                        BlendMode.LIGHTEN = "lighten";
                        BlendMode.DARKEN = "darken";
                        BlendMode.ADD = "add";
                        BlendMode.SUBTRACT = "subtract";
                        BlendMode.DIFFERENCE = "difference";
                        BlendMode.INVERT = "invert";
                        BlendMode.OVERLAY = "overlay";
                        BlendMode.HARDLIGHT = "hardlight";
                        BlendMode.ALPHA = "alpha";
                        BlendMode.ERASE = "erase";
                        BlendMode.SHADER = "shader";
                        return BlendMode;
                    })(AS.ASNative);
                    display.BlendMode = BlendMode;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ColorCorrection
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ColorCorrection = (function (_super) {
                        __extends(ColorCorrection, _super);
                        function ColorCorrection() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.ColorCorrection");
                        }
                        // AS -> JS Bindings
                        ColorCorrection.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return ColorCorrection.DEFAULT;
                                case 1:
                                    return ColorCorrection.ON;
                                case 2:
                                    return ColorCorrection.OFF;
                                default:
                                    return null;
                            }
                        };

                        ColorCorrection.toNumber = function (value) {
                            switch (value) {
                                case ColorCorrection.DEFAULT:
                                    return 0;
                                case ColorCorrection.ON:
                                    return 1;
                                case ColorCorrection.OFF:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        ColorCorrection.classInitializer = null;

                        ColorCorrection.initializer = null;

                        ColorCorrection.classSymbols = null;

                        ColorCorrection.instanceSymbols = null;

                        ColorCorrection.DEFAULT = "default";
                        ColorCorrection.ON = "on";
                        ColorCorrection.OFF = "off";
                        return ColorCorrection;
                    })(AS.ASNative);
                    display.ColorCorrection = ColorCorrection;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ColorCorrectionSupport
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ColorCorrectionSupport = (function (_super) {
                        __extends(ColorCorrectionSupport, _super);
                        function ColorCorrectionSupport() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.ColorCorrectionSupport");
                        }
                        // AS -> JS Bindings
                        ColorCorrectionSupport.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return ColorCorrectionSupport.UNSUPPORTED;
                                case 1:
                                    return ColorCorrectionSupport.DEFAULT_ON;
                                case 2:
                                    return ColorCorrectionSupport.DEFAULT_OFF;
                                default:
                                    return null;
                            }
                        };

                        ColorCorrectionSupport.toNumber = function (value) {
                            switch (value) {
                                case ColorCorrectionSupport.UNSUPPORTED:
                                    return 0;
                                case ColorCorrectionSupport.DEFAULT_ON:
                                    return 1;
                                case ColorCorrectionSupport.DEFAULT_OFF:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        ColorCorrectionSupport.classInitializer = null;

                        ColorCorrectionSupport.initializer = null;

                        ColorCorrectionSupport.classSymbols = null;

                        ColorCorrectionSupport.instanceSymbols = null;

                        ColorCorrectionSupport.UNSUPPORTED = "unsupported";
                        ColorCorrectionSupport.DEFAULT_ON = "defaultOn";
                        ColorCorrectionSupport.DEFAULT_OFF = "defaultOff";
                        return ColorCorrectionSupport;
                    })(AS.ASNative);
                    display.ColorCorrectionSupport = ColorCorrectionSupport;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: FocusDirection
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var FocusDirection = (function (_super) {
                        __extends(FocusDirection, _super);
                        function FocusDirection() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.FocusDirection");
                        }
                        FocusDirection.classInitializer = null;

                        FocusDirection.initializer = null;

                        FocusDirection.classSymbols = null;

                        FocusDirection.instanceSymbols = null;

                        FocusDirection.TOP = "top";
                        FocusDirection.BOTTOM = "bottom";
                        FocusDirection.NONE = "none";
                        return FocusDirection;
                    })(AS.ASNative);
                    display.FocusDirection = FocusDirection;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: FrameLabel
                (function (display) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var FrameLabel = (function (_super) {
                        __extends(FrameLabel, _super);
                        function FrameLabel(name, frame /*int*/ ) {
                            false && _super.call(this, undefined);
                            this._name = asCoerceString(name);
                            this._frame = frame | 0;
                        }
                        Object.defineProperty(FrameLabel.prototype, "name", {
                            get: function () {
                                return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FrameLabel.prototype, "frame", {
                            get: function () {
                                return this._frame;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        FrameLabel.prototype.clone = function () {
                            return new FrameLabel(this._name, this._frame);
                        };
                        FrameLabel.classInitializer = null;

                        FrameLabel.initializer = null;

                        FrameLabel.classSymbols = null;

                        FrameLabel.instanceSymbols = null;
                        return FrameLabel;
                    })(flash.events.EventDispatcher);
                    display.FrameLabel = FrameLabel;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (_AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BitmapData
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var AVM2 = Shumway.AVM2.Runtime.AVM2;
                    var swap32 = Shumway.IntegerUtilities.swap32;
                    var premultiplyARGB = Shumway.ColorUtilities.premultiplyARGB;
                    var unpremultiplyARGB = Shumway.ColorUtilities.unpremultiplyARGB;
                    var RGBAToARGB = Shumway.ColorUtilities.RGBAToARGB;

                    var blendPremultipliedBGRA = Shumway.ColorUtilities.blendPremultipliedBGRA;
                    var ensureInverseSourceAlphaTable = Shumway.ColorUtilities.ensureInverseSourceAlphaTable;
                    var indexOf = Shumway.ArrayUtilities.indexOf;

                    var Rectangle = flash.geom.Rectangle;

                    /**
                    * Holds blobs of bitmap data in various formats and lets you do basic pixel operations. When data is
                    * unpacked, it is stored as premultiplied ARGB since it's what the SWF encodes bitmaps as.  This way
                    * we don't have to do unecessary byte conversions.
                    */
                    var BitmapData = (function (_super) {
                        __extends(BitmapData, _super);
                        function BitmapData(width /*int*/ , height /*int*/ , transparent, fillColorARGB) {
                            if (typeof transparent === "undefined") { transparent = true; }
                            if (typeof fillColorARGB === "undefined") { fillColorARGB = 4294967295; }
                            width = width | 0;
                            height = height | 0;
                            fillColorARGB = fillColorARGB | 0;
                            false && _super.call(this);
                            this._id = flash.display.DisplayObject.getNextSyncID();
                            if (this._symbol) {
                                width = this._symbol.width;
                                height = this._symbol.height;
                            }
                            if (width > BitmapData.MAXIMUM_WIDTH || width <= 0 || height > BitmapData.MAXIMUM_HEIGHT || height <= 0 || width * height > BitmapData.MAXIMUM_DIMENSION) {
                                throwError('ArgumentError', _AVM2.Errors.InvalidBitmapData);
                            }
                            this._bitmapReferrers = [];
                            this._transparent = !!transparent;
                            this._rect = new Rectangle(0, 0, width, height);
                            this._fillColorBGRA = swap32(fillColorARGB); // Specified as ARGB but stored as BGRA.
                            if (this._symbol) {
                                this._data = new Uint8Array(this._symbol.data.buffer);
                                this._type = this._symbol.type;
                                if (this._type === 1 /* PremultipliedAlphaARGB */ || this._type === 2 /* StraightAlphaARGB */ || this._type === 3 /* StraightAlphaRGBA */) {
                                    this._view = new Int32Array(this._symbol.data.buffer);
                                }
                            } else {
                                this._data = new Uint8Array(width * height * 4);
                                this._view = new Int32Array(this._data.buffer);
                                this._type = 1 /* PremultipliedAlphaARGB */;
                                var alpha = fillColorARGB >> 24;
                                if (alpha === 0 && transparent) {
                                    // No need to do an initial fill since this would all be zeros anyway.
                                } else {
                                    this.fillRect(this.rect, fillColorARGB);
                                }
                            }
                            this._dataBuffer = DataBuffer.FromArrayBuffer(this._data.buffer);
                            this._invalidate();
                        }
                        BitmapData.prototype._addBitmapReferrer = function (bitmap) {
                            var index = indexOf(this._bitmapReferrers, bitmap);
                            release && assert(index < 0);
                            this._bitmapReferrers.push(bitmap);
                        };

                        BitmapData.prototype._removeBitmapReferrer = function (bitmap) {
                            var index = indexOf(this._bitmapReferrers, bitmap);
                            release && assert(index >= 0);
                            this._bitmapReferrers[index] = null;
                        };

                        /**
                        * Called whenever the contents of this bitmap data changes.
                        */
                        BitmapData.prototype._invalidate = function () {
                            if (this._isDirty) {
                                return;
                            }
                            this._isDirty = true;
                            this._isRemoteDirty = false;

                            for (var i = 0; i < this._bitmapReferrers.length; i++) {
                                var bitmap = this._bitmapReferrers[i];
                                if (bitmap) {
                                    bitmap._setDirtyFlags(16777216 /* DirtyBitmapData */);
                                }
                            }
                        };

                        BitmapData.prototype.getDataBuffer = function () {
                            return this._dataBuffer;
                        };

                        BitmapData.prototype._getContentBounds = function () {
                            return Shumway.Bounds.FromRectangle(this._rect);
                        };

                        /**
                        * TODO: Not tested.
                        */
                        BitmapData.prototype._getPixelData = function (rect) {
                            var r = this.rect.intersectInPlace(rect);
                            if (r.isEmpty()) {
                                return;
                            }
                            var xMin = r.x;
                            var xMax = r.x + r.width;
                            var yMin = r.y;
                            var yMax = r.y + r.height;
                            var view = this._view;
                            var width = this._rect.width;
                            var output = new Int32Array(r.area);
                            var p = 0;
                            for (var y = yMin; y < yMax; y++) {
                                var offset = y * width;
                                for (var x = xMin; x < xMax; x++) {
                                    var colorBGRA = view[offset + x];
                                    var alpha = colorBGRA & 0xff;
                                    var colorBGR = colorBGRA >>> 8;
                                    colorBGRA = ((255 * colorBGR) / alpha) << 8 | alpha;
                                    output[p++] = colorBGRA;
                                }
                            }
                            return output;
                        };

                        /**
                        * TODO: Not tested.
                        */
                        BitmapData.prototype._putPixelData = function (rect, input) {
                            var r = this.rect.intersectInPlace(rect);
                            if (r.isEmpty()) {
                                return;
                            }
                            var xMin = r.x;
                            var xMax = r.x + r.width;
                            var yMin = r.y;
                            var yMax = r.y + r.height;
                            var view = this._view;
                            var width = this._rect.width;
                            var p = (rect.width * rect.height - r.height) + (xMin - rect.x);
                            var padding = rect.width - r.width;
                            var alphaMask = this._transparent ? 0x00 : 0xff;
                            for (var y = yMin; y < yMax; y++) {
                                var offset = y * width;
                                for (var x = xMin; x < xMax; x++) {
                                    var colorBGRA = input[p++];
                                    var alpha = colorBGRA & alphaMask;
                                    var colorBGR = colorBGRA >>> 8;
                                    view[offset + x] = (((colorBGR * alpha + 254) / 255) & 0x00ffffff) << 8 | alpha;
                                }
                                p += padding;
                            }
                            this._invalidate();
                        };

                        Object.defineProperty(BitmapData.prototype, "width", {
                            get: function () {
                                return this._rect.width;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BitmapData.prototype, "height", {
                            get: function () {
                                return this._rect.height;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BitmapData.prototype, "rect", {
                            get: function () {
                                return this._rect.clone();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BitmapData.prototype, "transparent", {
                            get: function () {
                                return this._transparent;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        BitmapData.prototype.clone = function () {
                            somewhatImplemented("public flash.display.BitmapData::clone");

                            // This should be coping the buffer not the view.
                            var bd = new BitmapData(this._rect.width, this._rect.height, this._transparent, this._fillColorBGRA);
                            bd._view.set(this._view);
                            return bd;
                        };

                        /**
                        * Returns an straight alpha RGB pixel value 0x00RRGGBB.
                        */
                        BitmapData.prototype.getPixel = function (x /*int*/ , y /*int*/ ) {
                            x = x | 0;
                            y = y | 0;
                            return this.getPixel32(x, y) & 0x00ffffff;
                        };

                        /**
                        * Returns an straight alpha ARGB pixel value 0xAARRGGBB.
                        */
                        BitmapData.prototype.getPixel32 = function (x /*int*/ , y /*int*/ ) {
                            x = x | 0;
                            y = y | 0;
                            if (!this._rect.contains(x, y)) {
                                return 0;
                            }
                            this._requestBitmapData();
                            var value = this._view[y * this._rect.width + x];
                            switch (this._type) {
                                case 1 /* PremultipliedAlphaARGB */:
                                    var pARGB = swap32(value);
                                    var uARGB = unpremultiplyARGB(pARGB);
                                    return uARGB >>> 0;
                                case 3 /* StraightAlphaRGBA */:
                                    return RGBAToARGB(swap32(value));
                                default:
                                    Shumway.Debug.notImplemented(Shumway.ImageType[this._type]);
                                    return 0;
                            }
                        };

                        BitmapData.prototype.setPixel = function (x /*int*/ , y /*int*/ , uARGB /*uint*/ ) {
                            x = x | 0;
                            y = y | 0;
                            uARGB = uARGB | 0;
                            if (!this._rect.contains(x, y)) {
                                return;
                            }
                            this._requestBitmapData();
                            var i = y * this._rect.width + x;
                            var a = this._view[i] & 0xff;
                            uARGB = uARGB & 0x00ffffff | a << 24;
                            var pARGB = premultiplyARGB(uARGB);
                            this._view[i] = swap32(pARGB);
                            this._invalidate();
                        };

                        BitmapData.prototype.setPixel32 = function (x /*int*/ , y /*int*/ , uARGB /*uint*/ ) {
                            x = x | 0;
                            y = y | 0;
                            if (!this._rect.contains(x, y)) {
                                return;
                            }
                            this._requestBitmapData();
                            var a = uARGB >>> 24;
                            var uRGB = uARGB & 0x00ffffff;
                            if (this._transparent) {
                                var uARGB = uRGB | a << 24;
                                var pARGB = premultiplyARGB(uARGB);
                            } else {
                                var pARGB = uRGB | 0xff000000;
                            }
                            this._view[y * this._rect.width + x] = swap32(pARGB);
                            this._invalidate();
                        };

                        BitmapData.prototype.applyFilter = function (sourceBitmapData, sourceRect, destPoint, filter) {
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            filter = filter;
                            somewhatImplemented("public flash.display.BitmapData::applyFilter " + filter);
                            return;
                        };

                        BitmapData.prototype.colorTransform = function (rect, colorTransform) {
                            rect = rect;
                            colorTransform = colorTransform;
                            somewhatImplemented("public flash.display.BitmapData::colorTransform");
                            return;
                        };

                        BitmapData.prototype.compare = function (otherBitmapData) {
                            otherBitmapData = otherBitmapData;
                            notImplemented("public flash.display.BitmapData::compare");
                            return;
                        };

                        BitmapData.prototype.copyChannel = function (sourceBitmapData, sourceRect, destPoint, sourceChannel /*uint*/ , destChannel) {
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            sourceChannel = sourceChannel >>> 0;
                            destChannel = destChannel >>> 0;
                            notImplemented("public flash.display.BitmapData::copyChannel");
                            return;
                        };

                        /**
                        * Copies a rectangular region of pixels into the current bitmap data.
                        */
                        BitmapData.prototype.copyPixels = function (sourceBitmapData, sourceRect, destPoint, alphaBitmapData, alphaPoint, mergeAlpha) {
                            if (typeof alphaBitmapData === "undefined") { alphaBitmapData = null; }
                            if (typeof alphaPoint === "undefined") { alphaPoint = null; }
                            if (typeof mergeAlpha === "undefined") { mergeAlpha = false; }
                            _AVM2.enterTimeline("BitmapData.copyPixels");
                            mergeAlpha = !!mergeAlpha;

                            if (alphaBitmapData || alphaPoint) {
                                notImplemented("public flash.display.BitmapData::copyPixels - Alpha");
                                return;
                            }

                            // Deal with fractional pixel coordinates, looks like Flash "rounds" the corners of
                            // the source rect, however a width of |0.5| rounds down rather than up so we're not
                            // quite correct here.
                            var sR = sourceRect.clone().roundInPlace();

                            // Remember the original source rect in case in case the intersection changes it.
                            var oR = sR.clone();
                            var sR = sR.intersectInPlace(sourceBitmapData._rect);

                            // Clipped source rect is empty so there's nothing to do.
                            if (sR.isEmpty()) {
                                _AVM2.leaveTimeline();
                                return;
                            }

                            // Compute source rect offsets (in case the source rect had negative x, y coordinates).
                            var oX = sR.x - oR.x;
                            var oY = sR.y - oR.y;

                            // Compute the target rect taking into account the offsets and then clip it against the
                            // target.
                            var tR = new flash.geom.Rectangle(destPoint.x | 0 + oX, destPoint.y | 0 + oY, oR.width - oX, oR.height - oY);

                            tR.intersectInPlace(this._rect);

                            var sX = sR.x;
                            var sY = sR.y;

                            var tX = tR.x;
                            var tY = tR.y;

                            var tW = tR.width;
                            var tH = tR.height;

                            var sStride = sourceBitmapData._rect.width;
                            var tStride = this._rect.width;

                            var s = sourceBitmapData._view;
                            var t = this._view;

                            if (sourceBitmapData._type !== this._type) {
                                somewhatImplemented("public flash.display.BitmapData::copyPixels - Color Format Conversion");
                            }

                            if (mergeAlpha && this._type !== 1 /* PremultipliedAlphaARGB */) {
                                notImplemented("public flash.display.BitmapData::copyPixels - Merge Alpha");
                                return;
                            }

                            // Finally do the copy. All the math above is needed just so we don't do any branches inside
                            // this hot loop.
                            if (mergeAlpha) {
                                var sP = sY * sStride + sX;
                                var tP = tY * tStride + tX;
                                for (var y = 0; y < tH; y++) {
                                    for (var x = 0; x < tW; x++) {
                                        var spBGRA = s[sP + x];
                                        if ((spBGRA & 0xFF) === 0xFF) {
                                            t[tP + x] = spBGRA; // Opaque, just copy value over.
                                        } else {
                                            t[tP + x] = blendPremultipliedBGRA(t[tP + x], spBGRA);
                                        }
                                    }
                                    sP += sStride;
                                    tP += tStride;
                                }
                            } else {
                                var sP = sY * sStride + sX;
                                var tP = tY * tStride + tX;
                                if ((tW & 3) === 0) {
                                    for (var y = 0; y < tH; y++) {
                                        for (var x = 0; x < tW; x += 4) {
                                            t[tP + x + 0] = s[sP + x + 0];
                                            t[tP + x + 1] = s[sP + x + 1];
                                            t[tP + x + 2] = s[sP + x + 2];
                                            t[tP + x + 3] = s[sP + x + 3];
                                        }
                                        sP += sStride;
                                        tP += tStride;
                                    }
                                } else {
                                    for (var y = 0; y < tH; y++) {
                                        for (var x = 0; x < tW; x++) {
                                            t[tP + x] = s[sP + x];
                                        }
                                        sP += sStride;
                                        tP += tStride;
                                    }
                                }
                            }

                            this._invalidate();
                            somewhatImplemented("public flash.display.BitmapData::copyPixels");
                            _AVM2.leaveTimeline();
                        };

                        BitmapData.prototype.dispose = function () {
                            this._rect.setEmpty();
                            this._view = null;
                            this._invalidate();
                        };

                        BitmapData.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof colorTransform === "undefined") { colorTransform = null; }
                            if (typeof blendMode === "undefined") { blendMode = null; }
                            if (typeof clipRect === "undefined") { clipRect = null; }
                            if (typeof smoothing === "undefined") { smoothing = false; }
                            somewhatImplemented("public flash.display.BitmapData::draw");
                            var serializer = AVM2.instance.globals['Shumway.Player.Utils'];
                            if (matrix) {
                                matrix = matrix.clone().toTwipsInPlace();
                            }
                            serializer.drawToBitmap(this, source, matrix, colorTransform, blendMode, clipRect, smoothing);
                            this._isRemoteDirty = true;
                        };

                        BitmapData.prototype.drawWithQuality = function (source, matrix, colorTransform, blendMode, clipRect, smoothing, quality) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof colorTransform === "undefined") { colorTransform = null; }
                            if (typeof blendMode === "undefined") { blendMode = null; }
                            if (typeof clipRect === "undefined") { clipRect = null; }
                            if (typeof smoothing === "undefined") { smoothing = false; }
                            if (typeof quality === "undefined") { quality = null; }
                            source = source;
                            matrix = matrix;
                            colorTransform = colorTransform;
                            blendMode = asCoerceString(blendMode);
                            clipRect = clipRect;
                            smoothing = !!smoothing;
                            quality = asCoerceString(quality);
                            notImplemented("public flash.display.BitmapData::drawWithQuality");
                            return;
                        };

                        BitmapData.prototype.fillRect = function (rect, uARGB /*uint*/ ) {
                            if (this._transparent) {
                                var pARGB = premultiplyARGB(uARGB);
                            } else {
                                var pARGB = uARGB | 0xff000000;
                            }
                            release || assert(this._type === 1 /* PremultipliedAlphaARGB */);
                            var pBGRA = swap32(pARGB);
                            var r = this.rect.intersectInPlace(rect);
                            if (r.isEmpty()) {
                                return;
                            }
                            var xMin = r.x;
                            var xMax = r.x + r.width;
                            var yMin = r.y;
                            var yMax = r.y + r.height;
                            var view = this._view;
                            var width = this._rect.width;
                            for (var y = yMin; y < yMax; y++) {
                                var offset = y * width;
                                for (var x = xMin; x < xMax; x++) {
                                    view[offset + x] = pBGRA;
                                }
                            }
                            this._invalidate();
                        };

                        BitmapData.prototype.floodFill = function (x /*int*/ , y /*int*/ , color /*uint*/ ) {
                            x = x | 0;
                            y = y | 0;
                            color = color >>> 0;
                            notImplemented("public flash.display.BitmapData::floodFill");
                            return;
                        };

                        BitmapData.prototype.generateFilterRect = function (sourceRect, filter) {
                            sourceRect = sourceRect;
                            filter = filter;
                            notImplemented("public flash.display.BitmapData::generateFilterRect");
                            return;
                        };

                        BitmapData.prototype.getColorBoundsRect = function (mask /*uint*/ , color /*uint*/ , findColor) {
                            if (typeof findColor === "undefined") { findColor = true; }
                            mask = mask >>> 0;
                            color = color >>> 0;
                            findColor = !!findColor;
                            notImplemented("public flash.display.BitmapData::getColorBoundsRect");
                            return;
                        };

                        BitmapData.prototype.getPixels = function (rect) {
                            var outputByteArray = new flash.utils.ByteArray();
                            this.copyPixelsToByteArray(rect, outputByteArray);
                            return outputByteArray;
                        };

                        BitmapData.prototype.copyPixelsToByteArray = function (rect, data) {
                            var pixelData = this._getPixelData(rect);
                            if (!pixelData) {
                                return;
                            }
                            data.writeRawBytes(new Uint8Array(pixelData));
                        };

                        BitmapData.prototype.getVector = function (rect) {
                            var outputVector = new AS.Uint32Vector(pixelData.length);
                            var pixelData = this._getPixelData(rect);
                            if (!pixelData) {
                                return outputVector;
                            }
                            outputVector.length = pixelData.length;
                            outputVector._view().set(pixelData);
                            return outputVector;
                        };

                        BitmapData.prototype.hitTest = function (firstPoint, firstAlphaThreshold /*uint*/ , secondObject, secondBitmapDataPoint, secondAlphaThreshold) {
                            if (typeof secondBitmapDataPoint === "undefined") { secondBitmapDataPoint = null; }
                            if (typeof secondAlphaThreshold === "undefined") { secondAlphaThreshold = 1; }
                            firstPoint = firstPoint;
                            firstAlphaThreshold = firstAlphaThreshold >>> 0;
                            secondObject = secondObject;
                            secondBitmapDataPoint = secondBitmapDataPoint;
                            secondAlphaThreshold = secondAlphaThreshold >>> 0;
                            notImplemented("public flash.display.BitmapData::hitTest");
                            return;
                        };

                        BitmapData.prototype.merge = function (sourceBitmapData, sourceRect, destPoint, redMultiplier /*uint*/ , greenMultiplier, blueMultiplier /*uint*/ , alphaMultiplier /*uint*/ ) {
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            redMultiplier = redMultiplier >>> 0;
                            greenMultiplier = greenMultiplier >>> 0;
                            blueMultiplier = blueMultiplier >>> 0;
                            alphaMultiplier = alphaMultiplier >>> 0;
                            somewhatImplemented("public flash.display.BitmapData::merge");
                        };

                        BitmapData.prototype.noise = function (randomSeed /*int*/ , low, high, channelOptions, grayScale) {
                            if (typeof low === "undefined") { low = 0; }
                            if (typeof high === "undefined") { high = 255; }
                            if (typeof channelOptions === "undefined") { channelOptions = 7; }
                            if (typeof grayScale === "undefined") { grayScale = false; }
                            randomSeed = randomSeed | 0;
                            low = low >>> 0;
                            high = high >>> 0;
                            channelOptions = channelOptions >>> 0;
                            grayScale = !!grayScale;
                            somewhatImplemented("public flash.display.BitmapData::noise");
                        };

                        BitmapData.prototype.paletteMap = function (sourceBitmapData, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray) {
                            if (typeof redArray === "undefined") { redArray = null; }
                            if (typeof greenArray === "undefined") { greenArray = null; }
                            if (typeof blueArray === "undefined") { blueArray = null; }
                            if (typeof alphaArray === "undefined") { alphaArray = null; }
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            redArray = redArray;
                            greenArray = greenArray;
                            blueArray = blueArray;
                            alphaArray = alphaArray;
                            somewhatImplemented("public flash.display.BitmapData::paletteMap");
                        };

                        BitmapData.prototype.perlinNoise = function (baseX, baseY, numOctaves /*uint*/ , randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets) {
                            if (typeof channelOptions === "undefined") { channelOptions = 7; }
                            if (typeof grayScale === "undefined") { grayScale = false; }
                            if (typeof offsets === "undefined") { offsets = null; }
                            baseX = +baseX;
                            baseY = +baseY;
                            numOctaves = numOctaves >>> 0;
                            randomSeed = randomSeed | 0;
                            stitch = !!stitch;
                            fractalNoise = !!fractalNoise;
                            channelOptions = channelOptions >>> 0;
                            grayScale = !!grayScale;
                            offsets = offsets;
                            somewhatImplemented("public flash.display.BitmapData::perlinNoise");
                        };

                        BitmapData.prototype.pixelDissolve = function (sourceBitmapData, sourceRect, destPoint, randomSeed, numPixels, fillColor) {
                            if (typeof randomSeed === "undefined") { randomSeed = 0; }
                            if (typeof numPixels === "undefined") { numPixels = 0; }
                            if (typeof fillColor === "undefined") { fillColor = 0; }
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            randomSeed = randomSeed | 0;
                            numPixels = numPixels | 0;
                            fillColor = fillColor >>> 0;
                            notImplemented("public flash.display.BitmapData::pixelDissolve");
                            return;
                        };

                        BitmapData.prototype.scroll = function (x /*int*/ , y /*int*/ ) {
                            x = x | 0;
                            y = y | 0;
                            notImplemented("public flash.display.BitmapData::scroll");
                            return;
                        };

                        BitmapData.prototype.setPixels = function (rect, inputByteArray) {
                            this._putPixelData(rect, new Int32Array(inputByteArray.readRawBytes()));
                        };

                        BitmapData.prototype.setVector = function (rect, inputVector) {
                            this._putPixelData(rect, inputVector._view());
                        };

                        BitmapData.prototype.threshold = function (sourceBitmapData, sourceRect, destPoint, operation, threshold /*uint*/ , color, mask, copySource) {
                            if (typeof color === "undefined") { color = 0; }
                            if (typeof mask === "undefined") { mask = 4294967295; }
                            if (typeof copySource === "undefined") { copySource = false; }
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            operation = asCoerceString(operation);
                            threshold = threshold >>> 0;
                            color = color >>> 0;
                            mask = mask >>> 0;
                            copySource = !!copySource;
                            notImplemented("public flash.display.BitmapData::threshold");
                            return;
                        };

                        BitmapData.prototype.lock = function () {
                            this._locked = true;
                        };

                        BitmapData.prototype.unlock = function (changeRect) {
                            if (typeof changeRect === "undefined") { changeRect = null; }
                            //changeRect = changeRect;
                            this._locked = false;
                        };

                        BitmapData.prototype.histogram = function (hRect) {
                            if (typeof hRect === "undefined") { hRect = null; }
                            hRect = hRect;
                            notImplemented("public flash.display.BitmapData::histogram");
                            return;
                        };

                        BitmapData.prototype.encode = function (rect, compressor, byteArray) {
                            if (typeof byteArray === "undefined") { byteArray = null; }
                            rect = rect;
                            compressor = compressor;
                            byteArray = byteArray;
                            notImplemented("public flash.display.BitmapData::encode");
                            return;
                        };

                        /**
                        * Sends a synchronous message to the GFX remote requesting the latest image data. The remote image
                        * data is invalidated whenever a |BitmpaData.draw| call is made.
                        */
                        BitmapData.prototype._requestBitmapData = function () {
                            if (this._isRemoteDirty) {
                                var serializer = Shumway.AVM2.Runtime.AVM2.instance.globals['Shumway.Player.Utils'];
                                var data = serializer.requestBitmapData(this);
                                this._data = new Uint8Array(data.buffer);
                                this._type = 3 /* StraightAlphaRGBA */;
                                this._view = new Int32Array(data.buffer);
                                this._isRemoteDirty = false;
                                this._isDirty = false;
                            }
                        };
                        BitmapData.classInitializer = function () {
                            ensureInverseSourceAlphaTable();
                        };

                        BitmapData.initializer = function (symbol) {
                            this._symbol = symbol;
                        };

                        BitmapData.classSymbols = null;
                        BitmapData.instanceSymbols = null;

                        BitmapData.MAXIMUM_WIDTH = 8191;
                        BitmapData.MAXIMUM_HEIGHT = 8191;
                        BitmapData.MAXIMUM_DIMENSION = 16777215;
                        return BitmapData;
                    })(AS.ASNative);
                    display.BitmapData = BitmapData;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(_AVM2.AS || (_AVM2.AS = {}));
        var AS = _AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BitmapDataChannel
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var BitmapDataChannel = (function (_super) {
                        __extends(BitmapDataChannel, _super);
                        function BitmapDataChannel() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.BitmapDataChannel");
                        }
                        BitmapDataChannel.classInitializer = null;

                        BitmapDataChannel.initializer = null;

                        BitmapDataChannel.classSymbols = null;

                        BitmapDataChannel.instanceSymbols = null;

                        BitmapDataChannel.RED = 1;
                        BitmapDataChannel.GREEN = 2;
                        BitmapDataChannel.BLUE = 4;
                        BitmapDataChannel.ALPHA = 8;
                        return BitmapDataChannel;
                    })(AS.ASNative);
                    display.BitmapDataChannel = BitmapDataChannel;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BitmapEncodingColorSpace
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var BitmapEncodingColorSpace = (function (_super) {
                        __extends(BitmapEncodingColorSpace, _super);
                        function BitmapEncodingColorSpace() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.BitmapEncodingColorSpace");
                        }
                        BitmapEncodingColorSpace.classInitializer = null;

                        BitmapEncodingColorSpace.initializer = null;

                        BitmapEncodingColorSpace.classSymbols = null;

                        BitmapEncodingColorSpace.instanceSymbols = null;

                        BitmapEncodingColorSpace.COLORSPACE_AUTO = "auto";
                        BitmapEncodingColorSpace.COLORSPACE_4_4_4 = "4:4:4";
                        BitmapEncodingColorSpace.COLORSPACE_4_2_2 = "4:2:2";
                        BitmapEncodingColorSpace.COLORSPACE_4_2_0 = "4:2:0";
                        return BitmapEncodingColorSpace;
                    })(AS.ASNative);
                    display.BitmapEncodingColorSpace = BitmapEncodingColorSpace;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IBitmapDrawable
                (function (display) {
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: JPEGEncoderOptions
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var JPEGEncoderOptions = (function (_super) {
                        __extends(JPEGEncoderOptions, _super);
                        function JPEGEncoderOptions(quality) {
                            if (typeof quality === "undefined") { quality = 80; }
                            quality = quality >>> 0;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.JPEGEncoderOptions");
                        }
                        JPEGEncoderOptions.classInitializer = null;

                        JPEGEncoderOptions.initializer = null;

                        JPEGEncoderOptions.classSymbols = null;

                        JPEGEncoderOptions.instanceSymbols = null;
                        return JPEGEncoderOptions;
                    })(AS.ASNative);
                    display.JPEGEncoderOptions = JPEGEncoderOptions;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (_AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Loader
                (function (display) {
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var FileLoadingService = Shumway.FileLoadingService;
                    var Telemetry = Shumway.Telemetry;

                    var AVM2 = Shumway.AVM2.Runtime.AVM2;
                    var AbcFile = Shumway.AVM2.ABC.AbcFile;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var events = flash.events;
                    var ActionScriptVersion = flash.display.ActionScriptVersion;

                    var Bounds = Shumway.Bounds;

                    var LoadStatus;
                    (function (LoadStatus) {
                        LoadStatus[LoadStatus["Unloaded"] = 0] = "Unloaded";
                        LoadStatus[LoadStatus["Opened"] = 1] = "Opened";
                        LoadStatus[LoadStatus["Initialized"] = 2] = "Initialized";
                        LoadStatus[LoadStatus["Complete"] = 3] = "Complete";
                    })(LoadStatus || (LoadStatus = {}));

                    var Loader = (function (_super) {
                        __extends(Loader, _super);
                        function Loader() {
                            false && _super.call(this);
                            display.DisplayObjectContainer.instanceConstructorNoInitialize.call(this);

                            this._content = null;
                            this._contentLoaderInfo = new flash.display.LoaderInfo();

                            this._worker = null;
                            this._loadStatus = 0 /* Unloaded */;

                            this._contentLoaderInfo._loader = this;

                            this._commitDataQueue = Promise.resolve();

                            this._codeExecutionPromise = new Shumway.PromiseWrapper();
                            this._progressPromise = new Shumway.PromiseWrapper();
                            this._startPromise = Promise.all([
                                this._codeExecutionPromise.promise,
                                this._progressPromise.promise
                            ]);
                        }
                        /**
                        * Creates or returns the root Loader instance. The loader property of that instances LoaderInfo
                        * object is always null. Also, no OPEN event ever gets dispatched.
                        */
                        Loader.getRootLoader = function () {
                            if (Loader._rootLoader) {
                                return Loader._rootLoader;
                            }
                            var loader = new flash.display.Loader();
                            loader._contentLoaderInfo._loader = null;
                            loader._loadStatus = 1 /* Opened */;
                            Loader._rootLoader = loader;
                            return loader;
                        };

                        Loader.reset = function () {
                            Loader._rootLoader = null;
                        };

                        /**
                        * Handles the load status and dispatches progress events. This gets manually triggered in the
                        * event loop to ensure the correct order of operations.
                        */
                        Loader.progress = function () {
                            var queue = Loader._loadQueue;
                            for (var i = 0; i < queue.length; i++) {
                                var instance = queue[i];
                                var loaderInfo = instance._contentLoaderInfo;
                                var bytesLoaded = loaderInfo._bytesLoaded;
                                var bytesTotal = loaderInfo._bytesTotal;
                                switch (instance._loadStatus) {
                                    case 0 /* Unloaded */:
                                        if (bytesTotal) {
                                            loaderInfo.dispatchEvent(events.Event.getInstance(events.Event.OPEN));
                                            loaderInfo.dispatchEvent(new events.ProgressEvent(events.ProgressEvent.PROGRESS, false, false, 0, bytesTotal));
                                            instance._loadStatus = 1 /* Opened */;
                                        } else {
                                            break;
                                        }
                                    case 1 /* Opened */:
                                        if (instance._content && instance._content._hasFlags(256 /* Constructed */)) {
                                            instance._loadStatus = 2 /* Initialized */;
                                            loaderInfo.dispatchEvent(events.Event.getInstance(events.Event.INIT));
                                        } else {
                                            break;
                                        }
                                    case 2 /* Initialized */:
                                        if (bytesLoaded === bytesTotal) {
                                            instance._loadStatus = 3 /* Complete */;
                                            loaderInfo.dispatchEvent(new events.ProgressEvent(events.ProgressEvent.PROGRESS, false, false, bytesLoaded, bytesTotal));
                                            loaderInfo.dispatchEvent(events.Event.getInstance(events.Event.COMPLETE));
                                            queue.splice(i--, 0);
                                        }
                                        break;
                                }
                            }
                        };

                        Loader.prototype._initFrame = function (advance) {
                            // ...
                        };

                        Loader.prototype._constructFrame = function () {
                            this._constructChildren();
                        };

                        Loader.prototype._commitData = function (data) {
                            this._commitDataQueue = this._commitDataQueue.then(this._commitQueuedData.bind(this, data));
                        };

                        Loader.prototype._commitQueuedData = function (data) {
                            var loaderInfo = this._contentLoaderInfo;
                            var command = data.command;
                            var suspendUntil = null;
                            switch (command) {
                                case 'init':
                                    var info = data.result;

                                    loaderInfo._bytesLoaded = info.bytesLoaded;
                                    loaderInfo._bytesTotal = info.bytesTotal;
                                    loaderInfo._swfVersion = info.swfVersion;
                                    if (!info.fileAttributes || !info.fileAttributes.doAbc) {
                                        loaderInfo._actionScriptVersion = ActionScriptVersion.ACTIONSCRIPT2;
                                        suspendUntil = this._initAvm1(loaderInfo);
                                    }
                                    loaderInfo._frameRate = info.frameRate;
                                    var bbox = info.bbox;
                                    loaderInfo._width = bbox.xMax - bbox.xMin;
                                    loaderInfo._height = bbox.yMax - bbox.yMin;

                                    var rootSymbol = new Shumway.Timeline.SpriteSymbol(0, true);
                                    rootSymbol.numFrames = info.frameCount;
                                    loaderInfo.registerSymbol(rootSymbol);
                                    break;
                                case 'progress':
                                    var info = data.result;
                                    var bytesLoaded = info.bytesLoaded;
                                    var bytesTotal = info.bytesTotal;
                                    release || assert(bytesLoaded <= bytesTotal, "Loaded bytes should not exceed total bytes.");
                                    loaderInfo._bytesLoaded = bytesLoaded;
                                    if (!loaderInfo._bytesTotal) {
                                        loaderInfo._bytesTotal = bytesTotal;
                                    } else {
                                        release || assert(loaderInfo._bytesTotal === bytesTotal, "Total bytes should not change.");
                                    }
                                    if (this._loadStatus !== 0 /* Unloaded */) {
                                        loaderInfo.dispatchEvent(new events.ProgressEvent(events.ProgressEvent.PROGRESS, false, false, bytesLoaded, bytesTotal));
                                        this._progressPromise.resolve(undefined);
                                    }
                                    break;
                                case 'complete':
                                    if (data.stats) {
                                        Telemetry.instance.reportTelemetry(data.stats);
                                    }

                                    this._worker && this._worker.terminate();
                                    break;

                                case 'error':
                                    this._contentLoaderInfo.dispatchEvent(new events.IOErrorEvent(events.IOErrorEvent.IO_ERROR));
                                    break;
                                default:
                                    //TODO: fix special-casing. Might have to move document class out of dictionary[0].
                                    if (data.id === 0) {
                                        break;
                                    }
                                    if (data.isSymbol) {
                                        this._commitAsset(data);
                                    } else if (data.type === 'frame') {
                                        this._commitFrame(data);
                                    } else if (data.type === 'image') {
                                        this._commitImage(data);
                                    } else if (data.type === 'abc') {
                                        var appDomain = AVM2.instance.applicationDomain;
                                        var abc = new AbcFile(data.data, data.name);
                                        if (data.flags) {
                                            // kDoAbcLazyInitializeFlag = 1 Indicates that the ABC block should not be executed
                                            // immediately.
                                            appDomain.loadAbc(abc);
                                        } else {
                                            if (loaderInfo._allowCodeExecution) {
                                                appDomain.executeAbc(abc);
                                            }
                                        }
                                    }
                                    break;
                            }
                            return suspendUntil;
                        };

                        Loader.prototype._initAvm1 = function (loaderInfo) {
                            return AVM2.instance.loadAVM1().then(function () {
                                loaderInfo._avm1Context = Shumway.AVM1.AS2Context.create(loaderInfo.swfVersion);
                            });
                        };

                        Loader.prototype._commitAsset = function (data) {
                            var loaderInfo = this._contentLoaderInfo;
                            var symbolId = data.id;
                            var symbol;
                            if (data.updates) {
                                var updates = data.updates;
                                symbol = loaderInfo.getSymbolById(symbolId);
                                if (updates.scale9Grid) {
                                    symbol.scale9Grid = Bounds.FromUntyped(updates.scale9Grid);
                                }
                                return;
                            }
                            switch (data.type) {
                                case 'shape':
                                    symbol = Shumway.Timeline.ShapeSymbol.FromData(data, loaderInfo);
                                    break;
                                case 'morphshape':
                                    symbol = Shumway.Timeline.MorphShapeSymbol.FromData(data, loaderInfo);
                                    break;
                                case 'image':
                                    symbol = Shumway.Timeline.BitmapSymbol.FromData(data);
                                    break;
                                case 'label':
                                case 'text':
                                    symbol = Shumway.Timeline.TextSymbol.FromTextData(data);
                                    break;
                                case 'button':
                                    symbol = Shumway.Timeline.ButtonSymbol.FromData(data, loaderInfo);
                                    break;
                                case 'sprite':
                                    symbol = Shumway.Timeline.SpriteSymbol.FromData(data, loaderInfo);
                                    break;
                                case 'font':
                                    symbol = Shumway.Timeline.FontSymbol.FromData(data);
                                    var font = flash.text.Font.initializeFrom(symbol);
                                    flash.text.Font.instanceConstructorNoInitialize.call(font);
                                    AVM2.instance.globals['Shumway.Player.Utils'].registerFont(font);
                                    break;
                                case 'sound':
                                    symbol = Shumway.Timeline.SoundSymbol.FromData(data);
                                    break;
                                case 'binary':
                                    symbol = Shumway.Timeline.BinarySymbol.FromData(data);
                                    break;
                            }
                            release || assert(symbol, "Unknown symbol type.");
                            loaderInfo.registerSymbol(symbol);
                        };

                        Loader.prototype._commitFrame = function (data) {
                            var loaderInfo = this._contentLoaderInfo;

                            // HACK: Someone should figure out how to set the color on the stage better.
                            if (data.bgcolor !== undefined) {
                                loaderInfo._colorRGBA = data.bgcolor;
                            }

                            if (data.symbolClasses) {
                                var symbolClasses = data.symbolClasses;
                                var appDomain = AVM2.instance.applicationDomain;
                                for (var i = 0; i < symbolClasses.length; i++) {
                                    var asset = symbolClasses[i];
                                    if (loaderInfo._allowCodeExecution) {
                                        var symbolClass = appDomain.getClass(asset.className);
                                        var symbol = loaderInfo.getSymbolById(asset.symbolId);
                                        release || assert(symbol, "Symbol is not defined.");
                                        symbolClass.defaultInitializerArgument = symbol;
                                        symbol.symbolClass = symbolClass;
                                    }
                                }
                            }

                            if (data.exports && loaderInfo._actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                                var exports = data.exports;
                                for (var i = 0; i < exports.length; i++) {
                                    var asset = exports[i];
                                    var symbol = loaderInfo.getSymbolById(asset.symbolId);
                                    release || assert(symbol);
                                    loaderInfo._avm1Context.addAsset(asset.className, symbol);
                                }
                            }

                            var rootSymbol = loaderInfo.getSymbolById(0);
                            var documentClass = rootSymbol.symbolClass;
                            var frames = rootSymbol.frames;
                            var frameIndex = frames.length;

                            var frame = new Shumway.Timeline.FrameDelta(loaderInfo, data.commands);
                            var repeat = data.repeat;
                            while (repeat--) {
                                frames.push(frame);
                            }

                            var root = this._content;
                            if (!root) {
                                root = documentClass.initializeFrom(rootSymbol);

                                if (display.MovieClip.isType(root)) {
                                    var mc = root;
                                    if (data.sceneData) {
                                        var scenes = data.sceneData.scenes;
                                        for (var i = 0, n = scenes.length; i < n; i++) {
                                            var sceneInfo = scenes[i];
                                            var offset = sceneInfo.offset;
                                            var endFrame = i < n - 1 ? scenes[i + 1].offset : rootSymbol.numFrames;
                                            mc.addScene(sceneInfo.name, [], offset, endFrame - offset);
                                        }
                                        var labels = data.sceneData.labels;
                                        for (var i = 0; i < labels.length; i++) {
                                            var labelInfo = labels[i];
                                            mc.addFrameLabel(labelInfo.name, labelInfo.frame + 1);
                                        }
                                    } else {
                                        mc.addScene('Scene 1', [], 0, rootSymbol.numFrames);
                                    }
                                }

                                if (loaderInfo._actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                                    this._initAvm1Root(root);
                                }

                                this._codeExecutionPromise.resolve(undefined);

                                root._loaderInfo = loaderInfo;
                                this._content = root;
                                this.addChildAtDepth(this._content, 0);
                            }

                            if (display.MovieClip.isType(root)) {
                                var rootMovie = root;

                                if (data.labelName) {
                                    rootMovie.addFrameLabel(data.labelName, frameIndex + 1);
                                }

                                if (loaderInfo._actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                                    this._executeAvm1Actions(rootMovie, frameIndex, data);
                                }

                                if (data.startSounds) {
                                    rootMovie._registerStartSounds(frameIndex + 1, data.startSounds);
                                }
                                if (data.soundStream) {
                                    rootMovie._initSoundStream(data.soundStream);
                                }
                                if (data.soundStreamBlock) {
                                    rootMovie._addSoundStreamBlock(frameIndex, data.soundStreamBlock);
                                }
                            }
                        };

                        Loader.prototype._initAvm1Root = function (root) {
                            // Finding movie top root
                            var topRoot = root;
                            var parent = this._parent;
                            if (parent && parent !== this._stage) {
                                var parentLoader = parent.loaderInfo._loader;
                                while (parentLoader._parent && parentLoader._parent !== this._stage) {
                                    parentLoader = parentLoader._parent.loaderInfo._loader;
                                }
                                if (parentLoader.loaderInfo._actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                                    notImplemented('AVM1Movie');
                                    this._worker && this._worker.terminate();
                                    return;
                                }
                                topRoot = parentLoader._content;
                            }

                            var avm1Context = this._contentLoaderInfo._avm1Context;
                            var as2Object = Shumway.AVM1.getAS2Object(topRoot);
                            avm1Context.globals.asSetPublicProperty('_root', as2Object);
                            avm1Context.globals.asSetPublicProperty('_level0', as2Object);

                            // transfer parameters
                            var parameters = this._contentLoaderInfo._parameters;
                            for (var paramName in parameters) {
                                if (!(paramName in as2Object)) {
                                    as2Object[paramName] = parameters[paramName];
                                }
                            }
                        };

                        Loader.prototype._executeAvm1Actions = function (root, frameIndex, frameData) {
                            var initActionBlocks = frameData.initActionBlocks;
                            var actionBlocks = frameData.actionBlocks;

                            if (initActionBlocks) {
                                var loaderInfo = this._contentLoaderInfo;
                                for (var i = 0; i < initActionBlocks.length; i++) {
                                    var actionBlock = initActionBlocks[i];
                                    if (actionBlock.spriteId === 0) {
                                        root.addAS2InitActionBlock(frameIndex, actionBlock);
                                    } else {
                                        var symbol = loaderInfo.getSymbolById(actionBlock.spriteId);
                                        symbol.initActionBlock = actionBlock;
                                    }
                                }
                            }

                            if (actionBlocks) {
                                for (var i = 0; i < actionBlocks.length; i++) {
                                    root.addAS2FrameScript(frameIndex, actionBlocks[i]);
                                }
                            }
                        };

                        Loader.prototype._commitImage = function (data) {
                            var b = new display.BitmapData(data.width, data.height);
                            this._content = new display.Bitmap(b);
                            this.addChildAtDepth(this._content, 0);

                            var loaderInfo = this._contentLoaderInfo;
                            loaderInfo._width = data.width;
                            loaderInfo._height = data.height;
                        };

                        Object.defineProperty(Loader.prototype, "content", {
                            get: function () {
                                if (this._loadStatus === 0 /* Unloaded */) {
                                    return null;
                                }
                                return this._content;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Loader.prototype, "contentLoaderInfo", {
                            get: function () {
                                return this._contentLoaderInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Loader.prototype._close = function () {
                            if (this._worker && this._loadStatus === 0 /* Unloaded */) {
                                this._worker.terminate();
                                this._worker = null;
                            }
                        };

                        Loader.prototype._unload = function (stopExecution, gc) {
                            stopExecution = !!stopExecution;
                            gc = !!gc;
                            if (this._loadStatus < 2 /* Initialized */) {
                                return;
                            }
                            this._content = null;
                            this._contentLoaderInfo._loader = null;
                            this._worker = null;
                            this._loadStatus = 0 /* Unloaded */;
                            this.dispatchEvent(events.Event.getInstance(events.Event.UNLOAD));
                        };

                        Loader.prototype._getJPEGLoaderContextdeblockingfilter = function (context) {
                            if (flash.system.JPEGLoaderContext.isType(context)) {
                                return context.deblockingFilter;
                            }
                            return 0.0;
                        };

                        Loader.prototype._getUncaughtErrorEvents = function () {
                            notImplemented("public flash.display.Loader::_getUncaughtErrorEvents");
                            return;
                        };
                        Loader.prototype._setUncaughtErrorEvents = function (value) {
                            value = value;
                            notImplemented("public flash.display.Loader::_setUncaughtErrorEvents");
                            return;
                        };

                        Loader.prototype._load = function (request, checkPolicyFile, applicationDomain, securityDomain, requestedContentParent, parameters, deblockingFilter, allowCodeExecution, imageDecodingPolicy) {
                            var loaderInfo = this._contentLoaderInfo;

                            //request = request; checkPolicyFile = !!checkPolicyFile; applicationDomain = applicationDomain; securityDomain = securityDomain; requestedContentParent = requestedContentParent; parameters = parameters; deblockingFilter = +deblockingFilter; allowCodeExecution = !!allowCodeExecution; imageDecodingPolicy = asCoerceString(imageDecodingPolicy);
                            //if (flash.net.URLRequest.isType(request)) {
                            this._contentLoaderInfo._url = request.url;

                            //}
                            var worker;
                            if (Loader.WORKERS_ENABLED) {
                                var loaderPath = typeof LOADER_WORKER_PATH !== 'undefined' ? LOADER_WORKER_PATH : SHUMWAY_ROOT + Loader.LOADER_PATH;
                                worker = new Worker(loaderPath);
                            } else {
                                var ResourceLoader = Shumway.SWF.ResourceLoader;
                                worker = new ResourceLoader(window, false);
                            }
                            if (!loaderInfo._allowCodeExecution) {
                                this._codeExecutionPromise.reject('Disabled by _allowCodeExecution');
                            }
                            var loader = this;

                            //loader._worker = worker;
                            worker.onmessage = function (e) {
                                if (e.data.type === 'exception') {
                                    console.log('error in parser: \n' + e.data.stack);
                                    AVM2.instance.exceptions.push({
                                        source: 'parser',
                                        message: e.data.message,
                                        stack: e.data.stack
                                    });
                                } else {
                                    loader._commitData(e.data);
                                }
                            };

                            //if (flash.net.URLRequest.class.isInstanceOf(request)) {
                            var session = FileLoadingService.instance.createSession();
                            session.onprogress = function (data, progress) {
                                worker.postMessage({ data: data, progress: progress });
                            };
                            session.onerror = function (error) {
                                loader._commitData({ command: 'error', error: error });
                            };
                            session.onopen = function () {
                                worker.postMessage('pipe:');
                            };
                            session.onclose = function () {
                                worker.postMessage({ data: null });
                            };
                            session.open(request._toFileRequest());

                            //} else {
                            //  worker.postMessage(request);
                            //}
                            Loader._loadQueue.push(this);
                        };

                        Loader.prototype._loadBytes = function (bytes, checkPolicyFile, applicationDomain, securityDomain, requestedContentParent, parameters, deblockingFilter, allowCodeExecution, imageDecodingPolicy) {
                            bytes = bytes;
                            checkPolicyFile = !!checkPolicyFile;
                            applicationDomain = applicationDomain;
                            securityDomain = securityDomain;
                            requestedContentParent = requestedContentParent;
                            parameters = parameters;
                            deblockingFilter = +deblockingFilter;
                            allowCodeExecution = !!allowCodeExecution;
                            imageDecodingPolicy = asCoerceString(imageDecodingPolicy);
                            notImplemented("public flash.display.Loader::_loadBytes");
                            return;
                        };
                        Loader.classInitializer = function () {
                            Loader._rootLoader = null;
                            Loader._loadQueue = [];
                        };

                        Loader.initializer = function () {
                            var self = this;
                            display.DisplayObject._advancableInstances.push(self);
                        };

                        Loader.classSymbols = null;

                        Loader.instanceSymbols = ["load!"];

                        Loader.WORKERS_ENABLED = typeof Worker !== 'undefined';
                        Loader.LOADER_PATH = 'swf/worker.js';
                        return Loader;
                    })(flash.display.DisplayObjectContainer);
                    display.Loader = Loader;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(_AVM2.AS || (_AVM2.AS = {}));
        var AS = _AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: LoaderInfo
                (function (display) {
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var ActionScriptVersion = flash.display.ActionScriptVersion;

                    var LoaderInfo = (function (_super) {
                        __extends(LoaderInfo, _super);
                        function LoaderInfo() {
                            false && _super.call(this, undefined);
                            flash.events.EventDispatcher.instanceConstructorNoInitialize.call(this);
                            this._loaderURL = '';
                            this._url = '';
                            this._isURLInaccessible = false;
                            this._bytesLoaded = 0;
                            this._bytesTotal = 0;
                            this._applicationDomain = null;
                            this._swfVersion = 9;
                            this._actionScriptVersion = ActionScriptVersion.ACTIONSCRIPT3;
                            release || assert(this._actionScriptVersion);
                            this._frameRate = 24;
                            this._parameters = null;
                            this._width = 0;
                            this._height = 0;
                            this._contentType = '';
                            this._sharedEvents = null;
                            this._parentSandboxBridge = null;
                            this._childSandboxBridge = null;
                            this._sameDomain = false;
                            this._childAllowsParent = false;
                            this._parentAllowsChild = false;
                            this._loader = null;
                            this._content = null;
                            this._bytes = null;
                            this._uncaughtErrorEvents = null;
                            this._allowCodeExecution = true;
                            this._dictionary = [];
                            this._avm1Context = null;

                            this._colorRGBA = 0xFFFFFFFF;
                        }
                        LoaderInfo.getLoaderInfoByDefinition = function (object) {
                            object = object;
                            notImplemented("public flash.display.LoaderInfo::static getLoaderInfoByDefinition");
                            return;
                        };

                        Object.defineProperty(LoaderInfo.prototype, "loaderURL", {
                            get: function () {
                                return this._loaderURL;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "url", {
                            get: function () {
                                return this._url;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "isURLInaccessible", {
                            get: function () {
                                return this._isURLInaccessible;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "bytesLoaded", {
                            get: function () {
                                return this._bytesLoaded;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "bytesTotal", {
                            get: function () {
                                return this._bytesTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "applicationDomain", {
                            get: function () {
                                somewhatImplemented("public flash.display.LoaderInfo::get applicationDomain");
                                return flash.system.ApplicationDomain.currentDomain;
                                // return this._applicationDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "swfVersion", {
                            get: function () {
                                return this._swfVersion;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "actionScriptVersion", {
                            get: function () {
                                return this._actionScriptVersion;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "frameRate", {
                            get: function () {
                                return this._frameRate;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "width", {
                            get: function () {
                                return (this._width / 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "height", {
                            get: function () {
                                return (this._height / 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "contentType", {
                            get: function () {
                                return this._contentType;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "sharedEvents", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get sharedEvents");
                                return;
                                // return this._sharedEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, "parentSandboxBridge", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get parentSandboxBridge");
                                return;
                                // return this._parentSandboxBridge;
                            },
                            set: function (door) {
                                door = door;
                                notImplemented("public flash.display.LoaderInfo::set parentSandboxBridge");
                                return;
                                // this._parentSandboxBridge = door;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, "childSandboxBridge", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get childSandboxBridge");
                                return;
                                // return this._childSandboxBridge;
                            },
                            set: function (door) {
                                door = door;
                                notImplemented("public flash.display.LoaderInfo::set childSandboxBridge");
                                return;
                                // this._childSandboxBridge = door;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, "sameDomain", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get sameDomain");
                                return;
                                // return this._sameDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, "childAllowsParent", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get childAllowsParent");
                                return;
                                // return this._childAllowsParent;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, "parentAllowsChild", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get parentAllowsChild");
                                return;
                                // return this._parentAllowsChild;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "loader", {
                            get: function () {
                                return this._loader;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "content", {
                            get: function () {
                                return this._loader && this._loader.content;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "bytes", {
                            get: function () {
                                notImplemented("public flash.display.LoaderInfo::get bytes");
                                return;
                                // return this._bytes;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(LoaderInfo.prototype, "parameters", {
                            get: function () {
                                somewhatImplemented("public flash.display.LoaderInfo::get parameters");
                                if (this._parameters) {
                                    return Shumway.ObjectUtilities.cloneObject(this._parameters);
                                }
                                return {};
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LoaderInfo.prototype._getUncaughtErrorEvents = function () {
                            notImplemented("public flash.display.LoaderInfo::_getUncaughtErrorEvents");
                            return;
                        };
                        LoaderInfo.prototype._setUncaughtErrorEvents = function (value) {
                            value = value;
                            notImplemented("public flash.display.LoaderInfo::_setUncaughtErrorEvents");
                            return;
                        };

                        LoaderInfo.prototype.registerSymbol = function (symbol) {
                            this._dictionary[symbol.id] = symbol;
                        };

                        LoaderInfo.prototype.getSymbolById = function (id) {
                            return this._dictionary[id] || null;
                        };
                        LoaderInfo.classInitializer = null;

                        LoaderInfo.initializer = null;

                        LoaderInfo.classSymbols = null;

                        LoaderInfo.instanceSymbols = null;
                        return LoaderInfo;
                    })(flash.events.EventDispatcher);
                    display.LoaderInfo = LoaderInfo;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MorphShape
                (function (display) {
                    var MorphShape = (function (_super) {
                        __extends(MorphShape, _super);
                        function MorphShape() {
                            false && _super.call(this);
                            display.DisplayObject.instanceConstructorNoInitialize.call(this);
                        }
                        MorphShape.prototype._canHaveGraphics = function () {
                            return true;
                        };

                        MorphShape.prototype._getGraphics = function () {
                            return this._graphics;
                        };

                        Object.defineProperty(MorphShape.prototype, "graphics", {
                            get: function () {
                                return this._ensureGraphics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MorphShape.classInitializer = null;

                        MorphShape.initializer = function (symbol) {
                            var self = this;
                            if (symbol) {
                                self._graphics = symbol.graphics;
                                self.morphFillBounds = symbol.morphFillBounds;
                                self.morphLineBounds = symbol.morphLineBounds;
                            } else {
                                self._graphics = new flash.display.Graphics();
                                self.morphFillBounds = null;
                                self.morphLineBounds = null;
                            }
                        };

                        MorphShape.classSymbols = null;

                        MorphShape.instanceSymbols = null;
                        return MorphShape;
                    })(flash.display.DisplayObject);
                    display.MorphShape = MorphShape;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NativeMenu
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var NativeMenu = (function (_super) {
                        __extends(NativeMenu, _super);
                        function NativeMenu() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.display.NativeMenu");
                        }
                        NativeMenu.classInitializer = null;

                        NativeMenu.initializer = null;

                        NativeMenu.classSymbols = null;

                        NativeMenu.instanceSymbols = null;
                        return NativeMenu;
                    })(flash.events.EventDispatcher);
                    display.NativeMenu = NativeMenu;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NativeMenuItem
                (function (display) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var NativeMenuItem = (function (_super) {
                        __extends(NativeMenuItem, _super);
                        function NativeMenuItem() {
                            false && _super.call(this, undefined);
                            flash.events.EventDispatcher.instanceConstructorNoInitialize.call(this);
                            this._enabled = true;
                        }
                        Object.defineProperty(NativeMenuItem.prototype, "enabled", {
                            get: function () {
                                somewhatImplemented("public flash.display.NativeMenuItem::get enabled");
                                return this._enabled;
                            },
                            set: function (isSeparator) {
                                isSeparator = !!isSeparator;
                                somewhatImplemented("public flash.display.NativeMenuItem::set enabled");
                                this._enabled = isSeparator;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NativeMenuItem.classInitializer = null;

                        NativeMenuItem.initializer = null;

                        NativeMenuItem.classSymbols = null;

                        NativeMenuItem.instanceSymbols = null;
                        return NativeMenuItem;
                    })(flash.events.EventDispatcher);
                    display.NativeMenuItem = NativeMenuItem;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: PNGEncoderOptions
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var PNGEncoderOptions = (function (_super) {
                        __extends(PNGEncoderOptions, _super);
                        function PNGEncoderOptions(fastCompression) {
                            if (typeof fastCompression === "undefined") { fastCompression = false; }
                            fastCompression = !!fastCompression;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.PNGEncoderOptions");
                        }
                        PNGEncoderOptions.classInitializer = null;

                        PNGEncoderOptions.initializer = null;

                        PNGEncoderOptions.classSymbols = null;

                        PNGEncoderOptions.instanceSymbols = null;
                        return PNGEncoderOptions;
                    })(AS.ASNative);
                    display.PNGEncoderOptions = PNGEncoderOptions;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: PixelSnapping
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var PixelSnapping = (function (_super) {
                        __extends(PixelSnapping, _super);
                        function PixelSnapping() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.PixelSnapping");
                        }
                        PixelSnapping.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return PixelSnapping.NEVER;
                                case 1:
                                    return PixelSnapping.ALWAYS;
                                case 2:
                                    return PixelSnapping.AUTO;
                                default:
                                    return null;
                            }
                        };

                        PixelSnapping.toNumber = function (value) {
                            switch (value) {
                                case PixelSnapping.NEVER:
                                    return 0;
                                case PixelSnapping.ALWAYS:
                                    return 1;
                                case PixelSnapping.AUTO:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        PixelSnapping.classInitializer = null;

                        PixelSnapping.initializer = null;

                        PixelSnapping.classSymbols = null;

                        PixelSnapping.instanceSymbols = null;

                        PixelSnapping.NEVER = "never";
                        PixelSnapping.ALWAYS = "always";
                        PixelSnapping.AUTO = "auto";
                        return PixelSnapping;
                    })(AS.ASNative);
                    display.PixelSnapping = PixelSnapping;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SWFVersion
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var SWFVersion = (function (_super) {
                        __extends(SWFVersion, _super);
                        function SWFVersion() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.SWFVersion");
                        }
                        SWFVersion.classInitializer = null;

                        SWFVersion.initializer = null;

                        SWFVersion.classSymbols = null;

                        SWFVersion.instanceSymbols = null;

                        SWFVersion.FLASH1 = 1;
                        SWFVersion.FLASH2 = 2;
                        SWFVersion.FLASH3 = 3;
                        SWFVersion.FLASH4 = 4;
                        SWFVersion.FLASH5 = 5;
                        SWFVersion.FLASH6 = 6;
                        SWFVersion.FLASH7 = 7;
                        SWFVersion.FLASH8 = 8;
                        SWFVersion.FLASH9 = 9;
                        SWFVersion.FLASH10 = 10;
                        SWFVersion.FLASH11 = 11;
                        SWFVersion.FLASH12 = 12;
                        return SWFVersion;
                    })(AS.ASNative);
                    display.SWFVersion = SWFVersion;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Scene
                (function (display) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var Scene = (function (_super) {
                        __extends(Scene, _super);
                        function Scene(name, labels, offset, numFrames /*int*/ ) {
                            false && _super.call(this);
                            this._name = asCoerceString(name);

                            // Note: creating Scene objects in ActionScript, while possible, is undocumented and entirely
                            // useless. Luckily, that also means that they're not very carefully implemented.
                            // Specifically, the `labels` array isn't cloned during construction or when returned from
                            // the getter. I.e., it can be modified freely.
                            this._labels = labels;
                            this.offset = offset;
                            this._numFrames = numFrames | 0;
                        }
                        Object.defineProperty(Scene.prototype, "name", {
                            get: function () {
                                return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Scene.prototype, "labels", {
                            get: function () {
                                return this._labels;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Scene.prototype, "numFrames", {
                            get: function () {
                                return this._numFrames;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Scene.prototype.clone = function () {
                            var labels = this._labels.map(function (label) {
                                return label.clone();
                            });
                            return new Scene(this._name, labels, this.offset, this._numFrames);
                        };
                        Scene.classInitializer = null;
                        Scene.initializer = null;
                        Scene.classSymbols = null;
                        Scene.instanceSymbols = null;
                        return Scene;
                    })(AS.ASNative);
                    display.Scene = Scene;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: StageAlign
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var StageAlignFlags;
                    (function (StageAlignFlags) {
                        StageAlignFlags[StageAlignFlags["None"] = 0] = "None";
                        StageAlignFlags[StageAlignFlags["Top"] = 1] = "Top";
                        StageAlignFlags[StageAlignFlags["Bottom"] = 2] = "Bottom";
                        StageAlignFlags[StageAlignFlags["Left"] = 4] = "Left";
                        StageAlignFlags[StageAlignFlags["Right"] = 8] = "Right";
                    })(StageAlignFlags || (StageAlignFlags = {}));

                    var StageAlign = (function (_super) {
                        __extends(StageAlign, _super);
                        function StageAlign() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.StageAlign");
                        }
                        StageAlign.fromNumber = function (n) {
                            if (n === 0) {
                                return "";
                            }
                            var s = "";
                            if (n & 1 /* Top */) {
                                s += "T";
                            }
                            if (n & 2 /* Bottom */) {
                                s += "B";
                            }
                            if (n & 4 /* Left */) {
                                s += "L";
                            }
                            if (n & 8 /* Right */) {
                                s += "R";
                            }
                            return s;
                        };

                        /**
                        * Looks like the Flash player just searches for the "T", "B", "L", "R" characters and
                        * maintains an internal bit field for alignment, for instance it's possible to set the
                        * alignment value "TBLR" even though there is no enum for it.
                        */
                        StageAlign.toNumber = function (value) {
                            var n = 0;
                            value = value.toUpperCase();
                            if (value.indexOf("T") >= 0) {
                                n |= 1 /* Top */;
                            }
                            if (value.indexOf("B") >= 0) {
                                n |= 2 /* Bottom */;
                            }
                            if (value.indexOf("L") >= 0) {
                                n |= 4 /* Left */;
                            }
                            if (value.indexOf("R") >= 0) {
                                n |= 8 /* Right */;
                            }
                            return n;
                        };
                        StageAlign.classInitializer = null;
                        StageAlign.initializer = null;
                        StageAlign.classSymbols = null;
                        StageAlign.instanceSymbols = null;

                        StageAlign.TOP = "T";
                        StageAlign.LEFT = "L";
                        StageAlign.BOTTOM = "B";
                        StageAlign.RIGHT = "R";
                        StageAlign.TOP_LEFT = "TL";
                        StageAlign.TOP_RIGHT = "TR";
                        StageAlign.BOTTOM_LEFT = "BL";
                        StageAlign.BOTTOM_RIGHT = "BR";
                        return StageAlign;
                    })(AS.ASNative);
                    display.StageAlign = StageAlign;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: StageDisplayState
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var StageDisplayState = (function (_super) {
                        __extends(StageDisplayState, _super);
                        function StageDisplayState() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.StageDisplayState");
                        }
                        // AS -> JS Bindings
                        StageDisplayState.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return StageDisplayState.FULL_SCREEN;
                                case 1:
                                    return StageDisplayState.FULL_SCREEN_INTERACTIVE;
                                case 2:
                                    return StageDisplayState.NORMAL;
                                default:
                                    return null;
                            }
                        };

                        StageDisplayState.toNumber = function (value) {
                            switch (value) {
                                case StageDisplayState.FULL_SCREEN:
                                    return 0;
                                case StageDisplayState.FULL_SCREEN_INTERACTIVE:
                                    return 1;
                                case StageDisplayState.NORMAL:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        StageDisplayState.classInitializer = null;

                        StageDisplayState.initializer = null;

                        StageDisplayState.classSymbols = null;

                        StageDisplayState.instanceSymbols = null;

                        StageDisplayState.FULL_SCREEN = "fullScreen";
                        StageDisplayState.FULL_SCREEN_INTERACTIVE = "fullScreenInteractive";
                        StageDisplayState.NORMAL = "normal";
                        return StageDisplayState;
                    })(AS.ASNative);
                    display.StageDisplayState = StageDisplayState;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: StageQuality
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var StageQuality = (function (_super) {
                        __extends(StageQuality, _super);
                        function StageQuality() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.StageQuality");
                        }
                        // AS -> JS Bindings
                        StageQuality.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return StageQuality.LOW;
                                case 1:
                                    return StageQuality.MEDIUM;
                                case 2:
                                    return StageQuality.HIGH;
                                case 3:
                                    return StageQuality.BEST;
                                case 4:
                                    return StageQuality.HIGH_8X8;
                                case 5:
                                    return StageQuality.HIGH_8X8_LINEAR;
                                case 6:
                                    return StageQuality.HIGH_16X16;
                                case 7:
                                    return StageQuality.HIGH_16X16_LINEAR;
                                default:
                                    return null;
                            }
                        };

                        StageQuality.toNumber = function (value) {
                            switch (value) {
                                case StageQuality.LOW:
                                    return 0;
                                case StageQuality.MEDIUM:
                                    return 1;
                                case StageQuality.HIGH:
                                    return 2;
                                case StageQuality.BEST:
                                    return 3;
                                case StageQuality.HIGH_8X8:
                                    return 4;
                                case StageQuality.HIGH_8X8_LINEAR:
                                    return 5;
                                case StageQuality.HIGH_16X16:
                                    return 6;
                                case StageQuality.HIGH_16X16_LINEAR:
                                    return 7;
                                default:
                                    return -1;
                            }
                        };
                        StageQuality.classInitializer = null;

                        StageQuality.initializer = null;

                        StageQuality.classSymbols = null;

                        StageQuality.instanceSymbols = null;

                        StageQuality.LOW = "low";
                        StageQuality.MEDIUM = "medium";
                        StageQuality.HIGH = "high";
                        StageQuality.BEST = "best";
                        StageQuality.HIGH_8X8 = "8x8";
                        StageQuality.HIGH_8X8_LINEAR = "8x8linear";
                        StageQuality.HIGH_16X16 = "16x16";
                        StageQuality.HIGH_16X16_LINEAR = "16x16linear";
                        return StageQuality;
                    })(AS.ASNative);
                    display.StageQuality = StageQuality;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: StageScaleMode
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var StageScaleMode = (function (_super) {
                        __extends(StageScaleMode, _super);
                        function StageScaleMode() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.StageScaleMode");
                        }
                        // AS -> JS Bindings
                        StageScaleMode.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return StageScaleMode.SHOW_ALL;
                                case 1:
                                    return StageScaleMode.EXACT_FIT;
                                case 2:
                                    return StageScaleMode.NO_BORDER;
                                case 4:
                                    return StageScaleMode.NO_SCALE;
                                default:
                                    return null;
                            }
                        };

                        StageScaleMode.toNumber = function (value) {
                            switch (value) {
                                case StageScaleMode.SHOW_ALL:
                                    return 0;
                                case StageScaleMode.EXACT_FIT:
                                    return 1;
                                case StageScaleMode.NO_BORDER:
                                    return 2;
                                case StageScaleMode.NO_SCALE:
                                    return 3;
                                default:
                                    return -1;
                            }
                        };
                        StageScaleMode.classInitializer = null;

                        StageScaleMode.initializer = null;

                        StageScaleMode.classSymbols = null;

                        StageScaleMode.instanceSymbols = null;

                        StageScaleMode.SHOW_ALL = "showAll";
                        StageScaleMode.EXACT_FIT = "exactFit";
                        StageScaleMode.NO_BORDER = "noBorder";
                        StageScaleMode.NO_SCALE = "noScale";
                        return StageScaleMode;
                    })(AS.ASNative);
                    display.StageScaleMode = StageScaleMode;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TriangleCulling
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var TriangleCulling = (function (_super) {
                        __extends(TriangleCulling, _super);
                        function TriangleCulling() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.TriangleCulling");
                        }
                        TriangleCulling.classInitializer = null;

                        TriangleCulling.initializer = null;

                        TriangleCulling.classSymbols = null;

                        TriangleCulling.instanceSymbols = null;

                        TriangleCulling.NONE = "none";
                        TriangleCulling.POSITIVE = "positive";
                        TriangleCulling.NEGATIVE = "negative";
                        return TriangleCulling;
                    })(AS.ASNative);
                    display.TriangleCulling = TriangleCulling;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: AVM1Movie
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var AVM1Movie = (function (_super) {
                        __extends(AVM1Movie, _super);
                        function AVM1Movie() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.display.AVM1Movie");
                        }
                        AVM1Movie.classInitializer = null;

                        AVM1Movie.initializer = null;

                        AVM1Movie.classSymbols = null;

                        AVM1Movie.instanceSymbols = null;
                        return AVM1Movie;
                    })(flash.display.DisplayObject);
                    display.AVM1Movie = AVM1Movie;
                })(flash.display || (flash.display = {}));
                var display = flash.display;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ExternalInterface
                (function (external) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;
                    var Telemetry = Shumway.Telemetry;
                    var forEachPublicProperty = Shumway.AVM2.Runtime.forEachPublicProperty;
                    var ExternalInterfaceService = Shumway.ExternalInterfaceService;

                    var ExternalInterface = (function (_super) {
                        __extends(ExternalInterface, _super);
                        function ExternalInterface() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.external.ExternalInterface");
                        }
                        ExternalInterface._getAvailable = function () {
                            return ExternalInterfaceService.instance.enabled;
                        };

                        ExternalInterface._initJS = function () {
                            if (ExternalInterface.initialized) {
                                return;
                            }
                            Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 1 /* EXTERNAL_INTERFACE_FEATURE */ });
                            ExternalInterface.initialized = true;
                            ExternalInterfaceService.instance.initJS(ExternalInterface._callIn);
                        };

                        ExternalInterface._callIn = function (functionName, args) {
                            var callback = ExternalInterface.registeredCallbacks[functionName];
                            if (!callback) {
                                return;
                            }
                            return callback(functionName, args);
                        };

                        ExternalInterface._getPropNames = function (obj) {
                            var keys = [];
                            forEachPublicProperty(obj, function (key) {
                                keys.push(key);
                            }, null);
                            return keys;
                        };

                        ExternalInterface._addCallback = function (functionName, closure, hasNullCallback) {
                            if (hasNullCallback) {
                                ExternalInterfaceService.instance.unregisterCallback(functionName);
                                delete ExternalInterface.registeredCallbacks[functionName];
                            } else {
                                ExternalInterfaceService.instance.registerCallback(functionName);
                                ExternalInterface.registeredCallbacks[functionName] = closure;
                            }
                        };

                        ExternalInterface._evalJS = function (expression) {
                            expression = asCoerceString(expression);
                            return ExternalInterfaceService.instance.eval(expression);
                        };

                        ExternalInterface._callOut = function (request) {
                            request = asCoerceString(request);
                            return ExternalInterfaceService.instance.call(request);
                        };

                        Object.defineProperty(ExternalInterface, "available", {
                            get: function () {
                                return ExternalInterface._getAvailable();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ExternalInterface, "objectID", {
                            get: function () {
                                return ExternalInterfaceService.instance.getId();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ExternalInterface, "activeX", {
                            get: function () {
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ExternalInterface.classInitializer = null;

                        ExternalInterface.initializer = null;

                        ExternalInterface.classSymbols = null;

                        ExternalInterface.instanceSymbols = null;

                        ExternalInterface.initialized = false;
                        ExternalInterface.registeredCallbacks = createEmptyObject();
                        return ExternalInterface;
                    })(AS.ASNative);
                    external.ExternalInterface = ExternalInterface;
                })(flash.external || (flash.external = {}));
                var external = flash.external;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BitmapFilterQuality
                (function (filters) {
                    var BitmapFilterQuality = (function (_super) {
                        __extends(BitmapFilterQuality, _super);
                        function BitmapFilterQuality() {
                            false && _super.call(this);
                        }
                        BitmapFilterQuality.classInitializer = null;

                        BitmapFilterQuality.initializer = null;

                        BitmapFilterQuality.classSymbols = null;

                        BitmapFilterQuality.instanceSymbols = null;

                        BitmapFilterQuality.LOW = 1;
                        BitmapFilterQuality.MEDIUM = 2;
                        BitmapFilterQuality.HIGH = 3;
                        return BitmapFilterQuality;
                    })(AS.ASNative);
                    filters.BitmapFilterQuality = BitmapFilterQuality;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BitmapFilterType
                (function (filters) {
                    var BitmapFilterType = (function (_super) {
                        __extends(BitmapFilterType, _super);
                        function BitmapFilterType() {
                            false && _super.call(this);
                        }
                        BitmapFilterType.classInitializer = null;

                        BitmapFilterType.initializer = null;

                        BitmapFilterType.classSymbols = null;

                        BitmapFilterType.instanceSymbols = null;

                        BitmapFilterType.INNER = "inner";
                        BitmapFilterType.OUTER = "outer";
                        BitmapFilterType.FULL = "full";
                        return BitmapFilterType;
                    })(AS.ASNative);
                    filters.BitmapFilterType = BitmapFilterType;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BitmapFilter
                (function (filters) {
                    var BitmapFilter = (function (_super) {
                        __extends(BitmapFilter, _super);
                        function BitmapFilter() {
                            false && _super.call(this);
                        }
                        BitmapFilter._updateBlurBounds = function (bounds, blurX, blurY, quality /*int*/ , isBlurFilter) {
                            if (typeof isBlurFilter === "undefined") { isBlurFilter = false; }
                            // Approximation of BitmapData.generateFilterRect()
                            var stepWidth = BitmapFilter.blurFilterStepWidths[quality - 1];
                            if (isBlurFilter) {
                                // BlurFilter behaves slightly different from other blur based filters:
                                // Given ascending blurX/blurY values, generateFilterRect with BlurFilter
                                // expands the source rect later than with i.e. GlowFilter. The difference
                                // appears to be stepWidth / 4 for all quality values.
                                var stepWidth4 = stepWidth / 4;
                                blurX -= stepWidth4;
                                blurY -= stepWidth4;
                            }

                            // Calculate horizontal and vertical borders:
                            // blurX/blurY values <= 1 are always rounded up to 1,
                            // which means that generateFilterRect always expands the source rect,
                            // even when blurX/blurY is 0.
                            var bh = Math.ceil((blurX < 1 ? 1 : blurX) * stepWidth);
                            var bv = Math.ceil((blurY < 1 ? 1 : blurY) * stepWidth);
                            bounds.inflate(bh, bv);
                        };

                        BitmapFilter.prototype._updateFilterBounds = function (bounds) {
                            // ...
                        };

                        BitmapFilter.prototype._serialize = function (message) {
                            // Overridden by subclasses
                            // -1: Filter not supported, no further serialization
                            // 0-7: Filter IDs according to SWF spec
                            message.writeInt(-1);
                        };

                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        BitmapFilter.prototype.clone = function () {
                            return null;
                        };
                        BitmapFilter.classInitializer = null;

                        BitmapFilter.initializer = null;

                        BitmapFilter.classSymbols = null;

                        BitmapFilter.instanceSymbols = null;

                        BitmapFilter.EPS = 0.000000001;

                        BitmapFilter.blurFilterStepWidths = [0.5, 1.05, 1.35, 1.55, 1.75, 1.9, 2, 2.1, 2.2, 2.3, 2.5, 3, 3, 3.5, 3.5];
                        return BitmapFilter;
                    })(AS.ASNative);
                    filters.BitmapFilter = BitmapFilter;

                    var GradientArrays = (function () {
                        function GradientArrays() {
                        }
                        // colors null or empty - all empty
                        // ratios empty - all empty
                        // ratios null and alphas null - length: colors, alphas set to 0, ratios set to 0
                        // ratios null and alphas != null - length: colors, alphas filled with 1, ratios set to 0
                        // ratios not empty and alphas null - length: min(colors,ratios), alphas set to 0
                        // ratios not empty and alphas != null - length: min(colors,ratios), alphas filled with 1
                        GradientArrays.sanitize = function (colors, alphas, ratios) {
                            if (Shumway.isNullOrUndefined(colors) || colors.length === 0) {
                                this.colors = [];
                                this.alphas = [];
                                this.ratios = [];
                            } else {
                                var len;
                                if (Shumway.isNullOrUndefined(ratios)) {
                                    this.colors = this.sanitizeColors(colors);
                                    len = this.colors.length;
                                    this.ratios = this.initArray(len);
                                    if (Shumway.isNullOrUndefined(alphas)) {
                                        this.alphas = this.initArray(len);
                                    } else {
                                        this.alphas = this.sanitizeAlphas(alphas, len, len, 1);
                                    }
                                } else {
                                    if (ratios.length === 0) {
                                        this.colors = [];
                                        this.alphas = [];
                                        this.ratios = [];
                                    } else {
                                        len = Math.min(colors.length, ratios.length, 16);
                                        this.colors = this.sanitizeColors(colors, len);
                                        this.ratios = this.sanitizeRatios(ratios, len);
                                        if (Shumway.isNullOrUndefined(alphas)) {
                                            this.alphas = this.initArray(len);
                                        } else {
                                            this.alphas = this.sanitizeAlphas(alphas, len, len, 1);
                                        }
                                    }
                                }
                            }
                        };

                        GradientArrays.sanitizeColors = function (colors, maxLen) {
                            if (typeof maxLen === "undefined") { maxLen = 16; }
                            var arr = [];
                            for (var i = 0, n = Math.min(colors.length, maxLen); i < n; i++) {
                                arr[i] = (colors[i] >>> 0) & 0xffffff;
                            }
                            return arr;
                        };

                        GradientArrays.sanitizeAlphas = function (alphas, maxLen, minLen, value) {
                            if (typeof maxLen === "undefined") { maxLen = 16; }
                            if (typeof minLen === "undefined") { minLen = 0; }
                            if (typeof value === "undefined") { value = 0; }
                            var arr = [];
                            for (var i = 0, n = Math.min(alphas.length, maxLen); i < n; i++) {
                                arr[i] = Shumway.NumberUtilities.clamp(+alphas[i], 0, 1);
                            }
                            while (i < minLen) {
                                arr[i++] = value;
                            }
                            return arr;
                        };

                        GradientArrays.sanitizeRatios = function (ratios, maxLen, minLen, value) {
                            if (typeof maxLen === "undefined") { maxLen = 16; }
                            if (typeof minLen === "undefined") { minLen = 0; }
                            if (typeof value === "undefined") { value = 0; }
                            var arr = [];
                            for (var i = 0, n = Math.min(ratios.length, maxLen); i < n; i++) {
                                arr[i] = Shumway.NumberUtilities.clamp(+ratios[i], 0, 255);
                            }
                            while (i < minLen) {
                                arr[i++] = value;
                            }
                            return arr;
                        };

                        GradientArrays.initArray = function (len, value) {
                            if (typeof value === "undefined") { value = 0; }
                            var arr = Array(len);
                            for (var i = 0; i < len; i++) {
                                arr[i] = value;
                            }
                            return arr;
                        };
                        return GradientArrays;
                    })();
                    filters.GradientArrays = GradientArrays;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BevelFilter
                (function (filters) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var assert = Shumway.Debug.assert;

                    var BevelFilter = (function (_super) {
                        __extends(BevelFilter, _super);
                        function BevelFilter(distance, angle, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout) {
                            if (typeof distance === "undefined") { distance = 4; }
                            if (typeof angle === "undefined") { angle = 45; }
                            if (typeof highlightColor === "undefined") { highlightColor = 16777215; }
                            if (typeof highlightAlpha === "undefined") { highlightAlpha = 1; }
                            if (typeof shadowColor === "undefined") { shadowColor = 0; }
                            if (typeof shadowAlpha === "undefined") { shadowAlpha = 1; }
                            if (typeof blurX === "undefined") { blurX = 4; }
                            if (typeof blurY === "undefined") { blurY = 4; }
                            if (typeof strength === "undefined") { strength = 1; }
                            if (typeof quality === "undefined") { quality = 1; }
                            if (typeof type === "undefined") { type = "inner"; }
                            if (typeof knockout === "undefined") { knockout = false; }
                            false && _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            this.highlightColor = highlightColor;
                            this.highlightAlpha = highlightAlpha;
                            this.shadowColor = shadowColor;
                            this.shadowAlpha = shadowAlpha;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.type = type;
                            this.knockout = knockout;
                        }
                        BevelFilter.FromUntyped = function (obj) {
                            // obj.highlightColor is an RGBA color.
                            var highlightColor = obj.highlightColor >>> 8;
                            var highlightAlpha = (obj.highlightColor & 0xff) / 0xff;

                            // obj.colors is an array of RGBA colors.
                            // Here it contains exactly one color object, which maps to shadowColor and shadowAlpha.
                            release || assert(obj.colors && obj.colors.length === 1, "colors must be Array of length 1");
                            var shadowColor = obj.colors[0] >>> 8;
                            var shadowAlpha = (obj.colors[0] & 0xff) / 0xff;

                            // type is derived from obj.onTop and obj.innerShadow
                            // obj.onTop true: type is FULL
                            // obj.inner true: type is INNER
                            // neither true: type is OUTER
                            var type = flash.filters.BitmapFilterType.OUTER;
                            if (!!obj.onTop) {
                                type = flash.filters.BitmapFilterType.FULL;
                            } else if (!!obj.inner) {
                                type = flash.filters.BitmapFilterType.INNER;
                            }

                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            return new BevelFilter(obj.distance, angle, highlightColor, highlightAlpha, shadowColor, shadowAlpha, obj.blurX, obj.blurY, obj.strength, obj.quality, type, obj.knockout);
                        };

                        BevelFilter.prototype._updateFilterBounds = function (bounds) {
                            if (this.type !== filters.BitmapFilterType.INNER) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };

                        Object.defineProperty(BevelFilter.prototype, "distance", {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "angle", {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "highlightColor", {
                            get: function () {
                                return this._highlightColor;
                            },
                            set: function (value /*uint*/ ) {
                                this._highlightColor = (value >>> 0) & 0xffffff;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "highlightAlpha", {
                            get: function () {
                                return this._highlightAlpha;
                            },
                            set: function (value) {
                                this._highlightAlpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "shadowColor", {
                            get: function () {
                                return this._shadowColor;
                            },
                            set: function (value /*uint*/ ) {
                                this._shadowColor = (value >>> 0) & 0xffffff;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "shadowAlpha", {
                            get: function () {
                                return this._shadowAlpha;
                            },
                            set: function (value) {
                                this._shadowAlpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "blurX", {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "blurY", {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "knockout", {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "quality", {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value /*int*/ ) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "strength", {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BevelFilter.prototype, "type", {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                if (value === null) {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                                } else {
                                    if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                        this._type = value;
                                    } else {
                                        this._type = filters.BitmapFilterType.FULL;
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        BevelFilter.prototype.clone = function () {
                            return new BevelFilter(this._distance, this._angle, this._highlightColor, this._highlightAlpha, this._shadowColor, this._shadowAlpha, this._blurX, this._blurY, this._strength, this._quality, this._type, this._knockout);
                        };
                        BevelFilter.classInitializer = null;

                        BevelFilter.initializer = null;

                        BevelFilter.classSymbols = null;

                        BevelFilter.instanceSymbols = null;
                        return BevelFilter;
                    })(flash.filters.BitmapFilter);
                    filters.BevelFilter = BevelFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: BlurFilter
                (function (filters) {
                    var BlurFilter = (function (_super) {
                        __extends(BlurFilter, _super);
                        function BlurFilter(blurX, blurY, quality) {
                            if (typeof blurX === "undefined") { blurX = 4; }
                            if (typeof blurY === "undefined") { blurY = 4; }
                            if (typeof quality === "undefined") { quality = 1; }
                            false && _super.call(this);
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.quality = quality;
                        }
                        BlurFilter.FromUntyped = function (obj) {
                            return new BlurFilter(obj.blurX, obj.blurY, obj.quality);
                        };

                        BlurFilter.prototype._updateFilterBounds = function (bounds) {
                            filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality, true);
                        };

                        BlurFilter.prototype._serialize = function (message) {
                            message.ensureAdditionalCapacity(16);
                            message.writeIntUnsafe(1);
                            message.writeFloatUnsafe(this._blurX);
                            message.writeFloatUnsafe(this._blurY);
                            message.writeIntUnsafe(this._quality);
                        };

                        Object.defineProperty(BlurFilter.prototype, "blurX", {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BlurFilter.prototype, "blurY", {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(BlurFilter.prototype, "quality", {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value /*int*/ ) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        BlurFilter.prototype.clone = function () {
                            return new BlurFilter(this._blurX, this._blurY, this._quality);
                        };
                        BlurFilter.classInitializer = null;

                        BlurFilter.initializer = null;

                        BlurFilter.classSymbols = null;

                        BlurFilter.instanceSymbols = null;
                        return BlurFilter;
                    })(flash.filters.BitmapFilter);
                    filters.BlurFilter = BlurFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ColorMatrixFilter
                (function (filters) {
                    var ColorMatrixFilter = (function (_super) {
                        __extends(ColorMatrixFilter, _super);
                        function ColorMatrixFilter(matrix) {
                            if (typeof matrix === "undefined") { matrix = null; }
                            false && _super.call(this);
                            if (matrix) {
                                this.matrix = matrix;
                            } else {
                                this._matrix = [
                                    1, 0, 0, 0, 0,
                                    0, 1, 0, 0, 0,
                                    0, 0, 1, 0, 0,
                                    0, 0, 0, 1, 0
                                ];
                            }
                        }
                        ColorMatrixFilter.FromUntyped = function (obj) {
                            return new ColorMatrixFilter(obj.matrix);
                        };

                        ColorMatrixFilter.prototype._serialize = function (message) {
                            var matrix = this._matrix;
                            message.ensureAdditionalCapacity((matrix.length + 1) * 4);
                            message.writeIntUnsafe(6);
                            for (var i = 0; i < matrix.length; i++) {
                                message.writeFloatUnsafe(matrix[i]);
                            }
                        };

                        Object.defineProperty(ColorMatrixFilter.prototype, "matrix", {
                            get: function () {
                                return this._matrix.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    var matrix = [
                                        0, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0,
                                        0, 0, 0, 0, 0
                                    ];
                                    for (var i = 0, n = Math.min(value.length, 20); i < n; i++) {
                                        matrix[i] = Shumway.toNumber(value[i]);
                                    }
                                    this._matrix = matrix;
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "matrix");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        ColorMatrixFilter.prototype.clone = function () {
                            return new ColorMatrixFilter(this.matrix);
                        };
                        ColorMatrixFilter.classInitializer = null;

                        ColorMatrixFilter.initializer = null;

                        ColorMatrixFilter.classSymbols = null;

                        ColorMatrixFilter.instanceSymbols = null;
                        return ColorMatrixFilter;
                    })(flash.filters.BitmapFilter);
                    filters.ColorMatrixFilter = ColorMatrixFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ConvolutionFilter
                (function (filters) {
                    var ConvolutionFilter = (function (_super) {
                        __extends(ConvolutionFilter, _super);
                        function ConvolutionFilter(matrixX, matrixY, matrix, divisor, bias, preserveAlpha, clamp, color, alpha) {
                            if (typeof matrixX === "undefined") { matrixX = 0; }
                            if (typeof matrixY === "undefined") { matrixY = 0; }
                            if (typeof matrix === "undefined") { matrix = null; }
                            if (typeof divisor === "undefined") { divisor = 1; }
                            if (typeof bias === "undefined") { bias = 0; }
                            if (typeof preserveAlpha === "undefined") { preserveAlpha = true; }
                            if (typeof clamp === "undefined") { clamp = true; }
                            if (typeof color === "undefined") { color = 0; }
                            if (typeof alpha === "undefined") { alpha = 0; }
                            false && _super.call(this);
                            this.matrixX = matrixX;
                            this.matrixY = matrixY;
                            if (matrix) {
                                this.matrix = matrix;
                            } else {
                                this._matrix = this._expandArray([], this._matrixX * this._matrixY);
                            }
                            this.divisor = divisor;
                            this.bias = bias;
                            this.preserveAlpha = preserveAlpha;
                            this.clamp = clamp;
                            this.color = color;
                            this.alpha = alpha;
                        }
                        ConvolutionFilter.FromUntyped = function (obj) {
                            return new ConvolutionFilter(obj.matrixX, obj.matrixY, obj.matrix, obj.divisor, obj.bias, obj.preserveAlpha, obj.clamp, obj.color >>> 8, (obj.color & 0xff) / 0xff);
                        };

                        ConvolutionFilter.prototype._expandArray = function (a, newLen /*uint*/ , value) {
                            if (typeof value === "undefined") { value = 0; }
                            if (a) {
                                var i = a.length;
                                while (i < newLen) {
                                    a[i++] = 0;
                                }
                            }
                            return a;
                        };

                        Object.defineProperty(ConvolutionFilter.prototype, "matrix", {
                            get: function () {
                                return this._matrix.slice(0, this._matrixX * this._matrixY);
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    var actualLen = this._matrixX * this._matrixY;
                                    var minLen = Math.min(value.length, actualLen);
                                    var matrix = Array(minLen);
                                    for (var i = 0; i < minLen; i++) {
                                        matrix[i] = Shumway.toNumber(value[i]);
                                    }
                                    this._expandArray(matrix, actualLen);
                                    this._matrix = matrix;
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "matrix");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "matrixX", {
                            get: function () {
                                return this._matrixX;
                            },
                            set: function (value) {
                                var mx = Shumway.NumberUtilities.clamp(+value, 0, 15) | 0;
                                if (this._matrixX !== mx) {
                                    this._matrixX = mx;
                                    this._expandArray(this._matrix, mx * this._matrixY);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "matrixY", {
                            get: function () {
                                return this._matrixY;
                            },
                            set: function (value) {
                                var my = Shumway.NumberUtilities.clamp(+value, 0, 15) | 0;
                                if (this._matrixY !== my) {
                                    this._matrixY = my;
                                    this._expandArray(this._matrix, my * this._matrixX);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, "divisor", {
                            get: function () {
                                return this._divisor;
                            },
                            set: function (value) {
                                this._divisor = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "bias", {
                            get: function () {
                                return this._bias;
                            },
                            set: function (value) {
                                this._bias = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "preserveAlpha", {
                            get: function () {
                                return this._preserveAlpha;
                            },
                            set: function (value) {
                                this._preserveAlpha = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "clamp", {
                            get: function () {
                                return this._clamp;
                            },
                            set: function (value) {
                                this._clamp = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "color", {
                            get: function () {
                                return this._color;
                            },
                            set: function (value /*uint*/ ) {
                                this._color = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ConvolutionFilter.prototype, "alpha", {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        ConvolutionFilter.prototype.clone = function () {
                            return new ConvolutionFilter(this._matrixX, this._matrixY, this.matrix, this._divisor, this._bias, this._preserveAlpha, this._clamp, this._color, this._alpha);
                        };
                        ConvolutionFilter.classInitializer = null;

                        ConvolutionFilter.initializer = null;

                        ConvolutionFilter.classSymbols = null;

                        ConvolutionFilter.instanceSymbols = null;
                        return ConvolutionFilter;
                    })(flash.filters.BitmapFilter);
                    filters.ConvolutionFilter = ConvolutionFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: DisplacementMapFilterMode
                (function (filters) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var DisplacementMapFilterMode = (function (_super) {
                        __extends(DisplacementMapFilterMode, _super);
                        function DisplacementMapFilterMode() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.filters.DisplacementMapFilterMode");
                        }
                        DisplacementMapFilterMode.classInitializer = null;

                        DisplacementMapFilterMode.initializer = null;

                        DisplacementMapFilterMode.classSymbols = null;

                        DisplacementMapFilterMode.instanceSymbols = null;

                        DisplacementMapFilterMode.WRAP = "wrap";
                        DisplacementMapFilterMode.CLAMP = "clamp";
                        DisplacementMapFilterMode.IGNORE = "ignore";
                        DisplacementMapFilterMode.COLOR = "color";
                        return DisplacementMapFilterMode;
                    })(AS.ASNative);
                    filters.DisplacementMapFilterMode = DisplacementMapFilterMode;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: DisplacementMapFilter
                (function (filters) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var DisplacementMapFilter = (function (_super) {
                        __extends(DisplacementMapFilter, _super);
                        function DisplacementMapFilter(mapBitmap, mapPoint, componentX, componentY, scaleX, scaleY, mode, color, alpha) {
                            if (typeof mapBitmap === "undefined") { mapBitmap = null; }
                            if (typeof mapPoint === "undefined") { mapPoint = null; }
                            if (typeof componentX === "undefined") { componentX = 0; }
                            if (typeof componentY === "undefined") { componentY = 0; }
                            if (typeof scaleX === "undefined") { scaleX = 0; }
                            if (typeof scaleY === "undefined") { scaleY = 0; }
                            if (typeof mode === "undefined") { mode = "wrap"; }
                            if (typeof color === "undefined") { color = 0; }
                            if (typeof alpha === "undefined") { alpha = 0; }
                            false && _super.call(this);
                            this.mapBitmap = mapBitmap;
                            this.mapPoint = mapPoint;
                            this.componentX = componentX;
                            this.componentY = componentY;
                            this.scaleX = scaleX;
                            this.scaleY = scaleY;
                            this.mode = mode;
                            this.color = color;
                            this.alpha = alpha;
                        }
                        DisplacementMapFilter.FromUntyped = function (obj) {
                            return new DisplacementMapFilter(obj.mapBitmap, obj.mapPoint, obj.componentX, obj.componentY, obj.scaleX, obj.scaleY, obj.mode, obj.color, obj.alpha);
                        };

                        Object.defineProperty(DisplacementMapFilter.prototype, "mapBitmap", {
                            get: function () {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::get mapBitmap");
                                return this._mapBitmap;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set mapBitmap");
                                this._mapBitmap = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "mapPoint", {
                            get: function () {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::get mapPoint");
                                return this._mapPoint;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set mapPoint");
                                this._mapPoint = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "componentX", {
                            get: function () {
                                return this._componentX;
                            },
                            set: function (value /*uint*/ ) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set componentX");
                                this._componentX = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "componentY", {
                            get: function () {
                                return this._componentY;
                            },
                            set: function (value /*uint*/ ) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set componentY");
                                this._componentY = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "scaleX", {
                            get: function () {
                                return this._scaleX;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set scaleX");
                                this._scaleX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "scaleY", {
                            get: function () {
                                return this._scaleY;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set scaleY");
                                this._scaleY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "mode", {
                            get: function () {
                                return this._mode;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set mode");
                                this._mode = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "color", {
                            get: function () {
                                return this._color;
                            },
                            set: function (value /*uint*/ ) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set color");
                                this._color = (value >>> 0) & 0xffffff;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DisplacementMapFilter.prototype, "alpha", {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.filters.DisplacementMapFilter::set alpha");
                                this._alpha = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        DisplacementMapFilter.prototype.clone = function () {
                            return new DisplacementMapFilter(this._mapBitmap, this._mapPoint, this._componentX, this._componentY, this._scaleX, this._scaleY, this._mode, this._color, this._alpha);
                        };
                        DisplacementMapFilter.classInitializer = null;

                        DisplacementMapFilter.initializer = null;

                        DisplacementMapFilter.classSymbols = null;

                        DisplacementMapFilter.instanceSymbols = null;
                        return DisplacementMapFilter;
                    })(flash.filters.BitmapFilter);
                    filters.DisplacementMapFilter = DisplacementMapFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: DropShadowFilter
                (function (filters) {
                    var assert = Shumway.Debug.assert;

                    var DropShadowFilter = (function (_super) {
                        __extends(DropShadowFilter, _super);
                        function DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject) {
                            if (typeof distance === "undefined") { distance = 4; }
                            if (typeof angle === "undefined") { angle = 45; }
                            if (typeof color === "undefined") { color = 0; }
                            if (typeof alpha === "undefined") { alpha = 1; }
                            if (typeof blurX === "undefined") { blurX = 4; }
                            if (typeof blurY === "undefined") { blurY = 4; }
                            if (typeof strength === "undefined") { strength = 1; }
                            if (typeof quality === "undefined") { quality = 1; }
                            if (typeof inner === "undefined") { inner = false; }
                            if (typeof knockout === "undefined") { knockout = false; }
                            if (typeof hideObject === "undefined") { hideObject = false; }
                            false && _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            this.color = color;
                            this.alpha = alpha;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.inner = inner;
                            this.knockout = knockout;
                            this.hideObject = hideObject;
                        }
                        DropShadowFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // Here it contains exactly one color object, which maps to color and alpha.
                            release || assert(obj.colors && obj.colors.length === 1, "colors must be Array of length 1");
                            var color = obj.colors[0] >>> 8;
                            var alpha = (obj.colors[0] & 0xff) / 0xff;

                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;

                            // obj.compositeSource maps to !hideObject
                            var hideObject = !obj.compositeSource;
                            return new DropShadowFilter(obj.distance, angle, color, alpha, obj.blurX, obj.blurY, obj.strength, obj.quality, obj.inner, obj.knockout, hideObject);
                        };

                        DropShadowFilter.prototype._updateFilterBounds = function (bounds) {
                            if (!this.inner) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };

                        DropShadowFilter.prototype._serialize = function (message) {
                            message.ensureAdditionalCapacity(48);
                            message.writeIntUnsafe(0);
                            message.writeFloatUnsafe(this._alpha);
                            message.writeFloatUnsafe(this._angle);
                            message.writeFloatUnsafe(this._blurX);
                            message.writeFloatUnsafe(this._blurY);
                            message.writeIntUnsafe(this._color);
                            message.writeFloatUnsafe(this._distance);
                            message.writeIntUnsafe(this._hideObject);
                            message.writeIntUnsafe(this._inner);
                            message.writeIntUnsafe(this._knockout);
                            message.writeIntUnsafe(this._quality);
                            message.writeFloatUnsafe(this._strength);
                        };

                        Object.defineProperty(DropShadowFilter.prototype, "distance", {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "angle", {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "color", {
                            get: function () {
                                return this._color;
                            },
                            set: function (value /*uint*/ ) {
                                this._color = (value >>> 0) & 0xffffff;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "alpha", {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "blurX", {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "blurY", {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DropShadowFilter.prototype, "hideObject", {
                            get: function () {
                                return this._hideObject;
                            },
                            set: function (value) {
                                this._hideObject = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "inner", {
                            get: function () {
                                return this._inner;
                            },
                            set: function (value) {
                                this._inner = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "knockout", {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(DropShadowFilter.prototype, "quality", {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value /*int*/ ) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(DropShadowFilter.prototype, "strength", {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        DropShadowFilter.prototype.clone = function () {
                            return new DropShadowFilter(this._distance, this._angle, this._color, this._alpha, this._blurX, this._blurY, this._strength, this._quality, this._inner, this._knockout, this._hideObject);
                        };
                        DropShadowFilter.classInitializer = null;

                        DropShadowFilter.initializer = null;

                        DropShadowFilter.classSymbols = null;

                        DropShadowFilter.instanceSymbols = null;
                        return DropShadowFilter;
                    })(flash.filters.BitmapFilter);
                    filters.DropShadowFilter = DropShadowFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GlowFilter
                (function (filters) {
                    var assert = Shumway.Debug.assert;

                    var GlowFilter = (function (_super) {
                        __extends(GlowFilter, _super);
                        function GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout) {
                            if (typeof color === "undefined") { color = 16711680; }
                            if (typeof alpha === "undefined") { alpha = 1; }
                            if (typeof blurX === "undefined") { blurX = 6; }
                            if (typeof blurY === "undefined") { blurY = 6; }
                            if (typeof strength === "undefined") { strength = 2; }
                            if (typeof quality === "undefined") { quality = 1; }
                            if (typeof inner === "undefined") { inner = false; }
                            if (typeof knockout === "undefined") { knockout = false; }
                            false && _super.call(this);
                            this.color = color;
                            this.alpha = alpha;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.inner = inner;
                            this.knockout = knockout;
                        }
                        GlowFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // Here it contains exactly one color object, which maps to color and alpha.
                            release || assert(obj.colors && obj.colors.length === 1, "colors must be Array of length 1");
                            var color = obj.colors[0] >>> 8;
                            var alpha = (obj.colors[0] & 0xff) / 0xff;
                            return new GlowFilter(color, alpha, obj.blurX, obj.blurY, obj.strength, obj.quality, obj.inner, obj.knockout);
                        };

                        GlowFilter.prototype._updateFilterBounds = function (bounds) {
                            filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                        };

                        GlowFilter.prototype._serialize = function (message) {
                            message.ensureAdditionalCapacity(36);
                            message.writeIntUnsafe(2);
                            message.writeFloatUnsafe(this._alpha);
                            message.writeFloatUnsafe(this._blurX);
                            message.writeFloatUnsafe(this._blurY);
                            message.writeIntUnsafe(this._color);
                            message.writeIntUnsafe(this._inner);
                            message.writeIntUnsafe(this._knockout);
                            message.writeIntUnsafe(this._quality);
                            message.writeFloatUnsafe(this._strength);
                        };

                        Object.defineProperty(GlowFilter.prototype, "color", {
                            get: function () {
                                return this._color;
                            },
                            set: function (value /*uint*/ ) {
                                this._color = (value >>> 0) & 0xffffff;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "alpha", {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "blurX", {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "blurY", {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "inner", {
                            get: function () {
                                return this._inner;
                            },
                            set: function (value) {
                                this._inner = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "knockout", {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "quality", {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value /*int*/ ) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GlowFilter.prototype, "strength", {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        GlowFilter.prototype.clone = function () {
                            return new GlowFilter(this._color, this._alpha, this._blurX, this._blurY, this._strength, this._quality, this._inner, this._knockout);
                        };
                        GlowFilter.classInitializer = null;

                        GlowFilter.initializer = null;

                        GlowFilter.classSymbols = null;

                        GlowFilter.instanceSymbols = null;
                        return GlowFilter;
                    })(flash.filters.BitmapFilter);
                    filters.GlowFilter = GlowFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GradientBevelFilter
                (function (filters) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var GradientBevelFilter = (function (_super) {
                        __extends(GradientBevelFilter, _super);
                        function GradientBevelFilter(distance, angle, colors, alphas, ratios, blurX, blurY, strength, quality, type, knockout) {
                            if (typeof distance === "undefined") { distance = 4; }
                            if (typeof angle === "undefined") { angle = 45; }
                            if (typeof colors === "undefined") { colors = null; }
                            if (typeof alphas === "undefined") { alphas = null; }
                            if (typeof ratios === "undefined") { ratios = null; }
                            if (typeof blurX === "undefined") { blurX = 4; }
                            if (typeof blurY === "undefined") { blurY = 4; }
                            if (typeof strength === "undefined") { strength = 1; }
                            if (typeof quality === "undefined") { quality = 1; }
                            if (typeof type === "undefined") { type = "inner"; }
                            if (typeof knockout === "undefined") { knockout = false; }
                            false && _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            filters.GradientArrays.sanitize(colors, alphas, ratios);
                            this._colors = filters.GradientArrays.colors;
                            this._alphas = filters.GradientArrays.alphas;
                            this._ratios = filters.GradientArrays.ratios;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.type = type;
                            this.knockout = knockout;
                        }
                        GradientBevelFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // The RGB and alpha parts must be separated into colors and alphas arrays.
                            var colors = [];
                            var alphas = [];
                            for (var i = 0; i < obj.colors.length; i++) {
                                var color = obj.colors[i];
                                colors.push(color >>> 8);
                                alphas.push(color & 0xff) / 0xff;
                            }

                            // type is derived from obj.onTop and obj.innerShadow
                            // obj.onTop true: type is FULL
                            // obj.inner true: type is INNER
                            // neither true: type is OUTER
                            var type = flash.filters.BitmapFilterType.OUTER;
                            if (!!obj.onTop) {
                                type = flash.filters.BitmapFilterType.FULL;
                            } else if (!!obj.inner) {
                                type = flash.filters.BitmapFilterType.INNER;
                            }

                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            return new GradientBevelFilter(obj.distance, angle, colors, alphas, obj.ratios, obj.blurX, obj.blurY, obj.strength, obj.quality, type, obj.knockout);
                        };

                        GradientBevelFilter.prototype._updateFilterBounds = function (bounds) {
                            if (this.type !== filters.BitmapFilterType.INNER) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };

                        Object.defineProperty(GradientBevelFilter.prototype, "distance", {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "angle", {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "colors", {
                            get: function () {
                                return this._colors.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    this._colors = filters.GradientArrays.sanitizeColors(value);
                                    var len = this._colors.length;
                                    this._alphas = filters.GradientArrays.sanitizeAlphas(this._alphas, len, len);
                                    this._ratios = filters.GradientArrays.sanitizeRatios(this._ratios, len, len);
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "colors");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "alphas", {
                            get: function () {
                                return this._alphas.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    filters.GradientArrays.sanitize(this._colors, value, this._ratios);
                                    this._colors = filters.GradientArrays.colors;
                                    this._alphas = filters.GradientArrays.alphas;
                                    this._ratios = filters.GradientArrays.ratios;
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "alphas");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "ratios", {
                            get: function () {
                                return this._ratios.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    filters.GradientArrays.sanitize(this._colors, this._alphas, value);
                                    this._colors = filters.GradientArrays.colors;
                                    this._alphas = filters.GradientArrays.alphas;
                                    this._ratios = filters.GradientArrays.ratios;
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "ratios");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "blurX", {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "blurY", {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "knockout", {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "quality", {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value /*int*/ ) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "strength", {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientBevelFilter.prototype, "type", {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                if (value === null) {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                                } else {
                                    if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                        this._type = value;
                                    } else {
                                        this._type = filters.BitmapFilterType.FULL;
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        GradientBevelFilter.prototype.clone = function () {
                            return new GradientBevelFilter(this._distance, this._angle, this._colors, this._alphas, this._ratios, this._blurX, this._blurY, this._strength, this._quality, this._type, this._knockout);
                        };
                        GradientBevelFilter.classInitializer = null;

                        GradientBevelFilter.initializer = null;

                        GradientBevelFilter.classSymbols = null;

                        GradientBevelFilter.instanceSymbols = null;
                        return GradientBevelFilter;
                    })(flash.filters.BitmapFilter);
                    filters.GradientBevelFilter = GradientBevelFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GradientGlowFilter
                (function (filters) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var GradientGlowFilter = (function (_super) {
                        __extends(GradientGlowFilter, _super);
                        function GradientGlowFilter(distance, angle, colors, alphas, ratios, blurX, blurY, strength, quality, type, knockout) {
                            if (typeof distance === "undefined") { distance = 4; }
                            if (typeof angle === "undefined") { angle = 45; }
                            if (typeof colors === "undefined") { colors = null; }
                            if (typeof alphas === "undefined") { alphas = null; }
                            if (typeof ratios === "undefined") { ratios = null; }
                            if (typeof blurX === "undefined") { blurX = 4; }
                            if (typeof blurY === "undefined") { blurY = 4; }
                            if (typeof strength === "undefined") { strength = 1; }
                            if (typeof quality === "undefined") { quality = 1; }
                            if (typeof type === "undefined") { type = "inner"; }
                            if (typeof knockout === "undefined") { knockout = false; }
                            false && _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            filters.GradientArrays.sanitize(colors, alphas, ratios);
                            this._colors = filters.GradientArrays.colors;
                            this._alphas = filters.GradientArrays.alphas;
                            this._ratios = filters.GradientArrays.ratios;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.type = type;
                            this.knockout = knockout;
                        }
                        GradientGlowFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // The RGB and alpha parts must be separated into colors and alphas arrays.
                            var colors = [];
                            var alphas = [];
                            for (var i = 0; i < obj.colors.length; i++) {
                                var color = obj.colors[i];
                                colors.push(color >>> 8);
                                alphas.push(color & 0xff) / 0xff;
                            }

                            // type is derived from obj.onTop and obj.innerShadow
                            // obj.onTop true: type is FULL
                            // obj.inner true: type is INNER
                            // neither true: type is OUTER
                            var type = flash.filters.BitmapFilterType.OUTER;
                            if (!!obj.onTop) {
                                type = flash.filters.BitmapFilterType.FULL;
                            } else if (!!obj.inner) {
                                type = flash.filters.BitmapFilterType.INNER;
                            }

                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            return new GradientGlowFilter(obj.distance, angle, colors, alphas, obj.ratios, obj.blurX, obj.blurY, obj.strength, obj.quality, type, obj.knockout);
                        };

                        GradientGlowFilter.prototype._updateFilterBounds = function (bounds) {
                            if (this.type !== filters.BitmapFilterType.INNER) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };

                        Object.defineProperty(GradientGlowFilter.prototype, "distance", {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "angle", {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "colors", {
                            get: function () {
                                return this._colors.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    this._colors = filters.GradientArrays.sanitizeColors(value);
                                    var len = this._colors.length;
                                    this._alphas = filters.GradientArrays.sanitizeAlphas(this._alphas, len, len);
                                    this._ratios = filters.GradientArrays.sanitizeRatios(this._ratios, len, len);
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "colors");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "alphas", {
                            get: function () {
                                return this._alphas.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    filters.GradientArrays.sanitize(this._colors, value, this._ratios);
                                    this._colors = filters.GradientArrays.colors;
                                    this._alphas = filters.GradientArrays.alphas;
                                    this._ratios = filters.GradientArrays.ratios;
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "alphas");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "ratios", {
                            get: function () {
                                return this._ratios.concat();
                            },
                            set: function (value) {
                                if (!Shumway.isNullOrUndefined(value)) {
                                    filters.GradientArrays.sanitize(this._colors, this._alphas, value);
                                    this._colors = filters.GradientArrays.colors;
                                    this._alphas = filters.GradientArrays.alphas;
                                    this._ratios = filters.GradientArrays.ratios;
                                } else {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "ratios");
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "blurX", {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "blurY", {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "knockout", {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "quality", {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value /*int*/ ) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "strength", {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(GradientGlowFilter.prototype, "type", {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                if (value === null) {
                                    AVM2.Runtime.throwError("TypeError", AVM2.Errors.NullPointerError, "type");
                                } else {
                                    if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                        this._type = value;
                                    } else {
                                        this._type = filters.BitmapFilterType.FULL;
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });

                        GradientGlowFilter.prototype.clone = function () {
                            return new GradientGlowFilter(this._distance, this._angle, this._colors, this._alphas, this._ratios, this._blurX, this._blurY, this._strength, this._quality, this._type, this._knockout);
                        };
                        GradientGlowFilter.classInitializer = null;

                        GradientGlowFilter.initializer = null;

                        GradientGlowFilter.classSymbols = null;

                        GradientGlowFilter.instanceSymbols = null;
                        return GradientGlowFilter;
                    })(flash.filters.BitmapFilter);
                    filters.GradientGlowFilter = GradientGlowFilter;
                })(flash.filters || (flash.filters = {}));
                var filters = flash.filters;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ColorTransform
                (function (geom) {
                    var toS16 = Shumway.IntegerUtilities.toS16;
                    var clampS8U8 = Shumway.IntegerUtilities.clampS8U8;

                    var ColorTransform = (function (_super) {
                        __extends(ColorTransform, _super);
                        function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                            if (typeof redMultiplier === "undefined") { redMultiplier = 1; }
                            if (typeof greenMultiplier === "undefined") { greenMultiplier = 1; }
                            if (typeof blueMultiplier === "undefined") { blueMultiplier = 1; }
                            if (typeof alphaMultiplier === "undefined") { alphaMultiplier = 1; }
                            if (typeof redOffset === "undefined") { redOffset = 0; }
                            if (typeof greenOffset === "undefined") { greenOffset = 0; }
                            if (typeof blueOffset === "undefined") { blueOffset = 0; }
                            if (typeof alphaOffset === "undefined") { alphaOffset = 0; }
                            false && _super.call(this);
                            this.redMultiplier = +redMultiplier;
                            this.greenMultiplier = +greenMultiplier;
                            this.blueMultiplier = +blueMultiplier;
                            this.alphaMultiplier = +alphaMultiplier;
                            this.redOffset = +redOffset;
                            this.greenOffset = +greenOffset;
                            this.blueOffset = +blueOffset;
                            this.alphaOffset = +alphaOffset;
                        }
                        ColorTransform.FromCXForm = function (cxform) {
                            return new ColorTransform(cxform.redMultiplier / 256, cxform.greenMultiplier / 256, cxform.blueMultiplier / 256, cxform.alphaMultiplier / 256, cxform.redOffset, cxform.greenOffset, cxform.blueOffset, cxform.alphaOffset);
                        };


                        Object.defineProperty(ColorTransform.prototype, "native_redMultiplier", {
                            get: function () {
                                return this.redMultiplier;
                            },
                            set: function (redMultiplier) {
                                this.redMultiplier = +redMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_greenMultiplier", {
                            get: function () {
                                return this.greenMultiplier;
                            },
                            set: function (greenMultiplier) {
                                this.greenMultiplier = +greenMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_blueMultiplier", {
                            get: function () {
                                return this.blueMultiplier;
                            },
                            set: function (blueMultiplier) {
                                this.blueMultiplier = +blueMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_alphaMultiplier", {
                            get: function () {
                                return this.alphaMultiplier;
                            },
                            set: function (alphaMultiplier) {
                                this.alphaMultiplier = +alphaMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_redOffset", {
                            get: function () {
                                return this.redOffset;
                            },
                            set: function (redOffset) {
                                this.redOffset = +redOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_greenOffset", {
                            get: function () {
                                return this.greenOffset;
                            },
                            set: function (greenOffset) {
                                this.greenOffset = +greenOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_blueOffset", {
                            get: function () {
                                return this.blueOffset;
                            },
                            set: function (blueOffset) {
                                this.blueOffset = +blueOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(ColorTransform.prototype, "native_alphaOffset", {
                            get: function () {
                                return this.alphaOffset;
                            },
                            set: function (alphaOffset) {
                                this.alphaOffset = +alphaOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        ColorTransform.prototype.ColorTransform = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                            if (typeof redMultiplier === "undefined") { redMultiplier = 1; }
                            if (typeof greenMultiplier === "undefined") { greenMultiplier = 1; }
                            if (typeof blueMultiplier === "undefined") { blueMultiplier = 1; }
                            if (typeof alphaMultiplier === "undefined") { alphaMultiplier = 1; }
                            if (typeof redOffset === "undefined") { redOffset = 0; }
                            if (typeof greenOffset === "undefined") { greenOffset = 0; }
                            if (typeof blueOffset === "undefined") { blueOffset = 0; }
                            if (typeof alphaOffset === "undefined") { alphaOffset = 0; }
                            this.redMultiplier = redMultiplier;
                            this.greenMultiplier = greenMultiplier;
                            this.blueMultiplier = blueMultiplier;
                            this.alphaMultiplier = alphaMultiplier;
                            this.redOffset = redOffset;
                            this.greenOffset = greenOffset;
                            this.blueOffset = blueOffset;
                            this.alphaOffset = alphaOffset;
                        };

                        Object.defineProperty(ColorTransform.prototype, "color", {
                            get: function () {
                                return (this.redOffset << 16) | (this.greenOffset << 8) | this.blueOffset;
                            },
                            set: function (newColor) {
                                this.redOffset = (newColor >> 16) & 0xff;
                                this.greenOffset = (newColor >> 8) & 0xff;
                                this.blueOffset = newColor & 0xff;
                                this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        ColorTransform.prototype.concat = function (second) {
                            this.redMultiplier *= second.redMultiplier;
                            this.greenMultiplier *= second.greenMultiplier;
                            this.blueMultiplier *= second.blueMultiplier;
                            this.alphaMultiplier *= second.alphaMultiplier;
                            this.redOffset += second.redOffset;
                            this.greenOffset += second.greenOffset;
                            this.blueOffset += second.blueOffset;
                            this.alphaOffset += second.alphaOffset;
                        };

                        ColorTransform.prototype.preMultiply = function (second) {
                            this.redOffset += second.redOffset * this.redMultiplier;
                            this.greenOffset += second.greenOffset * this.greenMultiplier;
                            this.blueOffset += second.blueOffset * this.blueMultiplier;
                            this.alphaOffset += second.alphaOffset * this.alphaMultiplier;
                            this.redMultiplier *= second.redMultiplier;
                            this.greenMultiplier *= second.greenMultiplier;
                            this.blueMultiplier *= second.blueMultiplier;
                            this.alphaMultiplier *= second.alphaMultiplier;
                        };

                        ColorTransform.prototype.copyFrom = function (sourceColorTransform) {
                            this.redMultiplier = sourceColorTransform.redMultiplier;
                            this.greenMultiplier = sourceColorTransform.greenMultiplier;
                            this.blueMultiplier = sourceColorTransform.blueMultiplier;
                            this.alphaMultiplier = sourceColorTransform.alphaMultiplier;
                            this.redOffset = sourceColorTransform.redOffset;
                            this.greenOffset = sourceColorTransform.greenOffset;
                            this.blueOffset = sourceColorTransform.blueOffset;
                            this.alphaOffset = sourceColorTransform.alphaOffset;
                        };

                        ColorTransform.prototype.setTo = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                            this.redMultiplier = redMultiplier;
                            this.greenMultiplier = greenMultiplier;
                            this.blueMultiplier = blueMultiplier;
                            this.alphaMultiplier = alphaMultiplier;
                            this.redOffset = redOffset;
                            this.greenOffset = greenOffset;
                            this.blueOffset = blueOffset;
                            this.alphaOffset = alphaOffset;
                        };

                        ColorTransform.prototype.clone = function () {
                            return new ColorTransform(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
                        };

                        ColorTransform.prototype.convertToFixedPoint = function () {
                            this.redMultiplier = clampS8U8(this.redMultiplier);
                            this.greenMultiplier = clampS8U8(this.greenMultiplier);
                            this.blueMultiplier = clampS8U8(this.blueMultiplier);
                            this.alphaMultiplier = clampS8U8(this.alphaMultiplier);
                            this.redOffset = toS16(this.redOffset);
                            this.greenOffset = toS16(this.greenOffset);
                            this.blueOffset = toS16(this.blueOffset);
                            this.alphaOffset = toS16(this.alphaOffset);
                            return this;
                        };

                        ColorTransform.prototype.toString = function () {
                            return "(redMultiplier=" + this.redMultiplier + ", greenMultiplier=" + this.greenMultiplier + ", blueMultiplier=" + this.blueMultiplier + ", alphaMultiplier=" + this.alphaMultiplier + ", redOffset=" + this.redOffset + ", greenOffset=" + this.greenOffset + ", blueOffset=" + this.blueOffset + ", alphaOffset=" + this.alphaOffset + ")";
                        };
                        ColorTransform.classInitializer = null;

                        ColorTransform.initializer = null;

                        ColorTransform.classSymbols = null;

                        ColorTransform.instanceSymbols = null;
                        return ColorTransform;
                    })(AS.ASNative);
                    geom.ColorTransform = ColorTransform;
                })(flash.geom || (flash.geom = {}));
                var geom = flash.geom;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Camera
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var Camera = (function (_super) {
                        __extends(Camera, _super);
                        function Camera() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.media.Camera");
                        }
                        Object.defineProperty(Camera.prototype, "names", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _names: any [];
                            // static _isSupported: boolean;
                            get: function () {
                                notImplemented("public flash.media.Camera::get names");
                                return;
                                // return this._names;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "isSupported", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get isSupported");
                                return;
                                // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Camera.getCamera = function (name) {
                            if (typeof name === "undefined") { name = null; }
                            name = asCoerceString(name);
                            notImplemented("public flash.media.Camera::static getCamera");
                            return;
                        };
                        Camera._scanHardware = function () {
                            notImplemented("public flash.media.Camera::static _scanHardware");
                            return;
                        };

                        Object.defineProperty(Camera.prototype, "activityLevel", {
                            // _activityLevel: number;
                            // _bandwidth: number /*int*/;
                            // _currentFPS: number;
                            // _fps: number;
                            // _height: number /*int*/;
                            // _index: number /*int*/;
                            // _keyFrameInterval: number /*int*/;
                            // _loopback: boolean;
                            // _motionLevel: number /*int*/;
                            // _motionTimeout: number /*int*/;
                            // _muted: boolean;
                            // _name: string;
                            // _position: string;
                            // _quality: number /*int*/;
                            // _width: number /*int*/;
                            get: function () {
                                notImplemented("public flash.media.Camera::get activityLevel");
                                return;
                                // return this._activityLevel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "bandwidth", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get bandwidth");
                                return;
                                // return this._bandwidth;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "currentFPS", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get currentFPS");
                                return;
                                // return this._currentFPS;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "fps", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get fps");
                                return;
                                // return this._fps;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "height", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get height");
                                return;
                                // return this._height;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "index", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get index");
                                return;
                                // return this._index;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "keyFrameInterval", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get keyFrameInterval");
                                return;
                                // return this._keyFrameInterval;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "loopback", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get loopback");
                                return;
                                // return this._loopback;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "motionLevel", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get motionLevel");
                                return;
                                // return this._motionLevel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "motionTimeout", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get motionTimeout");
                                return;
                                // return this._motionTimeout;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "muted", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get muted");
                                return;
                                // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "name", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get name");
                                return;
                                // return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "position", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get position");
                                return;
                                // return this._position;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "quality", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get quality");
                                return;
                                // return this._quality;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, "width", {
                            get: function () {
                                notImplemented("public flash.media.Camera::get width");
                                return;
                                // return this._width;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Camera.prototype.setCursor = function (value) {
                            value = !!value;
                            notImplemented("public flash.media.Camera::setCursor");
                            return;
                        };
                        Camera.prototype.setKeyFrameInterval = function (keyFrameInterval /*int*/ ) {
                            keyFrameInterval = keyFrameInterval | 0;
                            notImplemented("public flash.media.Camera::setKeyFrameInterval");
                            return;
                        };
                        Camera.prototype.setLoopback = function (compress) {
                            if (typeof compress === "undefined") { compress = false; }
                            compress = !!compress;
                            notImplemented("public flash.media.Camera::setLoopback");
                            return;
                        };
                        Camera.prototype.setMode = function (width /*int*/ , height /*int*/ , fps, favorArea) {
                            if (typeof favorArea === "undefined") { favorArea = true; }
                            width = width | 0;
                            height = height | 0;
                            fps = +fps;
                            favorArea = !!favorArea;
                            notImplemented("public flash.media.Camera::setMode");
                            return;
                        };
                        Camera.prototype.setMotionLevel = function (motionLevel /*int*/ , timeout) {
                            if (typeof timeout === "undefined") { timeout = 2000; }
                            motionLevel = motionLevel | 0;
                            timeout = timeout | 0;
                            notImplemented("public flash.media.Camera::setMotionLevel");
                            return;
                        };
                        Camera.prototype.setQuality = function (bandwidth /*int*/ , quality /*int*/ ) {
                            bandwidth = bandwidth | 0;
                            quality = quality | 0;
                            notImplemented("public flash.media.Camera::setQuality");
                            return;
                        };
                        Camera.prototype.drawToBitmapData = function (destination) {
                            destination = destination;
                            notImplemented("public flash.media.Camera::drawToBitmapData");
                            return;
                        };
                        Camera.prototype.copyToByteArray = function (rect, destination) {
                            rect = rect;
                            destination = destination;
                            notImplemented("public flash.media.Camera::copyToByteArray");
                            return;
                        };
                        Camera.prototype.copyToVector = function (rect, destination) {
                            rect = rect;
                            destination = destination;
                            notImplemented("public flash.media.Camera::copyToVector");
                            return;
                        };
                        Camera.classInitializer = null;

                        Camera.initializer = null;

                        Camera.classSymbols = null;

                        Camera.instanceSymbols = null;
                        return Camera;
                    })(flash.events.EventDispatcher);
                    media.Camera = Camera;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ID3Info
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ID3Info = (function (_super) {
                        __extends(ID3Info, _super);
                        function ID3Info() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.media.ID3Info");
                        }
                        ID3Info.classInitializer = null;

                        ID3Info.initializer = null;

                        ID3Info.classSymbols = null;

                        ID3Info.instanceSymbols = ["songName", "artist", "album", "year", "comment", "genre", "track"];
                        return ID3Info;
                    })(AS.ASNative);
                    media.ID3Info = ID3Info;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Microphone
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var Microphone = (function (_super) {
                        __extends(Microphone, _super);
                        function Microphone() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.media.Microphone");
                        }
                        Object.defineProperty(Microphone.prototype, "names", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _names: any [];
                            // static _isSupported: boolean;
                            get: function () {
                                notImplemented("public flash.media.Microphone::get names");
                                return;
                                // return this._names;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "isSupported", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get isSupported");
                                return;
                                // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Microphone.getMicrophone = function (index) {
                            if (typeof index === "undefined") { index = -1; }
                            index = index | 0;
                            notImplemented("public flash.media.Microphone::static getMicrophone");
                            return;
                        };
                        Microphone.getEnhancedMicrophone = function (index) {
                            if (typeof index === "undefined") { index = -1; }
                            index = index | 0;
                            notImplemented("public flash.media.Microphone::static getEnhancedMicrophone");
                            return;
                        };

                        Object.defineProperty(Microphone.prototype, "rate", {
                            // _rate: number /*int*/;
                            // _codec: string;
                            // _framesPerPacket: number /*int*/;
                            // _encodeQuality: number /*int*/;
                            // _noiseSuppressionLevel: number /*int*/;
                            // _enableVAD: boolean;
                            // _activityLevel: number;
                            // _gain: number;
                            // _index: number /*int*/;
                            // _muted: boolean;
                            // _name: string;
                            // _silenceLevel: number;
                            // _silenceTimeout: number /*int*/;
                            // _useEchoSuppression: boolean;
                            // _soundTransform: flash.media.SoundTransform;
                            // _enhancedOptions: flash.media.MicrophoneEnhancedOptions;
                            get: function () {
                                notImplemented("public flash.media.Microphone::get rate");
                                return;
                                // return this._rate;
                            },
                            set: function (rate /*int*/ ) {
                                rate = rate | 0;
                                notImplemented("public flash.media.Microphone::set rate");
                                return;
                                // this._rate = rate;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "codec", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get codec");
                                return;
                                // return this._codec;
                            },
                            set: function (codec) {
                                codec = asCoerceString(codec);
                                notImplemented("public flash.media.Microphone::set codec");
                                return;
                                // this._codec = codec;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "framesPerPacket", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get framesPerPacket");
                                return;
                                // return this._framesPerPacket;
                            },
                            set: function (frames /*int*/ ) {
                                frames = frames | 0;
                                notImplemented("public flash.media.Microphone::set framesPerPacket");
                                return;
                                // this._framesPerPacket = frames;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "encodeQuality", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get encodeQuality");
                                return;
                                // return this._encodeQuality;
                            },
                            set: function (quality /*int*/ ) {
                                quality = quality | 0;
                                notImplemented("public flash.media.Microphone::set encodeQuality");
                                return;
                                // this._encodeQuality = quality;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "noiseSuppressionLevel", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get noiseSuppressionLevel");
                                return;
                                // return this._noiseSuppressionLevel;
                            },
                            set: function (level /*int*/ ) {
                                level = level | 0;
                                notImplemented("public flash.media.Microphone::set noiseSuppressionLevel");
                                return;
                                // this._noiseSuppressionLevel = level;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "enableVAD", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get enableVAD");
                                return;
                                // return this._enableVAD;
                            },
                            set: function (enable) {
                                enable = !!enable;
                                notImplemented("public flash.media.Microphone::set enableVAD");
                                return;
                                // this._enableVAD = enable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "activityLevel", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get activityLevel");
                                return;
                                // return this._activityLevel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "gain", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get gain");
                                return;
                                // return this._gain;
                            },
                            set: function (gain) {
                                gain = +gain;
                                notImplemented("public flash.media.Microphone::set gain");
                                return;
                                // this._gain = gain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "index", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get index");
                                return;
                                // return this._index;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "muted", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get muted");
                                return;
                                // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "name", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get name");
                                return;
                                // return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "silenceLevel", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get silenceLevel");
                                return;
                                // return this._silenceLevel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "silenceTimeout", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get silenceTimeout");
                                return;
                                // return this._silenceTimeout;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "useEchoSuppression", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get useEchoSuppression");
                                return;
                                // return this._useEchoSuppression;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, "soundTransform", {
                            get: function () {
                                notImplemented("public flash.media.Microphone::get soundTransform");
                                return;
                                // return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                sndTransform = sndTransform;
                                notImplemented("public flash.media.Microphone::set soundTransform");
                                return;
                                // this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //    get enhancedOptions(): flash.media.MicrophoneEnhancedOptions {
                        //      notImplemented("public flash.media.Microphone::get enhancedOptions"); return;
                        //      // return this._enhancedOptions;
                        //    }
                        //    set enhancedOptions(options: flash.media.MicrophoneEnhancedOptions) {
                        //      options = options;
                        //      notImplemented("public flash.media.Microphone::set enhancedOptions"); return;
                        //      // this._enhancedOptions = options;
                        //    }
                        Microphone.prototype.setSilenceLevel = function (silenceLevel, timeout) {
                            if (typeof timeout === "undefined") { timeout = -1; }
                            silenceLevel = +silenceLevel;
                            timeout = timeout | 0;
                            notImplemented("public flash.media.Microphone::setSilenceLevel");
                            return;
                        };
                        Microphone.prototype.setUseEchoSuppression = function (useEchoSuppression) {
                            useEchoSuppression = !!useEchoSuppression;
                            notImplemented("public flash.media.Microphone::setUseEchoSuppression");
                            return;
                        };
                        Microphone.prototype.setLoopBack = function (state) {
                            if (typeof state === "undefined") { state = true; }
                            state = !!state;
                            notImplemented("public flash.media.Microphone::setLoopBack");
                            return;
                        };
                        Microphone.classInitializer = null;

                        Microphone.initializer = null;

                        Microphone.classSymbols = null;

                        Microphone.instanceSymbols = null;
                        return Microphone;
                    })(flash.events.EventDispatcher);
                    media.Microphone = Microphone;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Sound
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var Telemetry = Shumway.Telemetry;
                    var Multiname = Shumway.AVM2.ABC.Multiname;

                    var PLAY_USING_AUDIO_TAG = true;

                    function getAudioDescription(soundData, onComplete) {
                        var audioElement = document.createElement('audio');
                        if (!audioElement.canPlayType(soundData.mimeType)) {
                            onComplete({
                                duration: 0
                            });
                            return;
                        }
                        audioElement.preload = 'metadata'; // for mobile devices
                        var blob = new Blob([soundData.data], { type: soundData.mimeType });
                        audioElement.src = URL.createObjectURL(blob);
                        audioElement.load();
                        audioElement.addEventListener("loadedmetadata", function () {
                            onComplete({
                                duration: this.duration * 1000
                            });
                        });
                    }

                    var SoundData = (function () {
                        function SoundData() {
                        }
                        return SoundData;
                    })();

                    var Sound = (function (_super) {
                        __extends(Sound, _super);
                        function Sound(stream, context) {
                            if (typeof stream === "undefined") { stream = null; }
                            if (typeof context === "undefined") { context = null; }
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.media.Sound");
                        }
                        Object.defineProperty(Sound.prototype, "url", {
                            get: function () {
                                return this._url;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, "isURLInaccessible", {
                            get: function () {
                                notImplemented("public flash.media.Sound::get isURLInaccessible");
                                return;
                                // return this._isURLInaccessible;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, "length", {
                            get: function () {
                                return this._length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, "isBuffering", {
                            get: function () {
                                notImplemented("public flash.media.Sound::get isBuffering");
                                return;
                                // return this._isBuffering;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, "bytesLoaded", {
                            get: function () {
                                return this._bytesLoaded;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, "bytesTotal", {
                            get: function () {
                                return this._bytesTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, "id3", {
                            get: function () {
                                return this._id3;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Sound.prototype.loadCompressedDataFromByteArray = function (bytes, bytesLength /*uint*/ ) {
                            bytes = bytes;
                            bytesLength = bytesLength >>> 0;
                            notImplemented("public flash.media.Sound::loadCompressedDataFromByteArray");
                            return;
                        };
                        Sound.prototype.loadPCMFromByteArray = function (bytes, samples /*uint*/ , format, stereo, sampleRate) {
                            if (typeof format === "undefined") { format = "float"; }
                            if (typeof stereo === "undefined") { stereo = true; }
                            if (typeof sampleRate === "undefined") { sampleRate = 44100; }
                            bytes = bytes;
                            samples = samples >>> 0;
                            format = asCoerceString(format);
                            stereo = !!stereo;
                            sampleRate = +sampleRate;
                            notImplemented("public flash.media.Sound::loadPCMFromByteArray");
                            return;
                        };
                        Sound.prototype.play = function (startTime, loops, sndTransform) {
                            if (typeof startTime === "undefined") { startTime = 0; }
                            if (typeof loops === "undefined") { loops = 0; }
                            if (typeof sndTransform === "undefined") { sndTransform = null; }
                            startTime = +startTime;
                            loops = loops | 0;
                            var channel = new flash.media.SoundChannel();
                            channel._sound = this;
                            channel._soundTransform = Shumway.isNullOrUndefined(sndTransform) ? new flash.media.SoundTransform() : sndTransform;
                            this._playQueue.push({
                                channel: channel,
                                startTime: startTime
                            });
                            if (this._soundData) {
                                if (PLAY_USING_AUDIO_TAG) {
                                    channel._playSoundDataViaAudio(this._soundData, startTime, loops);
                                } else {
                                    channel._playSoundDataViaChannel(this._soundData, startTime, loops);
                                }
                            }
                            return channel;
                        };
                        Sound.prototype.close = function () {
                            somewhatImplemented("public flash.media.Sound::close");
                        };
                        Sound.prototype.extract = function (target, length, startPosition) {
                            if (typeof startPosition === "undefined") { startPosition = -1; }
                            target = target;
                            length = +length;
                            startPosition = +startPosition;
                            notImplemented("public flash.media.Sound::extract");
                            return;
                        };
                        Sound.prototype._load = function (request, checkPolicyFile, bufferTime) {
                            checkPolicyFile = !!checkPolicyFile;
                            bufferTime = +bufferTime;
                            if (!request) {
                                return;
                            }

                            var _this = this;
                            var stream = this._stream = new flash.net.URLStream();
                            var data = new flash.utils.ByteArray();
                            var dataPosition = 0;
                            var mp3DecodingSession = null;
                            var soundData = new SoundData();
                            soundData.completed = false;

                            stream.addEventListener("progress", function (event) {
                                _this._bytesLoaded = event[Multiname.getPublicQualifiedName("bytesLoaded")];
                                _this._bytesTotal = event[Multiname.getPublicQualifiedName("bytesTotal")];

                                if (!PLAY_USING_AUDIO_TAG && !mp3DecodingSession) {
                                    // initialize MP3 decoding
                                    mp3DecodingSession = decodeMP3(soundData, function (duration, final) {
                                        if (_this._length === 0) {
                                            // once we have some data, trying to play it
                                            _this._soundData = soundData;

                                            _this._playQueue.forEach(function (item) {
                                                item.channel._playSoundDataViaChannel(soundData, item.startTime);
                                            });
                                        }

                                        // estimate duration based on bytesTotal and current loaded data time
                                        _this._length = final ? duration * 1000 : Math.max(duration, mp3DecodingSession.estimateDuration(_this._bytesTotal)) * 1000;
                                    });
                                }

                                var bytesAvailable = stream.bytesAvailable;
                                stream.readBytes(data, dataPosition, bytesAvailable);
                                if (mp3DecodingSession) {
                                    mp3DecodingSession.pushData(new Uint8Array(data._buffer, dataPosition, bytesAvailable));
                                }
                                dataPosition += bytesAvailable;

                                _this.dispatchEvent(event);
                            });

                            stream.addEventListener("complete", function (event) {
                                _this.dispatchEvent(event);
                                soundData.data = data._buffer;
                                soundData.mimeType = 'audio/mpeg';
                                soundData.completed = true;

                                if (PLAY_USING_AUDIO_TAG) {
                                    _this._soundData = soundData;

                                    getAudioDescription(soundData, function (description) {
                                        _this._length = description.duration;
                                    });

                                    _this._playQueue.forEach(function (item) {
                                        item.channel._playSoundDataViaAudio(soundData, item.startTime);
                                    });
                                }

                                if (mp3DecodingSession) {
                                    mp3DecodingSession.close();
                                }
                            });

                            stream.load(request);
                        };
                        Sound.classInitializer = null;

                        Sound.initializer = function (symbol) {
                            this._playQueue = [];
                            this._url = null;
                            this._length = 0;
                            this._bytesTotal = 0;
                            this._bytesLoaded = 0;
                            this._id3 = new flash.media.ID3Info();

                            Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 5 /* SOUND_FEATURE */ });

                            if (symbol) {
                                var soundData = new SoundData();
                                if (symbol.pcm) {
                                    soundData.sampleRate = symbol.sampleRate;
                                    soundData.channels = symbol.channels;
                                    soundData.pcm = symbol.pcm;
                                    soundData.end = symbol.pcm.length;
                                }
                                soundData.completed = true;
                                if (symbol.packaged) {
                                    soundData.data = symbol.packaged.data.buffer;
                                    soundData.mimeType = symbol.packaged.mimeType;
                                }
                                var self = this;
                                getAudioDescription(soundData, function (description) {
                                    self._length = description.duration;
                                });
                                this._soundData = soundData;
                            }
                        };

                        Sound.classSymbols = null;

                        Sound.instanceSymbols = null;
                        return Sound;
                    })(flash.events.EventDispatcher);
                    media.Sound = Sound;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SoundChannel
                (function (media) {
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;

                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var error = Shumway.Debug.error;

                    function createAudioChannel(sampleRate, channels) {
                        if (WebAudioChannel.isSupported) {
                            return new WebAudioChannel(sampleRate, channels);
                        } else {
                            error('PCM data playback is not supported by the browser');
                        }
                    }

                    
                    var AudioResampler = (function () {
                        function AudioResampler(sourceRate, targetRate) {
                            this._sourceRate = sourceRate;
                            this._targetRate = targetRate;
                            this._tail = [];
                            this._sourceOffset = 0;
                        }
                        AudioResampler.prototype.getData = function (channelsData, count) {
                            var k = this._sourceRate / this._targetRate;

                            var offset = this._sourceOffset;
                            var needed = Math.ceil((count - 1) * k + offset) + 1;
                            var sourceData = [];
                            for (var channel = 0; channel < channelsData.length; channel++) {
                                sourceData.push(new Float32Array(needed));
                            }
                            var e = { data: sourceData, count: needed };
                            this.ondatarequested(e);
                            for (var channel = 0; channel < channelsData.length; channel++) {
                                var data = channelsData[channel];
                                var source = sourceData[channel];
                                for (var j = 0; j < count; j++) {
                                    var i = j * k + offset;
                                    var i1 = i | 0, i2 = Math.ceil(i) | 0;
                                    var source_i1 = i1 < 0 ? this._tail[channel] : source[i1];
                                    if (i1 === i2) {
                                        data[j] = source_i1;
                                    } else {
                                        var alpha = i - i1;
                                        data[j] = source_i1 * (1 - alpha) + source[i2] * alpha;
                                    }
                                }
                                this._tail[channel] = source[needed - 1];
                            }
                            this._sourceOffset = ((count - 1) * k + offset) - (needed - 1);
                        };
                        return AudioResampler;
                    })();

                    var WebAudioChannel = (function () {
                        function WebAudioChannel(sampleRate, channels) {
                            var context = WebAudioChannel._cachedContext;
                            if (!context) {
                                context = new AudioContext();
                                WebAudioChannel._cachedContext = context;
                            }
                            this._context = context;
                            this._contextSampleRate = context.sampleRate || 44100;

                            this._channels = channels;
                            this._sampleRate = sampleRate;
                            if (this._contextSampleRate !== sampleRate) {
                                this._resampler = new AudioResampler(sampleRate, this._contextSampleRate);
                                this._resampler.ondatarequested = function (e) {
                                    this.requestData(e.data, e.count);
                                }.bind(this);
                            }
                        }
                        WebAudioChannel.prototype.start = function () {
                            var source = this._context.createScriptProcessor(2048, 0, this._channels);
                            var self = this;
                            source.onaudioprocess = function (e) {
                                var channelsData = [];
                                for (var i = 0; i < self._channels; i++) {
                                    channelsData.push(e.outputBuffer.getChannelData(i));
                                }
                                var count = channelsData[0].length;
                                if (self._resampler) {
                                    self._resampler.getData(channelsData, count);
                                } else {
                                    self.requestData(channelsData, count);
                                }
                            };

                            source.connect(this._context.destination);
                            this._source = source;
                        };
                        WebAudioChannel.prototype.stop = function () {
                            this._source.disconnect(this._context.destination);
                        };
                        WebAudioChannel.prototype.requestData = function (channelsData, count) {
                            var channels = this._channels;
                            var buffer = new Float32Array(count * channels);
                            var e = { data: buffer, count: buffer.length };
                            this.ondatarequested(e);

                            for (var j = 0, p = 0; j < count; j++) {
                                for (var i = 0; i < channels; i++) {
                                    channelsData[i][j] = buffer[p++];
                                }
                            }
                        };
                        WebAudioChannel.isSupported = function () {
                            return typeof AudioContext !== 'undefined';
                        };
                        return WebAudioChannel;
                    })();

                    var SoundChannel = (function (_super) {
                        __extends(SoundChannel, _super);
                        function SoundChannel() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.media.SoundChannel");
                        }
                        Object.defineProperty(SoundChannel.prototype, "position", {
                            get: function () {
                                return this._position;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, "soundTransform", {
                            get: function () {
                                return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                somewhatImplemented("public flash.media.SoundChannel::set soundTransform");
                                this._soundTransform = Shumway.isNullOrUndefined(sndTransform) ? new flash.media.SoundTransform() : sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, "leftPeak", {
                            get: function () {
                                return this._leftPeak;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, "rightPeak", {
                            get: function () {
                                return this._rightPeak;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SoundChannel.prototype.stop = function () {
                            if (this._element) {
                                this._unregisterWithSoundMixer();
                                this._element.pause();
                            }
                            if (this._audioChannel) {
                                this._unregisterWithSoundMixer();
                                this._audioChannel.stop();
                            }
                        };
                        SoundChannel.prototype._playSoundDataViaAudio = function (soundData, startTime, loops) {
                            if (!soundData.mimeType) {
                                return;
                            }

                            this._registerWithSoundMixer();
                            this._position = startTime;
                            var self = this;
                            var lastCurrentTime = 0;
                            var element = document.createElement('audio');
                            if (!element.canPlayType(soundData.mimeType)) {
                                console.error('ERROR: \"' + soundData.mimeType + '\" ' + 'type playback is not supported by the browser');
                                return;
                            }
                            element.preload = 'metadata'; // for mobile devices
                            element.loop = loops > 0; // starts loop played if at least one is specified
                            var blob = new Blob([soundData.data], { type: soundData.mimeType });
                            element.src = URL.createObjectURL(blob);
                            element.addEventListener("loadeddata", function loaded() {
                                element.currentTime = startTime / 1000;
                                element.play();
                            });
                            element.addEventListener("timeupdate", function timeupdate() {
                                var currentTime = element.currentTime;
                                if (loops && lastCurrentTime > currentTime) {
                                    --loops;
                                    if (!loops) {
                                        element.loop = false;
                                    }
                                    if (currentTime < startTime / 1000) {
                                        element.currentTime = startTime / 1000;
                                    }
                                }
                                self._position = (lastCurrentTime = currentTime) * 1000;
                            });
                            element.addEventListener("ended", function ended() {
                                self._unregisterWithSoundMixer();
                                self.dispatchEvent(new flash.events.Event("soundComplete", false, false));
                                self._element = null;
                            });
                            this._element = element;
                            this._applySoundTransform();
                        };
                        SoundChannel.prototype._playSoundDataViaChannel = function (soundData, startTime, loops) {
                            release || assert(soundData.pcm, 'no pcm data found');

                            this._registerWithSoundMixer();
                            var self = this;
                            var startPosition = Math.round(startTime / 1000 * soundData.sampleRate) * soundData.channels;
                            var position = startPosition;
                            this._position = startTime;
                            this._audioChannel = createAudioChannel(soundData.sampleRate, soundData.channels);
                            this._audioChannel.ondatarequested = function (e) {
                                var end = soundData.end;
                                if (position >= end && soundData.completed) {
                                    // end of buffer
                                    self._unregisterWithSoundMixer();
                                    self._audioChannel.stop();
                                    self.dispatchEvent(new flash.events.Event("soundComplete", false, false));
                                    return;
                                }

                                var left = e.count;
                                var data = e.data;
                                var source = soundData.pcm;
                                do {
                                    var count = Math.min(end - position, left);
                                    for (var j = 0; j < count; j++) {
                                        data[j] = source[position++];
                                    }
                                    left -= count;
                                    if (position >= end) {
                                        if (!loops) {
                                            break;
                                        }
                                        loops--;
                                        position = startPosition;
                                    }
                                } while(left > 0);

                                self._position = position / soundData.sampleRate / soundData.channels * 1000;
                            };
                            this._audioChannel.start();
                            this._applySoundTransform();
                        };
                        SoundChannel.prototype._applySoundTransform = function () {
                            // TODO: apply pan
                            var volume = this._soundTransform.volume;
                            if (media.SoundMixer._soundTransform) {
                                volume *= media.SoundMixer._soundTransform.volume;
                            }
                            volume *= media.SoundMixer._getMasterVolume();
                            if (this._element) {
                                this._element.volume = volume <= 0 ? 0 : volume >= 1.0 ? 1.0 : volume;
                            }
                            if (this._audioChannel) {
                                // TODO
                            }
                        };
                        SoundChannel.prototype._registerWithSoundMixer = function () {
                            media.SoundMixer._registerChannel(this);
                        };
                        SoundChannel.prototype._unregisterWithSoundMixer = function () {
                            media.SoundMixer._unregisterChannel(this);
                        };
                        SoundChannel.classInitializer = null;

                        SoundChannel.initializer = function (symbol) {
                            this._element = null;
                            this._position = 0;
                            this._leftPeak = 0;
                            this._rightPeak = 0;
                            this._pcmData = null;
                            this._soundTransform = new flash.media.SoundTransform();
                            //this._element = symbol._element || null;
                            //if (this._element) {
                            //  this._registerWithSoundMixer();
                            //}
                        };

                        SoundChannel.classSymbols = null;

                        SoundChannel.instanceSymbols = null;
                        return SoundChannel;
                    })(flash.events.EventDispatcher);
                    media.SoundChannel = SoundChannel;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SoundLoaderContext
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var SoundLoaderContext = (function (_super) {
                        __extends(SoundLoaderContext, _super);
                        function SoundLoaderContext(bufferTime, checkPolicyFile) {
                            if (typeof bufferTime === "undefined") { bufferTime = 1000; }
                            if (typeof checkPolicyFile === "undefined") { checkPolicyFile = false; }
                            bufferTime = +bufferTime;
                            checkPolicyFile = !!checkPolicyFile;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.media.SoundLoaderContext");
                        }
                        SoundLoaderContext.classInitializer = null;

                        SoundLoaderContext.initializer = null;

                        SoundLoaderContext.classSymbols = null;

                        SoundLoaderContext.instanceSymbols = null;
                        return SoundLoaderContext;
                    })(AS.ASNative);
                    media.SoundLoaderContext = SoundLoaderContext;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SoundMixer
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var SoundMixer = (function (_super) {
                        __extends(SoundMixer, _super);
                        function SoundMixer() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.media.SoundMixer");
                        }
                        Object.defineProperty(SoundMixer, "bufferTime", {
                            // static _audioPlaybackMode: string;
                            // static _useSpeakerphoneForVoice: boolean;
                            get: function () {
                                notImplemented("public flash.media.SoundMixer::get bufferTime");
                                return;
                                // return SoundMixer._bufferTime;
                            },
                            set: function (bufferTime /*int*/ ) {
                                bufferTime = bufferTime | 0;
                                notImplemented("public flash.media.SoundMixer::set bufferTime");
                                return;
                                // SoundMixer._bufferTime = bufferTime;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundMixer, "soundTransform", {
                            get: function () {
                                somewhatImplemented("public flash.media.SoundMixer::get soundTransform");
                                return Shumway.isNullOrUndefined(SoundMixer._soundTransform) ? new flash.media.SoundTransform() : new flash.media.SoundTransform(SoundMixer._soundTransform.volume, SoundMixer._soundTransform.pan);
                            },
                            set: function (sndTransform) {
                                somewhatImplemented("public flash.media.SoundMixer::set soundTransform");
                                SoundMixer._soundTransform = Shumway.isNullOrUndefined(sndTransform) ? new flash.media.SoundTransform() : sndTransform;
                                SoundMixer._registeredChannels.forEach(function (channel) {
                                    channel._applySoundTransform();
                                });
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundMixer, "audioPlaybackMode", {
                            get: function () {
                                notImplemented("public flash.media.SoundMixer::get audioPlaybackMode");
                                return;
                                // return SoundMixer._audioPlaybackMode;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                notImplemented("public flash.media.SoundMixer::set audioPlaybackMode");
                                return;
                                // SoundMixer._audioPlaybackMode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundMixer, "useSpeakerphoneForVoice", {
                            get: function () {
                                notImplemented("public flash.media.SoundMixer::get useSpeakerphoneForVoice");
                                return;
                                // return SoundMixer._useSpeakerphoneForVoice;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.media.SoundMixer::set useSpeakerphoneForVoice");
                                return;
                                // SoundMixer._useSpeakerphoneForVoice = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SoundMixer.stopAll = function () {
                            SoundMixer._registeredChannels.forEach(function (channel) {
                                channel.stop();
                            });
                            SoundMixer._registeredChannels = [];
                        };
                        SoundMixer.computeSpectrum = function (outputArray, FFTMode, stretchFactor) {
                            if (typeof FFTMode === "undefined") { FFTMode = false; }
                            if (typeof stretchFactor === "undefined") { stretchFactor = 0; }
                            FFTMode = !!FFTMode;
                            stretchFactor = stretchFactor | 0;
                            somewhatImplemented("public flash.media.SoundMixer::static computeSpectrum");
                            var data = new Float32Array(1024);
                            for (var i = 0; i < 1024; i++) {
                                data[i] = Math.random();
                            }
                            outputArray.writeRawBytes(data);
                            outputArray.position = 0;
                        };
                        SoundMixer.areSoundsInaccessible = function () {
                            notImplemented("public flash.media.SoundMixer::static areSoundsInaccessible");
                            return;
                        };
                        SoundMixer._getMasterVolume = function () {
                            return SoundMixer._masterVolume;
                        };
                        SoundMixer._setMasterVolume = function (volume) {
                            volume = +volume;
                            SoundMixer._masterVolume = volume;
                            SoundMixer._registeredChannels.forEach(function (channel) {
                                channel._applySoundTransform();
                            });
                        };
                        SoundMixer._registerChannel = function (channel) {
                            SoundMixer._registeredChannels.push(channel);
                        };
                        SoundMixer._unregisterChannel = function (channel) {
                            var index = SoundMixer._registeredChannels.indexOf(channel);
                            if (index >= 0) {
                                SoundMixer._registeredChannels.splice(index, 1);
                            }
                        };
                        SoundMixer.classInitializer = null;

                        SoundMixer.initializer = null;

                        SoundMixer.classSymbols = null;

                        SoundMixer.instanceSymbols = null;

                        SoundMixer._masterVolume = 1;
                        SoundMixer._registeredChannels = [];
                        return SoundMixer;
                    })(AS.ASNative);
                    media.SoundMixer = SoundMixer;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SoundTransform
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var SoundTransform = (function (_super) {
                        __extends(SoundTransform, _super);
                        function SoundTransform(vol, panning) {
                            if (typeof vol === "undefined") { vol = 1; }
                            if (typeof panning === "undefined") { panning = 0; }
                            vol = +vol;
                            panning = +panning;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.media.SoundTransform");
                        }
                        Object.defineProperty(SoundTransform.prototype, "volume", {
                            get: function () {
                                return this._volume;
                            },
                            set: function (volume) {
                                volume = +volume;
                                this._volume = volume;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, "leftToLeft", {
                            get: function () {
                                return this._leftToLeft;
                            },
                            set: function (leftToLeft) {
                                leftToLeft = +leftToLeft;
                                this._leftToLeft = leftToLeft;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, "leftToRight", {
                            get: function () {
                                return this._leftToRight;
                            },
                            set: function (leftToRight) {
                                leftToRight = +leftToRight;
                                this._leftToRight = leftToRight;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, "rightToRight", {
                            get: function () {
                                return this._rightToRight;
                            },
                            set: function (rightToRight) {
                                rightToRight = +rightToRight;
                                this._rightToRight = rightToRight;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, "rightToLeft", {
                            get: function () {
                                return this._rightToLeft;
                            },
                            set: function (rightToLeft) {
                                rightToLeft = +rightToLeft;
                                this._rightToLeft = rightToLeft;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, "pan", {
                            get: function () {
                                if (this._leftToRight === 0 && this._rightToLeft === 0) {
                                    return 1 - this._leftToLeft * this._leftToLeft;
                                }
                                return 0;
                            },
                            set: function (panning) {
                                this.leftToLeft = Math.sqrt(1 - panning);
                                this.leftToRight = 0;
                                this.rightToRight = Math.sqrt(1 + panning);
                                this.rightToLeft = 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        SoundTransform.prototype._updateTransform = function () {
                            somewhatImplemented("public flash.media.SoundTransform::_updateTransform");
                            // TODO dispatch updates to the current audio destinations?
                        };
                        SoundTransform.classInitializer = null;

                        SoundTransform.initializer = null;

                        SoundTransform.classSymbols = null;

                        SoundTransform.instanceSymbols = null;
                        return SoundTransform;
                    })(AS.ASNative);
                    media.SoundTransform = SoundTransform;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Video
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Video = (function (_super) {
                        __extends(Video, _super);
                        function Video(width, height) {
                            if (typeof width === "undefined") { width = 320; }
                            if (typeof height === "undefined") { height = 240; }
                            width = width | 0;
                            height = height | 0;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.media.Video");
                        }
                        Object.defineProperty(Video.prototype, "deblocking", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _deblocking: number /*int*/;
                            // _smoothing: boolean;
                            // _videoWidth: number /*int*/;
                            // _videoHeight: number /*int*/;
                            get: function () {
                                notImplemented("public flash.media.Video::get deblocking");
                                return;
                                // return this._deblocking;
                            },
                            set: function (value /*int*/ ) {
                                value = value | 0;
                                notImplemented("public flash.media.Video::set deblocking");
                                return;
                                // this._deblocking = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Video.prototype, "smoothing", {
                            get: function () {
                                notImplemented("public flash.media.Video::get smoothing");
                                return;
                                // return this._smoothing;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.media.Video::set smoothing");
                                return;
                                // this._smoothing = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Video.prototype, "videoWidth", {
                            get: function () {
                                notImplemented("public flash.media.Video::get videoWidth");
                                return;
                                // return this._videoWidth;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Video.prototype, "videoHeight", {
                            get: function () {
                                notImplemented("public flash.media.Video::get videoHeight");
                                return;
                                // return this._videoHeight;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Video.prototype.clear = function () {
                            notImplemented("public flash.media.Video::clear");
                            return;
                        };
                        Video.prototype.attachNetStream = function (netStream) {
                            netStream = netStream;
                            notImplemented("public flash.media.Video::attachNetStream");
                            return;
                        };
                        Video.prototype.attachCamera = function (camera) {
                            camera = camera;
                            notImplemented("public flash.media.Video::attachCamera");
                            return;
                        };
                        Video.prototype.ctor = function (width /*int*/ , height /*int*/ ) {
                            width = width | 0;
                            height = height | 0;
                            notImplemented("public flash.media.Video::ctor");
                            return;
                        };
                        Video.classInitializer = null;

                        Video.initializer = null;

                        Video.classSymbols = null;

                        Video.instanceSymbols = null;
                        return Video;
                    })(flash.display.DisplayObject);
                    media.Video = Video;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: VideoStreamSettings
                (function (media) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var VideoStreamSettings = (function (_super) {
                        __extends(VideoStreamSettings, _super);
                        function VideoStreamSettings() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.media.VideoStreamSettings");
                        }
                        VideoStreamSettings.classInitializer = null;

                        VideoStreamSettings.initializer = null;

                        VideoStreamSettings.classSymbols = null;

                        VideoStreamSettings.instanceSymbols = null;
                        return VideoStreamSettings;
                    })(AS.ASNative);
                    media.VideoStreamSettings = VideoStreamSettings;
                })(flash.media || (flash.media = {}));
                var media = flash.media;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: FileFilter
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var FileFilter = (function (_super) {
                        __extends(FileFilter, _super);
                        function FileFilter(description, extension, macType) {
                            if (typeof macType === "undefined") { macType = null; }
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.net.FileFilter");
                        }
                        Object.defineProperty(FileFilter.prototype, "description", {
                            get: function () {
                                return this._description;
                            },
                            set: function (value) {
                                this._description = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileFilter.prototype, "extension", {
                            get: function () {
                                return this._extension;
                            },
                            set: function (value) {
                                this._extension = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileFilter.prototype, "macType", {
                            get: function () {
                                return this._macType;
                            },
                            set: function (value) {
                                this._macType = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        FileFilter.classInitializer = null;

                        FileFilter.initializer = null;

                        FileFilter.classSymbols = null;

                        FileFilter.instanceSymbols = null;
                        return FileFilter;
                    })(AS.ASNative);
                    net.FileFilter = FileFilter;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: LocalConnection
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var FileLoadingService = Shumway.FileLoadingService;

                    var LocalConnection = (function (_super) {
                        __extends(LocalConnection, _super);
                        function LocalConnection() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.LocalConnection");
                        }
                        // AS -> JS Bindings
                        // static _isSupported: boolean;
                        // _domain: string;
                        // _client: ASObject;
                        // _isPerUser: boolean;
                        LocalConnection.prototype.close = function () {
                            notImplemented("public flash.net.LocalConnection::close");
                            return;
                        };
                        LocalConnection.prototype.connect = function (connectionName) {
                            connectionName = asCoerceString(connectionName);
                            notImplemented("public flash.net.LocalConnection::connect");
                            return;
                        };
                        Object.defineProperty(LocalConnection.prototype, "domain", {
                            get: function () {
                                somewhatImplemented("public flash.net.LocalConnection::get domain");

                                // HACK some SWFs want to know where they are hosted
                                var url = FileLoadingService.instance.resolveUrl('/');
                                var m = /:\/\/(.+?)[:?#\/]/.exec(url);
                                return m && m[1];
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LocalConnection.prototype.send = function (connectionName, methodName) {
                            connectionName = asCoerceString(connectionName);
                            methodName = asCoerceString(methodName);
                            notImplemented("public flash.net.LocalConnection::send");
                            return;
                        };
                        Object.defineProperty(LocalConnection.prototype, "client", {
                            get: function () {
                                notImplemented("public flash.net.LocalConnection::get client");
                                return;
                                // return this._client;
                            },
                            set: function (client) {
                                client = client;
                                notImplemented("public flash.net.LocalConnection::set client");
                                return;
                                // this._client = client;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LocalConnection.prototype, "isPerUser", {
                            get: function () {
                                notImplemented("public flash.net.LocalConnection::get isPerUser");
                                return;
                                // return this._isPerUser;
                            },
                            set: function (newValue) {
                                newValue = !!newValue;
                                notImplemented("public flash.net.LocalConnection::set isPerUser");
                                return;
                                // this._isPerUser = newValue;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LocalConnection.prototype.allowDomain = function () {
                            notImplemented("public flash.net.LocalConnection::allowDomain");
                            return;
                        };
                        LocalConnection.prototype.allowInsecureDomain = function () {
                            notImplemented("public flash.net.LocalConnection::allowInsecureDomain");
                            return;
                        };
                        LocalConnection.classInitializer = null;

                        LocalConnection.initializer = null;

                        LocalConnection.classSymbols = null;

                        LocalConnection.instanceSymbols = null;
                        return LocalConnection;
                    })(flash.events.EventDispatcher);
                    net.LocalConnection = LocalConnection;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NetConnection
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var wrapJSObject = Shumway.AVM2.Runtime.wrapJSObject;
                    var Telemetry = Shumway.Telemetry;
                    var NetStatusEvent = Shumway.AVM2.AS.flash.events.NetStatusEvent;

                    var NetConnection = (function (_super) {
                        __extends(NetConnection, _super);
                        function NetConnection() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.NetConnection");
                        }
                        Object.defineProperty(NetConnection, "defaultObjectEncoding", {
                            get: function () {
                                return NetConnection._defaultObjectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                NetConnection._defaultObjectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(NetConnection.prototype, "connected", {
                            // _protocol: string;
                            // _maxPeerConnections: number /*uint*/;
                            // _nearID: string;
                            // _farID: string;
                            // _nearNonce: string;
                            // _farNonce: string;
                            // _unconnectedPeerStreams: any [];
                            get: function () {
                                return this._connected;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "uri", {
                            get: function () {
                                return this._uri;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetConnection.prototype.connect = function (command) {
                            command = asCoerceString(command);

                            somewhatImplemented("public flash.net.NetConnection::connect");
                            this._uri = command;
                            if (!command) {
                                this._connected = true;
                                this.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ level: 'status', code: 'NetConnection.Connect.Success' })));
                            } else {
                                this.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ level: 'status', code: 'NetConnection.Connect.Failed' })));
                            }
                        };
                        Object.defineProperty(NetConnection.prototype, "client", {
                            get: function () {
                                return this._client;
                            },
                            set: function (object) {
                                this._client = object;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "objectEncoding", {
                            get: function () {
                                return this._objectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                somewhatImplemented("public flash.net.NetConnection::set objectEncoding");
                                this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "proxyType", {
                            get: function () {
                                return this._proxyType;
                            },
                            set: function (ptype) {
                                ptype = asCoerceString(ptype);
                                somewhatImplemented("public flash.net.NetConnection::set proxyType");
                                this._proxyType = ptype;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "connectedProxyType", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get connectedProxyType");
                                return;
                                // return this._connectedProxyType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "usingTLS", {
                            get: function () {
                                somewhatImplemented("public flash.net.NetConnection::get usingTLS");
                                return this._usingTLS;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "protocol", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get protocol");
                                return;
                                // return this._protocol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "maxPeerConnections", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get maxPeerConnections");
                                return;
                                // return this._maxPeerConnections;
                            },
                            set: function (maxPeers /*uint*/ ) {
                                maxPeers = maxPeers >>> 0;
                                notImplemented("public flash.net.NetConnection::set maxPeerConnections");
                                return;
                                // this._maxPeerConnections = maxPeers;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "nearID", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get nearID");
                                return;
                                // return this._nearID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "farID", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get farID");
                                return;
                                // return this._farID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "nearNonce", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get nearNonce");
                                return;
                                // return this._nearNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "farNonce", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get farNonce");
                                return;
                                // return this._farNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, "unconnectedPeerStreams", {
                            get: function () {
                                notImplemented("public flash.net.NetConnection::get unconnectedPeerStreams");
                                return;
                                // return this._unconnectedPeerStreams;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetConnection.prototype.ctor = function () {
                            this._uri = null;
                            this._connected = false;
                            this._client = null;
                            this._proxyType = 'none';
                            this._objectEncoding = NetConnection.defaultObjectEncoding;
                            this._usingTLS = false;

                            Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 6 /* NETCONNECTION_FEATURE */ });
                        };
                        NetConnection.prototype.invoke = function (index /*uint*/ ) {
                            index = index >>> 0;
                            return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                        };
                        NetConnection.prototype.invokeWithArgsArray = function (index /*uint*/ , p_arguments) {
                            index = index >>> 0;
                            p_arguments = p_arguments;
                            return this._invoke.call(this, index, p_arguments);
                        };
                        NetConnection.prototype._invoke = function (index, args) {
                            var simulated = false;
                            var result;
                            switch (index) {
                                case 2:
                                    simulated = true;
                                    break;
                            }
                            (simulated ? somewhatImplemented : notImplemented)("private flash.net.NetConnection::_invoke (" + index + ")");
                            return result;
                        };
                        NetConnection.classInitializer = null;

                        NetConnection.initializer = null;

                        NetConnection.classSymbols = null;

                        NetConnection.instanceSymbols = ["close", "addHeader", "call"];

                        NetConnection._defaultObjectEncoding = 3;
                        return NetConnection;
                    })(flash.events.EventDispatcher);
                    net.NetConnection = NetConnection;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NetStream
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var wrapJSObject = Shumway.AVM2.Runtime.wrapJSObject;
                    var NetStatusEvent = Shumway.AVM2.AS.flash.events.NetStatusEvent;
                    var URLRequest = Shumway.AVM2.AS.flash.net.URLRequest;
                    var URLStream = Shumway.AVM2.AS.flash.net.URLStream;
                    var ByteArray = Shumway.AVM2.AS.flash.utils.ByteArray;
                    var FileLoadingService = Shumway.FileLoadingService;

                    var USE_MEDIASOURCE_API = false;

                    var NetStream = (function (_super) {
                        __extends(NetStream, _super);
                        function NetStream(connection, peerID) {
                            if (typeof peerID === "undefined") { peerID = "connectToFMS"; }
                            peerID = asCoerceString(peerID);
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.NetStream");
                        }
                        // _multicastPushNeighborLimit: number;
                        // _multicastWindowDuration: number;
                        // _multicastRelayMarginDuration: number;
                        // _multicastAvailabilityUpdatePeriod: number;
                        // _multicastFetchPeriod: number;
                        // _multicastAvailabilitySendToAll: boolean;
                        // _farID: string;
                        // _nearNonce: string;
                        // _farNonce: string;
                        // _peerStreams: any [];
                        // _audioReliable: boolean;
                        // _videoReliable: boolean;
                        // _dataReliable: boolean;
                        // _audioSampleAccess: boolean;
                        // _videoSampleAccess: boolean;
                        // _useHardwareDecoder: boolean;
                        // _useJitterBuffer: boolean;
                        // _videoStreamSettings: flash.media.VideoStreamSettings;
                        NetStream.prototype.dispose = function () {
                            notImplemented("public flash.net.NetStream::dispose");
                            return;
                        };
                        NetStream.prototype.play = function (url) {
                            // (void) -> void ???
                            url = asCoerceString(url);
                            var isMediaSourceEnabled = USE_MEDIASOURCE_API;
                            if (isMediaSourceEnabled && typeof MediaSource === 'undefined') {
                                console.warn('MediaSource API is not enabled, falling back to regular playback');
                                isMediaSourceEnabled = false;
                            }
                            if (!isMediaSourceEnabled) {
                                somewhatImplemented("public flash.net.NetStream::play");
                                this._createVideoElement(FileLoadingService.instance.resolveUrl(url));
                                return;
                            }

                            var mediaSource = new MediaSource();
                            mediaSource.addEventListener('sourceopen', function (e) {
                                this._mediaSource = mediaSource;
                            }.bind(this));
                            mediaSource.addEventListener('sourceend', function (e) {
                                this._mediaSource = null;
                            }.bind(this));
                            this._createVideoElement(URL.createObjectURL(mediaSource));

                            if (!url) {
                                return;
                            }

                            var request = new URLRequest(url);
                            request._checkPolicyFile = this._checkPolicyFile;
                            var stream = new URLStream();
                            stream.addEventListener('httpStatus', function (e) {
                                var responseHeaders = e.asGetPublicProperty('responseHeaders');
                                var contentTypeHeader = responseHeaders.filter(function (h) {
                                    return h.asGetPublicProperty('name') === 'Content-Type';
                                })[0];
                                if (contentTypeHeader && contentTypeHeader.asGetPublicProperty('value') !== 'application/octet-stream') {
                                    this._contentTypeHint = contentTypeHeader.asGetPublicProperty('value');
                                }
                            }.bind(this));
                            stream.addEventListener('progress', function (e) {
                                var available = stream.bytesAvailable;
                                var data = new ByteArray();
                                stream.readBytes(data, 0, available);
                                this.appendBytes(data);
                            }.bind(this));
                            stream.addEventListener('complete', function (e) {
                                this.appendBytesAction('endSequence'); // NetStreamAppendBytesAction.END_SEQUENCE
                            }.bind(this));
                            stream.load(request);
                        };
                        NetStream.prototype.play2 = function (param) {
                            param = param;
                            notImplemented("public flash.net.NetStream::play2");
                            return;
                        };
                        Object.defineProperty(NetStream.prototype, "info", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get info");
                                return;
                                // return this._info;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastInfo", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastInfo");
                                return;
                                // return this._multicastInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "soundTransform", {
                            get: function () {
                                return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                somewhatImplemented("public flash.net.NetStream::set soundTransform");
                                this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "checkPolicyFile", {
                            get: function () {
                                return this._checkPolicyFile;
                            },
                            set: function (state) {
                                state = !!state;
                                this._checkPolicyFile = state;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "client", {
                            get: function () {
                                return this._client;
                            },
                            set: function (object) {
                                somewhatImplemented("public flash.net.NetStream::set client");
                                this._client = object;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "objectEncoding", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get objectEncoding");
                                return;
                                // return this._objectEncoding;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastPushNeighborLimit", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastPushNeighborLimit");
                                return;
                                // return this._multicastPushNeighborLimit;
                            },
                            set: function (neighbors) {
                                neighbors = +neighbors;
                                notImplemented("public flash.net.NetStream::set multicastPushNeighborLimit");
                                return;
                                // this._multicastPushNeighborLimit = neighbors;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastWindowDuration", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastWindowDuration");
                                return;
                                // return this._multicastWindowDuration;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                notImplemented("public flash.net.NetStream::set multicastWindowDuration");
                                return;
                                // this._multicastWindowDuration = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastRelayMarginDuration", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastRelayMarginDuration");
                                return;
                                // return this._multicastRelayMarginDuration;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                notImplemented("public flash.net.NetStream::set multicastRelayMarginDuration");
                                return;
                                // this._multicastRelayMarginDuration = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastAvailabilityUpdatePeriod", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastAvailabilityUpdatePeriod");
                                return;
                                // return this._multicastAvailabilityUpdatePeriod;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                notImplemented("public flash.net.NetStream::set multicastAvailabilityUpdatePeriod");
                                return;
                                // this._multicastAvailabilityUpdatePeriod = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastFetchPeriod", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastFetchPeriod");
                                return;
                                // return this._multicastFetchPeriod;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                notImplemented("public flash.net.NetStream::set multicastFetchPeriod");
                                return;
                                // this._multicastFetchPeriod = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "multicastAvailabilitySendToAll", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get multicastAvailabilitySendToAll");
                                return;
                                // return this._multicastAvailabilitySendToAll;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.net.NetStream::set multicastAvailabilitySendToAll");
                                return;
                                // this._multicastAvailabilitySendToAll = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "farID", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get farID");
                                return;
                                // return this._farID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "nearNonce", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get nearNonce");
                                return;
                                // return this._nearNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "farNonce", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get farNonce");
                                return;
                                // return this._farNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "peerStreams", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get peerStreams");
                                return;
                                // return this._peerStreams;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "audioReliable", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get audioReliable");
                                return;
                                // return this._audioReliable;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                notImplemented("public flash.net.NetStream::set audioReliable");
                                return;
                                // this._audioReliable = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "videoReliable", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get videoReliable");
                                return;
                                // return this._videoReliable;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                notImplemented("public flash.net.NetStream::set videoReliable");
                                return;
                                // this._videoReliable = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "dataReliable", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get dataReliable");
                                return;
                                // return this._dataReliable;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                notImplemented("public flash.net.NetStream::set dataReliable");
                                return;
                                // this._dataReliable = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "audioSampleAccess", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get audioSampleAccess");
                                return;
                                // return this._audioSampleAccess;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                notImplemented("public flash.net.NetStream::set audioSampleAccess");
                                return;
                                // this._audioSampleAccess = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "videoSampleAccess", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get videoSampleAccess");
                                return;
                                // return this._videoSampleAccess;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                notImplemented("public flash.net.NetStream::set videoSampleAccess");
                                return;
                                // this._videoSampleAccess = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetStream.prototype.appendBytes = function (bytes) {
                            if (this._mediaSource) {
                                if (!this._mediaSourceBuffer) {
                                    this._mediaSourceBuffer = this._mediaSource.addSourceBuffer(this._contentTypeHint);
                                }
                                this._mediaSourceBuffer.appendBuffer(new Uint8Array(bytes._buffer, 0, bytes.length));
                            }

                            somewhatImplemented("public flash.net.NetStream::appendBytes");
                        };
                        NetStream.prototype.appendBytesAction = function (netStreamAppendBytesAction) {
                            netStreamAppendBytesAction = asCoerceString(netStreamAppendBytesAction);
                            if (netStreamAppendBytesAction === 'endSequence' && this._mediaSource) {
                                this._mediaSource.endOfStream();
                            }
                            somewhatImplemented("public flash.net.NetStream::appendBytesAction");
                        };
                        Object.defineProperty(NetStream.prototype, "useHardwareDecoder", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get useHardwareDecoder");
                                return;
                                // return this._useHardwareDecoder;
                            },
                            set: function (v) {
                                v = !!v;
                                notImplemented("public flash.net.NetStream::set useHardwareDecoder");
                                return;
                                // this._useHardwareDecoder = v;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "useJitterBuffer", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get useJitterBuffer");
                                return;
                                // return this._useJitterBuffer;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.net.NetStream::set useJitterBuffer");
                                return;
                                // this._useJitterBuffer = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, "videoStreamSettings", {
                            get: function () {
                                notImplemented("public flash.net.NetStream::get videoStreamSettings");
                                return;
                                // return this._videoStreamSettings;
                            },
                            set: function (settings) {
                                settings = settings;
                                notImplemented("public flash.net.NetStream::set videoStreamSettings");
                                return;
                                // this._videoStreamSettings = settings;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetStream.prototype.ctor = function (connection, peerID) {
                            peerID = asCoerceString(peerID);
                            somewhatImplemented("public flash.net.NetStream::ctor");
                            this._contentTypeHint = null;
                            this._mediaSource = null;
                            this._checkPolicyFile = true;
                            this._videoElement = null;
                            var videoReadyResolve, videoReadyReject;
                            this._videoReady = new Promise(function (resolve, reject) {
                                videoReadyResolve = resolve;
                                videoReadyReject = reject;
                            });
                            this._videoReady.resolve = videoReadyResolve;
                            this._videoReady.reject = videoReadyReject;
                            var videoMetadataReadyResolve, videoMetadataReadyReject;
                            this._videoMetadataReady = new Promise(function (resolve, reject) {
                                videoMetadataReadyResolve = resolve;
                                videoMetadataReadyReject = reject;
                            });
                            this._videoMetadataReady.resolve = videoMetadataReadyResolve;
                            this._videoMetadataReady.reject = videoMetadataReadyReject;
                            this._videoState = {
                                started: false,
                                buffer: 'empty',
                                bufferTime: 0.1
                            };
                        };
                        NetStream.prototype.invoke = function (index /*uint*/ ) {
                            index = index >>> 0;
                            return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                        };
                        NetStream.prototype.invokeWithArgsArray = function (index /*uint*/ , p_arguments) {
                            index = index >>> 0;
                            p_arguments = p_arguments;
                            return this._invoke.call(this, index, p_arguments);
                        };

                        NetStream.prototype._invoke = function (index, args) {
                            var simulated = false, result;
                            var videoElement = this._videoElement;
                            switch (index) {
                                case 4:
                                    this._videoState.bufferTime = args[0];
                                    simulated = true;
                                    break;
                                case 202:
                                    switch (args[1]) {
                                        case 'pause':
                                            simulated = true;
                                            if (videoElement) {
                                                if (args[3] !== false && !videoElement.paused) {
                                                    videoElement.pause();
                                                } else if (args[3] !== true && videoElement.paused) {
                                                    videoElement.play();
                                                }
                                                videoElement.currentTime = args[4] / 1000;
                                            }
                                            break;
                                        case 'seek':
                                            simulated = true;
                                            if (videoElement && !videoElement.paused) {
                                                videoElement.currentTime = args[3] / 1000;
                                            }
                                            break;
                                    }
                                    break;
                                case 300:
                                    result = videoElement ? videoElement.currentTime : 0;
                                    simulated = true;
                                    break;
                                case 302:
                                    result = this._videoState.bufferTime;
                                    simulated = true;
                                    break;
                                case 303:
                                    result = videoElement ? videoElement.duration : 0;
                                    simulated = true;
                                    break;
                                case 305:
                                    result = this._videoState.buffer === 'full' ? 100 : this._videoState.buffer === 'progress' ? 50 : 0;
                                    simulated = true;
                                    break;
                                case 306:
                                    result = 100;
                                    simulated = true;
                                    break;
                            }

                            // (index:uint) -> any
                            (simulated ? somewhatImplemented : notImplemented)("NetStream._invoke (" + index + ")");
                            return result;
                        };
                        NetStream.prototype._createVideoElement = function (url) {
                            function notifyPlayStart(e) {
                                if (netStream._videoState.started) {
                                    return;
                                }
                                netStream._videoState.started = true;
                                netStream.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ code: "NetStream.Play.Start", level: "status" })));
                            }
                            function notifyPlayStop(e) {
                                netStream._videoState.started = false;
                                netStream.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ code: "NetStream.Play.Stop", level: "status" })));
                            }
                            function notifyBufferFull(e) {
                                netStream._videoState.buffer = 'full';
                                netStream.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ code: "NetStream.Buffer.Full", level: "status" })));
                            }
                            function notifyProgress(e) {
                                netStream._videoState.buffer = 'progress';
                            }
                            function notifyBufferEmpty(e) {
                                netStream._videoState.buffer = 'empty';
                                netStream.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ code: "NetStream.Buffer.Empty", level: "status" })));
                            }
                            function notifyError(e) {
                                var code = e.target.error.code === 4 ? "NetStream.Play.NoSupportedTrackFound" : e.target.error.code === 3 ? "NetStream.Play.FileStructureInvalid" : "NetStream.Play.StreamNotFound";
                                netStream.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, wrapJSObject({ code: code, level: "error" })));
                            }
                            function notifyMetadata(e) {
                                netStream._videoMetadataReady.resolve({
                                    videoWidth: element.videoWidth,
                                    videoHeight: element.videoHeight
                                });
                                if (netStream._client) {
                                    var data = {};
                                    data.asSetPublicProperty('width', element.videoWidth);
                                    data.asSetPublicProperty('height', element.videoHeight);
                                    data.asSetPublicProperty('duration', element.duration);
                                    netStream._client.asCallPublicProperty('onMetaData', [data]);
                                }
                            }

                            var netStream = this;

                            // HACK Firefox/Mac does not support mp4 yet, using something playable
                            if (/\.mp4$/i.test(url) && /Intel Mac OS X.*?Firefox\/\d+/.test(window.navigator.userAgent)) {
                                url = 'http://videos-cdn.mozilla.net/brand/Mozilla_2011_Story.webm';
                            }

                            var element = document.createElement('video');
                            element.preload = 'metadata'; // for mobile devices
                            element.src = url;
                            element.addEventListener("play", notifyPlayStart);
                            element.addEventListener("ended", notifyPlayStop);
                            element.addEventListener("loadeddata", notifyBufferFull);
                            element.addEventListener("progress", notifyProgress);
                            element.addEventListener("waiting", notifyBufferEmpty);
                            element.addEventListener("loadedmetadata", notifyMetadata);
                            element.addEventListener("error", notifyError);
                            element.play();

                            this._videoElement = element;
                            this._videoReady.resolve(element);
                        };
                        NetStream.classInitializer = null;

                        NetStream.initializer = null;

                        NetStream.classSymbols = null;

                        NetStream.instanceSymbols = null;

                        NetStream.DIRECT_CONNECTIONS = "directConnections";
                        NetStream.CONNECT_TO_FMS = "connectToFMS";
                        return NetStream;
                    })(flash.events.EventDispatcher);
                    net.NetStream = NetStream;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NetStreamInfo
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var NetStreamInfo = (function (_super) {
                        __extends(NetStreamInfo, _super);
                        function NetStreamInfo(curBPS, byteCount, maxBPS, audioBPS, audioByteCount, videoBPS, videoByteCount, dataBPS, dataByteCount, playbackBPS, droppedFrames, audioBufferByteLength, videoBufferByteLength, dataBufferByteLength, audioBufferLength, videoBufferLength, dataBufferLength, srtt, audioLossRate, videoLossRate, metaData, xmpData, uri, resourceName, isLive) {
                            if (typeof metaData === "undefined") { metaData = null; }
                            if (typeof xmpData === "undefined") { xmpData = null; }
                            if (typeof uri === "undefined") { uri = null; }
                            if (typeof resourceName === "undefined") { resourceName = null; }
                            if (typeof isLive === "undefined") { isLive = true; }
                            curBPS = +curBPS;
                            byteCount = +byteCount;
                            maxBPS = +maxBPS;
                            audioBPS = +audioBPS;
                            audioByteCount = +audioByteCount;
                            videoBPS = +videoBPS;
                            videoByteCount = +videoByteCount;
                            dataBPS = +dataBPS;
                            dataByteCount = +dataByteCount;
                            playbackBPS = +playbackBPS;
                            droppedFrames = +droppedFrames;
                            audioBufferByteLength = +audioBufferByteLength;
                            videoBufferByteLength = +videoBufferByteLength;
                            dataBufferByteLength = +dataBufferByteLength;
                            audioBufferLength = +audioBufferLength;
                            videoBufferLength = +videoBufferLength;
                            dataBufferLength = +dataBufferLength;
                            srtt = +srtt;
                            audioLossRate = +audioLossRate;
                            videoLossRate = +videoLossRate;
                            metaData = metaData;
                            xmpData = xmpData;
                            uri = asCoerceString(uri);
                            resourceName = asCoerceString(resourceName);
                            isLive = !!isLive;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.net.NetStreamInfo");
                        }
                        NetStreamInfo.classInitializer = null;

                        NetStreamInfo.initializer = null;

                        NetStreamInfo.classSymbols = null;

                        NetStreamInfo.instanceSymbols = null;
                        return NetStreamInfo;
                    })(AS.ASNative);
                    net.NetStreamInfo = NetStreamInfo;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NetStreamMulticastInfo
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var NetStreamMulticastInfo = (function (_super) {
                        __extends(NetStreamMulticastInfo, _super);
                        function NetStreamMulticastInfo(sendDataBytesPerSecond, sendControlBytesPerSecond, receiveDataBytesPerSecond, receiveControlBytesPerSecond, bytesPushedToPeers, fragmentsPushedToPeers, bytesRequestedByPeers, fragmentsRequestedByPeers, bytesPushedFromPeers, fragmentsPushedFromPeers, bytesRequestedFromPeers, fragmentsRequestedFromPeers, sendControlBytesPerSecondToServer, receiveDataBytesPerSecondFromServer, bytesReceivedFromServer, fragmentsReceivedFromServer, receiveDataBytesPerSecondFromIPMulticast, bytesReceivedFromIPMulticast, fragmentsReceivedFromIPMulticast) {
                            sendDataBytesPerSecond = +sendDataBytesPerSecond;
                            sendControlBytesPerSecond = +sendControlBytesPerSecond;
                            receiveDataBytesPerSecond = +receiveDataBytesPerSecond;
                            receiveControlBytesPerSecond = +receiveControlBytesPerSecond;
                            bytesPushedToPeers = +bytesPushedToPeers;
                            fragmentsPushedToPeers = +fragmentsPushedToPeers;
                            bytesRequestedByPeers = +bytesRequestedByPeers;
                            fragmentsRequestedByPeers = +fragmentsRequestedByPeers;
                            bytesPushedFromPeers = +bytesPushedFromPeers;
                            fragmentsPushedFromPeers = +fragmentsPushedFromPeers;
                            bytesRequestedFromPeers = +bytesRequestedFromPeers;
                            fragmentsRequestedFromPeers = +fragmentsRequestedFromPeers;
                            sendControlBytesPerSecondToServer = +sendControlBytesPerSecondToServer;
                            receiveDataBytesPerSecondFromServer = +receiveDataBytesPerSecondFromServer;
                            bytesReceivedFromServer = +bytesReceivedFromServer;
                            fragmentsReceivedFromServer = +fragmentsReceivedFromServer;
                            receiveDataBytesPerSecondFromIPMulticast = +receiveDataBytesPerSecondFromIPMulticast;
                            bytesReceivedFromIPMulticast = +bytesReceivedFromIPMulticast;
                            fragmentsReceivedFromIPMulticast = +fragmentsReceivedFromIPMulticast;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.net.NetStreamMulticastInfo");
                        }
                        NetStreamMulticastInfo.classInitializer = null;

                        NetStreamMulticastInfo.initializer = null;

                        NetStreamMulticastInfo.classSymbols = null;

                        NetStreamMulticastInfo.instanceSymbols = null;
                        return NetStreamMulticastInfo;
                    })(AS.ASNative);
                    net.NetStreamMulticastInfo = NetStreamMulticastInfo;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: NetStreamPlayOptions
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var NetStreamPlayOptions = (function (_super) {
                        __extends(NetStreamPlayOptions, _super);
                        function NetStreamPlayOptions() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.NetStreamPlayOptions");
                        }
                        NetStreamPlayOptions.classInitializer = null;

                        NetStreamPlayOptions.initializer = null;

                        NetStreamPlayOptions.classSymbols = null;

                        NetStreamPlayOptions.instanceSymbols = null;
                        return NetStreamPlayOptions;
                    })(flash.events.EventDispatcher);
                    net.NetStreamPlayOptions = NetStreamPlayOptions;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Responder
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Responder = (function (_super) {
                        __extends(Responder, _super);
                        function Responder(result, status) {
                            if (typeof status === "undefined") { status = null; }
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.net.Responder");
                        }
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        Responder.prototype.ctor = function (result, status) {
                            this._result = result;
                            this._status = status;
                        };
                        Responder.classInitializer = null;

                        Responder.initializer = null;

                        Responder.classSymbols = null;

                        Responder.instanceSymbols = null;
                        return Responder;
                    })(AS.ASNative);
                    net.Responder = Responder;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SharedObject
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var createEmptyObject = Shumway.ObjectUtilities.createEmptyObject;

                    var SharedObject = (function (_super) {
                        __extends(SharedObject, _super);
                        function SharedObject() {
                            false && _super.call(this, undefined);
                            flash.events.EventDispatcher.instanceConstructorNoInitialize.call(this);
                            this._data = createEmptyObject();
                        }
                        SharedObject.deleteAll = function (url) {
                            url = asCoerceString(url);
                            notImplemented("public flash.net.SharedObject::static deleteAll");
                            return;
                        };
                        SharedObject.getDiskUsage = function (url) {
                            url = asCoerceString(url);
                            notImplemented("public flash.net.SharedObject::static getDiskUsage");
                            return;
                        };
                        SharedObject._create = function (path, data) {
                            var obj = new SharedObject();
                            obj._path = path;
                            obj._data = data;
                            obj._objectEncoding = SharedObject._defaultObjectEncoding;
                            Shumway.Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 3 /* SHAREDOBJECT_FEATURE */ });
                            return obj;
                        };
                        SharedObject.getLocal = function (name, localPath, secure) {
                            if (typeof localPath === "undefined") { localPath = null; }
                            if (typeof secure === "undefined") { secure = false; }
                            name = asCoerceString(name);
                            localPath = asCoerceString(localPath);
                            secure = !!secure;
                            var path = (localPath || '') + '/' + name;
                            if (SharedObject._sharedObjects[path]) {
                                return SharedObject._sharedObjects[path];
                            }
                            var data = sessionStorage.getItem(path);

                            // TODO: JSON here probably needs to convert things into AS3 objects.
                            var so = SharedObject._create(path, data ? JSON.parse(data) : {});

                            // so._data[Multiname.getPublicQualifiedName("cookie")] = {};
                            // so._data[Multiname.getPublicQualifiedName("cookie")][Multiname.getPublicQualifiedName("lc")] = 32;
                            // so._data[Multiname.getPublicQualifiedName("levelCompleted")] = 32;
                            // so._data[Multiname.getPublicQualifiedName("completeLevels")] = 32;
                            SharedObject._sharedObjects[path] = so;
                            return so;
                        };
                        SharedObject.getRemote = function (name, remotePath, persistence, secure) {
                            if (typeof remotePath === "undefined") { remotePath = null; }
                            if (typeof persistence === "undefined") { persistence = false; }
                            if (typeof secure === "undefined") { secure = false; }
                            name = asCoerceString(name);
                            remotePath = asCoerceString(remotePath);
                            secure = !!secure;
                            notImplemented("public flash.net.SharedObject::static getRemote");
                            return;
                        };
                        Object.defineProperty(SharedObject, "defaultObjectEncoding", {
                            get: function () {
                                return SharedObject._defaultObjectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                SharedObject._defaultObjectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(SharedObject.prototype, "data", {
                            // _client: ASObject;
                            get: function () {
                                return this._data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SharedObject.prototype, "objectEncoding", {
                            get: function () {
                                return this._objectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SharedObject.prototype, "client", {
                            get: function () {
                                notImplemented("public flash.net.SharedObject::get client");
                                return;
                                // return this._client;
                            },
                            set: function (object) {
                                object = object;
                                notImplemented("public flash.net.SharedObject::set client");
                                return;
                                // this._client = object;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SharedObject.prototype.setDirty = function (propertyName) {
                            propertyName = asCoerceString(propertyName);
                            somewhatImplemented("public flash.net.SharedObject::setDirty");
                        };
                        SharedObject.prototype.invoke = function (index /*uint*/ ) {
                            index = index >>> 0;
                            return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                        };
                        SharedObject.prototype.invokeWithArgsArray = function (index /*uint*/ , args) {
                            index = index >>> 0;
                            return this._invoke(index, args);
                        };
                        SharedObject.prototype._invoke = function (index, args) {
                            var simulated = false, result;
                            switch (index) {
                                case 4:
                                    result = JSON.stringify(this._data).length - 2;
                                    simulated = true;
                                    break;
                                case 6:
                                    this._data = {};
                                    sessionStorage.removeItem(this._path);
                                    simulated = true;
                                    break;
                                case 2:
                                    sessionStorage.setItem(this._path, JSON.stringify(this._data));
                                    simulated = true;
                                    result = true;
                                    break;
                                case 3:
                                    simulated = true;
                                    break;
                            }
                            (simulated ? somewhatImplemented : notImplemented)("private flash.net.SharedObject::_invoke (" + index + ")");
                            return result;
                        };
                        SharedObject.classInitializer = null;

                        SharedObject.initializer = null;

                        SharedObject.classSymbols = null;

                        SharedObject.instanceSymbols = null;

                        SharedObject._sharedObjects = createEmptyObject();

                        SharedObject._defaultObjectEncoding = 3;
                        return SharedObject;
                    })(flash.events.EventDispatcher);
                    net.SharedObject = SharedObject;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Socket
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var Errors = Shumway.AVM2.Errors;
                    var throwError = Shumway.AVM2.Runtime.throwError;

                    var Socket = (function (_super) {
                        __extends(Socket, _super);
                        function Socket(host, port) {
                            if (typeof host === "undefined") { host = null; }
                            if (typeof port === "undefined") { port = 0; }
                            host = asCoerceString(host);
                            port = port | 0;
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.Socket");
                        }
                        Object.defineProperty(Socket.prototype, "bytesAvailable", {
                            // AS -> JS Bindings
                            // _timeout: number /*uint*/;
                            // _bytesAvailable: number /*uint*/;
                            // _connected: boolean;
                            // _objectEncoding: number /*uint*/;
                            // _endian: string;
                            // _bytesPending: number /*uint*/;
                            get: function () {
                                notImplemented("public flash.net.Socket::get bytesAvailable");
                                return;
                                // return this._bytesAvailable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, "connected", {
                            get: function () {
                                notImplemented("public flash.net.Socket::get connected");
                                return;
                                // return this._connected;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, "objectEncoding", {
                            get: function () {
                                notImplemented("public flash.net.Socket::get objectEncoding");
                                return;
                                // return this._objectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                notImplemented("public flash.net.Socket::set objectEncoding");
                                return;
                                // this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, "endian", {
                            get: function () {
                                notImplemented("public flash.net.Socket::get endian");
                                return;
                                // return this._endian;
                            },
                            set: function (type) {
                                type = asCoerceString(type);
                                notImplemented("public flash.net.Socket::set endian");
                                return;
                                // this._endian = type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, "bytesPending", {
                            get: function () {
                                notImplemented("public flash.net.Socket::get bytesPending");
                                return;
                                // return this._bytesPending;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Socket.prototype.readBytes = function (bytes, offset, length) {
                            if (typeof offset === "undefined") { offset = 0; }
                            if (typeof length === "undefined") { length = 0; }
                            bytes = bytes;
                            offset = offset >>> 0;
                            length = length >>> 0;
                            notImplemented("public flash.net.Socket::readBytes");
                            return;
                        };
                        Socket.prototype.writeBytes = function (bytes, offset, length) {
                            if (typeof offset === "undefined") { offset = 0; }
                            if (typeof length === "undefined") { length = 0; }
                            bytes = bytes;
                            offset = offset >>> 0;
                            length = length >>> 0;
                            notImplemented("public flash.net.Socket::writeBytes");
                            return;
                        };
                        Socket.prototype.writeBoolean = function (value) {
                            value = !!value;
                            notImplemented("public flash.net.Socket::writeBoolean");
                            return;
                        };
                        Socket.prototype.writeByte = function (value /*int*/ ) {
                            value = value | 0;
                            notImplemented("public flash.net.Socket::writeByte");
                            return;
                        };
                        Socket.prototype.writeShort = function (value /*int*/ ) {
                            value = value | 0;
                            notImplemented("public flash.net.Socket::writeShort");
                            return;
                        };
                        Socket.prototype.writeInt = function (value /*int*/ ) {
                            value = value | 0;
                            notImplemented("public flash.net.Socket::writeInt");
                            return;
                        };
                        Socket.prototype.writeUnsignedInt = function (value /*uint*/ ) {
                            value = value >>> 0;
                            notImplemented("public flash.net.Socket::writeUnsignedInt");
                            return;
                        };
                        Socket.prototype.writeFloat = function (value) {
                            value = +value;
                            notImplemented("public flash.net.Socket::writeFloat");
                            return;
                        };
                        Socket.prototype.writeDouble = function (value) {
                            value = +value;
                            notImplemented("public flash.net.Socket::writeDouble");
                            return;
                        };
                        Socket.prototype.writeMultiByte = function (value, charSet) {
                            value = asCoerceString(value);
                            charSet = asCoerceString(charSet);
                            notImplemented("public flash.net.Socket::writeMultiByte");
                            return;
                        };
                        Socket.prototype.writeUTF = function (value) {
                            value = asCoerceString(value);
                            notImplemented("public flash.net.Socket::writeUTF");
                            return;
                        };
                        Socket.prototype.writeUTFBytes = function (value) {
                            value = asCoerceString(value);
                            notImplemented("public flash.net.Socket::writeUTFBytes");
                            return;
                        };
                        Socket.prototype.readBoolean = function () {
                            notImplemented("public flash.net.Socket::readBoolean");
                            return;
                        };
                        Socket.prototype.readByte = function () {
                            notImplemented("public flash.net.Socket::readByte");
                            return;
                        };
                        Socket.prototype.readUnsignedByte = function () {
                            notImplemented("public flash.net.Socket::readUnsignedByte");
                            return;
                        };
                        Socket.prototype.readShort = function () {
                            notImplemented("public flash.net.Socket::readShort");
                            return;
                        };
                        Socket.prototype.readUnsignedShort = function () {
                            notImplemented("public flash.net.Socket::readUnsignedShort");
                            return;
                        };
                        Socket.prototype.readInt = function () {
                            notImplemented("public flash.net.Socket::readInt");
                            return;
                        };
                        Socket.prototype.readUnsignedInt = function () {
                            notImplemented("public flash.net.Socket::readUnsignedInt");
                            return;
                        };
                        Socket.prototype.readFloat = function () {
                            notImplemented("public flash.net.Socket::readFloat");
                            return;
                        };
                        Socket.prototype.readDouble = function () {
                            notImplemented("public flash.net.Socket::readDouble");
                            return;
                        };
                        Socket.prototype.readMultiByte = function (length /*uint*/ , charSet) {
                            length = length >>> 0;
                            charSet = asCoerceString(charSet);
                            notImplemented("public flash.net.Socket::readMultiByte");
                            return;
                        };
                        Socket.prototype.readUTF = function () {
                            notImplemented("public flash.net.Socket::readUTF");
                            return;
                        };
                        Socket.prototype.readUTFBytes = function (length /*uint*/ ) {
                            length = length >>> 0;
                            notImplemented("public flash.net.Socket::readUTFBytes");
                            return;
                        };
                        Socket.prototype.flush = function () {
                            notImplemented("public flash.net.Socket::flush");
                            return;
                        };
                        Socket.prototype.writeObject = function (object) {
                            notImplemented("public flash.net.Socket::writeObject");
                            return;
                        };
                        Socket.prototype.readObject = function () {
                            notImplemented("public flash.net.Socket::readObject");
                            return;
                        };
                        Socket.prototype.internalGetSecurityErrorMessage = function (host, port) {
                            host = asCoerceString(host);
                            port |= 0;
                            somewhatImplemented("flash.net.Socket::internalGetSecurityErrorMessage");
                            return 'SecurityErrorEvent';
                        };
                        Socket.prototype.internalConnect = function (host, port) {
                            host = asCoerceString(host);
                            port |= 0;
                            somewhatImplemented("flash.net.Socket::internalConnect");
                            throwError('SecurityError', Errors.SocketConnectError, host, port);
                        };
                        Socket.prototype.didFailureOccur = function () {
                            somewhatImplemented("flash.net.Socket::didFailureOccur");
                            return true;
                        };
                        Socket.classInitializer = null;

                        Socket.initializer = null;

                        Socket.classSymbols = null;

                        Socket.instanceSymbols = null;
                        return Socket;
                    })(flash.events.EventDispatcher);
                    net.Socket = Socket;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: URLLoader
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var URLLoader = (function (_super) {
                        __extends(URLLoader, _super);
                        function URLLoader(request) {
                            if (typeof request === "undefined") { request = null; }
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.URLLoader");
                        }
                        URLLoader.classInitializer = null;

                        URLLoader.initializer = null;

                        URLLoader.classSymbols = null;

                        URLLoader.instanceSymbols = ["data", "dataFormat", "bytesLoaded", "bytesTotal", "load", "close"];
                        return URLLoader;
                    })(flash.events.EventDispatcher);
                    net.URLLoader = URLLoader;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: URLRequest
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var throwError = Shumway.AVM2.Runtime.throwError;

                    var URLRequest = (function (_super) {
                        __extends(URLRequest, _super);
                        function URLRequest(url) {
                            if (typeof url === "undefined") { url = null; }
                            url = asCoerceString(url);
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.net.URLRequest");
                        }
                        Object.defineProperty(URLRequest.prototype, "url", {
                            get: function () {
                                return this._url;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                this._url = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, "data", {
                            get: function () {
                                return this._data;
                            },
                            set: function (value) {
                                this._data = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, "method", {
                            get: function () {
                                return this._method;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                if (value !== 'get' && value !== 'GET' && value !== 'post' && value !== 'POST') {
                                    throwError('ArgumentError', AVM2.Errors.InvalidArgumentError);
                                }
                                this._method = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, "contentType", {
                            get: function () {
                                return this._contentType;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                this._contentType = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, "requestHeaders", {
                            get: function () {
                                return this._requestHeaders;
                            },
                            set: function (value) {
                                if (!Array.isArray(value)) {
                                    throwError('ArgumentError', AVM2.Errors.InvalidArgumentError, "value");
                                }
                                this._requestHeaders = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, "digest", {
                            get: function () {
                                return this._digest;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                this._digest = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        URLRequest.prototype._toFileRequest = function () {
                            var obj = {};
                            obj.url = this._url;
                            obj.method = this._method;
                            obj.checkPolicyFile = this._checkPolicyFile;
                            if (this._data) {
                                obj.mimeType = this._contentType;
                                if (flash.utils.ByteArray.isType(this._data)) {
                                    obj.data = new Uint8Array(this._data._buffer, 0, this._data.length);
                                } else {
                                    var data = this._data.asGetPublicProperty("toString").call(this._data);
                                    if (this._method === 'GET') {
                                        var i = obj.url.lastIndexOf('?');
                                        obj.url = (i < 0 ? obj.url : obj.url.substring(0, i)) + '?' + data;
                                    } else {
                                        obj.data = data;
                                    }
                                }
                            }
                            return obj;
                        };
                        URLRequest.classInitializer = null;

                        URLRequest.initializer = function () {
                            this._url = null;
                            this._method = 'GET';
                            this._data = null;
                            this._digest = null;
                            this._contentType = 'application/x-www-form-urlencoded';
                            this._requestHeaders = null;
                            this._checkPolicyFile = true;
                        };

                        URLRequest.classSymbols = null;

                        URLRequest.bindings = null;
                        return URLRequest;
                    })(AS.ASNative);
                    net.URLRequest = URLRequest;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: URLRequestHeader
                (function (net) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var URLRequestHeader = (function (_super) {
                        __extends(URLRequestHeader, _super);
                        function URLRequestHeader(name, value) {
                            if (typeof name === "undefined") { name = ""; }
                            if (typeof value === "undefined") { value = ""; }
                            name = asCoerceString(name);
                            value = asCoerceString(value);
                            false && _super.call(this);
                        }
                        URLRequestHeader.classInitializer = null;

                        URLRequestHeader.initializer = null;

                        URLRequestHeader.classSymbols = null;

                        URLRequestHeader.instanceSymbols = ["name!", "value!"];
                        return URLRequestHeader;
                    })(AS.ASNative);
                    net.URLRequestHeader = URLRequestHeader;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                /// <reference path='../references.ts'/>
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var FileLoadingService = Shumway.FileLoadingService;
                    var throwError = Shumway.AVM2.Runtime.throwError;

                    var Stream = Shumway.SWF.Stream;

                    var URLStream = (function (_super) {
                        __extends(URLStream, _super);
                        function URLStream() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.net.URLStream");
                        }
                        Object.defineProperty(URLStream.prototype, "connected", {
                            // _diskCacheEnabled: boolean;
                            // _position: number;
                            // _length: number;
                            get: function () {
                                return this._connected;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, "bytesAvailable", {
                            get: function () {
                                return this._stream.remaining();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, "objectEncoding", {
                            get: function () {
                                notImplemented("public flash.net.URLStream::get objectEncoding");
                                return;
                                // return this._objectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                notImplemented("public flash.net.URLStream::set objectEncoding");
                                return;
                                // this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, "endian", {
                            get: function () {
                                return this._endian;
                            },
                            set: function (type) {
                                type = asCoerceString(type);
                                this._endian = type;
                                this._littleEndian = type === 'littleEndian';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, "diskCacheEnabled", {
                            get: function () {
                                notImplemented("public flash.net.URLStream::get diskCacheEnabled");
                                return;
                                // return this._diskCacheEnabled;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, "position", {
                            get: function () {
                                notImplemented("public flash.net.URLStream::get position");
                                return;
                                // return this._position;
                            },
                            set: function (offset) {
                                offset = +offset;
                                notImplemented("public flash.net.URLStream::set position");
                                return;
                                // this._position = offset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, "length", {
                            get: function () {
                                notImplemented("public flash.net.URLStream::get length");
                                return;
                                // return this._length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        URLStream.prototype.load = function (request) {
                            var Event = flash.events.Event;
                            var IOErrorEvent = flash.events.IOErrorEvent;
                            var ProgressEvent = flash.events.ProgressEvent;
                            var HTTPStatusEvent = flash.events.HTTPStatusEvent;

                            var session = FileLoadingService.instance.createSession();
                            var self = this;
                            var initStream = true;
                            session.onprogress = function (data, progressState) {
                                var length;
                                var buffer;
                                if (initStream) {
                                    initStream = false;
                                    length = Math.max(progressState.bytesTotal, data.length);
                                    buffer = new ArrayBuffer(length);
                                    self._stream = new Stream(buffer, 0, 0, length);
                                } else if (self._stream.end + data.length > self._stream.bytes.length) {
                                    length = self._stream.end + data.length;
                                    buffer = new ArrayBuffer(length);
                                    var newStream = new Stream(buffer, 0, 0, length);
                                    newStream.push(self._stream.bytes.subarray(0, self._stream.end));
                                    self._stream = newStream;
                                }
                                self._stream.push(data);
                                self.dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, progressState.bytesLoaded, progressState.bytesTotal));
                            };
                            session.onerror = function (error) {
                                self._connected = false;
                                if (!self._stream) {
                                    // We need to have something to return in data
                                    self._stream = new Stream(new ArrayBuffer(0), 0, 0, 0);
                                }
                                self.dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR, false, false, error));
                            };
                            session.onopen = function () {
                                self._connected = true;
                                self.dispatchEvent(new Event(Event.OPEN, false, false));
                            };
                            session.onhttpstatus = function (location, httpStatus, httpHeaders) {
                                var httpStatusEvent = new HTTPStatusEvent(HTTPStatusEvent.HTTP_STATUS, false, false, httpStatus);
                                var headers = [];
                                httpHeaders.split(/(?:\n|\r?\n)/g).forEach(function (h) {
                                    var m = /^([^:]+): (.*)$/.exec(h);
                                    if (m) {
                                        headers.push(new flash.net.URLRequestHeader(m[1], m[2]));
                                        if (m[1] === 'Location') {
                                            location = m[2];
                                        }
                                    }
                                });
                                httpStatusEvent.asSetPublicProperty('responseHeaders', headers);
                                httpStatusEvent.asSetPublicProperty('responseURL', location);
                                self.dispatchEvent(httpStatusEvent);
                            };
                            session.onclose = function () {
                                self._connected = false;
                                if (!self._stream) {
                                    // We need to have something to return in data
                                    self._stream = new Stream(new ArrayBuffer(0), 0, 0, 0);
                                }

                                self.dispatchEvent(new Event(Event.COMPLETE, false, false));
                            };
                            session.open(request._toFileRequest());
                            this._session = session;
                        };
                        URLStream.prototype.readBytes = function (bytes, offset, length) {
                            if (typeof offset === "undefined") { offset = 0; }
                            if (typeof length === "undefined") { length = 0; }
                            offset = offset >>> 0;
                            length = length >>> 0;
                            if (length < 0) {
                                throwError('ArgumentError', AVM2.Errors.InvalidArgumentError, "length");
                            }

                            var stream = this._stream;
                            if (!length) {
                                length = stream.remaining();
                            } else {
                                stream.ensure(length);
                            }
                            bytes.position = offset;
                            bytes.writeRawBytes(stream.bytes.subarray(stream.pos, stream.pos + length));
                            stream.pos += length;
                        };
                        URLStream.prototype.readBoolean = function () {
                            notImplemented("public flash.net.URLStream::readBoolean");
                            return;
                        };
                        URLStream.prototype.readByte = function () {
                            var stream = this._stream;
                            stream.ensure(1);
                            return stream.bytes[stream.pos++];
                        };
                        URLStream.prototype.readUnsignedByte = function () {
                            notImplemented("public flash.net.URLStream::readUnsignedByte");
                            return;
                        };
                        URLStream.prototype.readShort = function () {
                            notImplemented("public flash.net.URLStream::readShort");
                            return;
                        };
                        URLStream.prototype.readUnsignedShort = function () {
                            var stream = this._stream;
                            stream.ensure(2);
                            var result = stream.getUint16(stream.pos, this._littleEndian);
                            stream.pos += 2;
                            return result;
                        };
                        URLStream.prototype.readUnsignedInt = function () {
                            notImplemented("public flash.net.URLStream::readUnsignedInt");
                            return;
                        };
                        URLStream.prototype.readInt = function () {
                            notImplemented("public flash.net.URLStream::readInt");
                            return;
                        };
                        URLStream.prototype.readFloat = function () {
                            notImplemented("public flash.net.URLStream::readFloat");
                            return;
                        };
                        URLStream.prototype.readDouble = function () {
                            notImplemented("public flash.net.URLStream::readDouble");
                            return;
                        };
                        URLStream.prototype.readMultiByte = function (length /*uint*/ , charSet) {
                            length = length >>> 0;
                            charSet = asCoerceString(charSet);
                            notImplemented("public flash.net.URLStream::readMultiByte");
                            return;
                        };
                        URLStream.prototype.readUTF = function () {
                            return this.readUTFBytes(this.readUnsignedShort());
                        };
                        URLStream.prototype.readUTFBytes = function (length /*uint*/ ) {
                            length = length >>> 0;
                            if (length < 0) {
                                throwError('ArgumentError', AVM2.Errors.InvalidArgumentError, "length");
                            }

                            var stream = this._stream;
                            stream.ensure(length);
                            var str = Shumway.StringUtilities.utf8encode(stream.bytes.subarray(stream.pos, stream.pos + length));
                            stream.pos += length;
                            return str;
                        };
                        URLStream.prototype.close = function () {
                            this._session.close();
                        };
                        URLStream.prototype.readObject = function () {
                            notImplemented("public flash.net.URLStream::readObject");
                            return;
                        };
                        URLStream.prototype.stop = function () {
                            notImplemented("public flash.net.URLStream::stop");
                            return;
                        };
                        URLStream.classInitializer = null;

                        URLStream.initializer = function () {
                            this._stream = null;
                            this._connected = false;
                            this._littleEndian = false;
                            this._endian = 'bigEndian';
                        };

                        URLStream.classSymbols = null;

                        URLStream.instanceSymbols = null;
                        return URLStream;
                    })(flash.events.EventDispatcher);
                    net.URLStream = URLStream;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: URLVariables
                (function (net) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var URLVariables = (function (_super) {
                        __extends(URLVariables, _super);
                        function URLVariables(source) {
                            if (typeof source === "undefined") { source = null; }
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.net.URLVariables");
                        }
                        URLVariables.classInitializer = null;

                        URLVariables.initializer = null;

                        URLVariables.classSymbols = null;

                        URLVariables.instanceSymbols = ["decode!"];
                        return URLVariables;
                    })(AS.ASNative);
                    net.URLVariables = URLVariables;
                })(flash.net || (flash.net = {}));
                var net = flash.net;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Accelerometer
                (function (sensors) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Accelerometer = (function (_super) {
                        __extends(Accelerometer, _super);
                        function Accelerometer() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.sensors.Accelerometer");
                        }
                        Object.defineProperty(Accelerometer.prototype, "isSupported", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _isSupported: boolean;
                            get: function () {
                                notImplemented("public flash.sensors.Accelerometer::get isSupported");
                                return;
                                // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Accelerometer.prototype, "muted", {
                            // _muted: boolean;
                            get: function () {
                                notImplemented("public flash.sensors.Accelerometer::get muted");
                                return;
                                // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Accelerometer.prototype.setRequestedUpdateInterval = function (interval) {
                            interval = +interval;
                            notImplemented("public flash.sensors.Accelerometer::setRequestedUpdateInterval");
                            return;
                        };
                        Accelerometer.classInitializer = null;

                        Accelerometer.initializer = null;

                        Accelerometer.classSymbols = null;

                        Accelerometer.instanceSymbols = null;
                        return Accelerometer;
                    })(flash.events.EventDispatcher);
                    sensors.Accelerometer = Accelerometer;
                })(flash.sensors || (flash.sensors = {}));
                var sensors = flash.sensors;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Geolocation
                (function (sensors) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Geolocation = (function (_super) {
                        __extends(Geolocation, _super);
                        function Geolocation() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.sensors.Geolocation");
                        }
                        Object.defineProperty(Geolocation.prototype, "isSupported", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _isSupported: boolean;
                            get: function () {
                                notImplemented("public flash.sensors.Geolocation::get isSupported");
                                return;
                                // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Geolocation.prototype, "muted", {
                            // _muted: boolean;
                            get: function () {
                                notImplemented("public flash.sensors.Geolocation::get muted");
                                return;
                                // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Geolocation.prototype.setRequestedUpdateInterval = function (interval) {
                            interval = +interval;
                            notImplemented("public flash.sensors.Geolocation::setRequestedUpdateInterval");
                            return;
                        };
                        Geolocation.classInitializer = null;

                        Geolocation.initializer = null;

                        Geolocation.classSymbols = null;

                        Geolocation.instanceSymbols = null;
                        return Geolocation;
                    })(flash.events.EventDispatcher);
                    sensors.Geolocation = Geolocation;
                })(flash.sensors || (flash.sensors = {}));
                var sensors = flash.sensors;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (_AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ApplicationDomain
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var AVM2 = Shumway.AVM2.Runtime.AVM2;
                    var ExecutionMode = Shumway.AVM2.Runtime.ExecutionMode;
                    var RuntimeApplicationDomain = Shumway.AVM2.Runtime.ApplicationDomain;
                    var Multiname = Shumway.AVM2.ABC.Multiname;

                    var ApplicationDomain = (function (_super) {
                        __extends(ApplicationDomain, _super);
                        function ApplicationDomain(parentDomainOrRuntimeDomain) {
                            if (typeof parentDomainOrRuntimeDomain === "undefined") { parentDomainOrRuntimeDomain = null; }
                            false && _super.call(this);
                            if (parentDomainOrRuntimeDomain instanceof RuntimeApplicationDomain) {
                                this._runtimeDomain = parentDomainOrRuntimeDomain;
                                return;
                            }
                            var parentRuntimeDomain;
                            if (parentDomainOrRuntimeDomain) {
                                parentRuntimeDomain = parentDomainOrRuntimeDomain._runtimeDomain;
                            } else {
                                parentRuntimeDomain = AVM2.currentDomain().system;
                            }
                            this._runtimeDomain = new RuntimeApplicationDomain(parentRuntimeDomain.vm, parentRuntimeDomain, 2 /* COMPILE */, false);
                        }
                        Object.defineProperty(ApplicationDomain, "currentDomain", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _currentDomain: flash.system.ApplicationDomain;
                            // static _MIN_DOMAIN_MEMORY_LENGTH: number /*uint*/;
                            get: function () {
                                return new ApplicationDomain(AVM2.currentDomain());
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ApplicationDomain, "MIN_DOMAIN_MEMORY_LENGTH", {
                            get: function () {
                                notImplemented("public flash.system.ApplicationDomain::get MIN_DOMAIN_MEMORY_LENGTH");
                                return;
                                // return this._MIN_DOMAIN_MEMORY_LENGTH;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(ApplicationDomain.prototype, "parentDomain", {
                            // _parentDomain: flash.system.ApplicationDomain;
                            // _domainMemory: flash.utils.ByteArray;
                            get: function () {
                                if (this._runtimeDomain.base) {
                                    return new ApplicationDomain(this._runtimeDomain.base);
                                }
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ApplicationDomain.prototype, "domainMemory", {
                            get: function () {
                                notImplemented("public flash.system.ApplicationDomain::get domainMemory");
                                return;
                                // return this._domainMemory;
                            },
                            set: function (mem) {
                                mem = mem;
                                notImplemented("public flash.system.ApplicationDomain::set domainMemory");
                                return;
                                // this._domainMemory = mem;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ApplicationDomain.prototype.getDefinition = function (name) {
                            name = asCoerceString(name);
                            if (name) {
                                var simpleName = name.replace("::", ".");
                                return this._runtimeDomain.getProperty(Multiname.fromSimpleName(simpleName), true, true);
                            }
                            return null;
                        };
                        ApplicationDomain.prototype.hasDefinition = function (name) {
                            name = asCoerceString(name);
                            if (name) {
                                var simpleName = name.replace("::", ".");
                                return !!this._runtimeDomain.findDomainProperty(Multiname.fromSimpleName(simpleName), false, false);
                            }
                            return false;
                        };
                        ApplicationDomain.prototype.getQualifiedDefinitionNames = function () {
                            notImplemented("public flash.system.ApplicationDomain::getQualifiedDefinitionNames");
                            return;
                        };
                        ApplicationDomain.classInitializer = null;
                        ApplicationDomain.initializer = null;
                        ApplicationDomain.classSymbols = null;
                        ApplicationDomain.instanceSymbols = null;
                        return ApplicationDomain;
                    })(AS.ASNative);
                    system.ApplicationDomain = ApplicationDomain;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(_AVM2.AS || (_AVM2.AS = {}));
        var AS = _AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Capabilities
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var toKeyValueArray = Shumway.ObjectUtilities.toKeyValueArray;

                    var Capabilities = (function (_super) {
                        __extends(Capabilities, _super);
                        function Capabilities() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.Capabilities");
                        }
                        Object.defineProperty(Capabilities, "isEmbeddedInAcrobat", {
                            // static _screenColor: string;
                            // static _pixelAspectRatio: number;
                            // static _screenDPI: number;
                            // static _touchscreenType: string;
                            // static _hasIME: boolean;
                            // static _hasTLS: boolean;
                            // static _maxLevelIDC: string;
                            // static _supports32BitProcesses: boolean;
                            // static _supports64BitProcesses: boolean;
                            // static __internal: number /*uint*/;
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get isEmbeddedInAcrobat");
                                return;
                                // return Capabilities._isEmbeddedInAcrobat;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasEmbeddedVideo", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasEmbeddedVideo");
                                return;
                                // return Capabilities._hasEmbeddedVideo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasAudio", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasAudio");
                                return;
                                // return Capabilities._hasAudio;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "avHardwareDisable", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get avHardwareDisable");
                                return;
                                // return Capabilities._avHardwareDisable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasAccessibility", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get hasAccessibility");
                                return Capabilities._hasAccessibility;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasAudioEncoder", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasAudioEncoder");
                                return;
                                // return Capabilities._hasAudioEncoder;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasMP3", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasMP3");
                                return;
                                // return Capabilities._hasMP3;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasPrinting", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasPrinting");
                                return;
                                // return Capabilities._hasPrinting;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasScreenBroadcast", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasScreenBroadcast");
                                return;
                                // return Capabilities._hasScreenBroadcast;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasScreenPlayback", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasScreenPlayback");
                                return;
                                // return Capabilities._hasScreenPlayback;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasStreamingAudio", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasStreamingAudio");
                                return;
                                // return Capabilities._hasStreamingAudio;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasStreamingVideo", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasStreamingVideo");
                                return;
                                // return Capabilities._hasStreamingVideo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasVideoEncoder", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasVideoEncoder");
                                return;
                                // return Capabilities._hasVideoEncoder;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "isDebugger", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get isDebugger");
                                return Capabilities._isDebugger;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "localFileReadDisable", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get localFileReadDisable");
                                return;
                                // return Capabilities._localFileReadDisable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "language", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get language");
                                return Capabilities._language;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "manufacturer", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get manufacturer");
                                return Capabilities._manufacturer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "os", {
                            get: function () {
                                if (Capabilities._os === null) {
                                    var os;
                                    var userAgent = window.navigator.userAgent;
                                    if (userAgent.indexOf("Macintosh") > 0) {
                                        os = "Mac OS 10.5.2";
                                    } else if (userAgent.indexOf("Windows") > 0) {
                                        os = "Windows XP";
                                    } else if (userAgent.indexOf("Linux") > 0) {
                                        os = "Linux";
                                    } else if (/(iPad|iPhone|iPod|Android)/.test(userAgent)) {
                                        os = "iPhone3,1";
                                    } else {
                                        notImplemented("public flash.system.Capabilities::get os");
                                    }
                                    Capabilities._os = os;
                                }
                                return Capabilities._os;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "cpuArchitecture", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get cpuArchitecture");
                                return;
                                // return Capabilities._cpuArchitecture;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "playerType", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get playerType");
                                return Capabilities._playerType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "serverString", {
                            get: function () {
                                var str = toKeyValueArray({ OS: Capabilities.os }).map(function (pair) {
                                    return pair[0] + "=" + encodeURIComponent(pair[1]);
                                }).join("&");
                                somewhatImplemented("Capabilities.serverString: " + str);
                                return str;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "version", {
                            get: function () {
                                return Capabilities._version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "screenColor", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get screenColor");
                                return;
                                // return Capabilities._screenColor;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "pixelAspectRatio", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get pixelAspectRatio");
                                return;
                                // return Capabilities._pixelAspectRatio;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "screenDPI", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get screenDPI");
                                return;
                                // return Capabilities._screenDPI;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "screenResolutionX", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get screenResolutionX");
                                return window.screen.width;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "screenResolutionY", {
                            get: function () {
                                somewhatImplemented("public flash.system.Capabilities::get screenResolutionY");
                                return window.screen.height;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "touchscreenType", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get touchscreenType");
                                return;
                                // return Capabilities._touchscreenType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasIME", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasIME");
                                return;
                                // return Capabilities._hasIME;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "hasTLS", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get hasTLS");
                                return;
                                // return Capabilities._hasTLS;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "maxLevelIDC", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get maxLevelIDC");
                                return;
                                // return Capabilities._maxLevelIDC;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "supports32BitProcesses", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get supports32BitProcesses");
                                return;
                                // return Capabilities._supports32BitProcesses;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "supports64BitProcesses", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get supports64BitProcesses");
                                return;
                                // return Capabilities._supports64BitProcesses;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, "_internal", {
                            get: function () {
                                notImplemented("public flash.system.Capabilities::get _internal");
                                return;
                                // return Capabilities.__internal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Capabilities.hasMultiChannelAudio = function (type) {
                            type = asCoerceString(type);
                            notImplemented("public flash.system.Capabilities::static hasMultiChannelAudio");
                            return;
                        };
                        Capabilities.classInitializer = null;

                        Capabilities.initializer = null;

                        Capabilities.classSymbols = null;

                        Capabilities.instanceSymbols = null;

                        Capabilities._hasAccessibility = false;

                        Capabilities._isDebugger = false;

                        Capabilities._language = 'en';
                        Capabilities._manufacturer = 'Mozilla Research';
                        Capabilities._os = null;

                        Capabilities._playerType = 'PlugIn';
                        Capabilities._version = 'SHUMWAY 10,0,0,0';
                        return Capabilities;
                    })(AS.ASNative);
                    system.Capabilities = Capabilities;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: FSCommand
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var FSCommand = (function (_super) {
                        __extends(FSCommand, _super);
                        function FSCommand() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: packageInternal flash.system.FSCommand");
                        }
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        FSCommand._fscommand = function (command, args) {
                            command = asCoerceString(command);
                            args = asCoerceString(args);
                            console.log('FSCommand: ' + command + '; ' + args);
                            switch (command.toLowerCase()) {
                                case 'quit':
                                    renderingTerminated = true;
                                    return;
                                case 'debugger':
                                    debugger;

                                    /* tslint:enable */
                                    return;
                                default:
                                    break;
                            }
                        };
                        FSCommand.classInitializer = null;

                        FSCommand.initializer = null;

                        FSCommand.classSymbols = null;

                        FSCommand.instanceSymbols = null;
                        return FSCommand;
                    })(AS.ASNative);
                    system.FSCommand = FSCommand;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ImageDecodingPolicy
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ImageDecodingPolicy = (function (_super) {
                        __extends(ImageDecodingPolicy, _super);
                        function ImageDecodingPolicy() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.ImageDecodingPolicy");
                        }
                        ImageDecodingPolicy.classInitializer = null;

                        ImageDecodingPolicy.initializer = null;

                        ImageDecodingPolicy.classSymbols = null;

                        ImageDecodingPolicy.instanceSymbols = null;

                        ImageDecodingPolicy.ON_DEMAND = "onDemand";
                        ImageDecodingPolicy.ON_LOAD = "onLoad";
                        return ImageDecodingPolicy;
                    })(AS.ASNative);
                    system.ImageDecodingPolicy = ImageDecodingPolicy;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: LoaderContext
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var LoaderContext = (function (_super) {
                        __extends(LoaderContext, _super);
                        function LoaderContext(checkPolicyFile, applicationDomain, securityDomain) {
                            if (typeof checkPolicyFile === "undefined") { checkPolicyFile = false; }
                            if (typeof applicationDomain === "undefined") { applicationDomain = null; }
                            if (typeof securityDomain === "undefined") { securityDomain = null; }
                            checkPolicyFile = !!checkPolicyFile;
                            applicationDomain = applicationDomain;
                            securityDomain = securityDomain;
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.LoaderContext");
                        }
                        LoaderContext.classInitializer = null;

                        LoaderContext.initializer = null;

                        LoaderContext.classSymbols = null;

                        LoaderContext.instanceSymbols = null;
                        return LoaderContext;
                    })(AS.ASNative);
                    system.LoaderContext = LoaderContext;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: JPEGLoaderContext
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var JPEGLoaderContext = (function (_super) {
                        __extends(JPEGLoaderContext, _super);
                        function JPEGLoaderContext(deblockingFilter, checkPolicyFile, applicationDomain, securityDomain) {
                            if (typeof deblockingFilter === "undefined") { deblockingFilter = 0; }
                            if (typeof checkPolicyFile === "undefined") { checkPolicyFile = false; }
                            if (typeof applicationDomain === "undefined") { applicationDomain = null; }
                            if (typeof securityDomain === "undefined") { securityDomain = null; }
                            deblockingFilter = +deblockingFilter;
                            checkPolicyFile = !!checkPolicyFile;
                            applicationDomain = applicationDomain;
                            securityDomain = securityDomain;
                            false && _super.call(this, undefined, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.system.JPEGLoaderContext");
                        }
                        JPEGLoaderContext.classInitializer = null;

                        JPEGLoaderContext.initializer = null;

                        JPEGLoaderContext.classSymbols = null;

                        JPEGLoaderContext.instanceSymbols = null;
                        return JPEGLoaderContext;
                    })(flash.system.LoaderContext);
                    system.JPEGLoaderContext = JPEGLoaderContext;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MessageChannel
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var MessageChannel = (function (_super) {
                        __extends(MessageChannel, _super);
                        function MessageChannel() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.system.MessageChannel");
                        }
                        Object.defineProperty(MessageChannel.prototype, "messageAvailable", {
                            // JS -> AS Bindings
                            // addEventListener: (type: string, listener: ASFunction, useCapture: boolean = false, priority: number /*int*/ = 0, useWeakReference: boolean = false) => void;
                            // removeEventListener: (type: string, listener: ASFunction, useCapture: boolean = false) => void;
                            // AS -> JS Bindings
                            // _messageAvailable: boolean;
                            // _state: string;
                            get: function () {
                                notImplemented("public flash.system.MessageChannel::get messageAvailable");
                                return;
                                // return this._messageAvailable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MessageChannel.prototype, "state", {
                            get: function () {
                                notImplemented("public flash.system.MessageChannel::get state");
                                return;
                                // return this._state;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MessageChannel.prototype.send = function (arg, queueLimit) {
                            if (typeof queueLimit === "undefined") { queueLimit = -1; }
                            queueLimit = queueLimit | 0;
                            notImplemented("public flash.system.MessageChannel::send");
                            return;
                        };
                        MessageChannel.prototype.receive = function (blockUntilReceived) {
                            if (typeof blockUntilReceived === "undefined") { blockUntilReceived = false; }
                            blockUntilReceived = !!blockUntilReceived;
                            notImplemented("public flash.system.MessageChannel::receive");
                            return;
                        };
                        MessageChannel.prototype.close = function () {
                            notImplemented("public flash.system.MessageChannel::close");
                            return;
                        };
                        MessageChannel.classInitializer = null;

                        MessageChannel.initializer = null;

                        MessageChannel.classSymbols = null;

                        MessageChannel.instanceSymbols = null;
                        return MessageChannel;
                    })(flash.events.EventDispatcher);
                    system.MessageChannel = MessageChannel;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MessageChannelState
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var MessageChannelState = (function (_super) {
                        __extends(MessageChannelState, _super);
                        function MessageChannelState() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.MessageChannelState");
                        }
                        MessageChannelState.classInitializer = null;

                        MessageChannelState.initializer = null;

                        MessageChannelState.classSymbols = null;

                        MessageChannelState.instanceSymbols = null;

                        MessageChannelState.OPEN = "open";
                        MessageChannelState.CLOSING = "closing";
                        MessageChannelState.CLOSED = "closed";
                        return MessageChannelState;
                    })(AS.ASNative);
                    system.MessageChannelState = MessageChannelState;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Security
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var Security = (function (_super) {
                        __extends(Security, _super);
                        function Security() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.Security");
                        }
                        Object.defineProperty(Security, "exactSettings", {
                            // static _pageDomain: string;
                            get: function () {
                                return Security._exactSettings;
                            },
                            set: function (value) {
                                value = !!value;
                                Security._exactSettings = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Security, "disableAVM1Loading", {
                            get: function () {
                                notImplemented("public flash.system.Security::get disableAVM1Loading");
                                return;
                                // return Security._disableAVM1Loading;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.system.Security::set disableAVM1Loading");
                                return;
                                // Security._disableAVM1Loading = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Security, "sandboxType", {
                            get: function () {
                                somewhatImplemented("public flash.system.Security::get sandboxType");
                                return Security._sandboxType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Security, "pageDomain", {
                            get: function () {
                                somewhatImplemented("public flash.system.Security::get pageDomain");
                                var pageHost = Shumway.FileLoadingService.instance.resolveUrl('/');
                                var parts = pageHost.split('/');
                                parts.pop();
                                return parts.pop();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Security.allowDomain = function () {
                            somewhatImplemented("public flash.system.Security::static allowDomain [\"" + Array.prototype.join.call(arguments, "\", \"") + "\"]");
                        };
                        Security.allowInsecureDomain = function () {
                            somewhatImplemented("public flash.system.Security::static allowInsecureDomain");
                        };
                        Security.loadPolicyFile = function (url) {
                            url = asCoerceString(url);
                            somewhatImplemented("public flash.system.Security::static loadPolicyFile");
                        };
                        Security.showSettings = function (panel) {
                            if (typeof panel === "undefined") { panel = "default"; }
                            panel = asCoerceString(panel);
                            notImplemented("public flash.system.Security::static showSettings");
                            return;
                        };
                        Security.duplicateSandboxBridgeInputArguments = function (toplevel, args) {
                            toplevel = toplevel;
                            args = args;
                            notImplemented("public flash.system.Security::static duplicateSandboxBridgeInputArguments");
                            return;
                        };
                        Security.duplicateSandboxBridgeOutputArgument = function (toplevel, arg) {
                            toplevel = toplevel;
                            notImplemented("public flash.system.Security::static duplicateSandboxBridgeOutputArgument");
                            return;
                        };
                        Security.classInitializer = null;

                        Security.initializer = null;

                        Security.classSymbols = null;

                        Security.instanceSymbols = null;

                        Security.REMOTE = "remote";
                        Security.LOCAL_WITH_FILE = "localWithFile";
                        Security.LOCAL_WITH_NETWORK = "localWithNetwork";
                        Security.LOCAL_TRUSTED = "localTrusted";
                        Security.APPLICATION = "application";

                        Security._exactSettings = false;

                        Security._sandboxType = 'remote';
                        return Security;
                    })(AS.ASNative);
                    system.Security = Security;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SecurityDomain
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var SecurityDomain = (function (_super) {
                        __extends(SecurityDomain, _super);
                        function SecurityDomain() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.SecurityDomain");
                        }
                        Object.defineProperty(SecurityDomain.prototype, "currentDomain", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _currentDomain: flash.system.SecurityDomain;
                            get: function () {
                                notImplemented("public flash.system.SecurityDomain::get currentDomain");
                                return;
                                // return this._currentDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(SecurityDomain.prototype, "domainID", {
                            // _domainID: string;
                            get: function () {
                                notImplemented("public flash.system.SecurityDomain::get domainID");
                                return;
                                // return this._domainID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SecurityDomain.classInitializer = null;

                        SecurityDomain.initializer = null;

                        SecurityDomain.classSymbols = null;

                        SecurityDomain.instanceSymbols = null;
                        return SecurityDomain;
                    })(AS.ASNative);
                    system.SecurityDomain = SecurityDomain;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SecurityPanel
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var SecurityPanel = (function (_super) {
                        __extends(SecurityPanel, _super);
                        function SecurityPanel() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.SecurityPanel");
                        }
                        SecurityPanel.classInitializer = null;

                        SecurityPanel.initializer = null;

                        SecurityPanel.classSymbols = null;

                        SecurityPanel.instanceSymbols = null;

                        SecurityPanel.DEFAULT = "default";
                        SecurityPanel.PRIVACY = "privacy";
                        SecurityPanel.LOCAL_STORAGE = "localStorage";
                        SecurityPanel.MICROPHONE = "microphone";
                        SecurityPanel.CAMERA = "camera";
                        SecurityPanel.DISPLAY = "display";
                        SecurityPanel.SETTINGS_MANAGER = "settingsManager";
                        return SecurityPanel;
                    })(AS.ASNative);
                    system.SecurityPanel = SecurityPanel;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TouchscreenType
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var TouchscreenType = (function (_super) {
                        __extends(TouchscreenType, _super);
                        function TouchscreenType() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.system.TouchscreenType");
                        }
                        TouchscreenType.classInitializer = null;

                        TouchscreenType.initializer = null;

                        TouchscreenType.classSymbols = null;

                        TouchscreenType.instanceSymbols = null;

                        TouchscreenType.FINGER = "finger";
                        TouchscreenType.STYLUS = "stylus";
                        TouchscreenType.NONE = "none";
                        return TouchscreenType;
                    })(AS.ASNative);
                    system.TouchscreenType = TouchscreenType;
                })(flash.system || (flash.system = {}));
                var system = flash.system;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: AntiAliasType
                (function (text) {
                    var AntiAliasType = (function (_super) {
                        __extends(AntiAliasType, _super);
                        function AntiAliasType() {
                            _super.call(this);
                        }
                        AntiAliasType.fromNumber = function (n) {
                            switch (n) {
                                case 1:
                                    return AntiAliasType.NORMAL;
                                case 2:
                                    return AntiAliasType.ADVANCED;
                                default:
                                    return null;
                            }
                        };

                        AntiAliasType.toNumber = function (value) {
                            switch (value) {
                                case AntiAliasType.NORMAL:
                                    return 1;
                                case AntiAliasType.ADVANCED:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        AntiAliasType.classInitializer = null;
                        AntiAliasType.initializer = null;
                        AntiAliasType.classSymbols = null;
                        AntiAliasType.instanceSymbols = null;

                        AntiAliasType.NORMAL = "normal";
                        AntiAliasType.ADVANCED = "advanced";
                        return AntiAliasType;
                    })(AS.ASNative);
                    text.AntiAliasType = AntiAliasType;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: FontStyle
                (function (text) {
                    var FontStyle = (function (_super) {
                        __extends(FontStyle, _super);
                        function FontStyle() {
                            _super.call(this);
                        }
                        FontStyle.classInitializer = null;
                        FontStyle.initializer = null;
                        FontStyle.classSymbols = null;
                        FontStyle.instanceSymbols = null;

                        FontStyle.REGULAR = "regular";
                        FontStyle.BOLD = "bold";
                        FontStyle.ITALIC = "italic";
                        FontStyle.BOLD_ITALIC = "boldItalic";
                        return FontStyle;
                    })(AS.ASNative);
                    text.FontStyle = FontStyle;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: FontType
                (function (text) {
                    var FontType = (function (_super) {
                        __extends(FontType, _super);
                        function FontType() {
                            _super.call(this);
                        }
                        FontType.classInitializer = null;
                        FontType.initializer = null;
                        FontType.classSymbols = null;
                        FontType.instanceSymbols = null;

                        FontType.EMBEDDED = "embedded";
                        FontType.EMBEDDED_CFF = "embeddedCFF";
                        FontType.DEVICE = "device";
                        return FontType;
                    })(AS.ASNative);
                    text.FontType = FontType;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Font
                (function (text) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var FontStyle = flash.text.FontStyle;
                    var FontType = flash.text.FontType;

                    var Font = (function (_super) {
                        __extends(Font, _super);
                        function Font() {
                            false && _super.call(this);
                        }
                        Font._getFontMetrics = function (name) {
                            if (!this._deviceFontMetrics) {
                                var userAgent = self.navigator.userAgent;
                                if (userAgent.indexOf("Windows") > -1) {
                                    this._deviceFontMetrics = Font.DEVICE_FONT_METRICS_WIN;
                                } else if (/(Macintosh|iPad|iPhone|iPod|Android)/.test(userAgent)) {
                                    this._deviceFontMetrics = this.DEVICE_FONT_METRICS_MAC;
                                } else {
                                    this._deviceFontMetrics = this.DEVICE_FONT_METRICS_LINUX;
                                }
                            }
                            return this._deviceFontMetrics[Font.resolveFontName(name)];
                        };

                        Font.resolveFontName = function (name) {
                            if (name === '_sans') {
                                return 'sans-serif';
                            } else if (name === '_serif') {
                                return 'serif';
                            } else if (name === '_typewriter') {
                                return 'monospace';
                            }
                            return name;
                        };

                        Font.getBySymbolId = function (id) {
                            return this._fontsBySymbolId[id];
                        };

                        Font.getByName = function (name) {
                            name = name.toLowerCase();
                            var font = this._fontsByName[name];
                            if (!font) {
                                var font = new Font();
                                font._fontName = name;
                                font._fontStyle = FontStyle.REGULAR;
                                font._fontType = FontType.DEVICE;
                                this._fontsByName[name] = font;
                            }
                            if (font._fontType === FontType.DEVICE) {
                                var metrics = Font._getFontMetrics(name);
                                if (metrics) {
                                    font.ascent = metrics[0];
                                    font.descent = metrics[1];
                                    font.leading = metrics[2];
                                }
                            }
                            return font;
                        };

                        Font.getDefaultFont = function () {
                            return Font.getByName('times roman');
                        };

                        // AS -> JS Bindings
                        Font.enumerateFonts = function (enumerateDeviceFonts) {
                            if (typeof enumerateDeviceFonts === "undefined") { enumerateDeviceFonts = false; }
                            //TODO: support iterating device fonts, perhaps?
                            somewhatImplemented("public flash.text.Font::static enumerateFonts");
                            return Font._fonts.slice();
                        };

                        Font.registerFont = function (font) {
                            somewhatImplemented('Font.registerFont');
                        };

                        Object.defineProperty(Font.prototype, "fontName", {
                            get: function () {
                                return this._fontName;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Font.prototype, "fontStyle", {
                            get: function () {
                                return this._fontStyle;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Font.prototype, "fontType", {
                            get: function () {
                                return this._fontType;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Font.prototype.hasGlyphs = function (str) {
                            str = asCoerceString(str);
                            somewhatImplemented('Font#hasGlyphs');
                            return true;
                        };
                        Font.classInitializer = function () {
                            Font._fonts = [];
                            Font._fontsBySymbolId = Shumway.ObjectUtilities.createMap();
                            Font._fontsByName = Shumway.ObjectUtilities.createMap();

                            Font.DEVICE_FONT_METRICS_WIN = {
                                "serif": [1, 0.25, 0],
                                "sans-serif": [1, 0.25, 0],
                                "monospace": [1, 0.25, 0],
                                "birch std": [0.9167, 0.25, 0],
                                "blackoak std": [1, 0.3333, 0],
                                "chaparral pro": [0.8333, 0.3333, 0],
                                "chaparral pro light": [0.8333, 0.3333, 0],
                                "charlemagne std": [0.9167, 0.25, 0],
                                "cooper std black": [0.9167, 0.25, 0],
                                "giddyup std": [0.8333, 0.3333, 0],
                                "hobo std": [1.0833, 0.3333, 0],
                                "kozuka gothic pro b": [1, 0.4167, 0],
                                "kozuka gothic pro el": [1.0833, 0.25, 0],
                                "kozuka gothic pro h": [1, 0.4167, 0],
                                "kozuka gothic pro l": [1, 0.3333, 0],
                                "kozuka gothic pro m": [1.0833, 0.3333, 0],
                                "kozuka gothic pro r": [1, 0.3333, 0],
                                "kozuka mincho pro b": [1.0833, 0.25, 0],
                                "kozuka mincho pro el": [1.0833, 0.25, 0],
                                "kozuka mincho pro h": [1.1667, 0.25, 0],
                                "kozuka mincho pro l": [1.0833, 0.25, 0],
                                "kozuka mincho pro m": [1.0833, 0.25, 0],
                                "kozuka mincho pro r": [1.0833, 0.25, 0],
                                "mesquite std": [0.9167, 0.25, 0],
                                "minion pro cond": [1, 0.3333, 0],
                                "minion pro med": [1, 0.3333, 0],
                                "minion pro smbd": [1, 0.3333, 0],
                                "myriad arabic": [1, 0.4167, 0],
                                "nueva std": [0.75, 0.25, 0],
                                "nueva std cond": [0.75, 0.25, 0],
                                "ocr a std": [0.8333, 0.25, 0],
                                "orator std": [1.0833, 0.25, 0],
                                "poplar std": [0.9167, 0.25, 0],
                                "prestige elite std": [0.9167, 0.25, 0],
                                "rosewood std regular": [0.8333, 0.3333, 0],
                                "stencil std": [1, 0.3333, 0],
                                "trajan pro": [1, 0.25, 0],
                                "kozuka gothic pr6n b": [1.4167, 0.4167, 0],
                                "kozuka gothic pr6n el": [1.4167, 0.3333, 0],
                                "kozuka gothic pr6n h": [1.4167, 0.4167, 0],
                                "kozuka gothic pr6n l": [1.4167, 0.3333, 0],
                                "kozuka gothic pr6n m": [1.5, 0.3333, 0],
                                "kozuka gothic pr6n r": [1.4167, 0.3333, 0],
                                "kozuka mincho pr6n b": [1.3333, 0.3333, 0],
                                "kozuka mincho pr6n el": [1.3333, 0.3333, 0],
                                "kozuka mincho pr6n h": [1.4167, 0.3333, 0],
                                "kozuka mincho pr6n l": [1.3333, 0.3333, 0],
                                "kozuka mincho pr6n m": [1.3333, 0.3333, 0],
                                "kozuka mincho pr6n r": [1.3333, 0.3333, 0],
                                "letter gothic std": [1, 0.25, 0],
                                "minion pro": [1, 0.3333, 0],
                                "myriad hebrew": [0.8333, 0.3333, 0],
                                "myriad pro": [0.9167, 0.25, 0],
                                "myriad pro cond": [0.9167, 0.25, 0],
                                "myriad pro light": [1, 0.25, 0],
                                "marlett": [1, 0, 0],
                                "arial": [1, 0.25, 0],
                                "arabic transparent": [1, 0.25, 0],
                                "arial baltic": [1, 0.25, 0],
                                "arial ce": [1, 0.25, 0],
                                "arial cyr": [1, 0.25, 0],
                                "arial greek": [1, 0.25, 0],
                                "arial tur": [1, 0.25, 0],
                                "batang": [0.8333, 0.1667, 0],
                                "batangche": [0.8333, 0.1667, 0],
                                "gungsuh": [0.8333, 0.1667, 0],
                                "gungsuhche": [0.8333, 0.1667, 0],
                                "courier new": [1, 0.25, 0],
                                "courier new baltic": [1, 0.25, 0],
                                "courier new ce": [1, 0.25, 0],
                                "courier new cyr": [1, 0.25, 0],
                                "courier new greek": [1, 0.25, 0],
                                "courier new tur": [1, 0.25, 0],
                                "daunpenh": [0.6667, 0.6667, 0],
                                "dokchampa": [1.4167, 0.5833, 0],
                                "estrangelo edessa": [0.75, 0.3333, 0],
                                "euphemia": [1.0833, 0.3333, 0],
                                "gautami": [1.1667, 0.8333, 0],
                                "vani": [1.0833, 0.75, 0],
                                "gulim": [0.8333, 0.1667, 0],
                                "gulimche": [0.8333, 0.1667, 0],
                                "dotum": [0.8333, 0.1667, 0],
                                "dotumche": [0.8333, 0.1667, 0],
                                "impact": [1.0833, 0.25, 0],
                                "iskoola pota": [1, 0.3333, 0],
                                "kalinga": [1.0833, 0.5, 0],
                                "kartika": [1, 0.4167, 0],
                                "khmer ui": [1.0833, 0.3333, 0],
                                "lao ui": [1, 0.25, 0],
                                "latha": [1.0833, 0.4167, 0],
                                "lucida console": [0.75, 0.25, 0],
                                "malgun gothic": [1, 0.25, 0],
                                "mangal": [1.0833, 0.3333, 0],
                                "meiryo": [1.0833, 0.4167, 0],
                                "meiryo ui": [1, 0.25, 0],
                                "microsoft himalaya": [0.5833, 0.4167, 0],
                                "microsoft jhenghei": [1, 0.3333, 0],
                                "microsoft yahei": [1.0833, 0.3333, 0],
                                "mingliu": [0.8333, 0.1667, 0],
                                "pmingliu": [0.8333, 0.1667, 0],
                                "mingliu_hkscs": [0.8333, 0.1667, 0],
                                "mingliu-extb": [0.8333, 0.1667, 0],
                                "pmingliu-extb": [0.8333, 0.1667, 0],
                                "mingliu_hkscs-extb": [0.8333, 0.1667, 0],
                                "mongolian baiti": [0.8333, 0.25, 0],
                                "ms gothic": [0.8333, 0.1667, 0],
                                "ms pgothic": [0.8333, 0.1667, 0],
                                "ms ui gothic": [0.8333, 0.1667, 0],
                                "ms mincho": [0.8333, 0.1667, 0],
                                "ms pmincho": [0.8333, 0.1667, 0],
                                "mv boli": [1.1667, 0.25, 0],
                                "microsoft new tai lue": [1, 0.4167, 0],
                                "nyala": [0.9167, 0.3333, 0],
                                "microsoft phagspa": [1.0833, 0.25, 0],
                                "plantagenet cherokee": [1, 0.4167, 0],
                                "raavi": [1.0833, 0.6667, 0],
                                "segoe script": [1.0833, 0.5, 0],
                                "segoe ui": [1, 0.25, 0],
                                "segoe ui semibold": [1, 0.25, 0],
                                "segoe ui light": [1, 0.25, 0],
                                "segoe ui symbol": [1, 0.25, 0],
                                "shruti": [1.0833, 0.5, 0],
                                "simsun": [0.8333, 0.1667, 0],
                                "nsimsun": [0.8333, 0.1667, 0],
                                "simsun-extb": [0.8333, 0.1667, 0],
                                "sylfaen": [1, 0.3333, 0],
                                "microsoft tai le": [1, 0.3333, 0],
                                "times new roman": [1, 0.25, 0],
                                "times new roman baltic": [1, 0.25, 0],
                                "times new roman ce": [1, 0.25, 0],
                                "times new roman cyr": [1, 0.25, 0],
                                "times new roman greek": [1, 0.25, 0],
                                "times new roman tur": [1, 0.25, 0],
                                "tunga": [1.0833, 0.75, 0],
                                "vrinda": [1, 0.4167, 0],
                                "shonar bangla": [0.8333, 0.5, 0],
                                "microsoft yi baiti": [0.8333, 0.1667, 0],
                                "tahoma": [1, 0.1667, 0],
                                "microsoft sans serif": [1.0833, 0.1667, 0],
                                "angsana new": [0.9167, 0.4167, 0],
                                "aparajita": [0.75, 0.4167, 0],
                                "cordia new": [0.9167, 0.5, 0],
                                "ebrima": [1.0833, 0.5, 0],
                                "gisha": [0.9167, 0.25, 0],
                                "kokila": [0.8333, 0.3333, 0],
                                "leelawadee": [0.9167, 0.25, 0],
                                "microsoft uighur": [1.0833, 0.5, 0],
                                "moolboran": [0.6667, 0.6667, 0],
                                "symbol": [1, 0.25, 0],
                                "utsaah": [0.8333, 0.4167, 0],
                                "vijaya": [1.0833, 0.25, 0],
                                "wingdings": [0.9167, 0.25, 0],
                                "andalus": [1.3333, 0.4167, 0],
                                "arabic typesetting": [0.8333, 0.5, 0],
                                "simplified arabic": [1.3333, 0.5, 0],
                                "simplified arabic fixed": [1, 0.4167, 0],
                                "sakkal majalla": [0.9167, 0.5, 0],
                                "traditional arabic": [1.3333, 0.5, 0],
                                "aharoni": [0.75, 0.25, 0],
                                "david": [0.75, 0.25, 0],
                                "frankruehl": [0.75, 0.25, 0],
                                "fangsong": [0.8333, 0.1667, 0],
                                "simhei": [0.8333, 0.1667, 0],
                                "kaiti": [0.8333, 0.1667, 0],
                                "browallia new": [0.8333, 0.4167, 0],
                                "lucida sans unicode": [1.0833, 0.25, 0],
                                "arial black": [1.0833, 0.3333, 0],
                                "calibri": [0.9167, 0.25, 0],
                                "cambria": [0.9167, 0.25, 0],
                                "cambria math": [3.0833, 2.5, 0],
                                "candara": [0.9167, 0.25, 0],
                                "comic sans ms": [1.0833, 0.3333, 0],
                                "consolas": [0.9167, 0.25, 0],
                                "constantia": [0.9167, 0.25, 0],
                                "corbel": [0.9167, 0.25, 0],
                                "franklin gothic medium": [1, 0.3333, 0],
                                "gabriola": [1.1667, 0.6667, 0],
                                "georgia": [1, 0.25, 0],
                                "palatino linotype": [1.0833, 0.3333, 0],
                                "segoe print": [1.25, 0.5, 0],
                                "trebuchet ms": [1.0833, 0.4167, 0],
                                "verdana": [1, 0.1667, 0],
                                "webdings": [1.0833, 0.5, 0],
                                "lucida bright": [0.9167, 0.25, 0],
                                "lucida sans": [0.9167, 0.25, 0],
                                "lucida sans typewriter": [0.9167, 0.25, 0],
                                "gentium basic": [0.8333, 0.25, 0],
                                "dejavu serif condensed": [0.9167, 0.25, 0],
                                "arimo": [1, 0.25, 0],
                                "dejavu sans condensed": [0.9167, 0.25, 0],
                                "dejavu sans": [0.9167, 0.25, 0],
                                "dejavu sans light": [0.9167, 0.25, 0],
                                "opensymbol": [0.8333, 0.1667, 0],
                                "gentium book basic": [0.8333, 0.25, 0],
                                "dejavu sans mono": [0.9167, 0.25, 0],
                                "dejavu serif": [0.9167, 0.25, 0],
                                "calibri light": [0.9167, 0.25, 0]
                            };
                            Font.DEVICE_FONT_METRICS_MAC = {
                                "al bayan plain": [1, 0.5, 0],
                                "al bayan bold": [1, 0.5833, 0],
                                "american typewriter": [0.9167, 0.25, 0],
                                "american typewriter bold": [0.9167, 0.25, 0],
                                "american typewriter condensed": [0.9167, 0.25, 0],
                                "american typewriter condensed bold": [0.9167, 0.25, 0],
                                "american typewriter condensed light": [0.8333, 0.25, 0],
                                "american typewriter light": [0.9167, 0.25, 0],
                                "andale mono": [0.9167, 0.25, 0],
                                "apple symbols": [0.6667, 0.25, 0],
                                "arial bold italic": [0.9167, 0.25, 0],
                                "arial bold": [0.9167, 0.25, 0],
                                "arial italic": [0.9167, 0.25, 0],
                                "arial hebrew": [0.75, 0.3333, 0],
                                "arial hebrew bold": [0.75, 0.3333, 0],
                                "arial": [0.9167, 0.25, 0],
                                "arial narrow": [0.9167, 0.25, 0],
                                "arial narrow bold": [0.9167, 0.25, 0],
                                "arial narrow bold italic": [0.9167, 0.25, 0],
                                "arial narrow italic": [0.9167, 0.25, 0],
                                "arial rounded mt bold": [0.9167, 0.25, 0],
                                "arial unicode ms": [1.0833, 0.25, 0],
                                "avenir black": [1, 0.3333, 0],
                                "avenir black oblique": [1, 0.3333, 0],
                                "avenir book": [1, 0.3333, 0],
                                "avenir book oblique": [1, 0.3333, 0],
                                "avenir heavy": [1, 0.3333, 0],
                                "avenir heavy oblique": [1, 0.3333, 0],
                                "avenir light": [1, 0.3333, 0],
                                "avenir light oblique": [1, 0.3333, 0],
                                "avenir medium": [1, 0.3333, 0],
                                "avenir medium oblique": [1, 0.3333, 0],
                                "avenir oblique": [1, 0.3333, 0],
                                "avenir roman": [1, 0.3333, 0],
                                "avenir next bold": [1, 0.3333, 0],
                                "avenir next bold italic": [1, 0.3333, 0],
                                "avenir next demi bold": [1, 0.3333, 0],
                                "avenir next demi bold italic": [1, 0.3333, 0],
                                "avenir next heavy": [1, 0.3333, 0],
                                "avenir next heavy italic": [1, 0.3333, 0],
                                "avenir next italic": [1, 0.3333, 0],
                                "avenir next medium": [1, 0.3333, 0],
                                "avenir next medium italic": [1, 0.3333, 0],
                                "avenir next regular": [1, 0.3333, 0],
                                "avenir next ultra light": [1, 0.3333, 0],
                                "avenir next ultra light italic": [1, 0.3333, 0],
                                "avenir next condensed bold": [1, 0.3333, 0],
                                "avenir next condensed bold italic": [1, 0.3333, 0],
                                "avenir next condensed demi bold": [1, 0.3333, 0],
                                "avenir next condensed demi bold italic": [1, 0.3333, 0],
                                "avenir next condensed heavy": [1, 0.3333, 0],
                                "avenir next condensed heavy italic": [1, 0.3333, 0],
                                "avenir next condensed italic": [1, 0.3333, 0],
                                "avenir next condensed medium": [1, 0.3333, 0],
                                "avenir next condensed medium italic": [1, 0.3333, 0],
                                "avenir next condensed regular": [1, 0.3333, 0],
                                "avenir next condensed ultra light": [1, 0.3333, 0],
                                "avenir next condensed ultra light italic": [1, 0.3333, 0],
                                "ayuthaya": [1.0833, 0.3333, 0],
                                "baghdad": [0.9167, 0.4167, 0],
                                "bangla mn": [0.9167, 0.6667, 0],
                                "bangla mn bold": [0.9167, 0.6667, 0],
                                "bangla sangam mn": [0.9167, 0.4167, 0],
                                "bangla sangam mn bold": [0.9167, 0.4167, 0],
                                "baskerville": [0.9167, 0.25, 0],
                                "baskerville bold": [0.9167, 0.25, 0],
                                "baskerville bold italic": [0.9167, 0.25, 0],
                                "baskerville italic": [0.9167, 0.25, 0],
                                "baskerville semibold": [0.9167, 0.25, 0],
                                "baskerville semibold italic": [0.9167, 0.25, 0],
                                "big caslon medium": [0.9167, 0.25, 0],
                                "brush script mt italic": [0.9167, 0.3333, 0],
                                "chalkboard": [1, 0.25, 0],
                                "chalkboard bold": [1, 0.25, 0],
                                "chalkboard se bold": [1.1667, 0.25, 0],
                                "chalkboard se light": [1.1667, 0.25, 0],
                                "chalkboard se regular": [1.1667, 0.25, 0],
                                "chalkduster": [1, 0.25, 0],
                                "charcoal cy": [1, 0.25, 0],
                                "cochin": [0.9167, 0.25, 0],
                                "cochin bold": [0.9167, 0.25, 0],
                                "cochin bold italic": [0.9167, 0.25, 0],
                                "cochin italic": [0.9167, 0.25, 0],
                                "comic sans ms": [1.0833, 0.25, 0],
                                "comic sans ms bold": [1.0833, 0.25, 0],
                                "copperplate": [0.75, 0.25, 0],
                                "copperplate bold": [0.75, 0.25, 0],
                                "copperplate light": [0.75, 0.25, 0],
                                "corsiva hebrew": [0.6667, 0.3333, 0],
                                "corsiva hebrew bold": [0.6667, 0.3333, 0],
                                "courier": [0.75, 0.25, 0],
                                "courier bold": [0.75, 0.25, 0],
                                "courier bold oblique": [0.75, 0.25, 0],
                                "courier oblique": [0.75, 0.25, 0],
                                "courier new bold italic": [0.8333, 0.3333, 0],
                                "courier new bold": [0.8333, 0.3333, 0],
                                "courier new italic": [0.8333, 0.3333, 0],
                                "courier new": [0.8333, 0.3333, 0],
                                "biaukai": [0.8333, 0.1667, 0],
                                "damascus": [0.5833, 0.4167, 0],
                                "damascus bold": [0.5833, 0.4167, 0],
                                "decotype naskh": [1.1667, 0.6667, 0],
                                "devanagari mt": [0.9167, 0.6667, 0],
                                "devanagari mt bold": [0.9167, 0.6667, 0],
                                "devanagari sangam mn": [0.9167, 0.4167, 0],
                                "devanagari sangam mn bold": [0.9167, 0.4167, 0],
                                "didot": [0.9167, 0.3333, 0],
                                "didot bold": [1, 0.3333, 0],
                                "didot italic": [0.9167, 0.25, 0],
                                "euphemia ucas": [1.0833, 0.25, 0],
                                "euphemia ucas bold": [1.0833, 0.25, 0],
                                "euphemia ucas italic": [1.0833, 0.25, 0],
                                "futura condensed extrabold": [1, 0.25, 0],
                                "futura condensed medium": [1, 0.25, 0],
                                "futura medium": [1, 0.25, 0],
                                "futura medium italic": [1, 0.25, 0],
                                "gb18030 bitmap": [1, 0.6667, 0],
                                "geeza pro": [0.9167, 0.3333, 0],
                                "geeza pro bold": [0.9167, 0.3333, 0],
                                "geneva": [1, 0.25, 0],
                                "geneva cy": [1, 0.25, 0],
                                "georgia": [0.9167, 0.25, 0],
                                "georgia bold": [0.9167, 0.25, 0],
                                "georgia bold italic": [0.9167, 0.25, 0],
                                "georgia italic": [0.9167, 0.25, 0],
                                "gill sans": [0.9167, 0.25, 0],
                                "gill sans bold": [0.9167, 0.25, 0],
                                "gill sans bold italic": [0.9167, 0.25, 0],
                                "gill sans italic": [0.9167, 0.25, 0],
                                "gill sans light": [0.9167, 0.25, 0],
                                "gill sans light italic": [0.9167, 0.25, 0],
                                "gujarati mt": [0.9167, 0.6667, 0],
                                "gujarati mt bold": [0.9167, 0.6667, 0],
                                "gujarati sangam mn": [0.8333, 0.4167, 0],
                                "gujarati sangam mn bold": [0.8333, 0.4167, 0],
                                "gurmukhi mn": [0.9167, 0.25, 0],
                                "gurmukhi mn bold": [0.9167, 0.25, 0],
                                "gurmukhi sangam mn": [0.9167, 0.3333, 0],
                                "gurmukhi sangam mn bold": [0.9167, 0.3333, 0],
                                "helvetica": [0.75, 0.25, 0],
                                "helvetica bold": [0.75, 0.25, 0],
                                "helvetica bold oblique": [0.75, 0.25, 0],
                                "helvetica light": [0.75, 0.25, 0],
                                "helvetica light oblique": [0.75, 0.25, 0],
                                "helvetica oblique": [0.75, 0.25, 0],
                                "helvetica neue": [0.9167, 0.25, 0],
                                "helvetica neue bold": [1, 0.25, 0],
                                "helvetica neue bold italic": [1, 0.25, 0],
                                "helvetica neue condensed black": [1, 0.25, 0],
                                "helvetica neue condensed bold": [1, 0.25, 0],
                                "helvetica neue italic": [0.9167, 0.25, 0],
                                "helvetica neue light": [1, 0.25, 0],
                                "helvetica neue light italic": [0.9167, 0.25, 0],
                                "helvetica neue medium": [1, 0.25, 0],
                                "helvetica neue ultralight": [0.9167, 0.25, 0],
                                "helvetica neue ultralight italic": [0.9167, 0.25, 0],
                                "herculanum": [0.8333, 0.1667, 0],
                                "hiragino kaku gothic pro w3": [0.9167, 0.0833, 0],
                                "hiragino kaku gothic pro w6": [0.9167, 0.0833, 0],
                                "hiragino kaku gothic pron w3": [0.9167, 0.0833, 0],
                                "hiragino kaku gothic pron w6": [0.9167, 0.0833, 0],
                                "hiragino kaku gothic std w8": [0.9167, 0.0833, 0],
                                "hiragino kaku gothic stdn w8": [0.9167, 0.0833, 0],
                                "hiragino maru gothic pro w4": [0.9167, 0.0833, 0],
                                "hiragino maru gothic pron w4": [0.9167, 0.0833, 0],
                                "hiragino mincho pro w3": [0.9167, 0.0833, 0],
                                "hiragino mincho pro w6": [0.9167, 0.0833, 0],
                                "hiragino mincho pron w3": [0.9167, 0.0833, 0],
                                "hiragino mincho pron w6": [0.9167, 0.0833, 0],
                                "hiragino sans gb w3": [0.9167, 0.0833, 0],
                                "hiragino sans gb w6": [0.9167, 0.0833, 0],
                                "hoefler text black": [0.75, 0.25, 0],
                                "hoefler text black italic": [0.75, 0.25, 0],
                                "hoefler text italic": [0.75, 0.25, 0],
                                "hoefler text ornaments": [0.8333, 0.1667, 0],
                                "hoefler text": [0.75, 0.25, 0],
                                "impact": [1, 0.25, 0],
                                "inaimathi": [0.8333, 0.4167, 0],
                                "headlinea regular": [0.8333, 0.1667, 0],
                                "pilgi regular": [0.8333, 0.25, 0],
                                "gungseo regular": [0.8333, 0.25, 0],
                                "pcmyungjo regular": [0.8333, 0.25, 0],
                                "kailasa regular": [1.0833, 0.5833, 0],
                                "kannada mn": [0.9167, 0.25, 0],
                                "kannada mn bold": [0.9167, 0.25, 0],
                                "kannada sangam mn": [1, 0.5833, 0],
                                "kannada sangam mn bold": [1, 0.5833, 0],
                                "kefa bold": [0.9167, 0.25, 0],
                                "kefa regular": [0.9167, 0.25, 0],
                                "khmer mn": [1, 0.6667, 0],
                                "khmer mn bold": [1, 0.6667, 0],
                                "khmer sangam mn": [1.0833, 0.6667, 0],
                                "kokonor regular": [1.0833, 0.5833, 0],
                                "krungthep": [1, 0.25, 0],
                                "kufistandardgk": [0.9167, 0.5, 0],
                                "lao mn": [0.9167, 0.4167, 0],
                                "lao mn bold": [0.9167, 0.4167, 0],
                                "lao sangam mn": [1, 0.3333, 0],
                                "apple ligothic medium": [0.8333, 0.1667, 0],
                                "lihei pro": [0.8333, 0.1667, 0],
                                "lisong pro": [0.8333, 0.1667, 0],
                                "lucida grande": [1, 0.25, 0],
                                "lucida grande bold": [1, 0.25, 0],
                                "malayalam mn": [1, 0.4167, 0],
                                "malayalam mn bold": [1, 0.4167, 0],
                                "malayalam sangam mn": [0.8333, 0.4167, 0],
                                "malayalam sangam mn bold": [0.8333, 0.4167, 0],
                                "marion bold": [0.6667, 0.3333, 0],
                                "marion italic": [0.6667, 0.3333, 0],
                                "marion regular": [0.6667, 0.3333, 0],
                                "marker felt thin": [0.8333, 0.25, 0],
                                "marker felt wide": [0.9167, 0.25, 0],
                                "menlo bold": [0.9167, 0.25, 0],
                                "menlo bold italic": [0.9167, 0.25, 0],
                                "menlo italic": [0.9167, 0.25, 0],
                                "menlo regular": [0.9167, 0.25, 0],
                                "microsoft sans serif": [0.9167, 0.25, 0],
                                "monaco": [1, 0.25, 0],
                                "gurmukhi mt": [0.8333, 0.4167, 0],
                                "mshtakan": [0.9167, 0.25, 0],
                                "mshtakan bold": [0.9167, 0.25, 0],
                                "mshtakan boldoblique": [0.9167, 0.25, 0],
                                "mshtakan oblique": [0.9167, 0.25, 0],
                                "myanmar mn": [1, 0.4167, 0],
                                "myanmar mn bold": [1, 0.4167, 0],
                                "myanmar sangam mn": [0.9167, 0.4167, 0],
                                "nadeem": [0.9167, 0.4167, 0],
                                "nanum brush script": [0.9167, 0.25, 0],
                                "nanumgothic": [0.9167, 0.25, 0],
                                "nanumgothic bold": [0.9167, 0.25, 0],
                                "nanumgothic extrabold": [0.9167, 0.25, 0],
                                "nanummyeongjo": [0.9167, 0.25, 0],
                                "nanummyeongjo bold": [0.9167, 0.25, 0],
                                "nanummyeongjo extrabold": [0.9167, 0.25, 0],
                                "nanum pen script": [0.9167, 0.25, 0],
                                "optima bold": [0.9167, 0.25, 0],
                                "optima bold italic": [0.9167, 0.25, 0],
                                "optima extrablack": [1, 0.25, 0],
                                "optima italic": [0.9167, 0.25, 0],
                                "optima regular": [0.9167, 0.25, 0],
                                "oriya mn": [0.9167, 0.25, 0],
                                "oriya mn bold": [0.9167, 0.25, 0],
                                "oriya sangam mn": [0.8333, 0.4167, 0],
                                "oriya sangam mn bold": [0.8333, 0.4167, 0],
                                "osaka": [1, 0.25, 0],
                                "osaka-mono": [0.8333, 0.1667, 0],
                                "palatino bold": [0.8333, 0.25, 0],
                                "palatino bold italic": [0.8333, 0.25, 0],
                                "palatino italic": [0.8333, 0.25, 0],
                                "palatino": [0.8333, 0.25, 0],
                                "papyrus": [0.9167, 0.5833, 0],
                                "papyrus condensed": [0.9167, 0.5833, 0],
                                "plantagenet cherokee": [0.6667, 0.25, 0],
                                "raanana": [0.75, 0.25, 0],
                                "raanana bold": [0.75, 0.25, 0],
                                "hei regular": [0.8333, 0.1667, 0],
                                "kai regular": [0.8333, 0.1667, 0],
                                "stfangsong": [0.8333, 0.1667, 0],
                                "stheiti": [0.8333, 0.1667, 0],
                                "heiti sc light": [0.8333, 0.1667, 0],
                                "heiti sc medium": [0.8333, 0.1667, 0],
                                "heiti tc light": [0.8333, 0.1667, 0],
                                "heiti tc medium": [0.8333, 0.1667, 0],
                                "stkaiti": [0.8333, 0.1667, 0],
                                "kaiti sc black": [1.0833, 0.3333, 0],
                                "kaiti sc bold": [1.0833, 0.3333, 0],
                                "kaiti sc regular": [1.0833, 0.3333, 0],
                                "stsong": [0.8333, 0.1667, 0],
                                "songti sc black": [1.0833, 0.3333, 0],
                                "songti sc bold": [1.0833, 0.3333, 0],
                                "songti sc light": [1.0833, 0.3333, 0],
                                "songti sc regular": [1.0833, 0.3333, 0],
                                "stxihei": [0.8333, 0.1667, 0],
                                "sathu": [0.9167, 0.3333, 0],
                                "silom": [1, 0.3333, 0],
                                "sinhala mn": [0.9167, 0.25, 0],
                                "sinhala mn bold": [0.9167, 0.25, 0],
                                "sinhala sangam mn": [1.1667, 0.3333, 0],
                                "sinhala sangam mn bold": [1.1667, 0.3333, 0],
                                "skia regular": [0.75, 0.25, 0],
                                "symbol": [0.6667, 0.3333, 0],
                                "tahoma negreta": [1, 0.1667, 0],
                                "tamil mn": [0.9167, 0.25, 0],
                                "tamil mn bold": [0.9167, 0.25, 0],
                                "tamil sangam mn": [0.75, 0.25, 0],
                                "tamil sangam mn bold": [0.75, 0.25, 0],
                                "telugu mn": [0.9167, 0.25, 0],
                                "telugu mn bold": [0.9167, 0.25, 0],
                                "telugu sangam mn": [1, 0.5833, 0],
                                "telugu sangam mn bold": [1, 0.5833, 0],
                                "thonburi": [1.0833, 0.25, 0],
                                "thonburi bold": [1.0833, 0.25, 0],
                                "times bold": [0.75, 0.25, 0],
                                "times bold italic": [0.75, 0.25, 0],
                                "times italic": [0.75, 0.25, 0],
                                "times roman": [0.75, 0.25, 0],
                                "times new roman bold italic": [0.9167, 0.25, 0],
                                "times new roman bold": [0.9167, 0.25, 0],
                                "times new roman italic": [0.9167, 0.25, 0],
                                "times new roman": [0.9167, 0.25, 0],
                                "trebuchet ms bold italic": [0.9167, 0.25, 0],
                                "trebuchet ms": [0.9167, 0.25, 0],
                                "trebuchet ms bold": [0.9167, 0.25, 0],
                                "trebuchet ms italic": [0.9167, 0.25, 0],
                                "verdana": [1, 0.25, 0],
                                "verdana bold": [1, 0.25, 0],
                                "verdana bold italic": [1, 0.25, 0],
                                "verdana italic": [1, 0.25, 0],
                                "webdings": [0.8333, 0.1667, 0],
                                "wingdings 2": [0.8333, 0.25, 0],
                                "wingdings 3": [0.9167, 0.25, 0],
                                "yuppy sc regular": [1.0833, 0.3333, 0],
                                "yuppy tc regular": [1.0833, 0.3333, 0],
                                "zapf dingbats": [0.8333, 0.1667, 0],
                                "zapfino": [1.9167, 1.5, 0]
                            };

                            Font.DEVICE_FONT_METRICS_LINUX = {
                                "kacstfarsi": [1.0831, 0.5215, 0],
                                "meera": [0.682, 0.4413, 0],
                                "freemono": [0.8023, 0.2006, 0],
                                "undotum": [1.0029, 0.2808, 0],
                                "loma": [1.1634, 0.4814, 0],
                                "century schoolbook l": [1.0029, 0.3209, 0],
                                "kacsttitlel": [1.0831, 0.5215, 0],
                                "undinaru": [1.0029, 0.2407, 0],
                                "ungungseo": [1.0029, 0.2808, 0],
                                "garuda": [1.3238, 0.6017, 0],
                                "rekha": [1.1232, 0.2808, 0],
                                "purisa": [1.1232, 0.5215, 0],
                                "dejavu sans mono": [0.9628, 0.2407, 0],
                                "vemana2000": [0.8825, 0.8424, 0],
                                "kacstoffice": [1.0831, 0.5215, 0],
                                "umpush": [1.2837, 0.682, 0],
                                "opensymbol": [0.8023, 0.2006, 0],
                                "sawasdee": [1.1232, 0.4413, 0],
                                "urw palladio l": [1.0029, 0.3209, 0],
                                "freeserif": [0.9227, 0.3209, 0],
                                "kacstdigital": [1.0831, 0.5215, 0],
                                "ubuntu condensed": [0.9628, 0.2006, 0],
                                "unpilgi": [1.0029, 0.4413, 0],
                                "mry_kacstqurn": [1.4442, 0.7221, 0],
                                "urw gothic l": [1.0029, 0.2407, 0],
                                "dingbats": [0.8424, 0.1605, 0],
                                "urw chancery l": [1.0029, 0.3209, 0],
                                "phetsarath ot": [1.0831, 0.5215, 0],
                                "tlwg typist": [0.8825, 0.4012, 0],
                                "kacstletter": [1.0831, 0.5215, 0],
                                "utkal": [1.2035, 0.6418, 0],
                                "dejavu sans light": [0.9628, 0.2407, 0],
                                "norasi": [1.2436, 0.5215, 0],
                                "dejavu serif condensed": [0.9628, 0.2407, 0],
                                "kacstone": [1.2436, 0.6418, 0],
                                "liberation sans narrow": [0.9628, 0.2407, 0],
                                "symbol": [1.043, 0.3209, 0],
                                "nanummyeongjo": [0.9227, 0.2407, 0],
                                "untitled1": [0.682, 0.5616, 0],
                                "lohit gujarati": [0.9628, 0.4012, 0],
                                "liberation mono": [0.8424, 0.3209, 0],
                                "kacstart": [1.0831, 0.5215, 0],
                                "mallige": [1.0029, 0.682, 0],
                                "bitstream charter": [1.0029, 0.2407, 0],
                                "nanumgothic": [0.9227, 0.2407, 0],
                                "liberation serif": [0.9227, 0.2407, 0],
                                "dejavu sans condensed": [0.9628, 0.2407, 0],
                                "ubuntu": [0.9628, 0.2006, 0],
                                "courier 10 pitch": [0.8825, 0.3209, 0],
                                "nimbus sans l": [0.9628, 0.3209, 0],
                                "takaopgothic": [0.8825, 0.2006, 0],
                                "wenquanyi micro hei mono": [0.9628, 0.2407, 0],
                                "dejavu sans": [0.9628, 0.2407, 0],
                                "kedage": [1.0029, 0.682, 0],
                                "kinnari": [1.3238, 0.5215, 0],
                                "tlwgmono": [0.8825, 0.4012, 0],
                                "standard symbols l": [1.043, 0.3209, 0],
                                "lohit punjabi": [1.2035, 0.682, 0],
                                "nimbus mono l": [0.8424, 0.2808, 0],
                                "rachana": [0.682, 0.5616, 0],
                                "waree": [1.2436, 0.4413, 0],
                                "kacstposter": [1.0831, 0.5215, 0],
                                "khmer os": [1.2837, 0.7622, 0],
                                "freesans": [1.0029, 0.3209, 0],
                                "gargi": [0.9628, 0.2808, 0],
                                "nimbus roman no9 l": [0.9628, 0.3209, 0],
                                "dejavu serif": [0.9628, 0.2407, 0],
                                "wenquanyi micro hei": [0.9628, 0.2407, 0],
                                "ubuntu light": [0.9628, 0.2006, 0],
                                "tlwgtypewriter": [0.9227, 0.4012, 0],
                                "kacstpen": [1.0831, 0.5215, 0],
                                "tlwg typo": [0.8825, 0.4012, 0],
                                "mukti narrow": [1.2837, 0.4413, 0],
                                "ubuntu mono": [0.8424, 0.2006, 0],
                                "lohit bengali": [1.0029, 0.4413, 0],
                                "liberation sans": [0.9227, 0.2407, 0],
                                "unbatang": [1.0029, 0.2808, 0],
                                "kacstdecorative": [1.1232, 0.5215, 0],
                                "khmer os system": [1.2436, 0.6017, 0],
                                "saab": [1.0029, 0.682, 0],
                                "kacsttitle": [1.0831, 0.5215, 0],
                                "mukti narrow bold": [1.2837, 0.4413, 0],
                                "lohit hindi": [1.0029, 0.5215, 0],
                                "kacstqurn": [1.0831, 0.5215, 0],
                                "urw bookman l": [0.9628, 0.2808, 0],
                                "kacstnaskh": [1.0831, 0.5215, 0],
                                "kacstscreen": [1.0831, 0.5215, 0],
                                "pothana2000": [0.8825, 0.8424, 0],
                                "ungraphic": [1.0029, 0.2808, 0],
                                "lohit tamil": [0.8825, 0.361, 0],
                                "kacstbook": [1.0831, 0.5215, 0]
                            };
                            Font.DEVICE_FONT_METRICS_MAC.__proto__ = Font.DEVICE_FONT_METRICS_WIN;
                            Font.DEVICE_FONT_METRICS_LINUX.__proto__ = Font.DEVICE_FONT_METRICS_MAC;
                        };

                        Font.classSymbols = null;
                        Font.instanceSymbols = null;

                        Font.initializer = function (symbol) {
                            var self = this;

                            self._id = flash.display.DisplayObject.getNextSyncID();

                            self._fontName = null;
                            self._fontStyle = null;
                            self._fontType = null;

                            self.ascent = 0;
                            self.descent = 0;
                            self.leading = 0;
                            self.advances = null;

                            if (symbol) {
                                self._symbol = symbol;
                                self._fontName = symbol.name;
                                if (symbol.bold) {
                                    if (symbol.italic) {
                                        self._fontStyle = FontStyle.BOLD_ITALIC;
                                    } else {
                                        self._fontStyle = FontStyle.BOLD;
                                    }
                                } else if (symbol.italic) {
                                    self._fontStyle = FontStyle.ITALIC;
                                } else {
                                    self._fontStyle = FontStyle.REGULAR;
                                }

                                var metrics = symbol.metrics;
                                if (metrics) {
                                    self.ascent = metrics.ascent;
                                    self.descent = metrics.descent;
                                    self.leading = metrics.leading;
                                    self.advances = metrics.advances;
                                }

                                // Font symbols without any glyphs describe device fonts.
                                self._fontType = symbol.data ? FontType.EMBEDDED : FontType.DEVICE;
                                Font._fontsBySymbolId[symbol.id] = self;
                                Font._fontsByName[symbol.name.toLowerCase()] = self;
                                Font._fontsByName['swffont' + symbol.id] = self;
                            }
                        };
                        return Font;
                    })(AS.ASNative);
                    text.Font = Font;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GridFitType
                (function (text) {
                    var GridFitType = (function (_super) {
                        __extends(GridFitType, _super);
                        function GridFitType() {
                            _super.call(this);
                        }
                        GridFitType.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return GridFitType.NONE;
                                case 1:
                                    return GridFitType.PIXEL;
                                case 2:
                                    return GridFitType.SUBPIXEL;
                                default:
                                    return null;
                            }
                        };

                        GridFitType.toNumber = function (value) {
                            switch (value) {
                                case GridFitType.NONE:
                                    return 0;
                                case GridFitType.PIXEL:
                                    return 1;
                                case GridFitType.SUBPIXEL:
                                    return 2;
                                default:
                                    return -1;
                            }
                        };
                        GridFitType.classInitializer = null;
                        GridFitType.initializer = null;
                        GridFitType.classSymbols = null;
                        GridFitType.instanceSymbolså = null;

                        GridFitType.NONE = "none";
                        GridFitType.PIXEL = "pixel";
                        GridFitType.SUBPIXEL = "subpixel";
                        return GridFitType;
                    })(AS.ASNative);
                    text.GridFitType = GridFitType;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: StaticText
                (function (text) {
                    var StaticText = (function (_super) {
                        __extends(StaticText, _super);
                        function StaticText() {
                            false && _super.call(this);
                            flash.display.DisplayObject.instanceConstructorNoInitialize.call(this);
                        }
                        StaticText.prototype._canHaveTextContent = function () {
                            return true;
                        };

                        StaticText.prototype._getTextContent = function () {
                            return this._textContent;
                        };

                        Object.defineProperty(StaticText.prototype, "text", {
                            get: function () {
                                return this._textContent.plainText;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        StaticText.classInitializer = null;
                        StaticText.classSymbols = null;
                        StaticText.instanceSymbols = null;

                        StaticText.initializer = function (symbol) {
                            var self = this;
                            self._textContent = null;
                            if (symbol) {
                                this._setStaticContentFromSymbol(symbol);
                            }
                        };
                        return StaticText;
                    })(flash.display.DisplayObject);
                    text.StaticText = StaticText;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: StyleSheet
                (function (text) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var StyleSheet = (function (_super) {
                        __extends(StyleSheet, _super);
                        function StyleSheet() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.text.StyleSheet");
                        }
                        StyleSheet.classInitializer = null;

                        StyleSheet.initializer = null;

                        StyleSheet.classSymbols = null;

                        StyleSheet.instanceSymbols = null;
                        return StyleSheet;
                    })(flash.events.EventDispatcher);
                    text.StyleSheet = StyleSheet;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextDisplayMode
                (function (text) {
                    var TextDisplayMode = (function (_super) {
                        __extends(TextDisplayMode, _super);
                        function TextDisplayMode() {
                            _super.call(this);
                        }
                        TextDisplayMode.classInitializer = null;
                        TextDisplayMode.initializer = null;
                        TextDisplayMode.classSymbols = null;
                        TextDisplayMode.instanceSymbolså = null;

                        TextDisplayMode.LCD = "lcd";
                        TextDisplayMode.CRT = "crt";
                        TextDisplayMode.DEFAULT = "default";
                        return TextDisplayMode;
                    })(AS.ASNative);
                    text.TextDisplayMode = TextDisplayMode;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextField
                (function (text) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;

                    var clamp = Shumway.NumberUtilities.clamp;

                    var DisplayObjectFlags = flash.display.DisplayObjectFlags;

                    var TextField = (function (_super) {
                        __extends(TextField, _super);
                        function TextField() {
                            _super.call(this);
                            notImplemented("Dummy Constructor: public flash.text.TextField");
                        }
                        TextField.prototype._setFillAndLineBoundsFromWidthAndHeight = function (width, height) {
                            _super.prototype._setFillAndLineBoundsFromWidthAndHeight.call(this, width, height);
                            this._textContent.bounds = this._lineBounds;
                            this._invalidateContent();
                        };

                        TextField.prototype._canHaveTextContent = function () {
                            return true;
                        };

                        TextField.prototype._getTextContent = function () {
                            return this._textContent;
                        };

                        TextField.prototype._getContentBounds = function (includeStrokes) {
                            if (typeof includeStrokes === "undefined") { includeStrokes = true; }
                            this._ensureLineMetrics();
                            return _super.prototype._getContentBounds.call(this, includeStrokes);
                        };

                        TextField.prototype._invalidateContent = function () {
                            if (this._textContent.flags & Shumway.TextContentFlags.Dirty) {
                                this._setFlags(8388608 /* DirtyTextContent */);
                            }
                        };

                        // JS -> AS Bindings
                        //selectedText: string;
                        //appendText: (newText: string) => void;
                        //getXMLText: (beginIndex: number /*int*/ = 0, endIndex: number /*int*/ = 2147483647) => string;
                        //insertXMLText: (beginIndex: number /*int*/, endIndex: number /*int*/, richText: string, pasting: boolean = false) => void;
                        //copyRichText: () => string;
                        //pasteRichText: (richText: string) => boolean;
                        // AS -> JS Bindings
                        TextField.isFontCompatible = function (fontName, fontStyle) {
                            fontName = asCoerceString(fontName);
                            fontStyle = asCoerceString(fontStyle);
                            somewhatImplemented("flash.text.TextField.isFontCompatible");
                            return true;
                        };

                        Object.defineProperty(TextField.prototype, "alwaysShowSelection", {
                            get: function () {
                                return this._alwaysShowSelection;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set alwaysShowSelection");
                                this._alwaysShowSelection = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "antiAliasType", {
                            get: function () {
                                return this._antiAliasType;
                            },
                            set: function (antiAliasType) {
                                somewhatImplemented("public flash.text.TextField::set antiAliasType");
                                antiAliasType = asCoerceString(antiAliasType);
                                if (text.AntiAliasType.toNumber(antiAliasType) < 0) {
                                    throwError("ArgumentError", AVM2.Errors.InvalidParamError, "antiAliasType");
                                }
                                this._antiAliasType = antiAliasType;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "autoSize", {
                            get: function () {
                                return this._autoSize;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                if (value === this._autoSize) {
                                    return;
                                }
                                if (text.TextFieldAutoSize.toNumber(value) < 0) {
                                    throwError("ArgumentError", AVM2.Errors.InvalidParamError, "autoSize");
                                }
                                this._autoSize = value;
                                this._textContent.autoSize = text.TextFieldAutoSize.toNumber(value);
                                this._invalidateContent();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "background", {
                            get: function () {
                                return this._background;
                            },
                            set: function (value) {
                                value = !!value;
                                if (value === this._background) {
                                    return;
                                }
                                this._background = value;
                                this._textContent.backgroundColor = value ? this._backgroundColor : 0;
                                this._setDirtyFlags(8388608 /* DirtyTextContent */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "backgroundColor", {
                            get: function () {
                                return this._backgroundColor >> 8;
                            },
                            set: function (value /*uint*/ ) {
                                value = ((value << 8) | 0xff) >>> 0;
                                if (value === this._backgroundColor) {
                                    return;
                                }
                                this._backgroundColor = value;
                                if (this._background) {
                                    this._textContent.backgroundColor = value;
                                    this._setDirtyFlags(8388608 /* DirtyTextContent */);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "border", {
                            get: function () {
                                return this._border;
                            },
                            set: function (value) {
                                value = !!value;
                                if (value === this._border) {
                                    return;
                                }
                                this._border = value;
                                this._textContent.borderColor = value ? this._borderColor : 0;
                                this._setDirtyFlags(8388608 /* DirtyTextContent */);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "borderColor", {
                            get: function () {
                                return this._borderColor >> 8;
                            },
                            set: function (value /*uint*/ ) {
                                value = ((value << 8) | 0xff) >>> 0;
                                if (value === this._borderColor) {
                                    return;
                                }
                                this._borderColor = value;
                                if (this._border) {
                                    this._textContent.borderColor = value;
                                    this._setDirtyFlags(8388608 /* DirtyTextContent */);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "bottomScrollV", {
                            get: function () {
                                notImplemented("public flash.text.TextField::get bottomScrollV");
                                return;
                                // return this._bottomScrollV;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, "caretIndex", {
                            get: function () {
                                notImplemented("public flash.text.TextField::get caretIndex");
                                return;
                                // return this._caretIndex;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "condenseWhite", {
                            get: function () {
                                somewhatImplemented("public flash.text.TextField::get condenseWhite");
                                return this._condenseWhite;
                            },
                            set: function (value) {
                                this._condenseWhite = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "defaultTextFormat", {
                            get: function () {
                                return this._textContent.defaultTextFormat.clone();
                            },
                            set: function (format) {
                                this._textContent.defaultTextFormat.merge(format);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "embedFonts", {
                            get: function () {
                                return this._embedFonts;
                            },
                            set: function (value) {
                                this._embedFonts = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "gridFitType", {
                            get: function () {
                                somewhatImplemented("public flash.text.TextField::get gridFitType");
                                return this._gridFitType;
                            },
                            set: function (gridFitType) {
                                gridFitType = asCoerceString(gridFitType);
                                release || assert(flash.text.GridFitType.toNumber(gridFitType) >= 0);
                                somewhatImplemented("public flash.text.TextField::set gridFitType");
                                this._gridFitType = gridFitType;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "htmlText", {
                            get: function () {
                                return this._htmlText;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set htmlText");
                                value = asCoerceString(value);

                                // Flash resets the bold and italic flags when an html value is set on a text field created from a symbol.
                                if (this._symbol) {
                                    this._textContent.defaultTextFormat.bold = false;
                                    this._textContent.defaultTextFormat.italic = false;
                                }
                                this._textContent.parseHtml(value, this._multiline);
                                this._htmlText = value;
                                this._invalidateContent();
                                this._ensureLineMetrics();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "length", {
                            get: function () {
                                return this._length;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "textInteractionMode", {
                            get: function () {
                                notImplemented("public flash.text.TextField::get textInteractionMode");
                                return;
                                // return this._textInteractionMode;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "maxChars", {
                            get: function () {
                                return this._maxChars;
                            },
                            set: function (value /*int*/ ) {
                                this._maxChars = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "maxScrollH", {
                            get: function () {
                                return this._maxScrollH;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "maxScrollV", {
                            get: function () {
                                return this._maxScrollV;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "mouseWheelEnabled", {
                            get: function () {
                                return this._mouseWheelEnabled;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set mouseWheelEnabled");
                                this._mouseWheelEnabled = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "multiline", {
                            get: function () {
                                return this._multiline;
                            },
                            set: function (value) {
                                this._multiline = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "numLines", {
                            get: function () {
                                return this._numLines;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "displayAsPassword", {
                            get: function () {
                                return this._displayAsPassword;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set displayAsPassword");
                                this._displayAsPassword = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "restrict", {
                            get: function () {
                                return this._restrict;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set restrict");
                                this._restrict = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "scrollH", {
                            get: function () {
                                somewhatImplemented("public flash.text.TextField::get scrollH");
                                return this._scrollH;
                            },
                            set: function (value /*int*/ ) {
                                value = value | 0;
                                somewhatImplemented("public flash.text.TextField::set scrollH");
                                this._scrollH = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, "scrollV", {
                            get: function () {
                                somewhatImplemented("public flash.text.TextField::get scrollV");
                                return this._scrollV;
                            },
                            set: function (value /*int*/ ) {
                                value = value | 0;
                                somewhatImplemented("public flash.text.TextField::set scrollV");
                                this._scrollV = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "selectable", {
                            get: function () {
                                return this._selectable;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set selectable");
                                this._selectable = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "selectionBeginIndex", {
                            get: function () {
                                return this._selectionBeginIndex;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "selectionEndIndex", {
                            get: function () {
                                return this._selectionEndIndex;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "sharpness", {
                            get: function () {
                                return this._sharpness;
                            },
                            set: function (value) {
                                this._sharpness = clamp(+value, -400, 400);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "styleSheet", {
                            get: function () {
                                notImplemented("public flash.text.TextField::get styleSheet");
                                return;
                                // return this._styleSheet;
                            },
                            set: function (value) {
                                value = value;
                                notImplemented("public flash.text.TextField::set styleSheet");
                                return;
                                // this._styleSheet = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "text", {
                            get: function () {
                                return this._textContent.plainText;
                            },
                            set: function (value) {
                                somewhatImplemented("public flash.text.TextField::set text");
                                this._textContent.plainText = asCoerceString(value);
                                this._invalidateContent();
                                this._ensureLineMetrics();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "textColor", {
                            get: function () {
                                return this._textColor < 0 ? +this._textContent.defaultTextFormat.color : this._textColor;
                            },
                            set: function (value /*uint*/ ) {
                                this._textColor = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "textHeight", {
                            get: function () {
                                this._ensureLineMetrics();
                                return (this._textHeight / 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "textWidth", {
                            get: function () {
                                this._ensureLineMetrics();
                                return (this._textWidth / 20) | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TextField.prototype, "thickness", {
                            get: function () {
                                return this._thickness;
                            },
                            set: function (value) {
                                this._thickness = clamp(+value, -200, 200);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "type", {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                this._type = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "wordWrap", {
                            get: function () {
                                return this._textContent.wordWrap;
                            },
                            set: function (value) {
                                value = !!value;
                                if (value === this._textContent.wordWrap) {
                                    return;
                                }
                                this._textContent.wordWrap = !!value;
                                this._invalidateContent();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextField.prototype, "useRichTextClipboard", {
                            get: function () {
                                notImplemented("public flash.text.TextField::get useRichTextClipboard");
                                return;
                                // return this._useRichTextClipboard;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.text.TextField::set useRichTextClipboard");
                                return;
                                // this._useRichTextClipboard = value;
                            },
                            enumerable: true,
                            configurable: true
                        });

                        TextField.prototype._ensureLineMetrics = function () {
                            if (!this._hasFlags(8388608 /* DirtyTextContent */)) {
                                return;
                            }
                            var serializer = Shumway.AVM2.Runtime.AVM2.instance.globals['Shumway.Player.Utils'];
                            var lineMetricsData = serializer.syncDisplayObject(this, false);
                            var textWidth = lineMetricsData.readInt();
                            var textHeight = lineMetricsData.readInt();
                            var offsetX = lineMetricsData.readInt();
                            if (this._autoSize !== text.TextFieldAutoSize.NONE) {
                                this._fillBounds.xMin = this._lineBounds.xMin = offsetX;
                                this._fillBounds.xMax = this._lineBounds.xMax = offsetX + textWidth + 80;
                                this._fillBounds.yMax = this._lineBounds.yMax = this._lineBounds.yMin + textHeight + 80;
                            }
                            this._textWidth = textWidth;
                            this._textHeight = textHeight;
                            this._numLines = lineMetricsData.readInt();
                            this._lineMetricsData = lineMetricsData;
                        };

                        TextField.prototype.getCharBoundaries = function (charIndex /*int*/ ) {
                            charIndex = charIndex | 0;
                            notImplemented("public flash.text.TextField::getCharBoundaries");
                            return;
                        };
                        TextField.prototype.getCharIndexAtPoint = function (x, y) {
                            x = +x;
                            y = +y;
                            notImplemented("public flash.text.TextField::getCharIndexAtPoint");
                            return;
                        };
                        TextField.prototype.getFirstCharInParagraph = function (charIndex /*int*/ ) {
                            charIndex = charIndex | 0;
                            notImplemented("public flash.text.TextField::getFirstCharInParagraph");
                            return;
                        };
                        TextField.prototype.getLineIndexAtPoint = function (x, y) {
                            x = +x;
                            y = +y;
                            notImplemented("public flash.text.TextField::getLineIndexAtPoint");
                            return;
                        };
                        TextField.prototype.getLineIndexOfChar = function (charIndex /*int*/ ) {
                            charIndex = charIndex | 0;
                            notImplemented("public flash.text.TextField::getLineIndexOfChar");
                            return;
                        };
                        TextField.prototype.getLineLength = function (lineIndex /*int*/ ) {
                            lineIndex = lineIndex | 0;
                            notImplemented("public flash.text.TextField::getLineLength");
                            return;
                        };

                        TextField.prototype.getLineMetrics = function (lineIndex /*int*/ ) {
                            lineIndex = lineIndex | 0;
                            if (lineIndex < 0 || lineIndex > this._numLines - 1) {
                                throwError('RangeError', AVM2.Errors.ParamRangeError);
                            }
                            this._ensureLineMetrics();
                            var lineMetricsData = this._lineMetricsData;
                            lineMetricsData.position = 12 + lineIndex * 20;
                            var x = lineMetricsData.readInt();
                            var width = lineMetricsData.readInt();
                            var ascent = lineMetricsData.readInt();
                            var descent = lineMetricsData.readInt();
                            var leading = lineMetricsData.readInt();
                            var height = ascent + descent + leading;
                            return new text.TextLineMetrics(x, width, height, ascent, descent, leading);
                        };

                        TextField.prototype.getLineOffset = function (lineIndex /*int*/ ) {
                            lineIndex = lineIndex | 0;
                            notImplemented("public flash.text.TextField::getLineOffset");
                            return;
                        };
                        TextField.prototype.getLineText = function (lineIndex /*int*/ ) {
                            lineIndex = lineIndex | 0;
                            notImplemented("public flash.text.TextField::getLineText");
                            return;
                        };
                        TextField.prototype.getParagraphLength = function (charIndex /*int*/ ) {
                            charIndex = charIndex | 0;
                            notImplemented("public flash.text.TextField::getParagraphLength");
                            return;
                        };
                        TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
                            if (typeof beginIndex === "undefined") { beginIndex = -1; }
                            if (typeof endIndex === "undefined") { endIndex = -1; }
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            notImplemented("public flash.text.TextField::getTextFormat");
                            return;
                        };

                        TextField.prototype.getTextRuns = function (beginIndex, endIndex) {
                            if (typeof beginIndex === "undefined") { beginIndex = 0; }
                            if (typeof endIndex === "undefined") { endIndex = 2147483647; }
                            var textRuns = this._textContent.textRuns;
                            var result = [];
                            for (var i = 0; i < textRuns.length; i++) {
                                var textRun = textRuns[i];
                                if (textRun.beginIndex >= beginIndex && textRun.endIndex <= endIndex) {
                                    result.push(textRun.clone());
                                }
                            }
                            return result;
                        };

                        TextField.prototype.getRawText = function () {
                            notImplemented("public flash.text.TextField::getRawText");
                            return;
                        };
                        TextField.prototype.replaceSelectedText = function (value) {
                            value = "" + value;
                            notImplemented("public flash.text.TextField::replaceSelectedText");
                            return;
                        };
                        TextField.prototype.replaceText = function (beginIndex /*int*/ , endIndex /*int*/ , newText) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            newText = "" + newText;
                            somewhatImplemented("public flash.text.TextField::replaceText");
                            var plainText = this._textContent.plainText;
                            this._textContent.plainText = plainText.substring(0, beginIndex) + newText + plainText.substring(endIndex);
                            this._invalidateContent();
                            this._ensureLineMetrics();
                        };
                        TextField.prototype.setSelection = function (beginIndex /*int*/ , endIndex /*int*/ ) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            notImplemented("public flash.text.TextField::setSelection");
                            return;
                        };
                        TextField.prototype.setTextFormat = function (format, beginIndex, endIndex) {
                            if (typeof beginIndex === "undefined") { beginIndex = -1; }
                            if (typeof endIndex === "undefined") { endIndex = -1; }
                            format = format;
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            somewhatImplemented("public flash.text.TextField::setTextFormat");
                            return;
                        };
                        TextField.prototype.getImageReference = function (id) {
                            id = "" + id;
                            notImplemented("public flash.text.TextField::getImageReference");
                            return;
                        };
                        TextField.classSymbols = null;
                        TextField.instanceSymbols = null;

                        TextField.classInitializer = null;

                        TextField.initializer = function (symbol) {
                            var self = this;

                            self._alwaysShowSelection = false;
                            self._antiAliasType = text.AntiAliasType.NORMAL;
                            self._autoSize = text.TextFieldAutoSize.NONE;
                            self._background = false;
                            self._backgroundColor = 0xffffffff;
                            self._border = false;
                            self._borderColor = 0x000000ff;
                            self._bottomScrollV = 1;
                            self._caretIndex = 0;
                            self._condenseWhite = false;
                            self._embedFonts = false;
                            self._gridFitType = text.GridFitType.PIXEL;
                            self._htmlText = '';
                            self._length = 0;
                            self._textInteractionMode = text.TextInteractionMode.NORMAL;
                            self._maxChars = 0;
                            self._maxScrollH = 0;
                            self._maxScrollV = 1;
                            self._mouseWheelEnabled = false;
                            self._multiline = false;
                            self._numLines = 1;
                            self._displayAsPassword = false;
                            self._restrict = null;
                            self._scrollH = 0;
                            self._scrollV = 1;
                            self._selectable = true;
                            self._selectedText = '';
                            self._selectionBeginIndex = 0;
                            self._selectionEndIndex = 0;
                            self._sharpness = 0;
                            self._styleSheet = null;
                            self._textColor = -1;
                            self._textHeight = 0;
                            self._textWidth = 0;
                            self._thickness = 0;
                            self._type = text.TextFieldType.DYNAMIC;
                            self._useRichTextClipboard = false;

                            var defaultTextFormat = new flash.text.TextFormat('Times Roman', 12, 0, false, false, false, '', '', text.TextFormatAlign.LEFT);
                            self._textContent = new Shumway.TextContent(defaultTextFormat);
                            self._lineMetricsData = null;

                            if (symbol) {
                                self._setFillAndLineBoundsFromSymbol(symbol);
                                self._textContent.bounds = this._lineBounds;

                                defaultTextFormat.color = symbol.color;
                                defaultTextFormat.size = (symbol.size / 20) | 0;
                                defaultTextFormat.font = symbol.font;
                                defaultTextFormat.align = symbol.align;
                                defaultTextFormat.leftMargin = (symbol.leftMargin / 20) | 0;
                                defaultTextFormat.rightMargin = (symbol.rightMargin / 20) | 0;
                                defaultTextFormat.indent = (symbol.indent / 20) | 0;
                                defaultTextFormat.leading = (symbol.leading / 20) | 0;

                                self._multiline = symbol.multiline;
                                self._embedFonts = symbol.embedFonts;
                                self._selectable = symbol.selectable;
                                self._displayAsPassword = symbol.displayAsPassword;
                                self._type = symbol.type;
                                self._maxChars = symbol.maxChars;

                                if (symbol.border) {
                                    self.background = true;
                                    self.border = true;
                                }
                                if (symbol.html) {
                                    self.htmlText = symbol.initialText;
                                } else {
                                    self.text = symbol.initialText;
                                }
                                self.wordWrap = symbol.wordWrap;
                                self.autoSize = symbol.autoSize;
                            } else {
                                self._setFillAndLineBoundsFromWidthAndHeight(100 * 20, 100 * 20);
                            }
                        };
                        return TextField;
                    })(flash.display.InteractiveObject);
                    text.TextField = TextField;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextFieldAutoSize
                (function (text) {
                    var TextFieldAutoSize = (function (_super) {
                        __extends(TextFieldAutoSize, _super);
                        function TextFieldAutoSize() {
                            _super.call(this);
                        }
                        TextFieldAutoSize.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return TextFieldAutoSize.NONE;
                                case 1:
                                    return TextFieldAutoSize.CENTER;
                                case 2:
                                    return TextFieldAutoSize.LEFT;
                                case 3:
                                    return TextFieldAutoSize.RIGHT;
                                default:
                                    return null;
                            }
                        };

                        TextFieldAutoSize.toNumber = function (value) {
                            switch (value) {
                                case TextFieldAutoSize.NONE:
                                    return 0;
                                case TextFieldAutoSize.CENTER:
                                    return 1;
                                case TextFieldAutoSize.LEFT:
                                    return 2;
                                case TextFieldAutoSize.RIGHT:
                                    return 3;
                                default:
                                    return -1;
                            }
                        };
                        TextFieldAutoSize.classInitializer = null;
                        TextFieldAutoSize.initializer = null;
                        TextFieldAutoSize.classSymbols = null;
                        TextFieldAutoSize.instanceSymbols = null;

                        TextFieldAutoSize.NONE = "none";
                        TextFieldAutoSize.LEFT = "left";
                        TextFieldAutoSize.CENTER = "center";
                        TextFieldAutoSize.RIGHT = "right";
                        return TextFieldAutoSize;
                    })(AS.ASNative);
                    text.TextFieldAutoSize = TextFieldAutoSize;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextFieldType
                (function (text) {
                    var TextFieldType = (function (_super) {
                        __extends(TextFieldType, _super);
                        function TextFieldType() {
                            _super.call(this);
                        }
                        TextFieldType.classInitializer = null;
                        TextFieldType.initializer = null;
                        TextFieldType.classSymbols = null;
                        TextFieldType.instanceSymbols = null;

                        TextFieldType.INPUT = "input";
                        TextFieldType.DYNAMIC = "dynamic";
                        return TextFieldType;
                    })(AS.ASNative);
                    text.TextFieldType = TextFieldType;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextFormat
                (function (_text) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var roundHalfEven = Shumway.NumberUtilities.roundHalfEven;

                    var throwError = Shumway.AVM2.Runtime.throwError;

                    var TextFormat = (function (_super) {
                        __extends(TextFormat, _super);
                        function TextFormat(font, size, color, bold, italic, underline, url, target, align, leftMargin, rightMargin, indent, leading) {
                            if (typeof font === "undefined") { font = null; }
                            if (typeof size === "undefined") { size = null; }
                            if (typeof color === "undefined") { color = null; }
                            if (typeof bold === "undefined") { bold = null; }
                            if (typeof italic === "undefined") { italic = null; }
                            if (typeof underline === "undefined") { underline = null; }
                            if (typeof url === "undefined") { url = null; }
                            if (typeof target === "undefined") { target = null; }
                            if (typeof align === "undefined") { align = null; }
                            if (typeof leftMargin === "undefined") { leftMargin = null; }
                            if (typeof rightMargin === "undefined") { rightMargin = null; }
                            if (typeof indent === "undefined") { indent = null; }
                            if (typeof leading === "undefined") { leading = null; }
                            false && _super.call(this);
                            this.font = font;
                            this.size = size;
                            this.color = color;
                            this.bold = bold;
                            this.italic = italic;
                            this.underline = underline;
                            this.url = url;
                            this.target = target;
                            this.align = align;
                            this.leftMargin = leftMargin;
                            this.rightMargin = rightMargin;
                            this.indent = indent;
                            this.leading = leading;
                        }
                        TextFormat.prototype.as2GetTextExtent = function (text, width /* optional */ ) {
                            if (!TextFormat.measureTextField) {
                                TextFormat.measureTextField = new flash.text.TextField();
                                TextFormat.measureTextField._multiline = true;
                            }
                            var measureTextField = TextFormat.measureTextField;
                            if (!isNaN(width) && width > 0) {
                                measureTextField.width = width + 4;
                                measureTextField._wordWrap = true;
                            } else {
                                measureTextField._wordWrap = false;
                            }
                            measureTextField.defaultTextFormat = this;
                            measureTextField.text = text;
                            var result = {};
                            var textWidth = measureTextField.textWidth;
                            var textHeight = measureTextField.textHeight;
                            result.asSetPublicProperty('width', textWidth);
                            result.asSetPublicProperty('height', textHeight);
                            result.asSetPublicProperty('textFieldWidth', textWidth + 4);
                            result.asSetPublicProperty('textFieldHeight', textHeight + 4);
                            var metrics = measureTextField.getLineMetrics(0);
                            result.asSetPublicProperty('ascent', metrics.ascent);
                            result.asSetPublicProperty('descent', metrics.descent);
                            return result;
                        };

                        Object.defineProperty(TextFormat.prototype, "align", {
                            // AS -> JS Bindings
                            get: function () {
                                return this._align;
                            },
                            set: function (value) {
                                value = asCoerceString(value);

                                //if (TextFormatAlign.toNumber(value) < 0) {
                                //  throwError("ArgumentError", Errors.InvalidEnumError, "align");
                                //}
                                this._align = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "blockIndent", {
                            get: function () {
                                return this._blockIndent;
                            },
                            set: function (value) {
                                this._blockIndent = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "bold", {
                            get: function () {
                                return this._bold;
                            },
                            set: function (value) {
                                this._bold = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "bullet", {
                            get: function () {
                                return this._bullet;
                            },
                            set: function (value) {
                                this._bullet = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "color", {
                            get: function () {
                                return this._color;
                            },
                            set: function (value) {
                                this._color = +value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "display", {
                            get: function () {
                                return this._display;
                            },
                            set: function (value) {
                                this._display = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "font", {
                            get: function () {
                                return this._font;
                            },
                            set: function (value) {
                                this._font = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "indent", {
                            get: function () {
                                return this._indent;
                            },
                            set: function (value) {
                                this._indent = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "italic", {
                            get: function () {
                                return this._italic;
                            },
                            set: function (value) {
                                this._italic = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "kerning", {
                            get: function () {
                                return this._kerning;
                            },
                            set: function (value) {
                                this._kerning = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "leading", {
                            get: function () {
                                return this._leading;
                            },
                            set: function (value) {
                                this._leading = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "leftMargin", {
                            get: function () {
                                return this._leftMargin;
                            },
                            set: function (value) {
                                this._leftMargin = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "letterSpacing", {
                            get: function () {
                                return this._letterSpacing;
                            },
                            set: function (value) {
                                this._letterSpacing = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "rightMargin", {
                            get: function () {
                                return this._rightMargin;
                            },
                            set: function (value) {
                                this._rightMargin = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "size", {
                            get: function () {
                                return this._size;
                            },
                            set: function (value) {
                                this._size = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "tabStops", {
                            get: function () {
                                return this._tabStops;
                            },
                            set: function (value) {
                                if (!(value instanceof Array)) {
                                    throwError("ArgumentError", AVM2.Errors.CheckTypeFailedError, value, 'Array');
                                }
                                this._tabStops = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "target", {
                            get: function () {
                                return this._target;
                            },
                            set: function (value) {
                                this._target = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "underline", {
                            get: function () {
                                return this._underline;
                            },
                            set: function (value) {
                                this._underline = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextFormat.prototype, "url", {
                            get: function () {
                                return this._url;
                            },
                            set: function (value) {
                                this._url = asCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });


                        /**
                        * All integer values on TextFormat are typed as Object and coerced to ints using the following
                        * "algorithm":
                        * - if the supplied value is null or undefined, the field is set to null
                        * - else if coercing to number results in NaN or the value is greater than MAX_INT, set to
                        *   -0x80000000
                        * - else, round the coerced value using half-even rounding
                        */
                        TextFormat.coerceNumber = function (value) {
                            /* tslint:disable */
                            if (value == undefined) {
                                return null;
                            }

                            /* tslint:enable */
                            if (isNaN(value) || value > 0xfffffff) {
                                return -0x80000000;
                            }
                            return roundHalfEven(value);
                        };

                        /**
                        * Boolean values are only stored as bools if they're not undefined or null. In that case,
                        * they're stored as null.
                        */
                        TextFormat.coerceBoolean = function (value) {
                            /* tslint:disable */
                            return value == undefined ? null : !!value;
                            /* tslint:enable */
                        };

                        TextFormat.prototype.clone = function () {
                            return new flash.text.TextFormat(this.font, this.size, this.color, this.bold, this.italic, this.underline, this.url, this.target, this.align, this.leftMargin, this.rightMargin, this.indent, this.leading);
                        };

                        TextFormat.prototype.equals = function (other) {
                            return this._align === other._align && this._blockIndent === other._blockIndent && this._bold === other._bold && this._bullet === other._bullet && this._color === other._color && this._display === other._display && this._font === other._font && this._indent === other._indent && this._italic === other._italic && this._kerning === other._kerning && this._leading === other._leading && this._leftMargin === other._leftMargin && this._letterSpacing === other._letterSpacing && this._rightMargin === other._rightMargin && this._size === other._size && this._tabStops === other._tabStops && this._target === other._target && this._underline === other._underline && this._url === other._url;
                        };

                        TextFormat.prototype.merge = function (other) {
                            if (other._align !== null) {
                                this._align = other._align;
                            }
                            if (other._blockIndent !== null) {
                                this._blockIndent = other._blockIndent;
                            }
                            if (other._bold !== null) {
                                this._bold = other._bold;
                            }
                            if (other._bullet !== null) {
                                this._bullet = other._bullet;
                            }
                            if (other._color !== null) {
                                this._color = other._color;
                            }
                            if (other._display !== null) {
                                this._display = other._display;
                            }
                            if (other._font !== null) {
                                this._font = other._font;
                            }
                            if (other._indent !== null) {
                                this._indent = other._indent;
                            }
                            if (other._italic !== null) {
                                this._italic = other._italic;
                            }
                            if (other._kerning !== null) {
                                this._kerning = other._kerning;
                            }
                            if (other._leading !== null) {
                                this._leading = other._leading;
                            }
                            if (other._leftMargin !== null) {
                                this._leftMargin = other._leftMargin;
                            }
                            if (other._letterSpacing !== null) {
                                this._letterSpacing = other._letterSpacing;
                            }
                            if (other._rightMargin !== null) {
                                this._rightMargin = other._rightMargin;
                            }
                            if (other._size !== null) {
                                this._size = other._size;
                            }
                            if (other._tabStops !== null) {
                                this._tabStops = other._tabStops;
                            }
                            if (other._target !== null) {
                                this._target = other._target;
                            }
                            if (other._underline !== null) {
                                this._underline = other._underline;
                            }
                            if (other._url !== null) {
                                this._url = other._url;
                            }
                        };
                        TextFormat.classInitializer = null;
                        TextFormat.initializer = null;
                        TextFormat.classSymbols = null;
                        TextFormat.instanceSymbols = null;
                        return TextFormat;
                    })(AS.ASNative);
                    _text.TextFormat = TextFormat;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextFormatAlign
                (function (text) {
                    var TextFormatAlign = (function (_super) {
                        __extends(TextFormatAlign, _super);
                        function TextFormatAlign() {
                            _super.call(this);
                        }
                        TextFormatAlign.fromNumber = function (n) {
                            switch (n) {
                                case 0:
                                    return TextFormatAlign.LEFT;
                                case 1:
                                    return TextFormatAlign.RIGHT;
                                case 2:
                                    return TextFormatAlign.CENTER;
                                case 3:
                                    return TextFormatAlign.JUSTIFY;
                                case 4:
                                    return TextFormatAlign.START;
                                case 5:
                                    return TextFormatAlign.END;
                                default:
                                    return null;
                            }
                        };

                        TextFormatAlign.toNumber = function (value) {
                            switch (value) {
                                case TextFormatAlign.LEFT:
                                    return 0;
                                case TextFormatAlign.RIGHT:
                                    return 1;
                                case TextFormatAlign.CENTER:
                                    return 2;
                                case TextFormatAlign.JUSTIFY:
                                    return 3;
                                case TextFormatAlign.START:
                                    return 4;
                                case TextFormatAlign.END:
                                    return 5;
                                default:
                                    return -1;
                            }
                        };
                        TextFormatAlign.classInitializer = null;
                        TextFormatAlign.initializer = null;
                        TextFormatAlign.classSymbols = null;
                        TextFormatAlign.instanceSymbols = null;

                        TextFormatAlign.LEFT = "left";
                        TextFormatAlign.CENTER = "center";
                        TextFormatAlign.RIGHT = "right";
                        TextFormatAlign.JUSTIFY = "justify";
                        TextFormatAlign.START = "start";
                        TextFormatAlign.END = "end";
                        return TextFormatAlign;
                    })(AS.ASNative);
                    text.TextFormatAlign = TextFormatAlign;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextFormatDisplay
                (function (text) {
                    var TextFormatDisplay = (function (_super) {
                        __extends(TextFormatDisplay, _super);
                        function TextFormatDisplay() {
                            _super.call(this);
                        }
                        TextFormatDisplay.classInitializer = null;
                        TextFormatDisplay.initializer = null;
                        TextFormatDisplay.classSymbols = null;
                        TextFormatDisplay.instanceSymbols = null;

                        TextFormatDisplay.INLINE = "inline";
                        TextFormatDisplay.BLOCK = "block";
                        return TextFormatDisplay;
                    })(AS.ASNative);
                    text.TextFormatDisplay = TextFormatDisplay;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextInteractionMode
                (function (text) {
                    var TextInteractionMode = (function (_super) {
                        __extends(TextInteractionMode, _super);
                        function TextInteractionMode() {
                            _super.call(this);
                        }
                        TextInteractionMode.classInitializer = null;
                        TextInteractionMode.initializer = null;
                        TextInteractionMode.classSymbols = null;
                        TextInteractionMode.instanceSymbols = null;

                        TextInteractionMode.NORMAL = "normal";
                        TextInteractionMode.SELECTION = "selection";
                        return TextInteractionMode;
                    })(AS.ASNative);
                    text.TextInteractionMode = TextInteractionMode;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextLineMetrics
                (function (text) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var TextLineMetrics = (function (_super) {
                        __extends(TextLineMetrics, _super);
                        function TextLineMetrics(x, width, height, ascent, descent, leading) {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.text.TextLineMetrics");
                            x = +x;
                            width = +width;
                            height = +height;
                            ascent = +ascent;
                            descent = +descent;
                            leading = +leading;
                        }
                        TextLineMetrics.classInitializer = null;
                        TextLineMetrics.initializer = null;
                        TextLineMetrics.classSymbols = null;
                        TextLineMetrics.instanceSymbolså = null;
                        return TextLineMetrics;
                    })(AS.ASNative);
                    text.TextLineMetrics = TextLineMetrics;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextRun
                (function (text) {
                    var TextRun = (function (_super) {
                        __extends(TextRun, _super);
                        function TextRun(beginIndex /*int*/ , endIndex /*int*/ , textFormat) {
                            false && _super.call(this);
                            this._beginIndex = beginIndex | 0;
                            this._endIndex = endIndex | 0;
                            this._textFormat = textFormat;
                        }
                        Object.defineProperty(TextRun.prototype, "beginIndex", {
                            // AS -> JS Bindings
                            get: function () {
                                return this._beginIndex;
                            },
                            set: function (value) {
                                this._beginIndex = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextRun.prototype, "endIndex", {
                            get: function () {
                                return this._endIndex;
                            },
                            set: function (value) {
                                this._endIndex = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TextRun.prototype, "textFormat", {
                            get: function () {
                                return this._textFormat;
                            },
                            set: function (value) {
                                this._textFormat = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        TextRun.prototype.clone = function () {
                            return new flash.text.TextRun(this.beginIndex, this.endIndex, this.textFormat);
                        };
                        TextRun.classInitializer = null;
                        TextRun.initializer = null;
                        TextRun.classSymbols = null;
                        TextRun.instanceSymbols = null;
                        return TextRun;
                    })(AS.ASNative);
                    text.TextRun = TextRun;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: TextSnapshot
                (function (text) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var TextSnapshot = (function (_super) {
                        __extends(TextSnapshot, _super);
                        function TextSnapshot() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.text.TextSnapshot");
                        }
                        Object.defineProperty(TextSnapshot.prototype, "charCount", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _charCount: number /*int*/;
                            get: function () {
                                notImplemented("public flash.text.TextSnapshot::get charCount");
                                return;
                                // return this._charCount;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TextSnapshot.prototype.findText = function (beginIndex /*int*/ , textToFind, caseSensitive) {
                            beginIndex = beginIndex | 0;
                            textToFind = asCoerceString(textToFind);
                            caseSensitive = !!caseSensitive;
                            notImplemented("public flash.text.TextSnapshot::findText");
                            return;
                        };
                        TextSnapshot.prototype.getSelected = function (beginIndex /*int*/ , endIndex /*int*/ ) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            notImplemented("public flash.text.TextSnapshot::getSelected");
                            return;
                        };
                        TextSnapshot.prototype.getSelectedText = function (includeLineEndings) {
                            if (typeof includeLineEndings === "undefined") { includeLineEndings = false; }
                            includeLineEndings = !!includeLineEndings;
                            notImplemented("public flash.text.TextSnapshot::getSelectedText");
                            return;
                        };
                        TextSnapshot.prototype.getText = function (beginIndex /*int*/ , endIndex /*int*/ , includeLineEndings) {
                            if (typeof includeLineEndings === "undefined") { includeLineEndings = false; }
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            includeLineEndings = !!includeLineEndings;
                            notImplemented("public flash.text.TextSnapshot::getText");
                            return;
                        };
                        TextSnapshot.prototype.getTextRunInfo = function (beginIndex /*int*/ , endIndex /*int*/ ) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            notImplemented("public flash.text.TextSnapshot::getTextRunInfo");
                            return;
                        };
                        TextSnapshot.prototype.hitTestTextNearPos = function (x, y, maxDistance) {
                            if (typeof maxDistance === "undefined") { maxDistance = 0; }
                            x = +x;
                            y = +y;
                            maxDistance = +maxDistance;
                            notImplemented("public flash.text.TextSnapshot::hitTestTextNearPos");
                            return;
                        };
                        TextSnapshot.prototype.setSelectColor = function (hexColor) {
                            if (typeof hexColor === "undefined") { hexColor = 16776960; }
                            hexColor = hexColor >>> 0;
                            notImplemented("public flash.text.TextSnapshot::setSelectColor");
                            return;
                        };
                        TextSnapshot.prototype.setSelected = function (beginIndex /*int*/ , endIndex /*int*/ , select) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            select = !!select;
                            notImplemented("public flash.text.TextSnapshot::setSelected");
                            return;
                        };
                        TextSnapshot.classInitializer = null;

                        TextSnapshot.initializer = null;

                        TextSnapshot.classSymbols = null;

                        TextSnapshot.instanceSymbols = null;
                        return TextSnapshot;
                    })(AS.ASNative);
                    text.TextSnapshot = TextSnapshot;
                })(flash.text || (flash.text = {}));
                var text = flash.text;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Trace
                (function (trace) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Trace = (function (_super) {
                        __extends(Trace, _super);
                        function Trace() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.trace.Trace");
                        }
                        // AS -> JS Bindings
                        Trace.setLevel = function (l /*int*/ , target) {
                            if (typeof target === "undefined") { target = 2; }
                            l = l | 0;
                            target = target | 0;
                            notImplemented("public flash.trace.Trace::static setLevel");
                            return;
                        };
                        Trace.getLevel = function (target) {
                            if (typeof target === "undefined") { target = 2; }
                            target = target | 0;
                            notImplemented("public flash.trace.Trace::static getLevel");
                            return;
                        };
                        Trace.setListener = function (f) {
                            f = f;
                            notImplemented("public flash.trace.Trace::static setListener");
                            return;
                        };
                        Trace.getListener = function () {
                            notImplemented("public flash.trace.Trace::static getListener");
                            return;
                        };
                        Trace.classInitializer = null;

                        Trace.initializer = null;

                        Trace.classSymbols = null;

                        Trace.instanceSymbols = null;

                        Trace.OFF = undefined;
                        Trace.METHODS = 1;
                        Trace.METHODS_WITH_ARGS = 2;
                        Trace.METHODS_AND_LINES = 3;
                        Trace.METHODS_AND_LINES_WITH_ARGS = 4;
                        Trace.FILE = 1;
                        Trace.LISTENER = 2;
                        return Trace;
                    })(AS.ASNative);
                    trace.Trace = Trace;
                })(flash.trace || (flash.trace = {}));
                var trace = flash.trace;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ContextMenu
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var ContextMenu = (function (_super) {
                        __extends(ContextMenu, _super);
                        function ContextMenu() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.ContextMenu");
                        }
                        Object.defineProperty(ContextMenu.prototype, "builtInItems", {
                            // _link: flash.net.URLRequest;
                            // _clipboardMenu: boolean;
                            // _clipboardItems: flash.ui.ContextMenuClipboardItems;
                            get: function () {
                                // TODO: Should clone here probably.
                                somewhatImplemented("public flash.ui.ContextMenu::get builtInItems");
                                return this._builtInItems;
                            },
                            set: function (value) {
                                // TODO: Should clone here probably.
                                value = value;
                                somewhatImplemented("public flash.ui.ContextMenu::set builtInItems");
                                this._builtInItems = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, "customItems", {
                            get: function () {
                                // TODO: Should clone here probably.
                                somewhatImplemented("public flash.ui.ContextMenu::get customItems");
                                return this._customItems;
                            },
                            set: function (value) {
                                // TODO: Should clone here probably.
                                value = value;
                                somewhatImplemented("public flash.ui.ContextMenu::set customItems");
                                this._customItems = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, "link", {
                            get: function () {
                                notImplemented("public flash.ui.ContextMenu::get link");
                                return;
                                // return this._link;
                            },
                            set: function (value) {
                                value = value;
                                notImplemented("public flash.ui.ContextMenu::set link");
                                return;
                                // this._link = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, "clipboardMenu", {
                            get: function () {
                                notImplemented("public flash.ui.ContextMenu::get clipboardMenu");
                                return;
                                // return this._clipboardMenu;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.ui.ContextMenu::set clipboardMenu");
                                return;
                                // this._clipboardMenu = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, "clipboardItems", {
                            get: function () {
                                notImplemented("public flash.ui.ContextMenu::get clipboardItems");
                                return;
                                // return this._clipboardItems;
                            },
                            set: function (value) {
                                value = value;
                                notImplemented("public flash.ui.ContextMenu::set clipboardItems");
                                return;
                                // this._clipboardItems = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ContextMenu.prototype.cloneLinkAndClipboardProperties = function (c) {
                            c = c;
                            notImplemented("public flash.ui.ContextMenu::cloneLinkAndClipboardProperties");
                            return;
                        };
                        ContextMenu.classInitializer = null;

                        ContextMenu.initializer = null;

                        ContextMenu.classSymbols = null;

                        ContextMenu.instanceSymbols = null;
                        return ContextMenu;
                    })(flash.display.NativeMenu);
                    ui.ContextMenu = ContextMenu;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ContextMenuBuiltInItems
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ContextMenuBuiltInItems = (function (_super) {
                        __extends(ContextMenuBuiltInItems, _super);
                        function ContextMenuBuiltInItems() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.ContextMenuBuiltInItems");
                        }
                        ContextMenuBuiltInItems.classInitializer = null;

                        ContextMenuBuiltInItems.initializer = null;

                        ContextMenuBuiltInItems.classSymbols = null;

                        ContextMenuBuiltInItems.instanceSymbols = null;
                        return ContextMenuBuiltInItems;
                    })(AS.ASNative);
                    ui.ContextMenuBuiltInItems = ContextMenuBuiltInItems;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ContextMenuClipboardItems
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var ContextMenuClipboardItems = (function (_super) {
                        __extends(ContextMenuClipboardItems, _super);
                        function ContextMenuClipboardItems() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.ContextMenuClipboardItems");
                        }
                        ContextMenuClipboardItems.classInitializer = null;

                        ContextMenuClipboardItems.initializer = null;

                        ContextMenuClipboardItems.classSymbols = null;

                        ContextMenuClipboardItems.instanceSymbols = null;
                        return ContextMenuClipboardItems;
                    })(AS.ASNative);
                    ui.ContextMenuClipboardItems = ContextMenuClipboardItems;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ContextMenuItem
                (function (ui) {
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var ContextMenuItem = (function (_super) {
                        __extends(ContextMenuItem, _super);
                        function ContextMenuItem(caption, separatorBefore, enabled, visible) {
                            if (typeof separatorBefore === "undefined") { separatorBefore = false; }
                            if (typeof enabled === "undefined") { enabled = true; }
                            if (typeof visible === "undefined") { visible = true; }
                            false && _super.call(this);
                            caption = asCoerceString(caption);
                            separatorBefore = !!separatorBefore;
                            enabled = !!enabled;
                            visible = !!visible;
                            this._caption = caption ? caption : "";
                            this._separatorBefore = separatorBefore;
                            this._enabled = enabled;
                            this._visible = visible;
                        }
                        Object.defineProperty(ContextMenuItem.prototype, "caption", {
                            get: function () {
                                return this._caption;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                this._caption = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuItem.prototype, "separatorBefore", {
                            get: function () {
                                return this._separatorBefore;
                            },
                            set: function (value) {
                                value = !!value;
                                this._separatorBefore = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuItem.prototype, "visible", {
                            get: function () {
                                return this._visible;
                            },
                            set: function (value) {
                                value = !!value;
                                this._visible = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ContextMenuItem.classInitializer = null;

                        ContextMenuItem.initializer = null;

                        ContextMenuItem.classSymbols = null;

                        ContextMenuItem.instanceSymbols = null;
                        return ContextMenuItem;
                    })(flash.display.NativeMenuItem);
                    ui.ContextMenuItem = ContextMenuItem;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInput
                (function (ui) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var throwError = Shumway.AVM2.Runtime.throwError;
                    var GameInput = (function (_super) {
                        __extends(GameInput, _super);
                        function GameInput() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.ui.GameInput");
                        }
                        Object.defineProperty(GameInput.prototype, "numDevices", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _numDevices: number /*int*/;
                            // static _isSupported: boolean;
                            get: function () {
                                somewhatImplemented("public flash.ui.GameInput::get numDevices");
                                return 0;
                                // return this._numDevices;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInput.prototype, "isSupported", {
                            get: function () {
                                somewhatImplemented("public flash.ui.GameInput::get isSupported");
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GameInput.getDeviceAt = function (index /*int*/ ) {
                            index = index | 0;

                            somewhatImplemented("public flash.ui.GameInput::static getDeviceAt");
                            throwError("RangeError", AVM2.Errors.ParamRangeError, "index");
                            return null;
                        };
                        GameInput.classInitializer = null;

                        GameInput.initializer = null;

                        GameInput.classSymbols = null;

                        GameInput.instanceSymbols = null;
                        return GameInput;
                    })(flash.events.EventDispatcher);
                    ui.GameInput = GameInput;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInputControl
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GameInputControl = (function (_super) {
                        __extends(GameInputControl, _super);
                        function GameInputControl() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.ui.GameInputControl");
                        }
                        Object.defineProperty(GameInputControl.prototype, "numValues", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _numValues: number /*int*/;
                            // _index: number /*int*/;
                            // _relative: boolean;
                            // _type: string;
                            // _hand: string;
                            // _finger: string;
                            // _device: flash.ui.GameInputDevice;
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get numValues");
                                return;
                                // return this._numValues;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, "index", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get index");
                                return;
                                // return this._index;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, "relative", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get relative");
                                return;
                                // return this._relative;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, "type", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get type");
                                return;
                                // return this._type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, "hand", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get hand");
                                return;
                                // return this._hand;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, "finger", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get finger");
                                return;
                                // return this._finger;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, "device", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputControl::get device");
                                return;
                                // return this._device;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GameInputControl.prototype.getValueAt = function (index) {
                            if (typeof index === "undefined") { index = 0; }
                            index = index | 0;
                            notImplemented("public flash.ui.GameInputControl::getValueAt");
                            return;
                        };
                        GameInputControl.classInitializer = null;

                        GameInputControl.initializer = null;

                        GameInputControl.classSymbols = null;

                        GameInputControl.instanceSymbols = null;
                        return GameInputControl;
                    })(flash.events.EventDispatcher);
                    ui.GameInputControl = GameInputControl;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInputControlType
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GameInputControlType = (function (_super) {
                        __extends(GameInputControlType, _super);
                        function GameInputControlType() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.GameInputControlType");
                        }
                        GameInputControlType.classInitializer = null;

                        GameInputControlType.initializer = null;

                        GameInputControlType.classSymbols = null;

                        GameInputControlType.instanceSymbols = null;

                        GameInputControlType.MOVEMENT = "movement";
                        GameInputControlType.ROTATION = "rotation";
                        GameInputControlType.DIRECTION = "direction";
                        GameInputControlType.ACCELERATION = "acceleration";
                        GameInputControlType.BUTTON = "button";
                        GameInputControlType.TRIGGER = "trigger";
                        return GameInputControlType;
                    })(AS.ASNative);
                    ui.GameInputControlType = GameInputControlType;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInputDevice
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GameInputDevice = (function (_super) {
                        __extends(GameInputDevice, _super);
                        function GameInputDevice() {
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.ui.GameInputDevice");
                        }
                        Object.defineProperty(GameInputDevice.prototype, "numControls", {
                            // AS -> JS Bindings
                            // _numControls: number /*int*/;
                            // _sampleInterval: number /*int*/;
                            // _enabled: boolean;
                            // _id: string;
                            // _name: string;
                            get: function () {
                                notImplemented("public flash.ui.GameInputDevice::get numControls");
                                return;
                                // return this._numControls;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, "sampleInterval", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputDevice::get sampleInterval");
                                return;
                                // return this._sampleInterval;
                            },
                            set: function (val /*int*/ ) {
                                val = val | 0;
                                notImplemented("public flash.ui.GameInputDevice::set sampleInterval");
                                return;
                                // this._sampleInterval = val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, "enabled", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputDevice::get enabled");
                                return;
                                // return this._enabled;
                            },
                            set: function (val) {
                                val = !!val;
                                notImplemented("public flash.ui.GameInputDevice::set enabled");
                                return;
                                // this._enabled = val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, "id", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputDevice::get id");
                                return;
                                // return this._id;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, "name", {
                            get: function () {
                                notImplemented("public flash.ui.GameInputDevice::get name");
                                return;
                                // return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GameInputDevice.prototype.getControlAt = function (i /*int*/ ) {
                            i = i | 0;
                            notImplemented("public flash.ui.GameInputDevice::getControlAt");
                            return;
                        };
                        GameInputDevice.prototype.startCachingSamples = function (numSamples /*int*/ , controls) {
                            numSamples = numSamples | 0;
                            controls = controls;
                            notImplemented("public flash.ui.GameInputDevice::startCachingSamples");
                            return;
                        };
                        GameInputDevice.prototype.stopCachingSamples = function () {
                            notImplemented("public flash.ui.GameInputDevice::stopCachingSamples");
                            return;
                        };
                        GameInputDevice.prototype.getCachedSamples = function (data, append) {
                            if (typeof append === "undefined") { append = false; }
                            data = data;
                            append = !!append;
                            notImplemented("public flash.ui.GameInputDevice::getCachedSamples");
                            return;
                        };
                        GameInputDevice.classInitializer = null;

                        GameInputDevice.initializer = null;

                        GameInputDevice.classSymbols = null;

                        GameInputDevice.instanceSymbols = null;

                        GameInputDevice.MAX_BUFFER_SIZE = 4800;
                        return GameInputDevice;
                    })(flash.events.EventDispatcher);
                    ui.GameInputDevice = GameInputDevice;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInputFinger
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GameInputFinger = (function (_super) {
                        __extends(GameInputFinger, _super);
                        function GameInputFinger() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.GameInputFinger");
                        }
                        GameInputFinger.classInitializer = null;

                        GameInputFinger.initializer = null;

                        GameInputFinger.classSymbols = null;

                        GameInputFinger.instanceSymbols = null;

                        GameInputFinger.THUMB = "thumb";
                        GameInputFinger.INDEX = "index";
                        GameInputFinger.MIDDLE = "middle";
                        GameInputFinger.UNKNOWN = "unknown";
                        return GameInputFinger;
                    })(AS.ASNative);
                    ui.GameInputFinger = GameInputFinger;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: GameInputHand
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var GameInputHand = (function (_super) {
                        __extends(GameInputHand, _super);
                        function GameInputHand() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.GameInputHand");
                        }
                        GameInputHand.classInitializer = null;

                        GameInputHand.initializer = null;

                        GameInputHand.classSymbols = null;

                        GameInputHand.instanceSymbols = null;

                        GameInputHand.RIGHT = "right";
                        GameInputHand.LEFT = "left";
                        GameInputHand.UNKNOWN = "unknown";
                        return GameInputHand;
                    })(AS.ASNative);
                    ui.GameInputHand = GameInputHand;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Keyboard
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    /**
                    * Dispatches AS3 keyboard events to the focus event dispatcher.
                    */
                    var KeyboardEventDispatcher = (function () {
                        function KeyboardEventDispatcher() {
                            this._lastKeyCode = 0;
                            this._captureKeyPress = false;
                            this._charCodeMap = [];
                        }
                        /**
                        * Converts DOM keyboard event data into AS3 keyboard events.
                        */
                        KeyboardEventDispatcher.prototype.dispatchKeyboardEvent = function (event) {
                            var keyCode = event.keyCode;
                            if (event.type === 'keydown') {
                                this._lastKeyCode = keyCode;

                                // Trying to capture charCode for ASCII keys.
                                this._captureKeyPress = keyCode === 8 || keyCode === 9 || keyCode === 13 || keyCode === 32 || (keyCode >= 48 && keyCode <= 90) || keyCode > 145;
                                if (this._captureKeyPress) {
                                    return;
                                }
                                this._charCodeMap[keyCode] = 0;
                            } else if (event.type === 'keypress') {
                                if (this._captureKeyPress) {
                                    keyCode = this._lastKeyCode;
                                    this._charCodeMap[keyCode] = event.charCode;
                                } else {
                                    return;
                                }
                            }

                            if (this.target) {
                                var isKeyUp = event.type === 'keyup';
                                this.target.dispatchEvent(new flash.events.KeyboardEvent(isKeyUp ? 'keyUp' : 'keyDown', true, false, isKeyUp ? this._charCodeMap[keyCode] : event.charCode, isKeyUp ? event.keyCode : this._lastKeyCode, event.location, event.ctrlKey, event.altKey, event.shiftKey));
                            }
                        };
                        return KeyboardEventDispatcher;
                    })();
                    ui.KeyboardEventDispatcher = KeyboardEventDispatcher;

                    var Keyboard = (function (_super) {
                        __extends(Keyboard, _super);
                        function Keyboard() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.Keyboard");
                        }
                        Object.defineProperty(Keyboard.prototype, "capsLock", {
                            // AS -> JS Bindings
                            // static _capsLock: boolean;
                            // static _numLock: boolean;
                            // static _hasVirtualKeyboard: boolean;
                            // static _physicalKeyboardType: string;
                            get: function () {
                                notImplemented("public flash.ui.Keyboard::get capsLock");
                                return;
                                // return this._capsLock;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Keyboard.prototype, "numLock", {
                            get: function () {
                                notImplemented("public flash.ui.Keyboard::get numLock");
                                return;
                                // return this._numLock;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Keyboard.prototype, "hasVirtualKeyboard", {
                            get: function () {
                                notImplemented("public flash.ui.Keyboard::get hasVirtualKeyboard");
                                return;
                                // return this._hasVirtualKeyboard;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Keyboard.prototype, "physicalKeyboardType", {
                            get: function () {
                                notImplemented("public flash.ui.Keyboard::get physicalKeyboardType");
                                return;
                                // return this._physicalKeyboardType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Keyboard.isAccessible = function () {
                            notImplemented("public flash.ui.Keyboard::static isAccessible");
                            return;
                        };
                        Keyboard.classInitializer = null;

                        Keyboard.initializer = null;

                        Keyboard.classSymbols = null;

                        Keyboard.instanceSymbols = null;

                        Keyboard.KEYNAME_UPARROW = "Up";
                        Keyboard.KEYNAME_DOWNARROW = "Down";
                        Keyboard.KEYNAME_LEFTARROW = "Left";
                        Keyboard.KEYNAME_RIGHTARROW = "Right";
                        Keyboard.KEYNAME_F1 = "F1";
                        Keyboard.KEYNAME_F2 = "F2";
                        Keyboard.KEYNAME_F3 = "F3";
                        Keyboard.KEYNAME_F4 = "F4";
                        Keyboard.KEYNAME_F5 = "F5";
                        Keyboard.KEYNAME_F6 = "F6";
                        Keyboard.KEYNAME_F7 = "F7";
                        Keyboard.KEYNAME_F8 = "F8";
                        Keyboard.KEYNAME_F9 = "F9";
                        Keyboard.KEYNAME_F10 = "F10";
                        Keyboard.KEYNAME_F11 = "F11";
                        Keyboard.KEYNAME_F12 = "F12";
                        Keyboard.KEYNAME_F13 = "F13";
                        Keyboard.KEYNAME_F14 = "F14";
                        Keyboard.KEYNAME_F15 = "F15";
                        Keyboard.KEYNAME_F16 = "F16";
                        Keyboard.KEYNAME_F17 = "F17";
                        Keyboard.KEYNAME_F18 = "F18";
                        Keyboard.KEYNAME_F19 = "F19";
                        Keyboard.KEYNAME_F20 = "F20";
                        Keyboard.KEYNAME_F21 = "F21";
                        Keyboard.KEYNAME_F22 = "F22";
                        Keyboard.KEYNAME_F23 = "F23";
                        Keyboard.KEYNAME_F24 = "F24";
                        Keyboard.KEYNAME_F25 = "F25";
                        Keyboard.KEYNAME_F26 = "F26";
                        Keyboard.KEYNAME_F27 = "F27";
                        Keyboard.KEYNAME_F28 = "F28";
                        Keyboard.KEYNAME_F29 = "F29";
                        Keyboard.KEYNAME_F30 = "F30";
                        Keyboard.KEYNAME_F31 = "F31";
                        Keyboard.KEYNAME_F32 = "F32";
                        Keyboard.KEYNAME_F33 = "F33";
                        Keyboard.KEYNAME_F34 = "F34";
                        Keyboard.KEYNAME_F35 = "F35";
                        Keyboard.KEYNAME_INSERT = "Insert";
                        Keyboard.KEYNAME_DELETE = "Delete";
                        Keyboard.KEYNAME_HOME = "Home";
                        Keyboard.KEYNAME_BEGIN = "Begin";
                        Keyboard.KEYNAME_END = "End";
                        Keyboard.KEYNAME_PAGEUP = "PgUp";
                        Keyboard.KEYNAME_PAGEDOWN = "PgDn";
                        Keyboard.KEYNAME_PRINTSCREEN = "PrntScrn";
                        Keyboard.KEYNAME_SCROLLLOCK = "ScrlLck";
                        Keyboard.KEYNAME_PAUSE = "Pause";
                        Keyboard.KEYNAME_SYSREQ = "SysReq";
                        Keyboard.KEYNAME_BREAK = "Break";
                        Keyboard.KEYNAME_RESET = "Reset";
                        Keyboard.KEYNAME_STOP = "Stop";
                        Keyboard.KEYNAME_MENU = "Menu";
                        Keyboard.KEYNAME_USER = "User";
                        Keyboard.KEYNAME_SYSTEM = "Sys";
                        Keyboard.KEYNAME_PRINT = "Print";
                        Keyboard.KEYNAME_CLEARLINE = "ClrLn";
                        Keyboard.KEYNAME_CLEARDISPLAY = "ClrDsp";
                        Keyboard.KEYNAME_INSERTLINE = "InsLn";
                        Keyboard.KEYNAME_DELETELINE = "DelLn";
                        Keyboard.KEYNAME_INSERTCHAR = "InsChr";
                        Keyboard.KEYNAME_DELETECHAR = "DelChr";
                        Keyboard.KEYNAME_PREV = "Prev";
                        Keyboard.KEYNAME_NEXT = "Next";
                        Keyboard.KEYNAME_SELECT = "Select";
                        Keyboard.KEYNAME_EXECUTE = "Exec";
                        Keyboard.KEYNAME_UNDO = "Undo";
                        Keyboard.KEYNAME_REDO = "Redo";
                        Keyboard.KEYNAME_FIND = "Find";
                        Keyboard.KEYNAME_HELP = "Help";
                        Keyboard.KEYNAME_MODESWITCH = "ModeSw";
                        Keyboard.STRING_UPARROW = "";
                        Keyboard.STRING_DOWNARROW = "";
                        Keyboard.STRING_LEFTARROW = "";
                        Keyboard.STRING_RIGHTARROW = "";
                        Keyboard.STRING_F1 = "";
                        Keyboard.STRING_F2 = "";
                        Keyboard.STRING_F3 = "";
                        Keyboard.STRING_F4 = "";
                        Keyboard.STRING_F5 = "";
                        Keyboard.STRING_F6 = "";
                        Keyboard.STRING_F7 = "";
                        Keyboard.STRING_F8 = "";
                        Keyboard.STRING_F9 = "";
                        Keyboard.STRING_F10 = "";
                        Keyboard.STRING_F11 = "";
                        Keyboard.STRING_F12 = "";
                        Keyboard.STRING_F13 = "";
                        Keyboard.STRING_F14 = "";
                        Keyboard.STRING_F15 = "";
                        Keyboard.STRING_F16 = "";
                        Keyboard.STRING_F17 = "";
                        Keyboard.STRING_F18 = "";
                        Keyboard.STRING_F19 = "";
                        Keyboard.STRING_F20 = "";
                        Keyboard.STRING_F21 = "";
                        Keyboard.STRING_F22 = "";
                        Keyboard.STRING_F23 = "";
                        Keyboard.STRING_F24 = "";
                        Keyboard.STRING_F25 = "";
                        Keyboard.STRING_F26 = "";
                        Keyboard.STRING_F27 = "";
                        Keyboard.STRING_F28 = "";
                        Keyboard.STRING_F29 = "";
                        Keyboard.STRING_F30 = "";
                        Keyboard.STRING_F31 = "";
                        Keyboard.STRING_F32 = "";
                        Keyboard.STRING_F33 = "";
                        Keyboard.STRING_F34 = "";
                        Keyboard.STRING_F35 = "";
                        Keyboard.STRING_INSERT = "";
                        Keyboard.STRING_DELETE = "";
                        Keyboard.STRING_HOME = "";
                        Keyboard.STRING_BEGIN = "";
                        Keyboard.STRING_END = "";
                        Keyboard.STRING_PAGEUP = "";
                        Keyboard.STRING_PAGEDOWN = "";
                        Keyboard.STRING_PRINTSCREEN = "";
                        Keyboard.STRING_SCROLLLOCK = "";
                        Keyboard.STRING_PAUSE = "";
                        Keyboard.STRING_SYSREQ = "";
                        Keyboard.STRING_BREAK = "";
                        Keyboard.STRING_RESET = "";
                        Keyboard.STRING_STOP = "";
                        Keyboard.STRING_MENU = "";
                        Keyboard.STRING_USER = "";
                        Keyboard.STRING_SYSTEM = "";
                        Keyboard.STRING_PRINT = "";
                        Keyboard.STRING_CLEARLINE = "";
                        Keyboard.STRING_CLEARDISPLAY = "";
                        Keyboard.STRING_INSERTLINE = "";
                        Keyboard.STRING_DELETELINE = "";
                        Keyboard.STRING_INSERTCHAR = "";
                        Keyboard.STRING_DELETECHAR = "";
                        Keyboard.STRING_PREV = "";
                        Keyboard.STRING_NEXT = "";
                        Keyboard.STRING_SELECT = "";
                        Keyboard.STRING_EXECUTE = "";
                        Keyboard.STRING_UNDO = "";
                        Keyboard.STRING_REDO = "";
                        Keyboard.STRING_FIND = "";
                        Keyboard.STRING_HELP = "";
                        Keyboard.STRING_MODESWITCH = "";
                        Keyboard.CharCodeStrings = undefined;
                        Keyboard.NUMBER_0 = 48;
                        Keyboard.NUMBER_1 = 49;
                        Keyboard.NUMBER_2 = 50;
                        Keyboard.NUMBER_3 = 51;
                        Keyboard.NUMBER_4 = 52;
                        Keyboard.NUMBER_5 = 53;
                        Keyboard.NUMBER_6 = 54;
                        Keyboard.NUMBER_7 = 55;
                        Keyboard.NUMBER_8 = 56;
                        Keyboard.NUMBER_9 = 57;
                        Keyboard.A = 65;
                        Keyboard.B = 66;
                        Keyboard.C = 67;
                        Keyboard.D = 68;
                        Keyboard.E = 69;
                        Keyboard.F = 70;
                        Keyboard.G = 71;
                        Keyboard.H = 72;
                        Keyboard.I = 73;
                        Keyboard.J = 74;
                        Keyboard.K = 75;
                        Keyboard.L = 76;
                        Keyboard.M = 77;
                        Keyboard.N = 78;
                        Keyboard.O = 79;
                        Keyboard.P = 80;
                        Keyboard.Q = 81;
                        Keyboard.R = 82;
                        Keyboard.S = 83;
                        Keyboard.T = 84;
                        Keyboard.U = 85;
                        Keyboard.V = 86;
                        Keyboard.W = 87;
                        Keyboard.X = 88;
                        Keyboard.Y = 89;
                        Keyboard.Z = 90;
                        Keyboard.SEMICOLON = 186;
                        Keyboard.EQUAL = 187;
                        Keyboard.COMMA = 188;
                        Keyboard.MINUS = 189;
                        Keyboard.PERIOD = 190;
                        Keyboard.SLASH = 191;
                        Keyboard.BACKQUOTE = 192;
                        Keyboard.LEFTBRACKET = 219;
                        Keyboard.BACKSLASH = 220;
                        Keyboard.RIGHTBRACKET = 221;
                        Keyboard.QUOTE = 222;
                        Keyboard.ALTERNATE = 18;
                        Keyboard.BACKSPACE = 8;
                        Keyboard.CAPS_LOCK = 20;
                        Keyboard.COMMAND = 15;
                        Keyboard.CONTROL = 17;
                        Keyboard.DELETE = 46;
                        Keyboard.DOWN = 40;
                        Keyboard.END = 35;
                        Keyboard.ENTER = 13;
                        Keyboard.ESCAPE = 27;
                        Keyboard.F1 = 112;
                        Keyboard.F2 = 113;
                        Keyboard.F3 = 114;
                        Keyboard.F4 = 115;
                        Keyboard.F5 = 116;
                        Keyboard.F6 = 117;
                        Keyboard.F7 = 118;
                        Keyboard.F8 = 119;
                        Keyboard.F9 = 120;
                        Keyboard.F10 = 121;
                        Keyboard.F11 = 122;
                        Keyboard.F12 = 123;
                        Keyboard.F13 = 124;
                        Keyboard.F14 = 125;
                        Keyboard.F15 = 126;
                        Keyboard.HOME = 36;
                        Keyboard.INSERT = 45;
                        Keyboard.LEFT = 37;
                        Keyboard.NUMPAD = 21;
                        Keyboard.NUMPAD_0 = 96;
                        Keyboard.NUMPAD_1 = 97;
                        Keyboard.NUMPAD_2 = 98;
                        Keyboard.NUMPAD_3 = 99;
                        Keyboard.NUMPAD_4 = 100;
                        Keyboard.NUMPAD_5 = 101;
                        Keyboard.NUMPAD_6 = 102;
                        Keyboard.NUMPAD_7 = 103;
                        Keyboard.NUMPAD_8 = 104;
                        Keyboard.NUMPAD_9 = 105;
                        Keyboard.NUMPAD_ADD = 107;
                        Keyboard.NUMPAD_DECIMAL = 110;
                        Keyboard.NUMPAD_DIVIDE = 111;
                        Keyboard.NUMPAD_ENTER = 108;
                        Keyboard.NUMPAD_MULTIPLY = 106;
                        Keyboard.NUMPAD_SUBTRACT = 109;
                        Keyboard.PAGE_DOWN = 34;
                        Keyboard.PAGE_UP = 33;
                        Keyboard.RIGHT = 39;
                        Keyboard.SHIFT = 16;
                        Keyboard.SPACE = 32;
                        Keyboard.TAB = 9;
                        Keyboard.UP = 38;
                        Keyboard.RED = 16777216;
                        Keyboard.GREEN = 16777217;
                        Keyboard.YELLOW = 16777218;
                        Keyboard.BLUE = 16777219;
                        Keyboard.CHANNEL_UP = 16777220;
                        Keyboard.CHANNEL_DOWN = 16777221;
                        Keyboard.RECORD = 16777222;
                        Keyboard.PLAY = 16777223;
                        Keyboard.PAUSE = 16777224;
                        Keyboard.STOP = 16777225;
                        Keyboard.FAST_FORWARD = 16777226;
                        Keyboard.REWIND = 16777227;
                        Keyboard.SKIP_FORWARD = 16777228;
                        Keyboard.SKIP_BACKWARD = 16777229;
                        Keyboard.NEXT = 16777230;
                        Keyboard.PREVIOUS = 16777231;
                        Keyboard.LIVE = 16777232;
                        Keyboard.LAST = 16777233;
                        Keyboard.MENU = 16777234;
                        Keyboard.INFO = 16777235;
                        Keyboard.GUIDE = 16777236;
                        Keyboard.EXIT = 16777237;
                        Keyboard.BACK = 16777238;
                        Keyboard.AUDIO = 16777239;
                        Keyboard.SUBTITLE = 16777240;
                        Keyboard.DVR = 16777241;
                        Keyboard.VOD = 16777242;
                        Keyboard.INPUT = 16777243;
                        Keyboard.SETUP = 16777244;
                        Keyboard.HELP = 16777245;
                        Keyboard.MASTER_SHELL = 16777246;
                        Keyboard.SEARCH = 16777247;
                        return Keyboard;
                    })(AS.ASNative);
                    ui.Keyboard = Keyboard;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Mouse
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var InteractiveObject = flash.display.InteractiveObject;

                    var events = flash.events;

                    /**
                    * Dispatches AS3 mouse events.
                    */
                    var MouseEventDispatcher = (function () {
                        function MouseEventDispatcher() {
                            this.stage = null;
                            this.currentTarget = null;
                        }
                        /**
                        * Finds the interactive object on which the event is dispatched.
                        */
                        MouseEventDispatcher.prototype._findTarget = function (point) {
                            var objects = this.stage.getObjectsUnderMouse(point);
                            var target;
                            var i = objects.length;
                            while (i--) {
                                var object = objects[i];
                                if (!flash.display.InteractiveObject.isType(object)) {
                                    var j = i;
                                    while (j--) {
                                        var sibling = objects[j];
                                        if (sibling._parent === object._parent && InteractiveObject.isType(sibling)) {
                                            object = sibling;
                                            i = j;
                                            break;
                                        }
                                    }
                                }
                                target = object.findFurthestInteractiveAncestorOrSelf();
                                if (!target) {
                                    continue;
                                }
                                if (target.mouseEnabled) {
                                    break;
                                }
                                if (flash.display.Sprite.isType(target)) {
                                    var hitTarget = target._hitTarget;
                                    if (hitTarget && hitTarget.mouseEnabled) {
                                        target = hitTarget;
                                        break;
                                    }
                                }
                            }
                            return target;
                        };

                        /**
                        * Converts DOM mouse event data into AS3 mouse events.
                        */
                        MouseEventDispatcher.prototype._dispatchMouseEvent = function (target, type, data, relatedObject) {
                            if (typeof relatedObject === "undefined") { relatedObject = null; }
                            var localPoint = target.globalToLocal(data.point);
                            var event = new events.MouseEvent(type, type !== events.MouseEvent.ROLL_OVER && type !== events.MouseEvent.ROLL_OUT && type !== events.MouseEvent.MOUSE_LEAVE, false, localPoint.x, localPoint.y, relatedObject, data.ctrlKey, data.altKey, data.shiftKey, !!data.buttons);
                            target.dispatchEvent(event);
                        };

                        MouseEventDispatcher.prototype.handleMouseEvent = function (data) {
                            var stage = this.stage;
                            if (!stage) {
                                return;
                            }

                            var globalPoint = data.point;
                            flash.ui.Mouse.updateCurrentPosition(globalPoint);
                            var currentTarget = this.currentTarget;

                            if (globalPoint.x < 0 || globalPoint.x > stage.stageWidth || globalPoint.y < 0 || globalPoint.y > stage.stageHeight) {
                                if (currentTarget) {
                                    this._dispatchMouseEvent(stage, events.MouseEvent.MOUSE_LEAVE, data);
                                }
                                this.currentTarget = null;
                                return;
                            }

                            var target = this._findTarget(globalPoint) || stage;
                            var type = flash.events.MouseEvent.typeFromDOMType(data.type);
                            switch (type) {
                                case events.MouseEvent.MOUSE_DOWN:
                                    if (data.buttons & 1 /* Left */) {
                                        data.buttons = 1 /* Left */;
                                    } else if (data.buttons & 2 /* Middle */) {
                                        type = events.MouseEvent.MIDDLE_MOUSE_DOWN;
                                        data.buttons = 2 /* Middle */;
                                    } else if (data.buttons & 4 /* Right */) {
                                        type = events.MouseEvent.RIGHT_MOUSE_DOWN;
                                        data.buttons = 4 /* Right */;
                                    }
                                    target._mouseDown = true;
                                    break;
                                case events.MouseEvent.MOUSE_UP:
                                    if (data.buttons & 1 /* Left */) {
                                        data.buttons = 1 /* Left */;
                                    } else if (data.buttons & 2 /* Middle */) {
                                        type = events.MouseEvent.MIDDLE_MOUSE_UP;
                                        data.buttons = 2 /* Middle */;
                                    } else if (data.buttons & 4 /* Right */) {
                                        type = events.MouseEvent.RIGHT_MOUSE_UP;
                                        data.buttons = 4 /* Right */;
                                    }
                                    target._mouseDown = false;
                                    break;
                                case events.MouseEvent.CLICK:
                                    if (!(data.buttons & 1 /* Left */)) {
                                        if (data.buttons & 2 /* Middle */) {
                                            type = events.MouseEvent.MIDDLE_CLICK;
                                        } else if (data.buttons & 4 /* Right */) {
                                            type = events.MouseEvent.RIGHT_CLICK;
                                        }
                                    }
                                    data.buttons = 0;
                                    break;
                                case events.MouseEvent.DOUBLE_CLICK:
                                    if (!target.doubleClickEnabled) {
                                        return;
                                    }
                                    data.buttons = 0;
                                    break;
                                case events.MouseEvent.MOUSE_MOVE:
                                    this.currentTarget = target;
                                    data.buttons &= 1 /* Left */;
                                    if (target === currentTarget) {
                                        break;
                                    }
                                    var commonAncestor = target.findNearestCommonAncestor(currentTarget);
                                    if (currentTarget && currentTarget !== stage) {
                                        currentTarget._mouseOver = false;

                                        // TODO: Support track as menu.
                                        currentTarget._mouseDown = false;
                                        this._dispatchMouseEvent(currentTarget, events.MouseEvent.MOUSE_OUT, data, target);
                                        var nodeLeft = currentTarget;
                                        while (nodeLeft !== commonAncestor) {
                                            this._dispatchMouseEvent(nodeLeft, events.MouseEvent.ROLL_OUT, data, target);
                                            nodeLeft = nodeLeft.parent;
                                        }
                                    }
                                    if (target === stage) {
                                        break;
                                    }
                                    var nodeEntered = target;
                                    while (nodeEntered !== commonAncestor) {
                                        this._dispatchMouseEvent(nodeEntered, events.MouseEvent.ROLL_OVER, data, currentTarget);
                                        nodeEntered = nodeEntered.parent;
                                    }
                                    target._mouseOver = true;
                                    this._dispatchMouseEvent(target, events.MouseEvent.MOUSE_OVER, data, currentTarget);
                                    return;
                            }

                            // TODO: handle MOUSE_WHEEL and MOUSE_RELEASE_OUTSIDE
                            this._dispatchMouseEvent(target, type, data);
                        };
                        return MouseEventDispatcher;
                    })();
                    ui.MouseEventDispatcher = MouseEventDispatcher;

                    (function (MouseButtonFlags) {
                        MouseButtonFlags[MouseButtonFlags["Left"] = 0x01] = "Left";
                        MouseButtonFlags[MouseButtonFlags["Middle"] = 0x02] = "Middle";
                        MouseButtonFlags[MouseButtonFlags["Right"] = 0x04] = "Right";
                    })(ui.MouseButtonFlags || (ui.MouseButtonFlags = {}));
                    var MouseButtonFlags = ui.MouseButtonFlags;

                    var Mouse = (function (_super) {
                        __extends(Mouse, _super);
                        function Mouse() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.Mouse");
                        }
                        Object.defineProperty(Mouse.prototype, "supportsCursor", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _supportsCursor: boolean;
                            // static _cursor: string;
                            // static _supportsNativeCursor: boolean;
                            get: function () {
                                notImplemented("public flash.ui.Mouse::get supportsCursor");
                                return;
                                // return this._supportsCursor;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Mouse.prototype, "cursor", {
                            get: function () {
                                notImplemented("public flash.ui.Mouse::get cursor");
                                return;
                                // return this._cursor;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                notImplemented("public flash.ui.Mouse::set cursor");
                                return;
                                // this._cursor = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Mouse.prototype, "supportsNativeCursor", {
                            get: function () {
                                notImplemented("public flash.ui.Mouse::get supportsNativeCursor");
                                return;
                                // return this._supportsNativeCursor;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Mouse.hide = function () {
                            somewhatImplemented("public flash.ui.Mouse::static hide");
                            return;
                        };
                        Mouse.show = function () {
                            somewhatImplemented("public flash.ui.Mouse::static show");
                            return;
                        };
                        Mouse.registerCursor = function (name, cursor) {
                            name = asCoerceString(name);
                            cursor = cursor;
                            notImplemented("public flash.ui.Mouse::static registerCursor");
                            return;
                        };
                        Mouse.unregisterCursor = function (name) {
                            name = asCoerceString(name);
                            notImplemented("public flash.ui.Mouse::static unregisterCursor");
                            return;
                        };

                        /**
                        * Remembers the current mouse position.
                        */
                        Mouse.updateCurrentPosition = function (value) {
                            this._currentPosition.copyFrom(value);
                        };
                        Mouse.classInitializer = function () {
                            this._currentPosition = new flash.geom.Point();
                        };

                        Mouse.initializer = null;

                        Mouse.classSymbols = null;

                        Mouse.instanceSymbols = null;
                        return Mouse;
                    })(AS.ASNative);
                    ui.Mouse = Mouse;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MouseCursorData
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var MouseCursorData = (function (_super) {
                        __extends(MouseCursorData, _super);
                        function MouseCursorData() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.MouseCursorData");
                        }
                        Object.defineProperty(MouseCursorData.prototype, "data", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _data: ASVector<any>;
                            // _hotSpot: flash.geom.Point;
                            // _frameRate: number;
                            get: function () {
                                notImplemented("public flash.ui.MouseCursorData::get data");
                                return;
                                // return this._data;
                            },
                            set: function (data) {
                                data = data;
                                notImplemented("public flash.ui.MouseCursorData::set data");
                                return;
                                // this._data = data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseCursorData.prototype, "hotSpot", {
                            get: function () {
                                notImplemented("public flash.ui.MouseCursorData::get hotSpot");
                                return;
                                // return this._hotSpot;
                            },
                            set: function (data) {
                                data = data;
                                notImplemented("public flash.ui.MouseCursorData::set hotSpot");
                                return;
                                // this._hotSpot = data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseCursorData.prototype, "frameRate", {
                            get: function () {
                                notImplemented("public flash.ui.MouseCursorData::get frameRate");
                                return;
                                // return this._frameRate;
                            },
                            set: function (data) {
                                data = +data;
                                notImplemented("public flash.ui.MouseCursorData::set frameRate");
                                return;
                                // this._frameRate = data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MouseCursorData.classInitializer = null;

                        MouseCursorData.initializer = null;

                        MouseCursorData.classSymbols = null;

                        MouseCursorData.instanceSymbols = null;
                        return MouseCursorData;
                    })(AS.ASNative);
                    ui.MouseCursorData = MouseCursorData;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Multitouch
                (function (ui) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var Multitouch = (function (_super) {
                        __extends(Multitouch, _super);
                        function Multitouch() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.Multitouch");
                        }
                        Object.defineProperty(Multitouch.prototype, "inputMode", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _inputMode: string;
                            // static _supportsTouchEvents: boolean;
                            // static _supportsGestureEvents: boolean;
                            // static _supportedGestures: ASVector<any>;
                            // static _maxTouchPoints: number /*int*/;
                            // static _mapTouchToMouse: boolean;
                            get: function () {
                                notImplemented("public flash.ui.Multitouch::get inputMode");
                                return;
                                // return this._inputMode;
                            },
                            set: function (value) {
                                value = asCoerceString(value);
                                notImplemented("public flash.ui.Multitouch::set inputMode");
                                return;
                                // this._inputMode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch.prototype, "supportsTouchEvents", {
                            get: function () {
                                somewhatImplemented("public flash.ui.Multitouch::get supportsTouchEvents");
                                return false;
                                // return this._supportsTouchEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch.prototype, "supportsGestureEvents", {
                            get: function () {
                                somewhatImplemented("public flash.ui.Multitouch::get supportsGestureEvents");
                                return false;
                                // return this._supportsGestureEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch.prototype, "supportedGestures", {
                            get: function () {
                                somewhatImplemented("public flash.ui.Multitouch::get supportedGestures");
                                return null;
                                // return this._supportedGestures;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch.prototype, "maxTouchPoints", {
                            get: function () {
                                somewhatImplemented("public flash.ui.Multitouch::get maxTouchPoints");
                                return 0;
                                // return this._maxTouchPoints;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch.prototype, "mapTouchToMouse", {
                            get: function () {
                                somewhatImplemented("public flash.ui.Multitouch::get mapTouchToMouse");
                                return true;
                                // return this._mapTouchToMouse;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("public flash.ui.Multitouch::set mapTouchToMouse");
                                return;
                                // this._mapTouchToMouse = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Multitouch.classInitializer = null;

                        Multitouch.initializer = null;

                        Multitouch.classSymbols = null;

                        Multitouch.instanceSymbols = null;
                        return Multitouch;
                    })(AS.ASNative);
                    ui.Multitouch = Multitouch;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: MultitouchInputMode
                (function (ui) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var MultitouchInputMode = (function (_super) {
                        __extends(MultitouchInputMode, _super);
                        function MultitouchInputMode() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.ui.MultitouchInputMode");
                        }
                        MultitouchInputMode.classInitializer = null;

                        MultitouchInputMode.initializer = null;

                        MultitouchInputMode.classSymbols = null;

                        MultitouchInputMode.instanceSymbols = null;

                        MultitouchInputMode.NONE = "none";
                        MultitouchInputMode.GESTURE = "gesture";
                        MultitouchInputMode.TOUCH_POINT = "touchPoint";
                        return MultitouchInputMode;
                    })(AS.ASNative);
                    ui.MultitouchInputMode = MultitouchInputMode;
                })(flash.ui || (flash.ui = {}));
                var ui = flash.ui;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Endian
                (function (utils) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Endian = (function (_super) {
                        __extends(Endian, _super);
                        function Endian() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.utils.Endian");
                        }
                        Endian.classInitializer = null;

                        Endian.initializer = null;

                        Endian.classSymbols = null;

                        Endian.instanceSymbols = null;

                        Endian.BIG_ENDIAN = "bigEndian";
                        Endian.LITTLE_ENDIAN = "littleEndian";
                        return Endian;
                    })(AS.ASNative);
                    utils.Endian = Endian;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IDataInput2
                (function (utils) {
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IDataOutput2
                (function (utils) {
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: IExternalizable
                (function (utils) {
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ObjectInput
                (function (utils) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var ObjectInput = (function (_super) {
                        __extends(ObjectInput, _super);
                        function ObjectInput() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: packageInternal flash.utils.ObjectInput");
                        }
                        Object.defineProperty(ObjectInput.prototype, "bytesAvailable", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _bytesAvailable: number /*uint*/;
                            // _objectEncoding: number /*uint*/;
                            // _endian: string;
                            get: function () {
                                notImplemented("packageInternal flash.utils.ObjectInput::get bytesAvailable");
                                return;
                                // return this._bytesAvailable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ObjectInput.prototype, "objectEncoding", {
                            get: function () {
                                notImplemented("packageInternal flash.utils.ObjectInput::get objectEncoding");
                                return;
                                // return this._objectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                notImplemented("packageInternal flash.utils.ObjectInput::set objectEncoding");
                                return;
                                // this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ObjectInput.prototype, "endian", {
                            get: function () {
                                notImplemented("packageInternal flash.utils.ObjectInput::get endian");
                                return;
                                // return this._endian;
                            },
                            set: function (type) {
                                type = asCoerceString(type);
                                notImplemented("packageInternal flash.utils.ObjectInput::set endian");
                                return;
                                // this._endian = type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ObjectInput.prototype.readBytes = function (bytes, offset, length) {
                            if (typeof offset === "undefined") { offset = 0; }
                            if (typeof length === "undefined") { length = 0; }
                            bytes = bytes;
                            offset = offset >>> 0;
                            length = length >>> 0;
                            notImplemented("packageInternal flash.utils.ObjectInput::readBytes");
                            return;
                        };
                        ObjectInput.prototype.readBoolean = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readBoolean");
                            return;
                        };
                        ObjectInput.prototype.readByte = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readByte");
                            return;
                        };
                        ObjectInput.prototype.readUnsignedByte = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readUnsignedByte");
                            return;
                        };
                        ObjectInput.prototype.readShort = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readShort");
                            return;
                        };
                        ObjectInput.prototype.readUnsignedShort = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readUnsignedShort");
                            return;
                        };
                        ObjectInput.prototype.readInt = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readInt");
                            return;
                        };
                        ObjectInput.prototype.readUnsignedInt = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readUnsignedInt");
                            return;
                        };
                        ObjectInput.prototype.readFloat = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readFloat");
                            return;
                        };
                        ObjectInput.prototype.readDouble = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readDouble");
                            return;
                        };
                        ObjectInput.prototype.readMultiByte = function (length /*uint*/ , charSet) {
                            length = length >>> 0;
                            charSet = asCoerceString(charSet);
                            notImplemented("packageInternal flash.utils.ObjectInput::readMultiByte");
                            return;
                        };
                        ObjectInput.prototype.readUTF = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readUTF");
                            return;
                        };
                        ObjectInput.prototype.readUTFBytes = function (length /*uint*/ ) {
                            length = length >>> 0;
                            notImplemented("packageInternal flash.utils.ObjectInput::readUTFBytes");
                            return;
                        };
                        ObjectInput.prototype.readObject = function () {
                            notImplemented("packageInternal flash.utils.ObjectInput::readObject");
                            return;
                        };
                        ObjectInput.classInitializer = null;

                        ObjectInput.initializer = null;

                        ObjectInput.classSymbols = null;

                        ObjectInput.instanceSymbols = null;
                        return ObjectInput;
                    })(AS.ASNative);
                    utils.ObjectInput = ObjectInput;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: ObjectOutput
                (function (utils) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var ObjectOutput = (function (_super) {
                        __extends(ObjectOutput, _super);
                        function ObjectOutput() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: packageInternal flash.utils.ObjectOutput");
                        }
                        Object.defineProperty(ObjectOutput.prototype, "objectEncoding", {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _objectEncoding: number /*uint*/;
                            // _endian: string;
                            get: function () {
                                notImplemented("packageInternal flash.utils.ObjectOutput::get objectEncoding");
                                return;
                                // return this._objectEncoding;
                            },
                            set: function (version /*uint*/ ) {
                                version = version >>> 0;
                                notImplemented("packageInternal flash.utils.ObjectOutput::set objectEncoding");
                                return;
                                // this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ObjectOutput.prototype, "endian", {
                            get: function () {
                                notImplemented("packageInternal flash.utils.ObjectOutput::get endian");
                                return;
                                // return this._endian;
                            },
                            set: function (type) {
                                type = asCoerceString(type);
                                notImplemented("packageInternal flash.utils.ObjectOutput::set endian");
                                return;
                                // this._endian = type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ObjectOutput.prototype.writeBytes = function (bytes, offset, length) {
                            if (typeof offset === "undefined") { offset = 0; }
                            if (typeof length === "undefined") { length = 0; }
                            bytes = bytes;
                            offset = offset >>> 0;
                            length = length >>> 0;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeBytes");
                            return;
                        };
                        ObjectOutput.prototype.writeBoolean = function (value) {
                            value = !!value;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeBoolean");
                            return;
                        };
                        ObjectOutput.prototype.writeByte = function (value /*int*/ ) {
                            value = value | 0;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeByte");
                            return;
                        };
                        ObjectOutput.prototype.writeShort = function (value /*int*/ ) {
                            value = value | 0;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeShort");
                            return;
                        };
                        ObjectOutput.prototype.writeInt = function (value /*int*/ ) {
                            value = value | 0;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeInt");
                            return;
                        };
                        ObjectOutput.prototype.writeUnsignedInt = function (value /*uint*/ ) {
                            value = value >>> 0;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeUnsignedInt");
                            return;
                        };
                        ObjectOutput.prototype.writeFloat = function (value) {
                            value = +value;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeFloat");
                            return;
                        };
                        ObjectOutput.prototype.writeDouble = function (value) {
                            value = +value;
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeDouble");
                            return;
                        };
                        ObjectOutput.prototype.writeMultiByte = function (value, charSet) {
                            value = asCoerceString(value);
                            charSet = asCoerceString(charSet);
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeMultiByte");
                            return;
                        };
                        ObjectOutput.prototype.writeUTF = function (value) {
                            value = asCoerceString(value);
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeUTF");
                            return;
                        };
                        ObjectOutput.prototype.writeUTFBytes = function (value) {
                            value = asCoerceString(value);
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeUTFBytes");
                            return;
                        };
                        ObjectOutput.prototype.writeObject = function (object) {
                            notImplemented("packageInternal flash.utils.ObjectOutput::writeObject");
                            return;
                        };
                        ObjectOutput.classInitializer = null;

                        ObjectOutput.initializer = null;

                        ObjectOutput.classSymbols = null;

                        ObjectOutput.instanceSymbols = null;
                        return ObjectOutput;
                    })(AS.ASNative);
                    utils.ObjectOutput = ObjectOutput;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: Timer
                (function (utils) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var Timer = (function (_super) {
                        __extends(Timer, _super);
                        function Timer(delay, repeatCount) {
                            if (typeof repeatCount === "undefined") { repeatCount = 0; }
                            false && _super.call(this, undefined);
                            notImplemented("Dummy Constructor: public flash.utils.Timer");
                        }
                        Object.defineProperty(Timer.prototype, "running", {
                            // AS -> JS Bindings
                            get: function () {
                                return this._running;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Timer.prototype.stop = function () {
                            this._running = false;
                            clearInterval(this._interval);
                        };
                        Timer.prototype._start = function (delay, closure) {
                            this._delay = +delay;
                            this._running = true;
                            this._interval = setInterval(closure, delay);
                        };
                        Timer.prototype._tick = function () {
                            if (!this._running) {
                                return;
                            }
                            if (flash.utils.Timer.dispatchingEnabled) {
                                this.dispatchEvent(new flash.events.TimerEvent("timer", true, false));
                            }
                        };
                        Timer.classInitializer = null;
                        Timer.initializer = null;
                        Timer.classSymbols = null;
                        Timer.instanceSymbols = ["start!"];

                        Timer.dispatchingEnabled = true;
                        return Timer;
                    })(flash.events.EventDispatcher);
                    utils.Timer = Timer;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: SetIntervalTimer
                (function (utils) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var SetIntervalTimer = (function (_super) {
                        __extends(SetIntervalTimer, _super);
                        function SetIntervalTimer(closure, delay, repeats, rest) {
                            closure = closure;
                            delay = +delay;
                            repeats = !!repeats;
                            rest = rest;
                            false && _super.call(this, undefined, undefined);
                            notImplemented("Dummy Constructor: packageInternal flash.utils.SetIntervalTimer");
                        }
                        SetIntervalTimer.classInitializer = null;

                        SetIntervalTimer.initializer = null;

                        SetIntervalTimer.classSymbols = null;

                        SetIntervalTimer.instanceSymbols = null;
                        return SetIntervalTimer;
                    })(flash.utils.Timer);
                    utils.SetIntervalTimer = SetIntervalTimer;
                })(flash.utils || (flash.utils = {}));
                var utils = flash.utils;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: XMLNode
                (function (xml) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var XMLNode = (function (_super) {
                        __extends(XMLNode, _super);
                        function XMLNode(type /*uint*/ , value) {
                            type = type >>> 0;
                            value = asCoerceString(value);
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.xml.XMLNode");
                        }
                        // Static   JS -> AS Bindings
                        // Static   AS -> JS Bindings
                        XMLNode.escapeXML = function (value) {
                            value = asCoerceString(value);
                            notImplemented("public flash.xml.XMLNode::static escapeXML");
                            return;
                        };
                        XMLNode.initializer = null;
                        return XMLNode;
                    })(AS.ASNative);
                    xml.XMLNode = XMLNode;
                })(flash.xml || (flash.xml = {}));
                var xml = flash.xml;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: XMLDocument
                (function (xml) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var XMLDocument = (function (_super) {
                        __extends(XMLDocument, _super);
                        function XMLDocument(source) {
                            if (typeof source === "undefined") { source = null; }
                            source = asCoerceString(source);
                            false && _super.call(this, undefined, undefined);
                            notImplemented("Dummy Constructor: public flash.xml.XMLDocument");
                        }
                        XMLDocument.initializer = null;
                        return XMLDocument;
                    })(flash.xml.XMLNode);
                    xml.XMLDocument = XMLDocument;
                })(flash.xml || (flash.xml = {}));
                var xml = flash.xml;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: XMLNodeType
                (function (xml) {
                    var notImplemented = Shumway.Debug.notImplemented;

                    var XMLNodeType = (function (_super) {
                        __extends(XMLNodeType, _super);
                        function XMLNodeType() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: public flash.xml.XMLNodeType");
                        }
                        XMLNodeType.initializer = null;
                        return XMLNodeType;
                    })(AS.ASNative);
                    xml.XMLNodeType = XMLNodeType;
                })(flash.xml || (flash.xml = {}));
                var xml = flash.xml;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: XMLParser
                (function (xml) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var XMLParser = (function (_super) {
                        __extends(XMLParser, _super);
                        function XMLParser() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: packageInternal flash.xml.XMLParser");
                        }
                        // Static   JS -> AS Bindings
                        // Static   AS -> JS Bindings
                        // Instance JS -> AS Bindings
                        // Instance AS -> JS Bindings
                        XMLParser.prototype.startParse = function (source, ignoreWhite) {
                            source = asCoerceString(source);
                            ignoreWhite = !!ignoreWhite;
                            notImplemented("packageInternal flash.xml.XMLParser::startParse");
                            return;
                        };
                        XMLParser.prototype.getNext = function (tag) {
                            tag = tag;
                            notImplemented("packageInternal flash.xml.XMLParser::getNext");
                            return;
                        };
                        XMLParser.initializer = null;
                        return XMLParser;
                    })(AS.ASNative);
                    xml.XMLParser = XMLParser;
                })(flash.xml || (flash.xml = {}));
                var xml = flash.xml;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (flash) {
                /**
                * Copyright 2014 Mozilla Foundation
                *
                * Licensed under the Apache License, Version 2.0 (the "License");
                * you may not use this file except in compliance with the License.
                * You may obtain a copy of the License at
                *
                * http://www.apache.org/licenses/LICENSE-2.0
                *
                * Unless required by applicable law or agreed to in writing, software
                * distributed under the License is distributed on an "AS IS" BASIS,
                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                * See the License for the specific language governing permissions and
                * limitations under the License.
                */
                // Class: XMLTag
                (function (xml) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                    var XMLTag = (function (_super) {
                        __extends(XMLTag, _super);
                        function XMLTag() {
                            false && _super.call(this);
                            notImplemented("Dummy Constructor: packageInternal flash.xml.XMLTag");
                        }
                        Object.defineProperty(XMLTag.prototype, "type", {
                            // Static   JS -> AS Bindings
                            // Static   AS -> JS Bindings
                            // Instance JS -> AS Bindings
                            // Instance AS -> JS Bindings
                            get: function () {
                                notImplemented("packageInternal flash.xml.XMLTag::get type");
                                return;
                            },
                            set: function (value /*uint*/ ) {
                                value = value >>> 0;
                                notImplemented("packageInternal flash.xml.XMLTag::set type");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(XMLTag.prototype, "empty", {
                            get: function () {
                                notImplemented("packageInternal flash.xml.XMLTag::get empty");
                                return;
                            },
                            set: function (value) {
                                value = !!value;
                                notImplemented("packageInternal flash.xml.XMLTag::set empty");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(XMLTag.prototype, "value", {
                            get: function () {
                                notImplemented("packageInternal flash.xml.XMLTag::get value");
                                return;
                            },
                            set: function (v) {
                                v = asCoerceString(v);
                                notImplemented("packageInternal flash.xml.XMLTag::set value");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(XMLTag.prototype, "attrs", {
                            get: function () {
                                notImplemented("packageInternal flash.xml.XMLTag::get attrs");
                                return;
                            },
                            set: function (value) {
                                value = value;
                                notImplemented("packageInternal flash.xml.XMLTag::set attrs");
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        XMLTag.initializer = null;
                        return XMLTag;
                    })(AS.ASNative);
                    xml.XMLTag = XMLTag;
                })(flash.xml || (flash.xml = {}));
                var xml = flash.xml;
            })(AS.flash || (AS.flash = {}));
            var flash = AS.flash;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (Timeline) {
        var notImplemented = Shumway.Debug.notImplemented;
        var isInteger = Shumway.isInteger;
        var assert = Shumway.Debug.assert;

        var Bounds = Shumway.Bounds;

        var flash = Shumway.AVM2.AS.flash;
        var PlaceObjectFlags = Shumway.SWF.Parser.PlaceObjectFlags;

        var ActionScriptVersion = Shumway.AVM2.AS.flash.display.ActionScriptVersion;

        /**
        * TODO document
        */
        var Symbol = (function () {
            function Symbol(id, symbolClass) {
                this.id = -1;
                release || assert(isInteger(id));
                this.id = id;
                this.symbolClass = symbolClass;
                this.isAS2Object = false;
            }
            return Symbol;
        })();
        Timeline.Symbol = Symbol;

        var DisplaySymbol = (function (_super) {
            __extends(DisplaySymbol, _super);
            function DisplaySymbol(id, symbolClass, dynamic) {
                if (typeof dynamic === "undefined") { dynamic = true; }
                _super.call(this, id, symbolClass);
                this.dynamic = dynamic;
            }
            DisplaySymbol.prototype._setBoundsFromData = function (data) {
                this.fillBounds = data.fillBounds ? Bounds.FromUntyped(data.fillBounds) : null;
                this.lineBounds = data.lineBounds ? Bounds.FromUntyped(data.lineBounds) : null;
                if (!this.lineBounds && this.fillBounds) {
                    this.lineBounds = this.fillBounds.clone();
                }
            };
            return DisplaySymbol;
        })(Symbol);
        Timeline.DisplaySymbol = DisplaySymbol;

        var ShapeSymbol = (function (_super) {
            __extends(ShapeSymbol, _super);
            function ShapeSymbol(id, symbolClass) {
                if (typeof symbolClass === "undefined") { symbolClass = flash.display.Shape; }
                _super.call(this, id, symbolClass, false);
                this.graphics = null;
            }
            ShapeSymbol.FromData = function (data, loaderInfo) {
                var symbol = new ShapeSymbol(data.id);
                symbol._setBoundsFromData(data);
                symbol.graphics = flash.display.Graphics.FromData(data);
                symbol.processRequires(data.require, loaderInfo);
                return symbol;
            };

            ShapeSymbol.prototype.processRequires = function (dependencies, loaderInfo) {
                if (!dependencies) {
                    return;
                }
                var textures = this.graphics.getUsedTextures();
                for (var i = 0; i < dependencies.length; i++) {
                    var bitmap = loaderInfo.getSymbolById(dependencies[i]);
                    release || assert(bitmap, "Bitmap symbol is not defined.");
                    var bitmapData = bitmap.symbolClass.initializeFrom(bitmap);
                    bitmap.symbolClass.instanceConstructorNoInitialize.call(bitmapData);
                    textures.push(bitmapData);
                }
            };
            return ShapeSymbol;
        })(DisplaySymbol);
        Timeline.ShapeSymbol = ShapeSymbol;

        var MorphShapeSymbol = (function (_super) {
            __extends(MorphShapeSymbol, _super);
            function MorphShapeSymbol(id) {
                _super.call(this, id, flash.display.MorphShape);
            }
            MorphShapeSymbol.FromData = function (data, loaderInfo) {
                var symbol = new MorphShapeSymbol(data.id);
                symbol._setBoundsFromData(data);
                symbol.graphics = flash.display.Graphics.FromData(data);
                symbol.processRequires(data.require, loaderInfo);
                symbol.morphFillBounds = data.morphFillBounds;
                symbol.morphLineBounds = data.morphLineBounds;
                return symbol;
            };
            return MorphShapeSymbol;
        })(ShapeSymbol);
        Timeline.MorphShapeSymbol = MorphShapeSymbol;

        var BitmapSymbol = (function (_super) {
            __extends(BitmapSymbol, _super);
            function BitmapSymbol(id) {
                _super.call(this, id, flash.display.BitmapData);
            }
            BitmapSymbol.FromData = function (data) {
                var symbol = new BitmapSymbol(data.id);
                symbol.width = data.width;
                symbol.height = data.height;
                symbol.data = data.data;
                switch (data.mimeType) {
                    case "application/octet-stream":
                        symbol.type = data.dataType;
                        break;
                    case "image/jpeg":
                        symbol.type = 4 /* JPEG */;
                        break;
                    case "image/png":
                        symbol.type = 5 /* PNG */;
                        break;
                    case "image/gif":
                        symbol.type = 6 /* GIF */;
                        break;
                    default:
                        notImplemented(data.mimeType);
                }
                return symbol;
            };
            return BitmapSymbol;
        })(DisplaySymbol);
        Timeline.BitmapSymbol = BitmapSymbol;

        var TextSymbol = (function (_super) {
            __extends(TextSymbol, _super);
            function TextSymbol(id) {
                _super.call(this, id, flash.text.TextField);
                this.color = 0;
                this.size = 0;
                this.font = "";
                this.fontClass = null;
                this.align = flash.text.TextFormatAlign.LEFT;
                this.leftMargin = 0;
                this.rightMargin = 0;
                this.indent = 0;
                this.leading = 0;
                this.multiline = false;
                this.wordWrap = false;
                this.embedFonts = false;
                this.selectable = true;
                this.border = false;
                this.initialText = "";
                this.html = false;
                this.displayAsPassword = false;
                this.type = flash.text.TextFieldType.DYNAMIC;
                this.maxChars = 0;
                this.autoSize = flash.text.TextFieldAutoSize.NONE;
                this.variableName = null;
                this.textContent = null;
            }
            TextSymbol.FromTextData = function (data) {
                var symbol = new TextSymbol(data.id);
                symbol._setBoundsFromData(data);
                var tag = data.tag;
                if (data.static) {
                    symbol.dynamic = false;
                    symbol.symbolClass = flash.text.StaticText;
                    if (tag.initialText) {
                        var textContent = new Shumway.TextContent();
                        textContent.bounds = symbol.lineBounds;
                        textContent.parseHtml(tag.initialText);
                        textContent.matrix = flash.geom.Matrix.FromUntyped(data.matrix);
                        textContent.coords = data.coords;
                        symbol.textContent = textContent;
                    }
                }
                if (tag.hasColor) {
                    symbol.color = tag.color >>> 8;
                }
                if (tag.hasFont) {
                    symbol.size = tag.fontHeight;
                    var font = flash.text.Font.getBySymbolId(tag.fontId);
                    if (font) {
                        symbol.font = font.fontName;
                        if (tag.fontClass) {
                            var appDomain = Shumway.AVM2.Runtime.AVM2.instance.applicationDomain;
                            symbol.fontClass = appDomain.getClass(tag.fontClass);
                        }
                    } else {
                        Shumway.Debug.warning("Font is not defined.");
                    }
                }
                if (tag.hasLayout) {
                    symbol.align = flash.text.TextFormatAlign.fromNumber(tag.align);
                    symbol.leftMargin = tag.leftMargin;
                    symbol.rightMargin = tag.rightMargin;
                    symbol.indent = tag.indent;
                    symbol.leading = tag.leading;
                }
                symbol.multiline = !!tag.multiline;
                symbol.wordWrap = !!tag.wordWrap;
                symbol.embedFonts = !!tag.useOutlines;
                symbol.selectable = !tag.noSelect;
                symbol.border = !!tag.border;
                if (tag.hasText) {
                    symbol.initialText = tag.initialText;
                }
                symbol.html = !!tag.html;
                symbol.displayAsPassword = !!tag.password;
                symbol.type = tag.readonly ? flash.text.TextFieldType.DYNAMIC : flash.text.TextFieldType.INPUT;
                if (tag.hasMaxLength) {
                    symbol.maxChars = tag.maxLength;
                }
                symbol.autoSize = tag.autoSize ? flash.text.TextFieldAutoSize.LEFT : flash.text.TextFieldAutoSize.NONE;
                symbol.variableName = tag.variableName;
                return symbol;
            };
            return TextSymbol;
        })(DisplaySymbol);
        Timeline.TextSymbol = TextSymbol;

        var ButtonSymbol = (function (_super) {
            __extends(ButtonSymbol, _super);
            function ButtonSymbol(id) {
                _super.call(this, id, flash.display.SimpleButton);
                this.upState = null;
                this.overState = null;
                this.downState = null;
                this.hitTestState = null;
            }
            ButtonSymbol.FromData = function (data, loaderInfo) {
                var symbol = new ButtonSymbol(data.id);
                if (loaderInfo.actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                    symbol.isAS2Object = true;
                    symbol.buttonActions = data.buttonActions;
                }
                var states = data.states;
                var character, matrix, colorTransform;
                for (var stateName in states) {
                    var commands = states[stateName];
                    if (commands.length === 1) {
                        var cmd = commands[0];
                        character = loaderInfo.getSymbolById(cmd.symbolId);
                        matrix = flash.geom.Matrix.FromUntyped(cmd.matrix);
                        if (cmd.cxform) {
                            colorTransform = flash.geom.ColorTransform.FromCXForm(cmd.cxform);
                        }
                    } else {
                        character = new Timeline.SpriteSymbol(-1);
                        character.frames.push(new FrameDelta(loaderInfo, commands));
                    }
                    symbol[stateName + 'State'] = new Timeline.AnimationState(character, 0, matrix, colorTransform);
                }
                return symbol;
            };
            return ButtonSymbol;
        })(DisplaySymbol);
        Timeline.ButtonSymbol = ButtonSymbol;

        var SpriteSymbol = (function (_super) {
            __extends(SpriteSymbol, _super);
            function SpriteSymbol(id, isRoot) {
                if (typeof isRoot === "undefined") { isRoot = false; }
                _super.call(this, id, flash.display.MovieClip);
                this.numFrames = 1;
                this.frames = [];
                this.labels = [];
                this.frameScripts = [];
                this.initActionBlock = null;
                this.isRoot = isRoot;
            }
            SpriteSymbol.FromData = function (data, loaderInfo) {
                var symbol = new SpriteSymbol(data.id);
                symbol.numFrames = data.frameCount;
                if (loaderInfo.actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                    symbol.isAS2Object = true;
                }
                symbol.frameScripts = data.frameScripts;
                var frames = data.frames;
                for (var i = 0; i < frames.length; i++) {
                    var frameInfo = frames[i];
                    var frame = new FrameDelta(loaderInfo, frameInfo.commands);
                    var repeat = frameInfo.repeat;
                    while (repeat--) {
                        symbol.frames.push(frame);
                    }
                    if (frameInfo.labelName) {
                        var frameNum = i + 1;
                        symbol.labels.push(new flash.display.FrameLabel(frameInfo.labelName, frameNum));
                    }
                    //if (frame.startSounds) {
                    //  startSoundRegistrations[frameNum] = frame.startSounds;
                    //}
                }
                return symbol;
            };
            return SpriteSymbol;
        })(DisplaySymbol);
        Timeline.SpriteSymbol = SpriteSymbol;

        // TODO: move this, and the other symbol classes, into better-suited files.
        var FontSymbol = (function (_super) {
            __extends(FontSymbol, _super);
            function FontSymbol(id) {
                _super.call(this, id, flash.text.Font);
                this.name = "";
                this.bold = false;
                this.italic = false;
            }
            FontSymbol.FromData = function (data) {
                var symbol = new FontSymbol(data.id);
                symbol.name = data.name;
                symbol.bold = data.bold;
                symbol.italic = data.italic;
                symbol.data = data.data;
                symbol.metrics = data.metrics;
                return symbol;
            };
            return FontSymbol;
        })(Symbol);
        Timeline.FontSymbol = FontSymbol;

        var SoundSymbol = (function (_super) {
            __extends(SoundSymbol, _super);
            function SoundSymbol(id) {
                _super.call(this, id, flash.media.Sound);
            }
            SoundSymbol.FromData = function (data) {
                var symbol = new SoundSymbol(data.id);
                symbol.channels = data.channels;
                symbol.sampleRate = data.sampleRate;
                symbol.pcm = data.pcm;
                symbol.packaged = data.packaged;
                return symbol;
            };
            return SoundSymbol;
        })(Symbol);
        Timeline.SoundSymbol = SoundSymbol;

        var BinarySymbol = (function (_super) {
            __extends(BinarySymbol, _super);
            function BinarySymbol(id) {
                _super.call(this, id, flash.utils.ByteArray);
            }
            BinarySymbol.FromData = function (data) {
                var symbol = new BinarySymbol(data.id);
                symbol.buffer = data.data;
                symbol.byteLength = data.data.byteLength;
                return symbol;
            };
            return BinarySymbol;
        })(Symbol);
        Timeline.BinarySymbol = BinarySymbol;

        /**
        * TODO document
        */
        var AnimationState = (function () {
            function AnimationState(symbol, depth, matrix, colorTransform, ratio, name, clipDepth, filters, blendMode, cacheAsBitmap, visible, events, variableName) {
                if (typeof symbol === "undefined") { symbol = null; }
                if (typeof depth === "undefined") { depth = 0; }
                if (typeof matrix === "undefined") { matrix = null; }
                if (typeof colorTransform === "undefined") { colorTransform = null; }
                if (typeof ratio === "undefined") { ratio = 0; }
                if (typeof name === "undefined") { name = null; }
                if (typeof clipDepth === "undefined") { clipDepth = -1; }
                if (typeof filters === "undefined") { filters = null; }
                if (typeof blendMode === "undefined") { blendMode = null; }
                if (typeof cacheAsBitmap === "undefined") { cacheAsBitmap = false; }
                if (typeof visible === "undefined") { visible = true; }
                if (typeof events === "undefined") { events = null; }
                if (typeof variableName === "undefined") { variableName = null; }
                this.symbol = symbol;
                this.depth = depth;
                this.matrix = matrix;
                this.colorTransform = colorTransform;
                this.ratio = ratio;
                this.name = name;
                this.clipDepth = clipDepth;
                this.filters = filters;
                this.blendMode = blendMode;
                this.cacheAsBitmap = cacheAsBitmap;
                this.visible = visible;
                this.events = events;
                this.variableName = variableName;
            }
            AnimationState.prototype.canBeAnimated = function (obj) {
                if (!obj._hasFlags(2048 /* AnimatedByTimeline */)) {
                    return false;
                }
                if (obj._depth !== this.depth) {
                    return false;
                }
                var symbol = this.symbol;
                if (symbol && obj._symbol !== symbol) {
                    if (symbol.dynamic) {
                        return false;
                    }
                    if (obj._clipDepth !== this.clipDepth) {
                        return false;
                    }
                    if (!symbol.symbolClass.isType(obj)) {
                        return false;
                    }
                }
                return true;
            };
            return AnimationState;
        })();
        Timeline.AnimationState = AnimationState;

        /**
        * TODO document
        */
        var FrameDelta = (function () {
            function FrameDelta(loaderInfo, commands) {
                this.loaderInfo = loaderInfo;
                this.commands = commands;
                this._stateAtDepth = null;
            }
            Object.defineProperty(FrameDelta.prototype, "stateAtDepth", {
                get: function () {
                    return this._stateAtDepth || this._initialize();
                },
                enumerable: true,
                configurable: true
            });

            FrameDelta.prototype._initialize = function () {
                var states = this._stateAtDepth = Object.create(null);
                var commands = this.commands;
                var loaderInfo = this.loaderInfo;
                for (var i = 0; i < commands.length; i++) {
                    var cmd = commands[i];
                    var depth = cmd.depth;
                    switch (cmd.code) {
                        case 5:
                        case 28:
                            states[depth] = null;
                            break;
                        default:
                            var symbol = null;
                            var matrix = null;
                            var colorTransform = null;
                            var filters = null;
                            var events = null;
                            if (cmd.symbolId) {
                                symbol = loaderInfo.getSymbolById(cmd.symbolId);
                                release || assert(symbol, "Symbol is not defined.");
                            }
                            if (cmd.flags & 4 /* HasMatrix */) {
                                matrix = flash.geom.Matrix.FromUntyped(cmd.matrix);
                            }
                            if (cmd.flags & 8 /* HasColorTransform */) {
                                colorTransform = flash.geom.ColorTransform.FromCXForm(cmd.cxform);
                            }
                            if (cmd.flags & 256 /* HasFilterList */) {
                                filters = [];
                                var swfFilters = cmd.filters;
                                for (var j = 0; j < swfFilters.length; j++) {
                                    var obj = swfFilters[j];
                                    var filter;
                                    switch (obj.type) {
                                        case 0:
                                            filter = flash.filters.DropShadowFilter.FromUntyped(obj);
                                            break;
                                        case 1:
                                            filter = flash.filters.BlurFilter.FromUntyped(obj);
                                            break;
                                        case 2:
                                            filter = flash.filters.GlowFilter.FromUntyped(obj);
                                            break;
                                        case 3:
                                            filter = flash.filters.BevelFilter.FromUntyped(obj);
                                            break;
                                        case 4:
                                            filter = flash.filters.GradientGlowFilter.FromUntyped(obj);
                                            break;
                                        case 5:
                                            filter = flash.filters.ConvolutionFilter.FromUntyped(obj);
                                            break;
                                        case 6:
                                            filter = flash.filters.ColorMatrixFilter.FromUntyped(obj);
                                            break;
                                        case 7:
                                            filter = flash.filters.GradientBevelFilter.FromUntyped(obj);
                                            break;
                                    }
                                    release || assert(filter, "Unknown filter type.");
                                    filters.push(filter);
                                }
                            }
                            if ((cmd.flags & 128 /* HasClipActions */) && loaderInfo._allowCodeExecution && loaderInfo._actionScriptVersion === ActionScriptVersion.ACTIONSCRIPT2) {
                                var swfEvents = cmd.events;
                                events = [];
                                for (var j = 0; j < swfEvents.length; j++) {
                                    var swfEvent = swfEvents[j];
                                    if (swfEvent.eoe) {
                                        break;
                                    }
                                    var actionsData = new Shumway.AVM1.AS2ActionsData(swfEvent.actionsData, 's' + cmd.symbolId + 'e' + j);
                                    var fn = (function (actionsData, loaderInfo) {
                                        return function () {
                                            var avm1Context = loaderInfo._avm1Context;
                                            var as2Object = Shumway.AVM1.getAS2Object(this);
                                            return avm1Context.executeActions(actionsData, this.stage, as2Object);
                                        };
                                    })(actionsData, loaderInfo);
                                    var eventNames = [];
                                    for (var eventName in swfEvent) {
                                        if (eventName.indexOf("on") !== 0 || !swfEvent[eventName]) {
                                            continue;
                                        }
                                        var avm2EventName = eventName[2].toLowerCase() + eventName.substring(3);
                                        if (avm2EventName === 'enterFrame') {
                                            avm2EventName = 'frameConstructed';
                                        }
                                        eventNames.push(avm2EventName);
                                    }
                                    events.push({
                                        eventNames: eventNames,
                                        handler: fn,
                                        keyPress: swfEvent.keyPress
                                    });
                                }
                            }
                            var state = new Timeline.AnimationState(symbol, depth, matrix, colorTransform, cmd.ratio, cmd.name, cmd.clipDepth, filters, flash.display.BlendMode.fromNumber(cmd.blendMode), !!(cmd.flags & 1024 /* HasCacheAsBitmap */), cmd.flags & 512 /* HasVisible */ ? !!cmd.visibility : true, events, cmd.variableName);
                            states[depth] = state;
                            break;
                    }
                }
                this.commands = null;
                return states;
            };
            return FrameDelta;
        })();
        Timeline.FrameDelta = FrameDelta;
    })(Shumway.Timeline || (Shumway.Timeline = {}));
    var Timeline = Shumway.Timeline;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        ///<reference path='references.ts' />
        (function (AS) {
            var throwError = Shumway.AVM2.Runtime.throwError;
            var flash = Shumway.AVM2.AS.flash;
            var Multiname = Shumway.AVM2.ABC.Multiname;

            var assert = Shumway.Debug.assert;

            function M(classSimpleName, nativeName, cls) {
                return {
                    classSimpleName: classSimpleName, nativeName: nativeName, cls: cls
                };
            }

            /**
            * Creates a self patching getter that lazily constructs the class and memoizes
            * to the class's instance constructor.
            */
            function makeStub(container, classSimpleName, shortName) {
                Object.defineProperty(container, shortName, {
                    get: function () {
                        release || assert(Shumway.AVM2.Runtime.AVM2.instance, "AVM2 needs to be initialized.");
                        var cls = Shumway.AVM2.Runtime.AVM2.instance.systemDomain.getClass(classSimpleName);
                        release || assert(cls.instanceConstructor);
                        Object.defineProperty(container, shortName, {
                            value: cls.instanceConstructor,
                            writable: false
                        });
                        return container[shortName];
                    },
                    configurable: true
                });
            }

            /* tslint:disable */
            jsGlobal["flash"] = Shumway.AVM2.AS.flash;

            /* tslint:enable */
            function linkNatives(runtime) {
                var symbols = [
                    M("flash.display.DisplayObject", "DisplayObjectClass", flash.display.DisplayObject),
                    M("flash.display.InteractiveObject", "InteractiveObjectClass", flash.display.InteractiveObject),
                    M("flash.display.DisplayObjectContainer", "ContainerClass", flash.display.DisplayObjectContainer),
                    M("flash.display.Sprite", "SpriteClass", flash.display.Sprite),
                    M("flash.display.MovieClip", "MovieClipClass", flash.display.MovieClip),
                    M("flash.display.Shape", "ShapeClass", flash.display.Shape),
                    M("flash.display.Bitmap", "BitmapClass", flash.display.Bitmap),
                    M("flash.display.BitmapData", "BitmapDataClass", flash.display.BitmapData),
                    M("flash.display.Stage", "StageClass", flash.display.Stage),
                    M("flash.display.Loader", "LoaderClass", flash.display.Loader),
                    M("flash.display.LoaderInfo", "LoaderInfoClass", flash.display.LoaderInfo),
                    M("flash.display.Graphics", "GraphicsClass", flash.display.Graphics),
                    M("flash.display.SimpleButton", "SimpleButtonClass", flash.display.SimpleButton),
                    M("flash.display.MorphShape", "MorphShapeClass", flash.display.MorphShape),
                    M("flash.display.NativeMenu", "MenuClass", flash.display.NativeMenu),
                    M("flash.display.NativeMenuItem", "MenuItemClass", flash.display.NativeMenuItem),
                    M("flash.display.FrameLabel", "FrameLabelClass", flash.display.FrameLabel),
                    M("flash.display.Scene", "SceneClass", flash.display.Scene),
                    M("flash.filters.BevelFilter", "BevelFilterClass", flash.filters.BevelFilter),
                    M("flash.filters.BitmapFilter", "BitmapFilterClass", flash.filters.BitmapFilter),
                    M("flash.filters.BlurFilter", "BlurFilterClass", flash.filters.BlurFilter),
                    M("flash.filters.ColorMatrixFilter", "ColorMatrixFilterClass", flash.filters.ColorMatrixFilter),
                    M("flash.filters.ConvolutionFilter", "ConvolutionFilterClass", flash.filters.ConvolutionFilter),
                    M("flash.filters.DisplacementMapFilter", "DisplacementMapFilterClass", flash.filters.DisplacementMapFilter),
                    M("flash.filters.DropShadowFilter", "DropShadowFilterClass", flash.filters.DropShadowFilter),
                    M("flash.filters.GlowFilter", "GlowFilterClass", flash.filters.GlowFilter),
                    M("flash.filters.GradientBevelFilter", "GradientBevelFilterClass", flash.filters.GradientBevelFilter),
                    M("flash.filters.GradientGlowFilter", "GradientGlowFilterClass", flash.filters.GradientGlowFilter),
                    M("flash.geom.Point", "PointClass", flash.geom.Point),
                    M("flash.geom.Rectangle", "RectangleClass", flash.geom.Rectangle),
                    M("flash.geom.Matrix", "MatrixClass", flash.geom.Matrix),
                    M("flash.geom.Matrix3D", "Matrix3DClass", flash.geom.Matrix3D),
                    M("flash.geom.Vector3D", "Vector3DClass", flash.geom.Vector3D),
                    M("flash.geom.Transform", "TransformClass", flash.geom.Transform),
                    M("flash.geom.ColorTransform", "ColorTransformClass", flash.geom.ColorTransform),
                    M("flash.events.EventDispatcher", "EventDispatcherClass", flash.events.EventDispatcher),
                    M("flash.events.Event", "EventClass", flash.events.Event),
                    M("flash.events.IOErrorEvent"),
                    M("flash.events.KeyboardEvent", "KeyboardEventClass", flash.events.KeyboardEvent),
                    M("flash.events.MouseEvent", "MouseEventClass", flash.events.MouseEvent),
                    M("flash.events.GestureEvent", "GestureEventClass", flash.events.GestureEvent),
                    M("flash.events.TextEvent", "TextEventClass", flash.events.TextEvent),
                    M("flash.events.TimerEvent", "TimerEventClass", flash.events.TimerEvent),
                    M("flash.events.ProgressEvent", "ProgressEventClass", flash.events.ProgressEvent),
                    M("flash.events.NetStatusEvent"),
                    M("flash.events.HTTPStatusEvent"),
                    M("flash.external.ExternalInterface", "ExternalInterfaceClass", flash.external.ExternalInterface),
                    M("flash.ui.ContextMenu", "ContextMenuClass", flash.ui.ContextMenu),
                    M("flash.ui.ContextMenuItem", "ContextMenuItemClass", flash.ui.ContextMenuItem),
                    M("flash.ui.Keyboard", "KeyboardClass", flash.ui.Keyboard),
                    M("flash.ui.Mouse", "MouseClass", flash.ui.Mouse),
                    M("flash.ui.MouseCursorData", "MouseCursorDataClass", flash.ui.MouseCursorData),
                    M("flash.ui.GameInput", "GameInputClass", flash.ui.GameInput),
                    M("flash.events.GameInputEvent", "GameInputEventClass", flash.events.GameInputEvent),
                    M("flash.ui.GameInputControl", "GameInputControlClass", flash.ui.GameInputControl),
                    M("flash.ui.GameInputControlType", "GameInputControlTypeClass", flash.ui.GameInputControlType),
                    M("flash.ui.GameInputDevice", "GameInputDeviceClass", flash.ui.GameInputDevice),
                    M("flash.ui.GameInputFinger", "GameInputFingerClass", flash.ui.GameInputFinger),
                    M("flash.ui.GameInputHand", "GameInputHandClass", flash.ui.GameInputHand),
                    M("flash.ui.Multitouch", "MultitouchClass", flash.ui.Multitouch),
                    M("flash.ui.MultitouchInputMode", "MultitouchInputModeClass", flash.ui.MultitouchInputMode),
                    M("flash.events.TouchEvent", "TouchEventClass", flash.events.TouchEvent),
                    M("flash.text.Font", "FontClass", flash.text.Font),
                    M("flash.text.TextField", "TextFieldClass", flash.text.TextField),
                    M("flash.text.StaticText", "StaticTextClass", flash.text.StaticText),
                    M("flash.text.StyleSheet", "StyleSheetClass", flash.text.StyleSheet),
                    M("flash.text.TextFormat", "TextFormatClass", flash.text.TextFormat),
                    M("flash.text.TextRun", "TextRunClass", flash.text.TextRun),
                    M("flash.text.TextLineMetrics"),
                    M("flash.media.Sound", "SoundClass", flash.media.Sound),
                    M("flash.media.SoundChannel", "SoundChannelClass", flash.media.SoundChannel),
                    M("flash.media.SoundMixer", "SoundMixerClass", flash.media.SoundMixer),
                    M("flash.media.SoundTransform", "SoundTransformClass", flash.media.SoundTransform),
                    M("flash.media.Video", "VideoClass", flash.media.Video),
                    M("flash.media.ID3Info", "ID3InfoClass", flash.media.ID3Info),
                    M("flash.media.Microphone", "MicrophoneClass", flash.media.Microphone),
                    M("flash.net.FileFilter", "FileFilterClass", flash.net.FileFilter),
                    M("flash.net.NetConnection", "NetConnectionClass", flash.net.NetConnection),
                    M("flash.net.NetStream", "NetStreamClass", flash.net.NetStream),
                    M("flash.net.Responder", "ResponderClass", flash.net.Responder),
                    M("flash.net.URLRequest", "URLRequestClass", flash.net.URLRequest),
                    M("flash.net.URLRequestHeader"),
                    M("flash.net.URLStream", "URLStreamClass", flash.net.URLStream),
                    M("flash.net.URLLoader", "URLLoaderClass", flash.net.URLLoader),
                    M("flash.net.SharedObject", "SharedObjectClass", flash.net.SharedObject),
                    M("flash.net.ObjectEncoding", "ObjectEncodingClass", flash.net.ObjectEncoding),
                    M("flash.net.LocalConnection", "LocalConnectionClass", flash.net.LocalConnection),
                    M("flash.net.Socket", "SocketClass", flash.net.Socket),
                    M("flash.net.URLVariables", "URLVariablesClass", flash.net.URLVariables),
                    M("packageInternal flash.system.FSCommand", "FSCommandClass", flash.system.FSCommand),
                    M("flash.system.Capabilities", "CapabilitiesClass", flash.system.Capabilities),
                    M("flash.system.Security", "SecurityClass", flash.system.Security),
                    M("flash.system.SecurityDomain", "SecurityDomainClass", flash.system.SecurityDomain),
                    M("flash.system.ApplicationDomain", "ApplicationDomainClass", flash.system.ApplicationDomain),
                    M("flash.system.JPEGLoaderContext", "JPEGLoaderContextClass", flash.system.JPEGLoaderContext),
                    M("flash.accessibility.Accessibility", "AccessibilityClass", flash.accessibility.Accessibility),
                    M("flash.utils.Timer", "TimerClass", flash.utils.Timer),
                    M("flash.utils.ByteArray", "ByteArrayClass", flash.utils.ByteArray),
                    M("avm1lib.AS2Utils", "AS2Utils", Shumway.AVM1.AS2Utils),
                    M("avm1lib.AS2Broadcaster"),
                    M("avm1lib.AS2Key"),
                    M("avm1lib.AS2Mouse"),
                    M("avm1lib.AS2MovieClip", "AS2MovieClip", Shumway.AVM2.AS.avm1lib.AS2MovieClip),
                    M("avm1lib.AS2BitmapData", "AS2BitmapData", Shumway.AVM2.AS.avm1lib.AS2BitmapData),
                    M("avm1lib.AS2Button", "AS2Button", Shumway.AVM2.AS.avm1lib.AS2Button),
                    M("avm1lib.AS2Sound"),
                    M("avm1lib.AS2TextField", "AS2TextField", Shumway.AVM2.AS.avm1lib.AS2TextField),
                    M("avm1lib.AS2Stage"),
                    M("avm1lib.AS2System"),
                    M("avm1lib.AS2Color"),
                    M("avm1lib.AS2Globals", "AS2Globals", Shumway.AVM2.AS.avm1lib.AS2Globals),
                    M("avm1lib.AS2MovieClipLoader", "AS2MovieClipLoader", Shumway.AVM2.AS.avm1lib.AS2MovieClipLoader)
                ];

                symbols.forEach(function (s) {
                    var className = Multiname.fromSimpleName(s.classSimpleName);
                    var path = className.getOriginalName().split(".");
                    var container = Shumway.AVM2.AS;
                    for (var i = 0, j = path.length - 1; i < j; i++) {
                        if (!container[path[i]]) {
                            container[path[i]] = {};
                        }
                        container = container[path[i]];
                    }
                    makeStub(container, s.classSimpleName, path[path.length - 1]);
                    AS.registerNativeClass(s.nativeName, s.cls);
                });

                AS.registerNativeFunction('FlashUtilScript::getDefinitionByName', Shumway.AVM2.AS.Natives.getDefinitionByName);

                var start = Date.now();
                AS.registerNativeFunction('FlashUtilScript::getTimer', function getTimer() {
                    return Date.now() - start;
                });

                AS.registerNativeFunction('FlashUtilScript::escapeMultiByte', escape);
                AS.registerNativeFunction('FlashUtilScript::unescapeMultiByte', unescape);

                AS.registerNativeFunction('FlashNetScript::navigateToURL', function navigateToURL(request, window_) {
                    if (request === null || request === undefined) {
                        throwError('TypeError', AVM2.Errors.NullPointerError, 'request');
                    }
                    var RequestClass = Shumway.AVM2.Runtime.AVM2.instance.systemDomain.getClass("flash.net.URLRequest");
                    if (!RequestClass.isInstanceOf(request)) {
                        throwError('TypeError', AVM2.Errors.CheckTypeFailedError, request, 'flash.net.URLRequest');
                    }
                    var url = request.url;
                    if (/^fscommand:/i.test(url)) {
                        var fscommand = Shumway.AVM2.Runtime.AVM2.instance.applicationDomain.getProperty(Multiname.fromSimpleName('flash.system.fscommand'), true, true);
                        fscommand.call(null, url.substring('fscommand:'.length), window_);
                        return;
                    }

                    // TODO handle other methods than GET
                    var targetWindow = window_ || '_parent';
                    window.open(Shumway.FileLoadingService.instance.resolveUrl(url), targetWindow);
                });

                AS.registerNativeFunction('FlashNetScript::sendToURL', function sendToURL(request) {
                    if (request === null || request === undefined) {
                        throwError('TypeError', AVM2.Errors.NullPointerError, 'request');
                    }
                    var RequestClass = Shumway.AVM2.Runtime.AVM2.instance.systemDomain.getClass("flash.net.URLRequest");
                    if (!RequestClass.isInstanceOf(request)) {
                        throwError('TypeError', AVM2.Errors.CheckTypeFailedError, request, 'flash.net.URLRequest');
                    }
                    var session = Shumway.FileLoadingService.instance.createSession();
                    session.onprogress = function () {
                        // ...
                    };
                    session.open(request);
                });

                AS.registerNativeFunction('Toplevel::registerClassAlias', function registerClassAlias(aliasName, classObject) {
                    if (!aliasName) {
                        throwError('TypeError', AVM2.Errors.NullPointerError, 'aliasName');
                    }
                    if (!classObject) {
                        throwError('TypeError', AVM2.Errors.NullPointerError, 'classObject');
                    }

                    AMFUtils.aliasesCache.classes.set(classObject, aliasName);
                    AMFUtils.aliasesCache.names[aliasName] = classObject;
                });

                AS.registerNativeFunction('Toplevel::getClassByAlias', function getClassByAlias(aliasName) {
                    if (!aliasName) {
                        throwError('TypeError', AVM2.Errors.NullPointerError, 'aliasName');
                    }

                    var classObject = AMFUtils.aliasesCache.names[aliasName];
                    if (!classObject) {
                        throwError('ReferenceError', AVM2.Errors.ClassNotFoundError, aliasName);
                    }
                    return classObject;
                });

                AS.registerNativeFunction('isFinite', isFinite);
            }
            AS.linkNatives = linkNatives;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/avm2.d.ts' />
/// <reference path='../../build/ts/swf.d.ts' />
///<reference path='../htmlparser.ts' />
///<reference path='../TextContent.ts' />
///<reference path='geom/Matrix.ts' />
///<reference path='geom/Matrix3D.ts' />
///<reference path='geom/Orientation3D.ts' />
///<reference path='geom/PerspectiveProjection.ts' />
///<reference path='geom/Point.ts' />
///<reference path='geom/Rectangle.ts' />
///<reference path='geom/Transform.ts' />
///<reference path='geom/Utils3D.ts' />
///<reference path='geom/Vector3D.ts' />
///<reference path='accessibility/Accessibility.ts' />
///<reference path='accessibility/AccessibilityImplementation.ts' />
///<reference path='accessibility/AccessibilityProperties.ts' />
// ///<reference path='accessibility/ISearchableText.ts' />
// ///<reference path='accessibility/ISimpleTextSelection.ts' />
// ///<reference path='automation/ActionGenerator.ts' />
// ///<reference path='automation/AutomationAction.ts' />
// ///<reference path='automation/Configuration.ts' />
// ///<reference path='automation/KeyboardAutomationAction.ts' />
// ///<reference path='automation/MouseAutomationAction.ts' />
// ///<reference path='automation/StageCapture.ts' />
// ///<reference path='automation/StageCaptureEvent.ts' />
// ///<reference path='desktop/Clipboard.ts' />
// ///<reference path='desktop/ClipboardFormats.ts' />
// ///<reference path='desktop/ClipboardTransferMode.ts' />
///<reference path='events/Event.ts' />
///<reference path='events/EventDispatcher.ts' />
///<reference path='events/EventPhase.ts' />
// ///<reference path='events/AccelerometerEvent.ts' />
// ///<reference path='events/ActivityEvent.ts' />
// ///<reference path='events/AsyncErrorEvent.ts' />
// ///<reference path='events/ContextMenuEvent.ts' />
// ///<reference path='events/DataEvent.ts' />
///<reference path='events/TextEvent.ts' />
///<reference path='events/ErrorEvent.ts' />
// ///<reference path='events/FocusEvent.ts' />
// ///<reference path='events/FullScreenEvent.ts' />
///<reference path='events/GameInputEvent.ts' />
// ///<reference path='events/GeolocationEvent.ts' />
///<reference path='events/GestureEvent.ts' />
// ///<reference path='events/GesturePhase.ts' />
///<reference path='events/HTTPStatusEvent.ts' />
///<reference path='events/IEventDispatcher.ts' />
// ///<reference path='events/IMEEvent.ts' />
///<reference path='events/IOErrorEvent.ts' />
///<reference path='events/KeyboardEvent.ts' />
///<reference path='events/MouseEvent.ts' />
// ///<reference path='events/NetDataEvent.ts' />
// ///<reference path='events/NetFilterEvent.ts' />
// ///<reference path='events/NetMonitorEvent.ts' />
///<reference path='events/NetStatusEvent.ts' />
// ///<reference path='events/OutputProgressEvent.ts' />
// ///<reference path='events/PressAndTapGestureEvent.ts' />
///<reference path='events/ProgressEvent.ts' />
// ///<reference path='events/SampleDataEvent.ts' />
///<reference path='events/SecurityErrorEvent.ts' />
// ///<reference path='events/ShaderEvent.ts' />
// ///<reference path='events/SoftKeyboardEvent.ts' />
// ///<reference path='events/SoftKeyboardTrigger.ts' />
// ///<reference path='events/StageVideoAvailabilityEvent.ts' />
// ///<reference path='events/StageVideoEvent.ts' />
// ///<reference path='events/StatusEvent.ts' />
// ///<reference path='events/SyncEvent.ts' />
// ///<reference path='events/ThrottleEvent.ts' />
// ///<reference path='events/ThrottleType.ts' />
///<reference path='events/TimerEvent.ts' />
///<reference path='events/TouchEvent.ts' />
// ///<reference path='events/TransformGestureEvent.ts' />
///<reference path='events/UncaughtErrorEvent.ts' />
///<reference path='events/UncaughtErrorEvents.ts' />
// ///<reference path='events/VideoEvent.ts' />
///<reference path='display/DisplayObject.ts' />
///<reference path='display/Bitmap.ts' />
///<reference path='display/Shape.ts' />
///<reference path='display/InteractiveObject.ts' />
///<reference path='display/SimpleButton.ts' />
///<reference path='display/DisplayObjectContainer.ts' />
///<reference path='display/JointStyle.ts' />
///<reference path='display/CapsStyle.ts' />
///<reference path='display/LineScaleMode.ts' />
///<reference path='display/GradientType.ts' />
///<reference path='display/SpreadMethod.ts' />
///<reference path='display/InterpolationMethod.ts' />
///<reference path='display/GraphicsBitmapFill.ts' />
///<reference path='display/GraphicsEndFill.ts' />
///<reference path='display/GraphicsGradientFill.ts' />
///<reference path='display/GraphicsPath.ts' />
///<reference path='display/GraphicsPathCommand.ts' />
///<reference path='display/GraphicsPathWinding.ts' />
// ///<reference path='display/GraphicsShaderFill.ts' />
///<reference path='display/GraphicsSolidFill.ts' />
///<reference path='display/GraphicsStroke.ts' />
///<reference path='display/GraphicsTrianglePath.ts' />
///<reference path='display/IDrawCommand.ts' />
///<reference path='display/IGraphicsData.ts' />
///<reference path='display/IGraphicsFill.ts' />
///<reference path='display/IGraphicsPath.ts' />
///<reference path='display/IGraphicsStroke.ts' />
///<reference path='display/Graphics.ts' />
///<reference path='display/Sprite.ts' />
///<reference path='display/MovieClip.ts' />
///<reference path='display/MovieClipSoundStream.ts' />
///<reference path='display/Stage.ts' />
///<reference path='display/ActionScriptVersion.ts' />
///<reference path='display/BlendMode.ts' />
///<reference path='display/ColorCorrection.ts' />
///<reference path='display/ColorCorrectionSupport.ts' />
///<reference path='display/FocusDirection.ts' />
///<reference path='display/FrameLabel.ts' />
///<reference path='display/BitmapData.ts' />
///<reference path='display/BitmapDataChannel.ts' />
///<reference path='display/BitmapEncodingColorSpace.ts' />
///<reference path='display/IBitmapDrawable.ts' />
///<reference path='display/JPEGEncoderOptions.ts' />
// ///<reference path='display/JPEGXREncoderOptions.ts' />
///<reference path='display/Loader.ts' />
///<reference path='display/LoaderInfo.ts' />
///<reference path='display/MorphShape.ts' />
///<reference path='display/NativeMenu.ts' />
///<reference path='display/NativeMenuItem.ts' />
///<reference path='display/PNGEncoderOptions.ts' />
///<reference path='display/PixelSnapping.ts' />
///<reference path='display/SWFVersion.ts' />
///<reference path='display/Scene.ts' />
// ///<reference path='display/Shader.ts' />
// ///<reference path='display/ShaderData.ts' />
// ///<reference path='display/ShaderInput.ts' />
// ///<reference path='display/ShaderJob.ts' />
// ///<reference path='display/ShaderParameter.ts' />
// ///<reference path='display/ShaderParameterType.ts' />
// ///<reference path='display/ShaderPrecision.ts' />
// ///<reference path='display/Stage3D.ts' />
///<reference path='display/StageAlign.ts' />
///<reference path='display/StageDisplayState.ts' />
///<reference path='display/StageQuality.ts' />
///<reference path='display/StageScaleMode.ts' />
///<reference path='display/TriangleCulling.ts' />
///<reference path='display/AVM1Movie.ts' />
// ///<reference path='display3D/Context3D.ts' />
// ///<reference path='display3D/Context3DBlendFactor.ts' />
// ///<reference path='display3D/Context3DClearMask.ts' />
// ///<reference path='display3D/Context3DCompareMode.ts' />
// ///<reference path='display3D/Context3DProfile.ts' />
// ///<reference path='display3D/Context3DProgramType.ts' />
// ///<reference path='display3D/Context3DRenderMode.ts' />
// ///<reference path='display3D/Context3DStencilAction.ts' />
// ///<reference path='display3D/Context3DTextureFormat.ts' />
// ///<reference path='display3D/Context3DTriangleFace.ts' />
// ///<reference path='display3D/Context3DVertexBufferFormat.ts' />
// ///<reference path='display3D/IndexBuffer3D.ts' />
// ///<reference path='display3D/Program3D.ts' />
// ///<reference path='display3D/VertexBuffer3D.ts' />
// ///<reference path='display3D/textures/CubeTexture.ts' />
// ///<reference path='display3D/textures/Texture.ts' />
// ///<reference path='display3D/textures/TextureBase.ts' />
// ///<reference path='errors/EOFError.ts' />
// ///<reference path='errors/IOError.ts' />
// ///<reference path='errors/IllegalOperationError.ts' />
// ///<reference path='errors/InvalidSWFError.ts' />
// ///<reference path='errors/MemoryError.ts' />
// ///<reference path='errors/ScriptTimeoutError.ts' />
// ///<reference path='errors/StackOverflowError.ts' />
///<reference path='external/ExternalInterface.ts' />
///<reference path='filters/BitmapFilterQuality.ts' />
///<reference path='filters/BitmapFilterType.ts' />
///<reference path='filters/BitmapFilter.ts' />
///<reference path='filters/BevelFilter.ts' />
///<reference path='filters/BlurFilter.ts' />
///<reference path='filters/ColorMatrixFilter.ts' />
///<reference path='filters/ConvolutionFilter.ts' />
///<reference path='filters/DisplacementMapFilterMode.ts' />
///<reference path='filters/DisplacementMapFilter.ts' />
///<reference path='filters/DropShadowFilter.ts' />
///<reference path='filters/GlowFilter.ts' />
///<reference path='filters/GradientBevelFilter.ts' />
///<reference path='filters/GradientGlowFilter.ts' />
// ///<reference path='filters/ShaderFilter.ts' />
///<reference path='geom/ColorTransform.ts' />
// ///<reference path='globalization/Collator.ts' />
// ///<reference path='globalization/CollatorMode.ts' />
// ///<reference path='globalization/CurrencyFormatter.ts' />
// ///<reference path='globalization/CurrencyParseResult.ts' />
// ///<reference path='globalization/DateTimeFormatter.ts' />
// ///<reference path='globalization/DateTimeNameContext.ts' />
// ///<reference path='globalization/DateTimeNameStyle.ts' />
// ///<reference path='globalization/DateTimeStyle.ts' />
// ///<reference path='globalization/LastOperationStatus.ts' />
// ///<reference path='globalization/LocaleID.ts' />
// ///<reference path='globalization/NationalDigitsType.ts' />
// ///<reference path='globalization/NumberFormatter.ts' />
// ///<reference path='globalization/NumberParseResult.ts' />
// ///<reference path='globalization/StringTools.ts' />
// ///<reference path='media/AudioDecoder.ts' />
///<reference path='media/Camera.ts' />
// ///<reference path='media/H264Level.ts' />
// ///<reference path='media/H264Profile.ts' />
// ///<reference path='media/H264VideoStreamSettings.ts' />
///<reference path='media/ID3Info.ts' />
///<reference path='media/Microphone.ts' />
// ///<reference path='media/MicrophoneEnhancedMode.ts' />
// ///<reference path='media/MicrophoneEnhancedOptions.ts' />
///<reference path='media/Sound.ts' />
///<reference path='media/SoundChannel.ts' />
// ///<reference path='media/SoundCodec.ts' />
///<reference path='media/SoundLoaderContext.ts' />
///<reference path='media/SoundMixer.ts' />
///<reference path='media/SoundTransform.ts' />
// ///<reference path='media/StageVideo.ts' />
// ///<reference path='media/StageVideoAvailability.ts' />
///<reference path='media/Video.ts' />
// ///<reference path='media/VideoCodec.ts' />
// ///<reference path='media/VideoStatus.ts' />
///<reference path='media/VideoStreamSettings.ts' />
// ///<reference path='net/DynamicPropertyOutput.ts' />
///<reference path='net/FileFilter.ts' />
// ///<reference path='net/FileReference.ts' />
// ///<reference path='net/FileReferenceList.ts' />
// ///<reference path='net/GroupSpecifier.ts' />
// ///<reference path='net/IDynamicPropertyOutput.ts' />
// ///<reference path='net/IDynamicPropertyWriter.ts' />
///<reference path='net/LocalConnection.ts' />
///<reference path='net/NetConnection.ts' />
// ///<reference path='net/NetGroup.ts' />
// ///<reference path='net/NetGroupInfo.ts' />
// ///<reference path='net/NetGroupReceiveMode.ts' />
// ///<reference path='net/NetGroupReplicationStrategy.ts' />
// ///<reference path='net/NetGroupSendMode.ts' />
// ///<reference path='net/NetGroupSendResult.ts' />
// ///<reference path='net/NetMonitor.ts' />
///<reference path='net/NetStream.ts' />
// ///<reference path='net/NetStreamAppendBytesAction.ts' />
///<reference path='net/NetStreamInfo.ts' />
///<reference path='net/NetStreamMulticastInfo.ts' />
///<reference path='net/NetStreamPlayOptions.ts' />
// ///<reference path='net/NetStreamPlayTransitions.ts' />
///<reference path='net/Responder.ts' />
// ///<reference path='net/SecureSocket.ts' />
///<reference path='net/SharedObject.ts' />
// ///<reference path='net/SharedObjectFlushStatus.ts' />
///<reference path='net/Socket.ts' />
///<reference path='net/URLLoader.ts' />
// ///<reference path='net/URLLoaderDataFormat.ts' />
///<reference path='net/URLRequest.ts' />
///<reference path='net/URLRequestHeader.ts' />
// ///<reference path='net/URLRequestMethod.ts' />
///<reference path='net/URLStream.ts' />
///<reference path='net/URLVariables.ts' />
// ///<reference path='net/XMLSocket.ts' />
// ///<reference path='printing/PrintJob.ts' />
// ///<reference path='printing/PrintJobOptions.ts' />
// ///<reference path='printing/PrintJobOrientation.ts' />
// ///<reference path='profiler/Telemetry.ts' />
// ///<reference path='sampler/ClassFactory.ts' />
// ///<reference path='sampler/DeleteObjectSample.ts' />
// ///<reference path='sampler/NewObjectSample.ts' />
// ///<reference path='sampler/Sample.ts' />
// ///<reference path='sampler/StackFrame.ts' />
// ///<reference path='security/CertificateStatus.ts' />
// ///<reference path='security/X500DistinguishedName.ts' />
// ///<reference path='security/X509Certificate.ts' />
///<reference path='sensors/Accelerometer.ts' />
///<reference path='sensors/Geolocation.ts' />
///<reference path='system/ApplicationDomain.ts' />
// ///<reference path='system/ApplicationInstaller.ts' />
// ///<reference path='system/AuthorizedFeatures.ts' />
// ///<reference path='system/AuthorizedFeaturesLoader.ts' />
///<reference path='system/Capabilities.ts' />
// ///<reference path='system/DomainMemoryWithStage3D.ts' />
///<reference path='system/FSCommand.ts' />
// ///<reference path='system/IMEConversionMode.ts' />
///<reference path='system/ImageDecodingPolicy.ts' />
///<reference path='system/LoaderContext.ts' />
///<reference path='system/JPEGLoaderContext.ts' />
///<reference path='system/MessageChannel.ts' />
///<reference path='system/MessageChannelState.ts' />
///<reference path='system/Security.ts' />
///<reference path='system/SecurityDomain.ts' />
///<reference path='system/SecurityPanel.ts' />
// ///<reference path='system/SystemUpdaterType.ts' />
///<reference path='system/TouchscreenType.ts' />
///<reference path='text/AntiAliasType.ts' />
// ///<reference path='text/CSMSettings.ts' />
///<reference path='text/FontStyle.ts' />
///<reference path='text/FontType.ts' />
///<reference path='text/Font.ts' />
///<reference path='text/GridFitType.ts' />
///<reference path='text/StaticText.ts' />
///<reference path='text/StyleSheet.ts' />
// ///<reference path='text/TextColorType.ts' />
///<reference path='text/TextDisplayMode.ts' />
// ///<reference path='text/TextExtent.ts' />
///<reference path='text/TextField.ts' />
///<reference path='text/TextFieldAutoSize.ts' />
///<reference path='text/TextFieldType.ts' />
///<reference path='text/TextFormat.ts' />
///<reference path='text/TextFormatAlign.ts' />
///<reference path='text/TextFormatDisplay.ts' />
///<reference path='text/TextInteractionMode.ts' />
///<reference path='text/TextLineMetrics.ts' />
// ///<reference path='text/TextRenderer.ts' />
///<reference path='text/TextRun.ts' />
///<reference path='text/TextSnapshot.ts' />
// ///<reference path='text/engine/BreakOpportunity.ts' />
// ///<reference path='text/engine/CFFHinting.ts' />
// ///<reference path='text/engine/ContentElement.ts' />
// ///<reference path='text/engine/DigitCase.ts' />
// ///<reference path='text/engine/DigitWidth.ts' />
// ///<reference path='text/engine/EastAsianJustifier.ts' />
// ///<reference path='text/engine/ElementFormat.ts' />
// ///<reference path='text/engine/FontDescription.ts' />
// ///<reference path='text/engine/FontLookup.ts' />
// ///<reference path='text/engine/FontMetrics.ts' />
// ///<reference path='text/engine/FontPosture.ts' />
// ///<reference path='text/engine/FontWeight.ts' />
// ///<reference path='text/engine/GraphicElement.ts' />
// ///<reference path='text/engine/GroupElement.ts' />
// ///<reference path='text/engine/JustificationStyle.ts' />
// ///<reference path='text/engine/Kerning.ts' />
// ///<reference path='text/engine/LigatureLevel.ts' />
// ///<reference path='text/engine/LineJustification.ts' />
// ///<reference path='text/engine/RenderingMode.ts' />
// ///<reference path='text/engine/TextJustifier.ts' />
// ///<reference path='text/engine/SpaceJustifier.ts' />
// ///<reference path='text/engine/TabAlignment.ts' />
// ///<reference path='text/engine/TabStop.ts' />
// ///<reference path='text/engine/TextBaseline.ts' />
// ///<reference path='text/engine/TextBlock.ts' />
// ///<reference path='text/engine/TextElement.ts' />
// ///<reference path='text/engine/TextLine.ts' />
// ///<reference path='text/engine/TextLineCreationResult.ts' />
// ///<reference path='text/engine/TextLineMirrorRegion.ts' />
// ///<reference path='text/engine/TextLineValidity.ts' />
// ///<reference path='text/engine/TextRotation.ts' />
// ///<reference path='text/engine/TypographicCase.ts' />
// ///<reference path='text/ime/CompositionAttributeRange.ts' />
// ///<reference path='text/ime/IIMEClient.ts' />
///<reference path='trace/Trace.ts' />
///<reference path='ui/ContextMenu.ts' />
///<reference path='ui/ContextMenuBuiltInItems.ts' />
///<reference path='ui/ContextMenuClipboardItems.ts' />
///<reference path='ui/ContextMenuItem.ts' />
///<reference path='ui/GameInput.ts' />
///<reference path='ui/GameInputControl.ts' />
///<reference path='ui/GameInputControlType.ts' />
///<reference path='ui/GameInputDevice.ts' />
///<reference path='ui/GameInputFinger.ts' />
///<reference path='ui/GameInputHand.ts' />
// ///<reference path='ui/KeyLocation.ts' />
///<reference path='ui/Keyboard.ts' />
// ///<reference path='ui/KeyboardType.ts' />
///<reference path='ui/Mouse.ts' />
// ///<reference path='ui/MouseCursor.ts' />
///<reference path='ui/MouseCursorData.ts' />
///<reference path='ui/Multitouch.ts' />
///<reference path='ui/MultitouchInputMode.ts' />
// ///<reference path='utils/CompressionAlgorithm.ts' />
///<reference path='utils/Endian.ts' />
///<reference path='utils/IDataInput2.ts' />
///<reference path='utils/IDataOutput2.ts' />
///<reference path='utils/IExternalizable.ts' />
///<reference path='utils/ObjectInput.ts' />
///<reference path='utils/ObjectOutput.ts' />
///<reference path='utils/Timer.ts' />
///<reference path='utils/SetIntervalTimer.ts' />
///<reference path='xml/XMLNode.ts' />
///<reference path='xml/XMLDocument.ts' />
///<reference path='xml/XMLNodeType.ts' />
///<reference path='xml/XMLParser.ts' />
///<reference path='xml/XMLTag.ts' />
///<reference path='avm1.d.ts' />
///<reference path='../player/timeline.ts' />
///<reference path='linker.ts' />
//# sourceMappingURL=flash.js.map

console.timeEnd("Load Flash TS Dependencies");
// Load AVM1 Dependencies
console.time("Load AVM1 Dependencies");
var Shumway;
(function (Shumway) {
    /*
    * Copyright 2014 Mozilla Foundation
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    (function (AVM1) {
        var ActionsDataStream = (function () {
            function ActionsDataStream(array, swfVersion) {
                this.array = array;
                this.position = 0;
                this.end = array.length;

                // TODO use system locale to determine if the shift-JIS
                // decoding is necessary
                this.readANSI = swfVersion < 6;

                // endianess sanity check
                var buffer = new ArrayBuffer(4);
                (new Int32Array(buffer))[0] = 1;
                if (!(new Uint8Array(buffer))[0]) {
                    throw new Error("big-endian platform");
                }
            }
            ActionsDataStream.prototype.readUI8 = function () {
                return this.array[this.position++];
            };
            ActionsDataStream.prototype.readUI16 = function () {
                var position = this.position, array = this.array;
                var value = (array[position + 1] << 8) | array[position];
                this.position = position + 2;
                return value;
            };
            ActionsDataStream.prototype.readSI16 = function () {
                var position = this.position, array = this.array;
                var value = (array[position + 1] << 8) | array[position];
                this.position = position + 2;
                return value < 0x8000 ? value : (value - 0x10000);
            };
            ActionsDataStream.prototype.readInteger = function () {
                var position = this.position, array = this.array;
                var value = array[position] | (array[position + 1] << 8) | (array[position + 2] << 16) | (array[position + 3] << 24);
                this.position = position + 4;
                return value;
            };
            ActionsDataStream.prototype.readFloat = function () {
                var position = this.position;
                var array = this.array;
                var buffer = new ArrayBuffer(4);
                var bytes = new Uint8Array(buffer);
                bytes[0] = array[position];
                bytes[1] = array[position + 1];
                bytes[2] = array[position + 2];
                bytes[3] = array[position + 3];
                this.position = position + 4;
                return (new Float32Array(buffer))[0];
            };
            ActionsDataStream.prototype.readDouble = function () {
                var position = this.position;
                var array = this.array;
                var buffer = new ArrayBuffer(8);
                var bytes = new Uint8Array(buffer);
                bytes[4] = array[position];
                bytes[5] = array[position + 1];
                bytes[6] = array[position + 2];
                bytes[7] = array[position + 3];
                bytes[0] = array[position + 4];
                bytes[1] = array[position + 5];
                bytes[2] = array[position + 6];
                bytes[3] = array[position + 7];
                this.position = position + 8;
                return (new Float64Array(buffer))[0];
            };
            ActionsDataStream.prototype.readBoolean = function () {
                return !!this.readUI8();
            };
            ActionsDataStream.prototype.readANSIString = function () {
                var value = '';
                var ch;
                while ((ch = this.readUI8())) {
                    value += String.fromCharCode(ch);
                }
                return value;
            };
            ActionsDataStream.prototype.readUTF8String = function () {
                var value = '';
                var ch;
                while ((ch = this.readUI8())) {
                    if (ch < 0x80) {
                        value += String.fromCharCode(ch);
                        continue;
                    }

                    if ((ch & 0xC0) === 0x80) {
                        throw new Error('Invalid UTF8 encoding');
                    }

                    var currentPrefix = 0xC0;
                    var validBits = 5;
                    do {
                        var mask = (currentPrefix >> 1) | 0x80;
                        if ((ch & mask) === currentPrefix) {
                            break;
                        }
                        currentPrefix = mask;
                        --validBits;
                    } while(validBits >= 0);

                    var code = (ch & ((1 << validBits) - 1));
                    for (var i = 5; i >= validBits; --i) {
                        ch = this.readUI8();
                        if ((ch & 0xC0) !== 0x80) {
                            throw new Error('Invalid UTF8 encoding');
                        }
                        code = (code << 6) | (ch & 0x3F);
                    }

                    if (code >= 0x10000) {
                        value += String.fromCharCode((((code - 0x10000) >> 10) & 0x3FF) | 0xD800, (code & 0x3FF) | 0xDC00);
                    } else {
                        value += String.fromCharCode(code);
                    }
                }
                return value;
            };
            ActionsDataStream.prototype.readString = function () {
                return this.readANSI ? this.readANSIString() : this.readUTF8String();
            };
            ActionsDataStream.prototype.readBytes = function (length) {
                var position = this.position;
                var remaining = Math.max(this.end - position, 0);
                if (remaining < length) {
                    length = remaining;
                }
                var subarray = this.array.subarray(position, position + length);
                this.position = position + length;
                return subarray;
            };
            return ActionsDataStream;
        })();
        AVM1.ActionsDataStream = ActionsDataStream;
    })(Shumway.AVM1 || (Shumway.AVM1 = {}));
    var AVM1 = Shumway.AVM1;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM1) {
        (function (ActionCode) {
            ActionCode[ActionCode["None"] = 0x00] = "None";
            ActionCode[ActionCode["ActionGotoFrame"] = 0x81] = "ActionGotoFrame";
            ActionCode[ActionCode["ActionGetURL"] = 0x83] = "ActionGetURL";
            ActionCode[ActionCode["ActionNextFrame"] = 0x04] = "ActionNextFrame";
            ActionCode[ActionCode["ActionPreviousFrame"] = 0x05] = "ActionPreviousFrame";
            ActionCode[ActionCode["ActionPlay"] = 0x06] = "ActionPlay";
            ActionCode[ActionCode["ActionStop"] = 0x07] = "ActionStop";
            ActionCode[ActionCode["ActionToggleQuality"] = 0x08] = "ActionToggleQuality";
            ActionCode[ActionCode["ActionStopSounds"] = 0x09] = "ActionStopSounds";
            ActionCode[ActionCode["ActionWaitForFrame"] = 0x8A] = "ActionWaitForFrame";
            ActionCode[ActionCode["ActionSetTarget"] = 0x8B] = "ActionSetTarget";
            ActionCode[ActionCode["ActionGoToLabel"] = 0x8C] = "ActionGoToLabel";
            ActionCode[ActionCode["ActionPush"] = 0x96] = "ActionPush";
            ActionCode[ActionCode["ActionPop"] = 0x17] = "ActionPop";
            ActionCode[ActionCode["ActionAdd"] = 0x0A] = "ActionAdd";
            ActionCode[ActionCode["ActionSubtract"] = 0x0B] = "ActionSubtract";
            ActionCode[ActionCode["ActionMultiply"] = 0x0C] = "ActionMultiply";
            ActionCode[ActionCode["ActionDivide"] = 0x0D] = "ActionDivide";
            ActionCode[ActionCode["ActionEquals"] = 0x0E] = "ActionEquals";
            ActionCode[ActionCode["ActionLess"] = 0x0F] = "ActionLess";
            ActionCode[ActionCode["ActionAnd"] = 0x10] = "ActionAnd";
            ActionCode[ActionCode["ActionOr"] = 0x11] = "ActionOr";
            ActionCode[ActionCode["ActionNot"] = 0x12] = "ActionNot";
            ActionCode[ActionCode["ActionStringEquals"] = 0x13] = "ActionStringEquals";
            ActionCode[ActionCode["ActionStringLength"] = 0x14] = "ActionStringLength";
            ActionCode[ActionCode["ActionMBStringLength"] = 0x31] = "ActionMBStringLength";
            ActionCode[ActionCode["ActionStringAdd"] = 0x21] = "ActionStringAdd";
            ActionCode[ActionCode["ActionStringExtract"] = 0x15] = "ActionStringExtract";
            ActionCode[ActionCode["ActionMBStringExtract"] = 0x35] = "ActionMBStringExtract";
            ActionCode[ActionCode["ActionStringLess"] = 0x29] = "ActionStringLess";
            ActionCode[ActionCode["ActionToInteger"] = 0x18] = "ActionToInteger";
            ActionCode[ActionCode["ActionCharToAscii"] = 0x32] = "ActionCharToAscii";
            ActionCode[ActionCode["ActionMBCharToAscii"] = 0x36] = "ActionMBCharToAscii";
            ActionCode[ActionCode["ActionAsciiToChar"] = 0x33] = "ActionAsciiToChar";
            ActionCode[ActionCode["ActionMBAsciiToChar"] = 0x37] = "ActionMBAsciiToChar";
            ActionCode[ActionCode["ActionJump"] = 0x99] = "ActionJump";
            ActionCode[ActionCode["ActionIf"] = 0x9D] = "ActionIf";
            ActionCode[ActionCode["ActionCall"] = 0x9E] = "ActionCall";
            ActionCode[ActionCode["ActionGetVariable"] = 0x1C] = "ActionGetVariable";
            ActionCode[ActionCode["ActionSetVariable"] = 0x1D] = "ActionSetVariable";
            ActionCode[ActionCode["ActionGetURL2"] = 0x9A] = "ActionGetURL2";
            ActionCode[ActionCode["ActionGotoFrame2"] = 0x9F] = "ActionGotoFrame2";
            ActionCode[ActionCode["ActionSetTarget2"] = 0x20] = "ActionSetTarget2";
            ActionCode[ActionCode["ActionGetProperty"] = 0x22] = "ActionGetProperty";
            ActionCode[ActionCode["ActionSetProperty"] = 0x23] = "ActionSetProperty";
            ActionCode[ActionCode["ActionCloneSprite"] = 0x24] = "ActionCloneSprite";
            ActionCode[ActionCode["ActionRemoveSprite"] = 0x25] = "ActionRemoveSprite";
            ActionCode[ActionCode["ActionStartDrag"] = 0x27] = "ActionStartDrag";
            ActionCode[ActionCode["ActionEndDrag"] = 0x28] = "ActionEndDrag";
            ActionCode[ActionCode["ActionWaitForFrame2"] = 0x8D] = "ActionWaitForFrame2";
            ActionCode[ActionCode["ActionTrace"] = 0x26] = "ActionTrace";
            ActionCode[ActionCode["ActionGetTime"] = 0x34] = "ActionGetTime";
            ActionCode[ActionCode["ActionRandomNumber"] = 0x30] = "ActionRandomNumber";
            ActionCode[ActionCode["ActionCallFunction"] = 0x3D] = "ActionCallFunction";
            ActionCode[ActionCode["ActionCallMethod"] = 0x52] = "ActionCallMethod";
            ActionCode[ActionCode["ActionConstantPool"] = 0x88] = "ActionConstantPool";
            ActionCode[ActionCode["ActionDefineFunction"] = 0x9B] = "ActionDefineFunction";
            ActionCode[ActionCode["ActionDefineLocal"] = 0x3C] = "ActionDefineLocal";
            ActionCode[ActionCode["ActionDefineLocal2"] = 0x41] = "ActionDefineLocal2";
            ActionCode[ActionCode["ActionDelete"] = 0x3A] = "ActionDelete";
            ActionCode[ActionCode["ActionDelete2"] = 0x3B] = "ActionDelete2";
            ActionCode[ActionCode["ActionEnumerate"] = 0x46] = "ActionEnumerate";
            ActionCode[ActionCode["ActionEquals2"] = 0x49] = "ActionEquals2";
            ActionCode[ActionCode["ActionGetMember"] = 0x4E] = "ActionGetMember";
            ActionCode[ActionCode["ActionInitArray"] = 0x42] = "ActionInitArray";
            ActionCode[ActionCode["ActionInitObject"] = 0x43] = "ActionInitObject";
            ActionCode[ActionCode["ActionNewMethod"] = 0x53] = "ActionNewMethod";
            ActionCode[ActionCode["ActionNewObject"] = 0x40] = "ActionNewObject";
            ActionCode[ActionCode["ActionSetMember"] = 0x4F] = "ActionSetMember";
            ActionCode[ActionCode["ActionTargetPath"] = 0x45] = "ActionTargetPath";
            ActionCode[ActionCode["ActionWith"] = 0x94] = "ActionWith";
            ActionCode[ActionCode["ActionToNumber"] = 0x4A] = "ActionToNumber";
            ActionCode[ActionCode["ActionToString"] = 0x4B] = "ActionToString";
            ActionCode[ActionCode["ActionTypeOf"] = 0x44] = "ActionTypeOf";
            ActionCode[ActionCode["ActionAdd2"] = 0x47] = "ActionAdd2";
            ActionCode[ActionCode["ActionLess2"] = 0x48] = "ActionLess2";
            ActionCode[ActionCode["ActionModulo"] = 0x3F] = "ActionModulo";
            ActionCode[ActionCode["ActionBitAnd"] = 0x60] = "ActionBitAnd";
            ActionCode[ActionCode["ActionBitLShift"] = 0x63] = "ActionBitLShift";
            ActionCode[ActionCode["ActionBitOr"] = 0x61] = "ActionBitOr";
            ActionCode[ActionCode["ActionBitRShift"] = 0x64] = "ActionBitRShift";
            ActionCode[ActionCode["ActionBitURShift"] = 0x65] = "ActionBitURShift";
            ActionCode[ActionCode["ActionBitXor"] = 0x62] = "ActionBitXor";
            ActionCode[ActionCode["ActionDecrement"] = 0x51] = "ActionDecrement";
            ActionCode[ActionCode["ActionIncrement"] = 0x50] = "ActionIncrement";
            ActionCode[ActionCode["ActionPushDuplicate"] = 0x4C] = "ActionPushDuplicate";
            ActionCode[ActionCode["ActionReturn"] = 0x3E] = "ActionReturn";
            ActionCode[ActionCode["ActionStackSwap"] = 0x4D] = "ActionStackSwap";
            ActionCode[ActionCode["ActionStoreRegister"] = 0x87] = "ActionStoreRegister";
            ActionCode[ActionCode["ActionInstanceOf"] = 0x54] = "ActionInstanceOf";
            ActionCode[ActionCode["ActionEnumerate2"] = 0x55] = "ActionEnumerate2";
            ActionCode[ActionCode["ActionStrictEquals"] = 0x66] = "ActionStrictEquals";
            ActionCode[ActionCode["ActionGreater"] = 0x67] = "ActionGreater";
            ActionCode[ActionCode["ActionStringGreater"] = 0x68] = "ActionStringGreater";
            ActionCode[ActionCode["ActionDefineFunction2"] = 0x8E] = "ActionDefineFunction2";
            ActionCode[ActionCode["ActionExtends"] = 0x69] = "ActionExtends";
            ActionCode[ActionCode["ActionCastOp"] = 0x2B] = "ActionCastOp";
            ActionCode[ActionCode["ActionImplementsOp"] = 0x2C] = "ActionImplementsOp";
            ActionCode[ActionCode["ActionTry"] = 0x8F] = "ActionTry";
            ActionCode[ActionCode["ActionThrow"] = 0x2A] = "ActionThrow";
            ActionCode[ActionCode["ActionFSCommand2"] = 0x2D] = "ActionFSCommand2";
            ActionCode[ActionCode["ActionStrictMode"] = 0x89] = "ActionStrictMode";
        })(AVM1.ActionCode || (AVM1.ActionCode = {}));
        var ActionCode = AVM1.ActionCode;

        var ParsedPushRegisterAction = (function () {
            function ParsedPushRegisterAction(registerNumber) {
                this.registerNumber = registerNumber;
            }
            return ParsedPushRegisterAction;
        })();
        AVM1.ParsedPushRegisterAction = ParsedPushRegisterAction;

        var ParsedPushConstantAction = (function () {
            function ParsedPushConstantAction(constantIndex) {
                this.constantIndex = constantIndex;
            }
            return ParsedPushConstantAction;
        })();
        AVM1.ParsedPushConstantAction = ParsedPushConstantAction;

        (function (ArgumentAssignmentType) {
            ArgumentAssignmentType[ArgumentAssignmentType["None"] = 0] = "None";
            ArgumentAssignmentType[ArgumentAssignmentType["Argument"] = 1] = "Argument";
            ArgumentAssignmentType[ArgumentAssignmentType["This"] = 2] = "This";
            ArgumentAssignmentType[ArgumentAssignmentType["Arguments"] = 4] = "Arguments";
            ArgumentAssignmentType[ArgumentAssignmentType["Super"] = 8] = "Super";
            ArgumentAssignmentType[ArgumentAssignmentType["Global"] = 16] = "Global";
            ArgumentAssignmentType[ArgumentAssignmentType["Parent"] = 32] = "Parent";
            ArgumentAssignmentType[ArgumentAssignmentType["Root"] = 64] = "Root";
        })(AVM1.ArgumentAssignmentType || (AVM1.ArgumentAssignmentType = {}));
        var ArgumentAssignmentType = AVM1.ArgumentAssignmentType;

        var ActionsDataParser = (function () {
            function ActionsDataParser(stream) {
                this.stream = stream;
            }
            Object.defineProperty(ActionsDataParser.prototype, "position", {
                get: function () {
                    return this.stream.position;
                },
                set: function (value) {
                    this.stream.position = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ActionsDataParser.prototype, "eof", {
                get: function () {
                    return this.stream.position >= this.stream.end;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ActionsDataParser.prototype, "length", {
                get: function () {
                    return this.stream.end;
                },
                enumerable: true,
                configurable: true
            });
            ActionsDataParser.prototype.readNext = function () {
                var stream = this.stream;
                var currentPosition = stream.position;
                var actionCode = stream.readUI8();
                var length = actionCode >= 0x80 ? stream.readUI16() : 0;
                var nextPosition = stream.position + length;

                var args = null;
                switch (actionCode | 0) {
                    case 129 /* ActionGotoFrame */:
                        var frame = stream.readUI16();
                        var nextActionCode = stream.readUI8();
                        var play = false;
                        if (nextActionCode !== 0x06 && nextActionCode !== 0x07) {
                            stream.position--;
                        } else {
                            nextPosition++;
                            play = nextActionCode === 0x06;
                        }
                        args = [frame, play];
                        break;
                    case 131 /* ActionGetURL */:
                        var urlString = stream.readString();
                        var targetString = stream.readString();
                        args = [urlString, targetString];
                        break;
                    case 138 /* ActionWaitForFrame */:
                        var frame = stream.readUI16();
                        var count = stream.readUI8();
                        args = [frame, count];
                        break;
                    case 139 /* ActionSetTarget */:
                        var targetName = stream.readString();
                        args = [targetName];
                        break;
                    case 140 /* ActionGoToLabel */:
                        var label = stream.readString();
                        args = [label];
                        break;
                    case 150 /* ActionPush */:
                        var type, value;
                        args = [];
                        while (stream.position < nextPosition) {
                            type = stream.readUI8();
                            switch (type | 0) {
                                case 0:
                                    value = stream.readString();
                                    break;
                                case 1:
                                    value = stream.readFloat();
                                    break;
                                case 2:
                                    value = null;
                                    break;
                                case 3:
                                    value = void (0);
                                    break;
                                case 4:
                                    value = new ParsedPushRegisterAction(stream.readUI8());
                                    break;
                                case 5:
                                    value = stream.readBoolean();
                                    break;
                                case 6:
                                    value = stream.readDouble();
                                    break;
                                case 7:
                                    value = stream.readInteger();
                                    break;
                                case 8:
                                    value = new ParsedPushConstantAction(stream.readUI8());
                                    break;
                                case 9:
                                    value = new ParsedPushConstantAction(stream.readUI16());
                                    break;
                                default:
                                    console.error('Unknown value type: ' + type);
                                    stream.position = nextPosition;
                                    continue;
                            }
                            args.push(value);
                        }
                        break;
                    case 153 /* ActionJump */:
                        var offset = stream.readSI16();
                        args = [offset];
                        break;
                    case 157 /* ActionIf */:
                        var offset = stream.readSI16();
                        args = [offset];
                        break;
                    case 154 /* ActionGetURL2 */:
                        var flags = stream.readUI8();
                        args = [flags];
                        break;
                    case 159 /* ActionGotoFrame2 */:
                        var flags = stream.readUI8();
                        args = [flags];
                        if (!!(flags & 2)) {
                            args.push(stream.readUI16());
                        }
                        break;
                    case 141 /* ActionWaitForFrame2 */:
                        var count = stream.readUI8();
                        args = [count];
                        break;
                    case 136 /* ActionConstantPool */:
                        var count = stream.readUI16();
                        var constantPool = [];
                        for (var i = 0; i < count; i++) {
                            constantPool.push(stream.readString());
                        }
                        args = [constantPool];
                        break;
                    case 155 /* ActionDefineFunction */:
                        var functionName = stream.readString();
                        var count = stream.readUI16();
                        var functionParams = [];
                        for (var i = 0; i < count; i++) {
                            functionParams.push(stream.readString());
                        }

                        var codeSize = stream.readUI16();
                        nextPosition += codeSize;
                        var functionBody = new AVM1.AS2ActionsData(stream.readBytes(codeSize), this.dataId + '_f' + stream.position);

                        args = [functionBody, functionName, functionParams];
                        break;
                    case 148 /* ActionWith */:
                        var codeSize = stream.readUI16();
                        nextPosition += codeSize;
                        var withBody = new AVM1.AS2ActionsData(stream.readBytes(codeSize), this.dataId + '_w' + stream.position);
                        args = [withBody];
                        break;
                    case 135 /* ActionStoreRegister */:
                        var register = stream.readUI8();
                        args = [register];
                        break;
                    case 142 /* ActionDefineFunction2 */:
                        var functionName = stream.readString();
                        var count = stream.readUI16();
                        var registerCount = stream.readUI8();
                        var flags = stream.readUI16();
                        var registerAllocation = [];
                        var functionParams = [];
                        for (var i = 0; i < count; i++) {
                            var register = stream.readUI8();
                            var paramName = stream.readString();
                            functionParams.push(paramName);
                            if (register) {
                                registerAllocation[register] = {
                                    type: 1 /* Argument */,
                                    name: paramName,
                                    index: i
                                };
                            }
                        }

                        var j = 1;

                        // order this, arguments, super, _root, _parent, and _global
                        if (flags & 0x0001) {
                            registerAllocation[j++] = { type: 2 /* This */ };
                        }
                        if (flags & 0x0004) {
                            registerAllocation[j++] = { type: 4 /* Arguments */ };
                        }
                        if (flags & 0x0010) {
                            registerAllocation[j++] = { type: 8 /* Super */ };
                        }
                        if (flags & 0x0040) {
                            registerAllocation[j++] = { type: 64 /* Root */ };
                        }
                        if (flags & 0x0080) {
                            registerAllocation[j++] = { type: 32 /* Parent */ };
                        }
                        if (flags & 0x0100) {
                            registerAllocation[j++] = { type: 16 /* Global */ };
                        }

                        var suppressArguments = 0;
                        if (flags & 0x0002) {
                            suppressArguments |= 2 /* This */;
                        }
                        if (flags & 0x0008) {
                            suppressArguments |= 4 /* Arguments */;
                        }
                        if (flags & 0x0020) {
                            suppressArguments |= 8 /* Super */;
                        }

                        var codeSize = stream.readUI16();
                        nextPosition += codeSize;
                        var functionBody = new AVM1.AS2ActionsData(stream.readBytes(codeSize), this.dataId + '_f' + stream.position);

                        args = [
                            functionBody, functionName, functionParams, registerCount,
                            registerAllocation, suppressArguments];
                        break;
                    case 143 /* ActionTry */:
                        var flags = stream.readUI8();
                        var catchIsRegisterFlag = !!(flags & 4);
                        var finallyBlockFlag = !!(flags & 2);
                        var catchBlockFlag = !!(flags & 1);
                        var trySize = stream.readUI16();
                        var catchSize = stream.readUI16();
                        var finallySize = stream.readUI16();
                        var catchTarget = catchIsRegisterFlag ? stream.readUI8() : stream.readString();

                        nextPosition += trySize + catchSize + finallySize;

                        var tryBody = new AVM1.AS2ActionsData(stream.readBytes(trySize), this.dataId + '_t' + stream.position);
                        var catchBody = new AVM1.AS2ActionsData(stream.readBytes(catchSize), this.dataId + '_c' + stream.position);
                        var finallyBody = new AVM1.AS2ActionsData(stream.readBytes(finallySize), this.dataId + '_z' + stream.position);

                        args = [
                            catchIsRegisterFlag, catchTarget, tryBody,
                            catchBlockFlag, catchBody, finallyBlockFlag, finallyBody];
                        break;
                    case 137 /* ActionStrictMode */:
                        var mode = stream.readUI8();
                        args = [mode];
                        break;
                }
                stream.position = nextPosition;
                return {
                    position: currentPosition,
                    actionCode: actionCode,
                    actionName: ActionNamesMap[actionCode],
                    args: args
                };
            };
            ActionsDataParser.prototype.skip = function (count) {
                var stream = this.stream;
                while (count > 0 && stream.position < stream.end) {
                    var actionCode = stream.readUI8();
                    var length = actionCode >= 0x80 ? stream.readUI16() : 0;
                    stream.position += length;
                    count--;
                }
            };
            return ActionsDataParser;
        })();
        AVM1.ActionsDataParser = ActionsDataParser;

        var ActionNamesMap = {
            0x00: 'EOA',
            0x04: 'ActionNextFrame',
            0x05: 'ActionPreviousFrame',
            0x06: 'ActionPlay',
            0x07: 'ActionStop',
            0x08: 'ActionToggleQuality',
            0x09: 'ActionStopSounds',
            0x0A: 'ActionAdd',
            0x0B: 'ActionSubtract',
            0x0C: 'ActionMultiply',
            0x0D: 'ActionDivide',
            0x0E: 'ActionEquals',
            0x0F: 'ActionLess',
            0x10: 'ActionAnd',
            0x11: 'ActionOr',
            0x12: 'ActionNot',
            0x13: 'ActionStringEquals',
            0x14: 'ActionStringLength',
            0x15: 'ActionStringExtract',
            0x17: 'ActionPop',
            0x18: 'ActionToInteger',
            0x1C: 'ActionGetVariable',
            0x1D: 'ActionSetVariable',
            0x20: 'ActionSetTarget2',
            0x21: 'ActionStringAdd',
            0x22: 'ActionGetProperty',
            0x23: 'ActionSetProperty',
            0x24: 'ActionCloneSprite',
            0x25: 'ActionRemoveSprite',
            0x26: 'ActionTrace',
            0x27: 'ActionStartDrag',
            0x28: 'ActionEndDrag',
            0x29: 'ActionStringLess',
            0x2A: 'ActionThrow',
            0x2B: 'ActionCastOp',
            0x2C: 'ActionImplementsOp',
            0x2D: 'ActionFSCommand2',
            0x30: 'ActionRandomNumber',
            0x31: 'ActionMBStringLength',
            0x32: 'ActionCharToAscii',
            0x33: 'ActionAsciiToChar',
            0x34: 'ActionGetTime',
            0x35: 'ActionMBStringExtract',
            0x36: 'ActionMBCharToAscii',
            0x37: 'ActionMBAsciiToChar',
            0x3A: 'ActionDelete',
            0x3B: 'ActionDelete2',
            0x3C: 'ActionDefineLocal',
            0x3D: 'ActionCallFunction',
            0x3E: 'ActionReturn',
            0x3F: 'ActionModulo',
            0x40: 'ActionNewObject',
            0x41: 'ActionDefineLocal2',
            0x42: 'ActionInitArray',
            0x43: 'ActionInitObject',
            0x44: 'ActionTypeOf',
            0x45: 'ActionTargetPath',
            0x46: 'ActionEnumerate',
            0x47: 'ActionAdd2',
            0x48: 'ActionLess2',
            0x49: 'ActionEquals2',
            0x4A: 'ActionToNumber',
            0x4B: 'ActionToString',
            0x4C: 'ActionPushDuplicate',
            0x4D: 'ActionStackSwap',
            0x4E: 'ActionGetMember',
            0x4F: 'ActionSetMember',
            0x50: 'ActionIncrement',
            0x51: 'ActionDecrement',
            0x52: 'ActionCallMethod',
            0x53: 'ActionNewMethod',
            0x54: 'ActionInstanceOf',
            0x55: 'ActionEnumerate2',
            0x60: 'ActionBitAnd',
            0x61: 'ActionBitOr',
            0x62: 'ActionBitXor',
            0x63: 'ActionBitLShift',
            0x64: 'ActionBitRShift',
            0x65: 'ActionBitURShift',
            0x66: 'ActionStrictEquals',
            0x67: 'ActionGreater',
            0x68: 'ActionStringGreater',
            0x69: 'ActionExtends',
            0x81: 'ActionGotoFrame',
            0x83: 'ActionGetURL',
            0x87: 'ActionStoreRegister',
            0x88: 'ActionConstantPool',
            0x89: 'ActionStrictMode',
            0x8A: 'ActionWaitForFrame',
            0x8B: 'ActionSetTarget',
            0x8C: 'ActionGoToLabel',
            0x8D: 'ActionWaitForFrame2',
            0x8E: 'ActionDefineFunction2',
            0x8F: 'ActionTry',
            0x94: 'ActionWith',
            0x96: 'ActionPush',
            0x99: 'ActionJump',
            0x9A: 'ActionGetURL2',
            0x9B: 'ActionDefineFunction',
            0x9D: 'ActionIf',
            0x9E: 'ActionCall',
            0x9F: 'ActionGotoFrame2'
        };
    })(Shumway.AVM1 || (Shumway.AVM1 = {}));
    var AVM1 = Shumway.AVM1;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM1) {
        var ActionsDataAnalyzer = (function () {
            function ActionsDataAnalyzer() {
            }
            ActionsDataAnalyzer.prototype.analyze = function (parser) {
                var actions = [];
                var labels = [0];
                var processedLabels = [true];

                // Parsing all actions we can reach. Every action will have next position
                // and conditional jump location.
                var queue = [0];
                while (queue.length > 0) {
                    var position = queue.shift();
                    if (actions[position]) {
                        continue;
                    }
                    parser.position = position;

                    while (!parser.eof && !actions[position]) {
                        var action = parser.readNext();
                        if (action.actionCode === 0) {
                            break;
                        }

                        var nextPosition = parser.position;

                        var item = {
                            action: action,
                            next: nextPosition,
                            conditionalJumpTo: -1
                        };

                        var jumpPosition = 0;
                        var branching = false;
                        var nonConditionalBranching = false;
                        switch (action.actionCode) {
                            case 138 /* ActionWaitForFrame */:
                            case 141 /* ActionWaitForFrame2 */:
                                branching = true;

                                // skip is specified in amount of actions (instead of bytes)
                                var skipCount = action.actionCode === 138 /* ActionWaitForFrame */ ? action.args[1] : action.args[0];
                                parser.skip(skipCount);
                                jumpPosition = parser.position;
                                parser.position = nextPosition;
                                break;
                            case 153 /* ActionJump */:
                                nonConditionalBranching = true;
                                branching = true;
                                jumpPosition = nextPosition + action.args[0];
                                break;
                            case 157 /* ActionIf */:
                                branching = true;
                                jumpPosition = nextPosition + action.args[0];
                                break;
                            case 42 /* ActionThrow */:
                            case 62 /* ActionReturn */:
                            case 0 /* None */:
                                nonConditionalBranching = true;
                                branching = true;
                                jumpPosition = parser.length;
                                break;
                        }
                        if (branching) {
                            if (jumpPosition < 0 || jumpPosition > parser.length) {
                                console.error('jump outside the action block;');
                                jumpPosition = parser.length;
                            }
                            if (nonConditionalBranching) {
                                item.next = jumpPosition;
                            } else {
                                item.conditionalJumpTo = jumpPosition;
                            }
                            if (!processedLabels[jumpPosition]) {
                                labels.push(jumpPosition);
                                queue.push(jumpPosition);
                                processedLabels[jumpPosition] = true;
                            }
                        }

                        actions[position] = item;
                        if (nonConditionalBranching) {
                            break;
                        }
                        position = nextPosition;
                    }
                }

                // Creating blocks for every unique label
                var blocks = [];
                labels.forEach(function (position) {
                    if (!actions[position]) {
                        return;
                    }
                    var items = [];
                    var lastPosition = position;

                    do {
                        var item = actions[lastPosition];
                        items.push(item);
                        lastPosition = item.next;
                    } while(!processedLabels[lastPosition] && actions[lastPosition]);

                    blocks.push({
                        label: position,
                        items: items,
                        jump: lastPosition
                    });
                });
                return {
                    actions: actions,
                    blocks: blocks,
                    dataId: parser.dataId
                };
            };
            return ActionsDataAnalyzer;
        })();
        AVM1.ActionsDataAnalyzer = ActionsDataAnalyzer;
    })(Shumway.AVM1 || (Shumway.AVM1 = {}));
    var AVM1 = Shumway.AVM1;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM1) {
        var assert = Shumway.Debug.assert;

        var AS2ActionsData = (function () {
            function AS2ActionsData(bytes, id) {
                this.bytes = bytes;
                this.id = id;
                release || assert(bytes instanceof Uint8Array);
            }
            return AS2ActionsData;
        })();
        AVM1.AS2ActionsData = AS2ActionsData;

        var AS2Context = (function () {
            function AS2Context() {
            }
            AS2Context.prototype.flushPendingScripts = function () {
            };
            AS2Context.prototype.addAsset = function (className, symbolProps) {
            };
            AS2Context.prototype.getAsset = function (className) {
            };
            AS2Context.prototype.resolveTarget = function (target) {
            };
            AS2Context.prototype.resolveLevel = function (level) {
            };
            AS2Context.prototype.addToPendingScripts = function (fn) {
            };

            AS2Context.prototype.executeActions = function (actionsData, stage, scopeObj) {
            };
            AS2Context.instance = null;
            return AS2Context;
        })();
        AVM1.AS2Context = AS2Context;
    })(Shumway.AVM1 || (Shumway.AVM1 = {}));
    var AVM1 = Shumway.AVM1;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (AVM1) {
        var Multiname = Shumway.AVM2.ABC.Multiname;
        var forEachPublicProperty = Shumway.AVM2.Runtime.forEachPublicProperty;
        var construct = Shumway.AVM2.Runtime.construct;
        var isNumeric = Shumway.isNumeric;
        var isFunction = Shumway.isFunction;
        var notImplemented = Shumway.Debug.notImplemented;

        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var Telemetry = Shumway.Telemetry;
        var assert = Shumway.Debug.assert;

        var shumwayOptions = Shumway.Settings.shumwayOptions;

        var avm1Options = shumwayOptions.register(new OptionSet("AVM1"));
        AVM1.avm1TraceEnabled = avm1Options.register(new Option("t1", "traceAvm1", "boolean", false, "trace AVM1 execution"));
        AVM1.avm1ErrorsEnabled = avm1Options.register(new Option("e1", "errorsAvm1", "boolean", false, "fail on AVM1 errors"));
        AVM1.avm1TimeoutDisabled = avm1Options.register(new Option("ha1", "nohangAvm1", "boolean", false, "disable fail on AVM1 hang"));
        AVM1.avm1CompilerEnabled = avm1Options.register(new Option("ca1", "compileAvm1", "boolean", true, "compiles AVM1 code"));
        AVM1.avm1DebuggerEnabled = avm1Options.register(new Option("da1", "debugAvm1", "boolean", false, "allows AVM1 code debugging"));

        AVM1.Debugger = {
            pause: false,
            breakpoints: {}
        };

        var MAX_AVM1_HANG_TIMEOUT = 1000;
        var CHECK_AVM1_HANG_EVERY = 1000;
        var MAX_AVM1_ERRORS_LIMIT = 1000;
        var MAX_AVM1_STACK_LIMIT = 256;

        var AS2ScopeListItem = (function () {
            function AS2ScopeListItem(scope, next) {
                this.scope = scope;
                this.next = next;
            }
            AS2ScopeListItem.prototype.create = function (scope) {
                return new AS2ScopeListItem(scope, this);
            };
            return AS2ScopeListItem;
        })();

        var AS2ContextImpl = (function (_super) {
            __extends(AS2ContextImpl, _super);
            function AS2ContextImpl(swfVersion) {
                _super.call(this);
                this.swfVersion = swfVersion;
                this.globals = new Shumway.AVM2.AS.avm1lib.AS2Globals();
                this.initialScope = new AS2ScopeListItem(this.globals, null);
                this.assets = {};
                this.isActive = false;
                this.executionProhibited = false;
                this.abortExecutionAt = 0;
                this.stackDepth = 0;
                this.isTryCatchListening = false;
                this.errorsIgnored = 0;
                this.deferScriptExecution = true;
                this.pendingScripts = [];
            }
            AS2ContextImpl.prototype.addAsset = function (className, symbolProps) {
                this.assets[className] = symbolProps;
            };
            AS2ContextImpl.prototype.getAsset = function (className) {
                return this.assets[className];
            };
            AS2ContextImpl.prototype.resolveTarget = function (target) {
                var currentTarget = this.currentTarget || this.defaultTarget;
                if (!target) {
                    target = currentTarget;
                } else if (typeof target === 'string') {
                    target = lookupAS2Children(target, currentTarget, this.globals.asGetPublicProperty('_root'));
                }
                if (typeof target !== 'object' || target === null || !('_nativeAS3Object' in target)) {
                    throw new Error('Invalid AS2 target object: ' + Object.prototype.toString.call(target));
                }

                return target;
            };
            AS2ContextImpl.prototype.resolveLevel = function (level) {
                return this.resolveTarget(this.globals['_level' + level]);
            };
            AS2ContextImpl.prototype.addToPendingScripts = function (fn) {
                if (!this.deferScriptExecution) {
                    fn();
                    return;
                }
                this.pendingScripts.push(fn);
            };
            AS2ContextImpl.prototype.flushPendingScripts = function () {
                var scripts = this.pendingScripts;
                while (scripts.length) {
                    scripts.shift()();
                }
                this.deferScriptExecution = false;
            };

            AS2ContextImpl.prototype.executeActions = function (actionsData, stage, scopeObj) {
                this.stage = stage;
                executeActions(actionsData, this, scopeObj);
            };
            return AS2ContextImpl;
        })(AVM1.AS2Context);

        AVM1.AS2Context.create = function (swfVersion) {
            return new AS2ContextImpl(swfVersion);
        };

        var AS2Error = (function () {
            function AS2Error(error) {
                this.error = error;
            }
            return AS2Error;
        })();

        var AS2CriticalError = (function (_super) {
            __extends(AS2CriticalError, _super);
            function AS2CriticalError(message, error) {
                _super.call(this, message);
                this.error = error;
            }
            return AS2CriticalError;
        })(Error);

        function isAS2MovieClip(obj) {
            return typeof obj === 'object' && obj && obj instanceof Shumway.AVM2.AS.avm1lib.AS2MovieClip;
        }

        function as2GetType(v) {
            if (v === null) {
                return 'null';
            }

            var type = typeof v;
            if (type === 'function') {
                return 'object';
            }
            if (type === 'object' && isAS2MovieClip(v)) {
                return 'movieclip';
            }
            return type;
        }

        function as2ToPrimitive(value) {
            return as2GetType(value) !== 'object' ? value : value.valueOf();
        }

        function as2GetCurrentSwfVersion() {
            return AVM1.AS2Context.instance.swfVersion;
        }

        function as2ToAddPrimitive(value) {
            if (as2GetType(value) !== 'object') {
                return value;
            }

            if (value instanceof Date && as2GetCurrentSwfVersion() >= 6) {
                return value.toString();
            } else {
                return value.valueOf();
            }
        }

        function as2ToBoolean(value) {
            switch (as2GetType(value)) {
                default:
                case 'undefined':
                case 'null':
                    return false;
                case 'boolean':
                    return value;
                case 'number':
                    return value !== 0 && !isNaN(value);
                case 'string':
                    return value.length !== 0;
                case 'movieclip':
                case 'object':
                    return true;
            }
        }

        function as2ToNumber(value) {
            value = as2ToPrimitive(value);
            switch (as2GetType(value)) {
                case 'undefined':
                case 'null':
                    return as2GetCurrentSwfVersion() >= 7 ? NaN : 0;
                case 'boolean':
                    return value ? 1 : +0;
                case 'number':
                    return value;
                case 'string':
                    if (value === '' && as2GetCurrentSwfVersion() < 5) {
                        return 0;
                    }
                    return +value;
                default:
                    return as2GetCurrentSwfVersion() >= 5 ? NaN : 0;
            }
        }

        function as2ToInteger(value) {
            var result = as2ToNumber(value);
            if (isNaN(result)) {
                return 0;
            }
            if (!isFinite(result) || result === 0) {
                return result;
            }
            return (result < 0 ? -1 : 1) * Math.abs(result) | 0;
        }

        function as2ToInt32(value) {
            var result = as2ToNumber(value);
            return (isNaN(result) || !isFinite(result) || result === 0) ? 0 : (result | 0);
        }

        // TODO: We should just override Function.prototype.toString and change this to
        // only have a special case for 'undefined'.
        function as2ToString(value) {
            switch (as2GetType(value)) {
                case 'undefined':
                    return as2GetCurrentSwfVersion() >= 7 ? 'undefined' : '';
                case 'null':
                    return 'null';
                case 'boolean':
                    return value ? 'true' : 'false';
                case 'number':
                    return value.toString();
                case 'string':
                    return value;
                case 'movieclip':
                    return value.__targetPath;
                case 'object':
                    var result = value.toString !== Function.prototype.toString ? value.toString() : value;
                    if (typeof result === 'string') {
                        return result;
                    }
                    return typeof value === 'function' ? '[type Function]' : '[type Object]';
            }
        }

        function as2Compare(x, y) {
            var x2 = as2ToPrimitive(x);
            var y2 = as2ToPrimitive(y);
            if (typeof x2 === 'string' && typeof y2 === 'string') {
                return x2 < y2;
            } else {
                return as2ToNumber(x2) < as2ToNumber(y2);
            }
        }

        function as2InstanceOf(obj, constructor) {
            if (obj instanceof constructor) {
                return true;
            }

            // TODO interface check
            return false;
        }

        function as2ResolveProperty(obj, name) {
            // AS2 just ignores lookups on non-existant containers
            if (Shumway.isNullOrUndefined(obj)) {
                warn("AVM1 warning: cannot look up member '" + name + "' on undefined object");
                return null;
            }
            obj = Object(obj);

            // checking if avm2 public property is present
            var avm2PublicName = Multiname.getPublicQualifiedName(name);
            if (avm2PublicName in obj) {
                return name;
            }
            if (isNumeric(name)) {
                return null;
            }

            if (isAS2MovieClip(obj)) {
                var child = obj.__lookupChild(name);
                if (child) {
                    return name;
                }
            }

            // versions 6 and below ignore identifier case
            if (as2GetCurrentSwfVersion() > 6) {
                return null;
            }

            var foundName = null;
            var lowerCaseName = name.toLowerCase();
            as2Enumerate(obj, function (name) {
                if (name.toLowerCase() === lowerCaseName) {
                    foundName = name;
                }
            }, null);
            return foundName;
        }

        function as2GetProperty(obj, name) {
            // AS2 just ignores lookups on non-existant containers
            if (Shumway.isNullOrUndefined(obj)) {
                warn("AVM1 warning: cannot get property '" + name + "' on undefined object");
                return undefined;
            }
            obj = Object(obj);
            if (!obj.asHasProperty(undefined, name, 0) && isAS2MovieClip(obj)) {
                return obj.__lookupChild(name);
            }
            return obj.asGetPublicProperty(name);
        }

        function as2GetPrototype(obj) {
            return obj && obj.asGetPublicProperty('prototype');
        }

        function as2Enumerate(obj, fn, thisArg) {
            forEachPublicProperty(obj, fn, thisArg);

            if (!isAS2MovieClip(obj)) {
                return;
            }

            // if it's a movie listing the children as well
            var as3MovieClip = obj._nativeAS3Object;
            for (var i = 0, length = as3MovieClip._children.length; i < length; i++) {
                var child = as3MovieClip._children[i];
                var name = child.name;
                if (!obj.asHasProperty(undefined, name, 0)) {
                    fn.call(thisArg, name);
                }
            }
        }

        function isAvm2Class(obj) {
            return obj instanceof Shumway.AVM2.AS.ASClass;
        }

        function as2CreatePrototypeProxy(obj) {
            var prototype = obj.asGetPublicProperty('prototype');
            if (typeof Proxy === 'undefined') {
                console.error('ES6 proxies are not found');
                return prototype;
            }
            return Proxy.create({
                getOwnPropertyDescriptor: function (name) {
                    return Object.getOwnPropertyDescriptor(prototype, name);
                },
                getPropertyDescriptor: function (name) {
                    for (var p = prototype; p; p = Object.getPrototypeOf(p)) {
                        var desc = Object.getOwnPropertyDescriptor(p, name);
                        if (desc) {
                            return desc;
                        }
                    }
                    return undefined;
                },
                getOwnPropertyNames: function () {
                    return Object.getOwnPropertyNames(prototype);
                },
                getPropertyNames: function () {
                    // ES6: return getPropertyNames(prototype, name);
                    var names = Object.getOwnPropertyNames(prototype);
                    for (var p = Object.getPrototypeOf(prototype); p; p = Object.getPrototypeOf(p)) {
                        names = names.concat(Object.getOwnPropertyNames(p));
                    }
                    return names;
                },
                defineProperty: function (name, desc) {
                    if (desc) {
                        if (typeof desc.value === 'function' && '_setClass' in desc.value) {
                            desc.value._setClass(obj);
                        }
                        if (typeof desc.get === 'function' && '_setClass' in desc.get) {
                            desc.get._setClass(obj);
                        }
                        if (typeof desc.set === 'function' && '_setClass' in desc.set) {
                            desc.set._setClass(obj);
                        }
                    }
                    return Object.defineProperty(prototype, name, desc);
                },
                delete: function (name) {
                    return delete prototype[name];
                },
                fix: function () {
                    return undefined;
                }
            });
        }

        function executeActions(actionsData, as2Context, scope) {
            var context = as2Context;
            if (context.executionProhibited) {
                return;
            }

            var actionTracer = ActionTracerFactory.get();

            var scopeContainer = context.initialScope.create(scope);
            var savedContext = AVM1.AS2Context.instance;
            var caughtError;
            try  {
                AVM1.AS2Context.instance = context;
                context.isActive = true;
                context.abortExecutionAt = AVM1.avm1TimeoutDisabled.value ? Number.MAX_VALUE : Date.now() + MAX_AVM1_HANG_TIMEOUT;
                context.errorsIgnored = 0;
                context.defaultTarget = scope;
                context.currentTarget = null;
                actionTracer.message('ActionScript Execution Starts');
                actionTracer.indent();
                interpretActions(actionsData, scopeContainer, [], []);
            } catch (e) {
                if (e instanceof AS2CriticalError) {
                    console.error('Disabling AVM1 execution');
                    context.executionProhibited = true;
                }
                caughtError = e;
            }
            context.isActive = false;
            context.defaultTarget = null;
            context.currentTarget = null;
            actionTracer.unindent();
            actionTracer.message('ActionScript Execution Stops');
            AVM1.AS2Context.instance = savedContext;
            if (caughtError) {
                throw caughtError;
            }
        }
        AVM1.executeActions = executeActions;

        function lookupAS2Children(targetPath, defaultTarget, root) {
            var path = targetPath.split(/[\/.]/g);
            if (path[path.length - 1] === '') {
                path.pop();
            }
            var obj = defaultTarget;
            if (path[0] === '' || path[0] === '_level0' || path[0] === '_root') {
                obj = root;
                path.shift();
            }
            while (path.length > 0) {
                var prevObj = obj;
                obj = obj.__lookupChild(path[0]);
                if (!obj) {
                    throw new Error(path[0] + ' (expr ' + targetPath + ') is not found in ' + prevObj._target);
                }
                path.shift();
            }
            return obj;
        }

        function createBuiltinType(obj, args) {
            if (obj === Array) {
                // special case of array
                var result = args;
                if (args.length == 1 && typeof args[0] === 'number') {
                    result = [];
                    result.length = args[0];
                }
                return result;
            }
            if (obj === Boolean || obj === Number || obj === String || obj === Function) {
                return obj.apply(null, args);
            }
            if (obj === Date) {
                switch (args.length) {
                    case 0:
                        return new Date();
                    case 1:
                        return new Date(args[0]);
                    default:
                        return new Date(args[0], args[1], args.length > 2 ? args[2] : 1, args.length > 3 ? args[3] : 0, args.length > 4 ? args[4] : 0, args.length > 5 ? args[5] : 0, args.length > 6 ? args[6] : 0);
                }
            }
            if (obj === Object) {
                return {};
            }
            return undefined;
        }

        var AS2_SUPER_STUB = {};

        function avm1ValidateArgsCount(numArgs, maxAmount) {
            if (isNaN(numArgs) || numArgs < 0 || numArgs > maxAmount || numArgs != (0 | numArgs)) {
                throw new Error('Invalid number of arguments: ' + numArgs);
            }
        }
        function avm1ReadFunctionArgs(stack) {
            var numArgs = +stack.pop();
            avm1ValidateArgsCount(numArgs, stack.length);
            var args = [];
            for (var i = 0; i < numArgs; i++) {
                args.push(stack.pop());
            }
            return args;
        }
        function avm1SetTarget(ectx, targetPath) {
            var currentContext = ectx.context;
            var _global = ectx.global;

            if (!targetPath) {
                currentContext.currentTarget = null;
                return;
            }

            try  {
                var currentTarget = lookupAS2Children(targetPath, currentContext.currentTarget || currentContext.defaultTarget, _global.asGetPublicProperty('_root'));
                currentContext.currentTarget = currentTarget;
            } catch (e) {
                currentContext.currentTarget = null;
                throw e;
            }
        }

        function avm1DefineFunction(ectx, actionsData, functionName, parametersNames, registersCount, registersAllocation, suppressArguments) {
            var currentContext = ectx.context;
            var _global = ectx.global;
            var scopeContainer = ectx.scopeContainer;
            var scope = ectx.scope;
            var actionTracer = ectx.actionTracer;
            var defaultTarget = currentContext.defaultTarget;
            var constantPool = ectx.constantPool;

            var skipArguments = null;
            if (registersAllocation) {
                for (var i = 0; i < registersAllocation.length; i++) {
                    var registerAllocation = registersAllocation[i];
                    if (registerAllocation && registerAllocation.type === 1 /* Argument */) {
                        if (!skipArguments) {
                            skipArguments = [];
                        }
                        skipArguments[registersAllocation[i].index] = true;
                    }
                }
            }

            var ownerClass;
            var fn = (function () {
                var newScopeContainer;
                var newScope = {};

                if (!(suppressArguments & 4 /* Arguments */)) {
                    newScope.asSetPublicProperty('arguments', arguments);
                }
                if (!(suppressArguments & 2 /* This */)) {
                    newScope.asSetPublicProperty('this', this);
                }
                if (!(suppressArguments & 8 /* Super */)) {
                    newScope.asSetPublicProperty('super', AS2_SUPER_STUB);
                }
                newScope.asSetPublicProperty('__class', ownerClass);
                newScopeContainer = scopeContainer.create(newScope);
                var i;
                var registers = [];
                if (registersAllocation) {
                    for (i = 0; i < registersAllocation.length; i++) {
                        var registerAllocation = registersAllocation[i];
                        if (!registerAllocation) {
                            continue;
                        }
                        switch (registerAllocation.type) {
                            case 1 /* Argument */:
                                registers[i] = arguments[registerAllocation.index];
                                break;
                            case 2 /* This */:
                                registers[i] = this;
                                break;
                            case 4 /* Arguments */:
                                registers[i] = arguments;
                                break;
                            case 8 /* Super */:
                                registers[i] = AS2_SUPER_STUB;
                                break;
                            case 16 /* Global */:
                                registers[i] = _global;
                                break;
                            case 32 /* Parent */:
                                registers[i] = scope.asGetPublicProperty('_parent');
                                break;
                            case 64 /* Root */:
                                registers[i] = _global.asGetPublicProperty('_root');
                                break;
                        }
                    }
                }
                for (i = 0; i < arguments.length || i < parametersNames.length; i++) {
                    if (skipArguments && skipArguments[i]) {
                        continue;
                    }
                    newScope.asSetPublicProperty(parametersNames[i], arguments[i]);
                }

                var savedContext = AVM1.AS2Context.instance;
                var savedIsActive = currentContext.isActive;
                var savedDefaultTarget = currentContext.defaultTarget;
                var savedCurrentTarget = currentContext.currentTarget;
                var result;
                var caughtError;
                try  {
                    // switching contexts if called outside main thread
                    AVM1.AS2Context.instance = currentContext;
                    if (!savedIsActive) {
                        currentContext.abortExecutionAt = AVM1.avm1TimeoutDisabled.value ? Number.MAX_VALUE : Date.now() + MAX_AVM1_HANG_TIMEOUT;
                        currentContext.errorsIgnored = 0;
                        currentContext.isActive = true;
                    }
                    currentContext.defaultTarget = defaultTarget;
                    currentContext.currentTarget = null;
                    actionTracer.indent();
                    if (++currentContext.stackDepth >= MAX_AVM1_STACK_LIMIT) {
                        throw new AS2CriticalError('long running script -- AVM1 recursion limit is reached');
                    }
                    result = interpretActions(actionsData, newScopeContainer, constantPool, registers);
                } catch (e) {
                    caughtError = e;
                }
                currentContext.defaultTarget = savedDefaultTarget;
                currentContext.currentTarget = savedCurrentTarget;
                currentContext.isActive = savedIsActive;
                currentContext.stackDepth--;
                actionTracer.unindent();
                AVM1.AS2Context.instance = savedContext;
                if (caughtError) {
                    throw caughtError;
                }
                return result;
            });

            ownerClass = fn;
            var fnObj = fn;
            fnObj._setClass = function (class_) {
                ownerClass = class_;
            };

            fnObj.instanceConstructor = fn;
            fnObj.debugName = 'avm1 ' + (functionName || '<function>');
            if (functionName) {
                fnObj.name = functionName;
            }
            return fn;
        }
        function avm1DeleteProperty(ectx, propertyName) {
            var scopeContainer = ectx.scopeContainer;

            for (var p = scopeContainer; p; p = p.next) {
                if (p.scope.asHasProperty(undefined, propertyName, 0)) {
                    p.scope.asSetPublicProperty(propertyName, undefined); // in some cases we need to cleanup events binding
                    return p.scope.asDeleteProperty(undefined, propertyName, 0);
                }
            }
            return false;
        }
        function avm1ResolveVariableName(ectx, variableName, nonStrict) {
            var _global = ectx.global;
            var currentContext = ectx.context;
            var currentTarget = currentContext.currentTarget || currentContext.defaultTarget;

            var obj, name, i;
            if (variableName.indexOf(':') >= 0) {
                // "/A/B:FOO references the FOO variable in the movie clip with a target path of /A/B."
                var parts = variableName.split(':');
                obj = lookupAS2Children(parts[0], currentTarget, _global.asGetPublicProperty('_root'));
                if (!obj) {
                    throw new Error(parts[0] + ' is undefined');
                }
                name = parts[1];
            } else if (variableName.indexOf('.') >= 0) {
                // new object reference
                var objPath = variableName.split('.');
                name = objPath.pop();
                obj = _global;
                for (i = 0; i < objPath.length; i++) {
                    obj = obj.asGetPublicProperty(objPath[i]) || obj[objPath[i]];
                    if (!obj) {
                        throw new Error(objPath.slice(0, i + 1) + ' is undefined');
                    }
                }
            }

            if (!obj) {
                return null;
            }

            var resolvedName = as2ResolveProperty(obj, name);
            var resolved = resolvedName !== null;
            if (resolved || nonStrict) {
                return { obj: obj, name: resolvedName || name, resolved: resolved };
            }

            return null;
        }
        function avm1GetVariable(ectx, variableName) {
            var scopeContainer = ectx.scopeContainer;
            var currentContext = ectx.context;
            var currentTarget = currentContext.currentTarget || currentContext.defaultTarget;
            var scope = ectx.scope;

            // fast check if variable in the current scope
            if (scope.asHasProperty(undefined, variableName, 0)) {
                return scope.asGetPublicProperty(variableName);
            }

            var target = avm1ResolveVariableName(ectx, variableName, false);
            if (target) {
                return target.obj.asGetPublicProperty(target.name);
            }

            var resolvedName;
            if ((resolvedName = as2ResolveProperty(scope, variableName))) {
                return scope.asGetPublicProperty(resolvedName);
            }
            for (var p = scopeContainer; p; p = p.next) {
                resolvedName = as2ResolveProperty(p.scope, variableName);
                if (resolvedName !== null) {
                    return p.scope.asGetPublicProperty(resolvedName);
                }
            }

            if (currentTarget.asHasProperty(undefined, variableName, 0)) {
                return currentTarget.asGetPublicProperty(variableName);
            }

            // TODO refactor that
            if (variableName === 'this') {
                return currentTarget;
            }

            // trying movie clip children (if object is a MovieClip)
            var mc = isAS2MovieClip(currentTarget) && currentTarget.__lookupChild(variableName);
            if (mc) {
                return mc;
            }
            return undefined;
        }
        function avm1SetVariable(ectx, variableName, value) {
            var scopeContainer = ectx.scopeContainer;
            var currentContext = ectx.context;
            var currentTarget = currentContext.currentTarget || currentContext.defaultTarget;
            var scope = ectx.scope;

            if (currentContext.currentTarget) {
                currentTarget.asSetPublicProperty(variableName, value);
                return;
            }

            // fast check if variable in the current scope
            if (scope.asHasProperty(undefined, variableName, 0)) {
                scope.asSetPublicProperty(variableName, value);
                return;
            }

            var target = avm1ResolveVariableName(ectx, variableName, true);
            if (target) {
                target.obj.asSetPublicProperty(target.name, value);
                return;
            }

            for (var p = scopeContainer; p.next; p = p.next) {
                var resolvedName = as2ResolveProperty(p.scope, variableName);
                if (resolvedName !== null) {
                    p.scope.asSetPublicProperty(resolvedName, value);
                    return;
                }
            }

            currentTarget.asSetPublicProperty(variableName, value);
        }
        function avm1ProcessWith(ectx, obj, withBlock) {
            var scopeContainer = ectx.scopeContainer;
            var constantPool = ectx.constantPool;
            var registers = ectx.registers;

            var newScopeContainer = scopeContainer.create(Object(obj));
            interpretActions(withBlock, newScopeContainer, constantPool, registers);
        }
        function avm1ProcessTry(ectx, catchIsRegisterFlag, finallyBlockFlag, catchBlockFlag, catchTarget, tryBlock, catchBlock, finallyBlock) {
            var currentContext = ectx.context;
            var scopeContainer = ectx.scopeContainer;
            var scope = ectx.scope;
            var constantPool = ectx.constantPool;
            var registers = ectx.registers;

            var savedTryCatchState = currentContext.isTryCatchListening;
            var caughtError;
            try  {
                currentContext.isTryCatchListening = true;
                interpretActions(tryBlock, scopeContainer, constantPool, registers);
            } catch (e) {
                currentContext.isTryCatchListening = savedTryCatchState;
                if (!catchBlockFlag || !(e instanceof AS2Error)) {
                    caughtError = e;
                } else {
                    if (typeof catchTarget === 'string') {
                        scope.asSetPublicProperty(catchTarget, e.error);
                    } else {
                        registers[catchTarget] = e.error;
                    }
                    interpretActions(catchBlock, scopeContainer, constantPool, registers);
                }
            }
            currentContext.isTryCatchListening = savedTryCatchState;
            if (finallyBlockFlag) {
                interpretActions(finallyBlock, scopeContainer, constantPool, registers);
            }
            if (caughtError) {
                throw caughtError;
            }
        }

        // SWF 3 actions
        function avm1_0x81_ActionGotoFrame(ectx, args) {
            var _global = ectx.global;

            var frame = args[0];
            var play = args[1];
            if (play) {
                _global.gotoAndPlay(frame + 1);
            } else {
                _global.gotoAndStop(frame + 1);
            }
        }
        function avm1_0x83_ActionGetURL(ectx, args) {
            var _global = ectx.global;

            var urlString = args[0];
            var targetString = args[1];
            _global.getURL(urlString, targetString);
        }
        function avm1_0x04_ActionNextFrame(ectx) {
            var _global = ectx.global;

            _global.nextFrame();
        }
        function avm1_0x05_ActionPreviousFrame(ectx) {
            var _global = ectx.global;

            _global.prevFrame();
        }
        function avm1_0x06_ActionPlay(ectx) {
            var _global = ectx.global;

            _global.play();
        }
        function avm1_0x07_ActionStop(ectx) {
            var _global = ectx.global;

            _global.stop();
        }
        function avm1_0x08_ActionToggleQuality(ectx) {
            var _global = ectx.global;

            _global.toggleHighQuality();
        }
        function avm1_0x09_ActionStopSounds(ectx) {
            var _global = ectx.global;

            _global.stopAllSounds();
        }
        function avm1_0x8A_ActionWaitForFrame(ectx, args) {
            var _global = ectx.global;

            var frame = args[0];
            var count = args[1];
            return !_global.ifFrameLoaded(frame);
        }
        function avm1_0x8B_ActionSetTarget(ectx, args) {
            var targetName = args[0];
            avm1SetTarget(ectx, targetName);
        }
        function avm1_0x8C_ActionGoToLabel(ectx, args) {
            var _global = ectx.global;

            var label = args[0];
            _global.gotoLabel(label);
        }

        // SWF 4 actions
        function avm1_0x96_ActionPush(ectx, args) {
            var registers = ectx.registers;
            var constantPool = ectx.constantPool;
            var stack = ectx.stack;

            args.forEach(function (value) {
                if (value instanceof AVM1.ParsedPushConstantAction) {
                    stack.push(constantPool[value.constantIndex]);
                } else if (value instanceof AVM1.ParsedPushRegisterAction) {
                    stack.push(registers[value.registerNumber]);
                } else {
                    stack.push(value);
                }
            });
        }
        function avm1_0x17_ActionPop(ectx) {
            var stack = ectx.stack;

            stack.pop();
        }
        function avm1_0x0A_ActionAdd(ectx) {
            var stack = ectx.stack;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            stack.push(a + b);
        }
        function avm1_0x0B_ActionSubtract(ectx) {
            var stack = ectx.stack;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            stack.push(b - a);
        }
        function avm1_0x0C_ActionMultiply(ectx) {
            var stack = ectx.stack;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            stack.push(a * b);
        }
        function avm1_0x0D_ActionDivide(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            var c = b / a;
            stack.push(isSwfVersion5 ? c : isFinite(c) ? c : '#ERROR#');
        }
        function avm1_0x0E_ActionEquals(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            var f = a == b;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x0F_ActionLess(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            var f = b < a;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x10_ActionAnd(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var a = as2ToBoolean(stack.pop());
            var b = as2ToBoolean(stack.pop());
            var f = a && b;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x11_ActionOr(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var a = as2ToBoolean(stack.pop());
            var b = as2ToBoolean(stack.pop());
            var f = a || b;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x12_ActionNot(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var f = !as2ToBoolean(stack.pop());
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x13_ActionStringEquals(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var sa = as2ToString(stack.pop());
            var sb = as2ToString(stack.pop());
            var f = sa == sb;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x14_ActionStringLength(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var sa = as2ToString(stack.pop());
            stack.push(_global.length(sa));
        }
        function avm1_0x31_ActionMBStringLength(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var sa = as2ToString(stack.pop());
            stack.push(_global.length(sa));
        }
        function avm1_0x21_ActionStringAdd(ectx) {
            var stack = ectx.stack;

            var sa = as2ToString(stack.pop());
            var sb = as2ToString(stack.pop());
            stack.push(sb + sa);
        }
        function avm1_0x15_ActionStringExtract(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var count = stack.pop();
            var index = stack.pop();
            var value = as2ToString(stack.pop());
            stack.push(_global.substring(value, index, count));
        }
        function avm1_0x35_ActionMBStringExtract(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var count = stack.pop();
            var index = stack.pop();
            var value = as2ToString(stack.pop());
            stack.push(_global.mbsubstring(value, index, count));
        }
        function avm1_0x29_ActionStringLess(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var sa = as2ToString(stack.pop());
            var sb = as2ToString(stack.pop());
            var f = sb < sa;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x18_ActionToInteger(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            stack.push(_global.int(stack.pop()));
        }
        function avm1_0x32_ActionCharToAscii(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var ch = stack.pop();
            var charCode = _global.ord(ch);
            stack.push(charCode);
        }
        function avm1_0x36_ActionMBCharToAscii(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var ch = stack.pop();
            var charCode = _global.mbord(ch);
            stack.push(charCode);
        }
        function avm1_0x33_ActionAsciiToChar(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var charCode = +stack.pop();
            var ch = _global.chr(charCode);
            stack.push(ch);
        }
        function avm1_0x37_ActionMBAsciiToChar(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var charCode = +stack.pop();
            var ch = _global.mbchr(charCode);
            stack.push(ch);
        }
        function avm1_0x99_ActionJump(ectx, args) {
            // implemented in the analyzer
        }
        function avm1_0x9D_ActionIf(ectx, args) {
            var stack = ectx.stack;

            var offset = args[0];
            return !!stack.pop();
        }
        function avm1_0x9E_ActionCall(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var label = stack.pop();
            _global.call(label);
        }
        function avm1_0x1C_ActionGetVariable(ectx) {
            var stack = ectx.stack;

            var variableName = '' + stack.pop();

            var sp = stack.length;
            stack.push(undefined);

            stack[sp] = avm1GetVariable(ectx, variableName);
        }
        function avm1_0x1D_ActionSetVariable(ectx) {
            var stack = ectx.stack;

            var value = stack.pop();
            var variableName = '' + stack.pop();
            avm1SetVariable(ectx, variableName, value);
        }
        function avm1_0x9A_ActionGetURL2(ectx, args) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var flags = args[0];
            var target = stack.pop();
            var url = stack.pop();
            var sendVarsMethod;
            if (flags & 1) {
                sendVarsMethod = 'GET';
            } else if (flags & 2) {
                sendVarsMethod = 'POST';
            }
            var loadTargetFlag = flags & 1 << 6;
            if (!loadTargetFlag) {
                _global.getURL(url, target, sendVarsMethod);
                return;
            }
            var loadVariablesFlag = flags & 1 << 7;
            if (loadVariablesFlag) {
                _global.loadVariables(url, target, sendVarsMethod);
            } else {
                _global.loadMovie(url, target, sendVarsMethod);
            }
        }
        function avm1_0x9F_ActionGotoFrame2(ectx, args) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var flags = args[0];
            var gotoParams = [stack.pop()];
            if (!!(flags & 2)) {
                gotoParams.push(args[1]);
            }
            var gotoMethod = !!(flags & 1) ? _global.gotoAndPlay : _global.gotoAndStop;
            gotoMethod.apply(_global, gotoParams);
        }
        function avm1_0x20_ActionSetTarget2(ectx) {
            var stack = ectx.stack;

            var target = stack.pop();
            avm1SetTarget(ectx, target);
        }
        function avm1_0x22_ActionGetProperty(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var index = stack.pop();
            var target = stack.pop();

            var sp = stack.length;
            stack.push(undefined);

            stack[sp] = _global.getAS2Property(target, index);
        }
        function avm1_0x23_ActionSetProperty(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var value = stack.pop();
            var index = stack.pop();
            var target = stack.pop();
            _global.setAS2Property(target, index, value);
        }
        function avm1_0x24_ActionCloneSprite(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var depth = stack.pop();
            var target = stack.pop();
            var source = stack.pop();
            _global.duplicateMovieClip(source, target, depth);
        }
        function avm1_0x25_ActionRemoveSprite(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var target = stack.pop();
            _global.removeMovieClip(target);
        }
        function avm1_0x27_ActionStartDrag(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var target = stack.pop();
            var lockcenter = stack.pop();
            var constrain = !stack.pop() ? null : {
                y2: stack.pop(),
                x2: stack.pop(),
                y1: stack.pop(),
                x1: stack.pop()
            };
            var dragParams = [target, lockcenter];
            if (constrain) {
                dragParams = dragParams.concat(constrain.x1, constrain.y1, constrain.x2, constrain.y2);
            }
            _global.startDrag.apply(_global, dragParams);
        }
        function avm1_0x28_ActionEndDrag(ectx) {
            var _global = ectx.global;

            _global.stopDrag();
        }
        function avm1_0x8D_ActionWaitForFrame2(ectx, args) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var count = args[0];
            var frame = stack.pop();
            return !_global.ifFrameLoaded(frame);
        }
        function avm1_0x26_ActionTrace(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            var value = stack.pop();
            _global.trace(value);
        }
        function avm1_0x34_ActionGetTime(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            stack.push(_global.getTimer());
        }
        function avm1_0x30_ActionRandomNumber(ectx) {
            var _global = ectx.global;
            var stack = ectx.stack;

            stack.push(_global.random(stack.pop()));
        }

        // SWF 5
        function avm1_0x3D_ActionCallFunction(ectx) {
            var stack = ectx.stack;
            var scope = ectx.scope;

            var functionName = stack.pop();
            var args = avm1ReadFunctionArgs(stack);

            var sp = stack.length;
            stack.push(undefined);

            var fn = avm1GetVariable(ectx, functionName);

            // AS2 simply ignores attempts to invoke non-functions.
            if (!(fn instanceof Function)) {
                warn("AVM1 warning: function '" + functionName + (fn ? "' is not callable" : "' is undefined"));
                return;
            }
            release || assert(stack.length === sp + 1);
            stack[sp] = fn.apply(scope, args);
        }
        function avm1_0x52_ActionCallMethod(ectx) {
            var stack = ectx.stack;

            var methodName = stack.pop();
            var obj = stack.pop();
            var args = avm1ReadFunctionArgs(stack);
            var target;

            var sp = stack.length;
            stack.push(undefined);

            // AS2 simply ignores attempts to invoke methods on non-existing objects.
            if (Shumway.isNullOrUndefined(obj)) {
                warn("AVM1 warning: method '" + methodName + "' can't be called on undefined object");
                return;
            }

            // Per spec, a missing or blank method name causes the container to be treated as
            // a function to call.
            if (Shumway.isNullOrUndefined(methodName) || methodName === '') {
                if (obj === AS2_SUPER_STUB) {
                    obj = avm1GetVariable(ectx, '__class').__super;
                    target = avm1GetVariable(ectx, 'this');
                } else {
                    // For non-super calls, we call obj with itself as the target.
                    // TODO: ensure this is correct.
                    target = obj;
                }

                // AS2 simply ignores attempts to invoke non-functions.
                if (isFunction(obj)) {
                    stack[sp] = obj.apply(target, args);
                } else {
                    warn("AVM1 warning: obj '" + obj + (obj ? "' is not callable" : "' is undefined"));
                }
                release || assert(stack.length === sp + 1);
                return;
            }

            if (obj === AS2_SUPER_STUB) {
                target = as2GetPrototype(avm1GetVariable(ectx, '__class').__super);
                obj = avm1GetVariable(ectx, 'this');
            } else {
                target = obj;
            }
            var resolvedName = as2ResolveProperty(target, methodName);
            var fn = target.asGetPublicProperty(resolvedName);

            // AS2 simply ignores attempts to invoke non-methods.
            if (!isFunction(fn)) {
                warn("AVM1 warning: method '" + methodName + "' on object", obj, (Shumway.isNullOrUndefined(fn) ? "is undefined" : "is not callable"));
                return;
            }
            release || assert(stack.length === sp + 1);
            stack[sp] = fn.apply(obj, args);
        }
        function avm1_0x88_ActionConstantPool(ectx, args) {
            var constantPool = args[0];
            ectx.constantPool = constantPool;
        }
        function avm1_0x9B_ActionDefineFunction(ectx, args) {
            var stack = ectx.stack;
            var scope = ectx.scope;

            var functionBody = args[0];
            var functionName = args[1];
            var functionParams = args[2];

            var fn = avm1DefineFunction(ectx, functionBody, functionName, functionParams, 0, null, 0);
            if (functionName) {
                scope.asSetPublicProperty(functionName, fn);
            } else {
                stack.push(fn);
            }
        }
        function avm1_0x3C_ActionDefineLocal(ectx) {
            var stack = ectx.stack;
            var scope = ectx.scope;

            var value = stack.pop();
            var name = stack.pop();
            scope.asSetPublicProperty(name, value);
        }
        function avm1_0x41_ActionDefineLocal2(ectx) {
            var stack = ectx.stack;
            var scope = ectx.scope;

            var name = stack.pop();
            scope.asSetPublicProperty(name, undefined);
        }
        function avm1_0x3A_ActionDelete(ectx) {
            var stack = ectx.stack;

            var name = stack.pop();
            var obj = stack.pop();

            // in some cases we need to cleanup events binding
            obj.asSetPublicProperty(name, undefined);
            stack.push(obj.asDeleteProperty(undefined, name, 0));
        }
        function avm1_0x3B_ActionDelete2(ectx) {
            var stack = ectx.stack;

            var name = stack.pop();
            var result = avm1DeleteProperty(ectx, name);
            stack.push(result);
        }
        function avm1_0x46_ActionEnumerate(ectx) {
            var stack = ectx.stack;

            var objectName = stack.pop();
            stack.push(null);
            var obj = avm1GetVariable(ectx, objectName);

            // AS2 just ignores lookups on non-existant containers. We warned in GetVariable already.
            if (Shumway.isNullOrUndefined(obj)) {
                return;
            }
            as2Enumerate(obj, function (name) {
                stack.push(name);
            }, null);
        }
        function avm1_0x49_ActionEquals2(ectx) {
            var stack = ectx.stack;

            var a = stack.pop();
            var b = stack.pop();
            stack.push(a == b);
        }
        function avm1_0x4E_ActionGetMember(ectx) {
            var stack = ectx.stack;

            var name = stack.pop();
            var obj = stack.pop();
            if (name === 'prototype') {
                // special case to track members
                stack.push(as2CreatePrototypeProxy(obj));
            } else {
                var resolvedName = as2ResolveProperty(obj, name);
                stack.push(resolvedName === null ? undefined : as2GetProperty(obj, resolvedName));
            }
        }
        function avm1_0x42_ActionInitArray(ectx) {
            var stack = ectx.stack;

            var obj = avm1ReadFunctionArgs(stack);
            stack.push(obj);
        }
        function avm1_0x43_ActionInitObject(ectx) {
            var stack = ectx.stack;

            var count = +stack.pop();
            avm1ValidateArgsCount(count, stack.length >> 1);
            var obj = {};
            for (var i = 0; i < count; i++) {
                var value = stack.pop();
                var name = stack.pop();
                obj.asSetPublicProperty(name, value);
            }
            stack.push(obj);
        }
        function avm1_0x53_ActionNewMethod(ectx) {
            var stack = ectx.stack;

            var methodName = stack.pop();
            var obj = stack.pop();
            var args = avm1ReadFunctionArgs(stack);

            var sp = stack.length;
            stack.push(undefined);

            // AS2 simply ignores attempts to construct methods on non-existing objects.
            if (Shumway.isNullOrUndefined(obj)) {
                warn("AVM1 warning: method '" + methodName + "' can't be constructed on undefined object");
                return;
            }

            var ctor;

            // Per spec, a missing or blank method name causes the container to be treated as
            // a function to construct.
            if (Shumway.isNullOrUndefined(methodName) || methodName === '') {
                ctor = obj;
            } else {
                var resolvedName = as2ResolveProperty(obj, methodName);
                ctor = obj.asGetPublicProperty(resolvedName);
            }

            // AS2 simply ignores attempts to invoke non-methods.
            if (!isFunction(ctor)) {
                warn("AVM1 warning: method '" + methodName + "' on object", obj, "is not constructible");
                return;
            }

            var result;
            if (isAvm2Class(ctor)) {
                result = construct(ctor, args);
            } else {
                result = Object.create(as2GetPrototype(ctor) || as2GetPrototype(Object));
                ctor.apply(result, args);
            }
            result.constructor = ctor;
            stack[sp] = result;
            release || assert(stack.length === sp + 1);
        }
        function avm1_0x40_ActionNewObject(ectx) {
            var stack = ectx.stack;

            var objectName = stack.pop();
            var args = avm1ReadFunctionArgs(stack);

            var sp = stack.length;
            stack.push(undefined);

            var obj = avm1GetVariable(ectx, objectName);

            var result = createBuiltinType(obj, args);
            if (typeof result === 'undefined') {
                // obj in not a built-in type
                if (isAvm2Class(obj)) {
                    result = construct(obj, args);
                } else {
                    // AS2 simply ignores attempts to invoke non-functions.
                    // We do this check here because AVM2 classes aren't functions but constructible.
                    if (!isFunction(obj)) {
                        warn("AVM1 warning: object '" + objectName + (obj ? "' is not constructible" : "' is undefined"));
                        return;
                    }
                    result = Object.create(as2GetPrototype(obj) || as2GetPrototype(Object));
                    obj.apply(result, args);
                }
                result.constructor = obj;
            }
            release || assert(stack.length === sp + 1);
            stack[sp] = result;
        }
        function avm1_0x4F_ActionSetMember(ectx) {
            var stack = ectx.stack;

            var value = stack.pop();
            var name = stack.pop();
            var obj = stack.pop();

            if (!Shumway.isNullOrUndefined(obj)) {
                obj.asSetPublicProperty(name, value);
            } else {
                // AS2 just ignores sets on non-existant containers
                warn("AVM1 warning: cannot set member '" + name + "' on undefined object");
            }
        }
        function avm1_0x45_ActionTargetPath(ectx) {
            var stack = ectx.stack;

            var obj = stack.pop();
            stack.push(as2GetType(obj) === 'movieclip' ? obj._target : void (0));
        }
        function avm1_0x94_ActionWith(ectx, args) {
            var stack = ectx.stack;

            var withBody = args[0];
            var obj = stack.pop();

            avm1ProcessWith(ectx, obj, withBody);
        }
        function avm1_0x4A_ActionToNumber(ectx) {
            var stack = ectx.stack;

            stack.push(as2ToNumber(stack.pop()));
        }
        function avm1_0x4B_ActionToString(ectx) {
            var stack = ectx.stack;

            stack.push(as2ToString(stack.pop()));
        }
        function avm1_0x44_ActionTypeOf(ectx) {
            var stack = ectx.stack;

            var obj = stack.pop();
            var result = as2GetType(obj);
            stack.push(result);
        }
        function avm1_0x47_ActionAdd2(ectx) {
            var stack = ectx.stack;

            var a = as2ToAddPrimitive(stack.pop());
            var b = as2ToAddPrimitive(stack.pop());
            if (typeof a === 'string' || typeof b === 'string') {
                stack.push(as2ToString(b) + as2ToString(a));
            } else {
                stack.push(as2ToNumber(b) + as2ToNumber(a));
            }
        }
        function avm1_0x48_ActionLess2(ectx) {
            var stack = ectx.stack;

            var a = stack.pop();
            var b = stack.pop();
            stack.push(as2Compare(b, a));
        }
        function avm1_0x3F_ActionModulo(ectx) {
            var stack = ectx.stack;

            var a = as2ToNumber(stack.pop());
            var b = as2ToNumber(stack.pop());
            stack.push(b % a);
        }
        function avm1_0x60_ActionBitAnd(ectx) {
            var stack = ectx.stack;

            var a = as2ToInt32(stack.pop());
            var b = as2ToInt32(stack.pop());
            stack.push(b & a);
        }
        function avm1_0x63_ActionBitLShift(ectx) {
            var stack = ectx.stack;

            var a = as2ToInt32(stack.pop());
            var b = as2ToInt32(stack.pop());
            stack.push(b << a);
        }
        function avm1_0x61_ActionBitOr(ectx) {
            var stack = ectx.stack;

            var a = as2ToInt32(stack.pop());
            var b = as2ToInt32(stack.pop());
            stack.push(b | a);
        }
        function avm1_0x64_ActionBitRShift(ectx) {
            var stack = ectx.stack;

            var a = as2ToInt32(stack.pop());
            var b = as2ToInt32(stack.pop());
            stack.push(b >> a);
        }
        function avm1_0x65_ActionBitURShift(ectx) {
            var stack = ectx.stack;

            var a = as2ToInt32(stack.pop());
            var b = as2ToInt32(stack.pop());
            stack.push(b >>> a);
        }
        function avm1_0x62_ActionBitXor(ectx) {
            var stack = ectx.stack;

            var a = as2ToInt32(stack.pop());
            var b = as2ToInt32(stack.pop());
            stack.push(b ^ a);
        }
        function avm1_0x51_ActionDecrement(ectx) {
            var stack = ectx.stack;

            var a = as2ToNumber(stack.pop());
            a--;
            stack.push(a);
        }
        function avm1_0x50_ActionIncrement(ectx) {
            var stack = ectx.stack;

            var a = as2ToNumber(stack.pop());
            a++;
            stack.push(a);
        }
        function avm1_0x4C_ActionPushDuplicate(ectx) {
            var stack = ectx.stack;

            stack.push(stack[stack.length - 1]);
        }
        function avm1_0x3E_ActionReturn(ectx) {
            ectx.isEndOfActions = true;
        }
        function avm1_0x4D_ActionStackSwap(ectx) {
            var stack = ectx.stack;

            stack.push(stack.pop(), stack.pop());
        }
        function avm1_0x87_ActionStoreRegister(ectx, args) {
            var stack = ectx.stack;
            var registers = ectx.registers;

            var register = args[0];
            registers[register] = stack[stack.length - 1];
        }

        // SWF 6
        function avm1_0x54_ActionInstanceOf(ectx) {
            var stack = ectx.stack;

            var constr = stack.pop();
            var obj = stack.pop();
            stack.push(as2InstanceOf(obj, constr));
        }
        function avm1_0x55_ActionEnumerate2(ectx) {
            var stack = ectx.stack;

            var obj = stack.pop();
            stack.push(null);

            // AS2 just ignores lookups on non-existant containers
            if (Shumway.isNullOrUndefined(obj)) {
                warn("AVM1 warning: cannot iterate over undefined object");
                return;
            }

            as2Enumerate(obj, function (name) {
                stack.push(name);
            }, null);
        }
        function avm1_0x66_ActionStrictEquals(ectx) {
            var stack = ectx.stack;

            var a = stack.pop();
            var b = stack.pop();
            stack.push(b === a);
        }
        function avm1_0x67_ActionGreater(ectx) {
            var stack = ectx.stack;

            var a = stack.pop();
            var b = stack.pop();
            stack.push(as2Compare(a, b));
        }
        function avm1_0x68_ActionStringGreater(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;

            var sa = as2ToString(stack.pop());
            var sb = as2ToString(stack.pop());
            var f = sb > sa;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }

        // SWF 7
        function avm1_0x8E_ActionDefineFunction2(ectx, args) {
            var stack = ectx.stack;
            var scope = ectx.scope;

            var functionBody = args[0];
            var functionName = args[1];
            var functionParams = args[2];
            var registerCount = args[3];
            var registerAllocation = args[4];
            var suppressArguments = args[5];

            var fn = avm1DefineFunction(ectx, functionBody, functionName, functionParams, registerCount, registerAllocation, suppressArguments);
            if (functionName) {
                scope.asSetPublicProperty(functionName, fn);
            } else {
                stack.push(fn);
            }
        }
        function avm1_0x69_ActionExtends(ectx) {
            var stack = ectx.stack;

            var constrSuper = stack.pop();
            var constr = stack.pop();
            var obj = Object.create(constrSuper.traitsPrototype || as2GetPrototype(constrSuper), {
                constructor: { value: constr, enumerable: false }
            });
            constr.__super = constrSuper;
            constr.prototype = obj;
        }
        function avm1_0x2B_ActionCastOp(ectx) {
            var stack = ectx.stack;

            var obj = stack.pop();
            var constr = stack.pop();
            stack.push(as2InstanceOf(obj, constr) ? obj : null);
        }
        function avm1_0x2C_ActionImplementsOp(ectx) {
            var stack = ectx.stack;

            var constr = stack.pop();
            var count = +stack.pop();
            avm1ValidateArgsCount(count, stack.length);
            var interfaces = [];
            for (var i = 0; i < count; i++) {
                interfaces.push(stack.pop());
            }
            constr._as2Interfaces = interfaces;
        }
        function avm1_0x8F_ActionTry(ectx, args) {
            var catchIsRegisterFlag = args[0];
            var catchTarget = args[1];
            var tryBody = args[2];
            var catchBlockFlag = args[3];
            var catchBody = args[4];
            var finallyBlockFlag = args[5];
            var finallyBody = args[6];

            avm1ProcessTry(ectx, catchIsRegisterFlag, finallyBlockFlag, catchBlockFlag, catchTarget, tryBody, catchBody, finallyBody);
        }
        function avm1_0x2A_ActionThrow(ectx) {
            var stack = ectx.stack;

            var obj = stack.pop();
            throw new AS2Error(obj);
        }
        function avm1_0x2D_ActionFSCommand2(ectx) {
            var stack = ectx.stack;
            var _global = ectx.global;

            var args = avm1ReadFunctionArgs(stack);

            var sp = stack.length;
            stack.push(undefined);

            var result = _global.fscommand.apply(null, args);
            stack[sp] = result;
        }
        function avm1_0x89_ActionStrictMode(ectx, args) {
            var mode = args[0];
        }

        function wrapAvm1Error(fn) {
            return function avm1ErrorWrapper(executionContext, args) {
                var currentContext;
                try  {
                    fn(executionContext, args);

                    executionContext.recoveringFromError = false;
                } catch (e) {
                    // handling AVM1 errors
                    currentContext = executionContext.context;
                    if ((AVM1.avm1ErrorsEnabled.value && !currentContext.isTryCatchListening) || e instanceof AS2CriticalError) {
                        throw e;
                    }
                    if (e instanceof AS2Error) {
                        throw e;
                    }

                    Telemetry.instance.reportTelemetry({ topic: 'error', error: 1 /* AVM1_ERROR */ });

                    if (!executionContext.recoveringFromError) {
                        if (currentContext.errorsIgnored++ >= MAX_AVM1_ERRORS_LIMIT) {
                            throw new AS2CriticalError('long running script -- AVM1 errors limit is reached');
                        }
                        console.error('AVM1 error: ' + e);
                        var avm2 = Shumway.AVM2.Runtime.AVM2;
                        avm2.instance.exceptions.push({
                            source: 'avm1', message: e.message,
                            stack: e.stack });
                        executionContext.recoveringFromError = true;
                    }
                }
            };
        }

        function generateActionCalls() {
            var wrap;
            if (AVM1.avm1ErrorsEnabled.value) {
                wrap = wrapAvm1Error;
            } else {
                wrap = function (fn) {
                    return fn;
                };
            }
            return {
                ActionGotoFrame: wrap(avm1_0x81_ActionGotoFrame),
                ActionGetURL: wrap(avm1_0x83_ActionGetURL),
                ActionNextFrame: wrap(avm1_0x04_ActionNextFrame),
                ActionPreviousFrame: wrap(avm1_0x05_ActionPreviousFrame),
                ActionPlay: wrap(avm1_0x06_ActionPlay),
                ActionStop: wrap(avm1_0x07_ActionStop),
                ActionToggleQuality: wrap(avm1_0x08_ActionToggleQuality),
                ActionStopSounds: wrap(avm1_0x09_ActionStopSounds),
                ActionWaitForFrame: wrap(avm1_0x8A_ActionWaitForFrame),
                ActionSetTarget: wrap(avm1_0x8B_ActionSetTarget),
                ActionGoToLabel: wrap(avm1_0x8C_ActionGoToLabel),
                ActionPush: wrap(avm1_0x96_ActionPush),
                ActionPop: wrap(avm1_0x17_ActionPop),
                ActionAdd: wrap(avm1_0x0A_ActionAdd),
                ActionSubtract: wrap(avm1_0x0B_ActionSubtract),
                ActionMultiply: wrap(avm1_0x0C_ActionMultiply),
                ActionDivide: wrap(avm1_0x0D_ActionDivide),
                ActionEquals: wrap(avm1_0x0E_ActionEquals),
                ActionLess: wrap(avm1_0x0F_ActionLess),
                ActionAnd: wrap(avm1_0x10_ActionAnd),
                ActionOr: wrap(avm1_0x11_ActionOr),
                ActionNot: wrap(avm1_0x12_ActionNot),
                ActionStringEquals: wrap(avm1_0x13_ActionStringEquals),
                ActionStringLength: wrap(avm1_0x14_ActionStringLength),
                ActionMBStringLength: wrap(avm1_0x31_ActionMBStringLength),
                ActionStringAdd: wrap(avm1_0x21_ActionStringAdd),
                ActionStringExtract: wrap(avm1_0x15_ActionStringExtract),
                ActionMBStringExtract: wrap(avm1_0x35_ActionMBStringExtract),
                ActionStringLess: wrap(avm1_0x29_ActionStringLess),
                ActionToInteger: wrap(avm1_0x18_ActionToInteger),
                ActionCharToAscii: wrap(avm1_0x32_ActionCharToAscii),
                ActionMBCharToAscii: wrap(avm1_0x36_ActionMBCharToAscii),
                ActionAsciiToChar: wrap(avm1_0x33_ActionAsciiToChar),
                ActionMBAsciiToChar: wrap(avm1_0x37_ActionMBAsciiToChar),
                ActionJump: wrap(avm1_0x99_ActionJump),
                ActionIf: wrap(avm1_0x9D_ActionIf),
                ActionCall: wrap(avm1_0x9E_ActionCall),
                ActionGetVariable: wrap(avm1_0x1C_ActionGetVariable),
                ActionSetVariable: wrap(avm1_0x1D_ActionSetVariable),
                ActionGetURL2: wrap(avm1_0x9A_ActionGetURL2),
                ActionGotoFrame2: wrap(avm1_0x9F_ActionGotoFrame2),
                ActionSetTarget2: wrap(avm1_0x20_ActionSetTarget2),
                ActionGetProperty: wrap(avm1_0x22_ActionGetProperty),
                ActionSetProperty: wrap(avm1_0x23_ActionSetProperty),
                ActionCloneSprite: wrap(avm1_0x24_ActionCloneSprite),
                ActionRemoveSprite: wrap(avm1_0x25_ActionRemoveSprite),
                ActionStartDrag: wrap(avm1_0x27_ActionStartDrag),
                ActionEndDrag: wrap(avm1_0x28_ActionEndDrag),
                ActionWaitForFrame2: wrap(avm1_0x8D_ActionWaitForFrame2),
                ActionTrace: wrap(avm1_0x26_ActionTrace),
                ActionGetTime: wrap(avm1_0x34_ActionGetTime),
                ActionRandomNumber: wrap(avm1_0x30_ActionRandomNumber),
                ActionCallFunction: wrap(avm1_0x3D_ActionCallFunction),
                ActionCallMethod: wrap(avm1_0x52_ActionCallMethod),
                ActionConstantPool: wrap(avm1_0x88_ActionConstantPool),
                ActionDefineFunction: wrap(avm1_0x9B_ActionDefineFunction),
                ActionDefineLocal: wrap(avm1_0x3C_ActionDefineLocal),
                ActionDefineLocal2: wrap(avm1_0x41_ActionDefineLocal2),
                ActionDelete: wrap(avm1_0x3A_ActionDelete),
                ActionDelete2: wrap(avm1_0x3B_ActionDelete2),
                ActionEnumerate: wrap(avm1_0x46_ActionEnumerate),
                ActionEquals2: wrap(avm1_0x49_ActionEquals2),
                ActionGetMember: wrap(avm1_0x4E_ActionGetMember),
                ActionInitArray: wrap(avm1_0x42_ActionInitArray),
                ActionInitObject: wrap(avm1_0x43_ActionInitObject),
                ActionNewMethod: wrap(avm1_0x53_ActionNewMethod),
                ActionNewObject: wrap(avm1_0x40_ActionNewObject),
                ActionSetMember: wrap(avm1_0x4F_ActionSetMember),
                ActionTargetPath: wrap(avm1_0x45_ActionTargetPath),
                ActionWith: wrap(avm1_0x94_ActionWith),
                ActionToNumber: wrap(avm1_0x4A_ActionToNumber),
                ActionToString: wrap(avm1_0x4B_ActionToString),
                ActionTypeOf: wrap(avm1_0x44_ActionTypeOf),
                ActionAdd2: wrap(avm1_0x47_ActionAdd2),
                ActionLess2: wrap(avm1_0x48_ActionLess2),
                ActionModulo: wrap(avm1_0x3F_ActionModulo),
                ActionBitAnd: wrap(avm1_0x60_ActionBitAnd),
                ActionBitLShift: wrap(avm1_0x63_ActionBitLShift),
                ActionBitOr: wrap(avm1_0x61_ActionBitOr),
                ActionBitRShift: wrap(avm1_0x64_ActionBitRShift),
                ActionBitURShift: wrap(avm1_0x65_ActionBitURShift),
                ActionBitXor: wrap(avm1_0x62_ActionBitXor),
                ActionDecrement: wrap(avm1_0x51_ActionDecrement),
                ActionIncrement: wrap(avm1_0x50_ActionIncrement),
                ActionPushDuplicate: wrap(avm1_0x4C_ActionPushDuplicate),
                ActionReturn: wrap(avm1_0x3E_ActionReturn),
                ActionStackSwap: wrap(avm1_0x4D_ActionStackSwap),
                ActionStoreRegister: wrap(avm1_0x87_ActionStoreRegister),
                ActionInstanceOf: wrap(avm1_0x54_ActionInstanceOf),
                ActionEnumerate2: wrap(avm1_0x55_ActionEnumerate2),
                ActionStrictEquals: wrap(avm1_0x66_ActionStrictEquals),
                ActionGreater: wrap(avm1_0x67_ActionGreater),
                ActionStringGreater: wrap(avm1_0x68_ActionStringGreater),
                ActionDefineFunction2: wrap(avm1_0x8E_ActionDefineFunction2),
                ActionExtends: wrap(avm1_0x69_ActionExtends),
                ActionCastOp: wrap(avm1_0x2B_ActionCastOp),
                ActionImplementsOp: wrap(avm1_0x2C_ActionImplementsOp),
                ActionTry: wrap(avm1_0x8F_ActionTry),
                ActionThrow: wrap(avm1_0x2A_ActionThrow),
                ActionFSCommand2: wrap(avm1_0x2D_ActionFSCommand2),
                ActionStrictMode: wrap(avm1_0x89_ActionStrictMode)
            };
        }

        function interpretAction(executionContext, parsedAction) {
            var stack = executionContext.stack;

            var actionCode = parsedAction.actionCode;
            var args = parsedAction.args;

            var actionTracer = executionContext.actionTracer;
            actionTracer.print(parsedAction, stack);

            var shallBranch = false;
            switch (actionCode | 0) {
                case 129 /* ActionGotoFrame */:
                    avm1_0x81_ActionGotoFrame(executionContext, args);
                    break;
                case 131 /* ActionGetURL */:
                    avm1_0x83_ActionGetURL(executionContext, args);
                    break;
                case 4 /* ActionNextFrame */:
                    avm1_0x04_ActionNextFrame(executionContext);
                    break;
                case 5 /* ActionPreviousFrame */:
                    avm1_0x05_ActionPreviousFrame(executionContext);
                    break;
                case 6 /* ActionPlay */:
                    avm1_0x06_ActionPlay(executionContext);
                    break;
                case 7 /* ActionStop */:
                    avm1_0x07_ActionStop(executionContext);
                    break;
                case 8 /* ActionToggleQuality */:
                    avm1_0x08_ActionToggleQuality(executionContext);
                    break;
                case 9 /* ActionStopSounds */:
                    avm1_0x09_ActionStopSounds(executionContext);
                    break;
                case 138 /* ActionWaitForFrame */:
                    shallBranch = avm1_0x8A_ActionWaitForFrame(executionContext, args);
                    break;
                case 139 /* ActionSetTarget */:
                    avm1_0x8B_ActionSetTarget(executionContext, args);
                    break;
                case 140 /* ActionGoToLabel */:
                    avm1_0x8C_ActionGoToLabel(executionContext, args);
                    break;

                case 150 /* ActionPush */:
                    avm1_0x96_ActionPush(executionContext, args);
                    break;
                case 23 /* ActionPop */:
                    avm1_0x17_ActionPop(executionContext);
                    break;
                case 10 /* ActionAdd */:
                    avm1_0x0A_ActionAdd(executionContext);
                    break;
                case 11 /* ActionSubtract */:
                    avm1_0x0B_ActionSubtract(executionContext);
                    break;
                case 12 /* ActionMultiply */:
                    avm1_0x0C_ActionMultiply(executionContext);
                    break;
                case 13 /* ActionDivide */:
                    avm1_0x0D_ActionDivide(executionContext);
                    break;
                case 14 /* ActionEquals */:
                    avm1_0x0E_ActionEquals(executionContext);
                    break;
                case 15 /* ActionLess */:
                    avm1_0x0F_ActionLess(executionContext);
                    break;
                case 16 /* ActionAnd */:
                    avm1_0x10_ActionAnd(executionContext);
                    break;
                case 17 /* ActionOr */:
                    avm1_0x11_ActionOr(executionContext);
                    break;
                case 18 /* ActionNot */:
                    avm1_0x12_ActionNot(executionContext);
                    break;
                case 19 /* ActionStringEquals */:
                    avm1_0x13_ActionStringEquals(executionContext);
                    break;
                case 20 /* ActionStringLength */:
                    avm1_0x14_ActionStringLength(executionContext);
                    break;
                case 49 /* ActionMBStringLength */:
                    avm1_0x31_ActionMBStringLength(executionContext);
                    break;
                case 33 /* ActionStringAdd */:
                    avm1_0x21_ActionStringAdd(executionContext);
                    break;
                case 21 /* ActionStringExtract */:
                    avm1_0x15_ActionStringExtract(executionContext);
                    break;
                case 53 /* ActionMBStringExtract */:
                    avm1_0x35_ActionMBStringExtract(executionContext);
                    break;
                case 41 /* ActionStringLess */:
                    avm1_0x29_ActionStringLess(executionContext);
                    break;
                case 24 /* ActionToInteger */:
                    avm1_0x18_ActionToInteger(executionContext);
                    break;
                case 50 /* ActionCharToAscii */:
                    avm1_0x32_ActionCharToAscii(executionContext);
                    break;
                case 54 /* ActionMBCharToAscii */:
                    avm1_0x36_ActionMBCharToAscii(executionContext);
                    break;
                case 51 /* ActionAsciiToChar */:
                    avm1_0x33_ActionAsciiToChar(executionContext);
                    break;
                case 55 /* ActionMBAsciiToChar */:
                    avm1_0x37_ActionMBAsciiToChar(executionContext);
                    break;
                case 153 /* ActionJump */:
                    avm1_0x99_ActionJump(executionContext, args);
                    break;
                case 157 /* ActionIf */:
                    shallBranch = avm1_0x9D_ActionIf(executionContext, args);
                    break;
                case 158 /* ActionCall */:
                    avm1_0x9E_ActionCall(executionContext);
                    break;
                case 28 /* ActionGetVariable */:
                    avm1_0x1C_ActionGetVariable(executionContext);
                    break;
                case 29 /* ActionSetVariable */:
                    avm1_0x1D_ActionSetVariable(executionContext);
                    break;
                case 154 /* ActionGetURL2 */:
                    avm1_0x9A_ActionGetURL2(executionContext, args);
                    break;
                case 159 /* ActionGotoFrame2 */:
                    avm1_0x9F_ActionGotoFrame2(executionContext, args);
                    break;
                case 32 /* ActionSetTarget2 */:
                    avm1_0x20_ActionSetTarget2(executionContext);
                    break;
                case 34 /* ActionGetProperty */:
                    avm1_0x22_ActionGetProperty(executionContext);
                    break;
                case 35 /* ActionSetProperty */:
                    avm1_0x23_ActionSetProperty(executionContext);
                    break;
                case 36 /* ActionCloneSprite */:
                    avm1_0x24_ActionCloneSprite(executionContext);
                    break;
                case 37 /* ActionRemoveSprite */:
                    avm1_0x25_ActionRemoveSprite(executionContext);
                    break;
                case 39 /* ActionStartDrag */:
                    avm1_0x27_ActionStartDrag(executionContext);
                    break;
                case 40 /* ActionEndDrag */:
                    avm1_0x28_ActionEndDrag(executionContext);
                    break;
                case 141 /* ActionWaitForFrame2 */:
                    shallBranch = avm1_0x8D_ActionWaitForFrame2(executionContext, args);
                    break;
                case 38 /* ActionTrace */:
                    avm1_0x26_ActionTrace(executionContext);
                    break;
                case 52 /* ActionGetTime */:
                    avm1_0x34_ActionGetTime(executionContext);
                    break;
                case 48 /* ActionRandomNumber */:
                    avm1_0x30_ActionRandomNumber(executionContext);
                    break;

                case 61 /* ActionCallFunction */:
                    avm1_0x3D_ActionCallFunction(executionContext);
                    break;
                case 82 /* ActionCallMethod */:
                    avm1_0x52_ActionCallMethod(executionContext);
                    break;
                case 136 /* ActionConstantPool */:
                    avm1_0x88_ActionConstantPool(executionContext, args);
                    break;
                case 155 /* ActionDefineFunction */:
                    avm1_0x9B_ActionDefineFunction(executionContext, args);
                    break;
                case 60 /* ActionDefineLocal */:
                    avm1_0x3C_ActionDefineLocal(executionContext);
                    break;
                case 65 /* ActionDefineLocal2 */:
                    avm1_0x41_ActionDefineLocal2(executionContext);
                    break;
                case 58 /* ActionDelete */:
                    avm1_0x3A_ActionDelete(executionContext);
                    break;
                case 59 /* ActionDelete2 */:
                    avm1_0x3B_ActionDelete2(executionContext);
                    break;
                case 70 /* ActionEnumerate */:
                    avm1_0x46_ActionEnumerate(executionContext);
                    break;
                case 73 /* ActionEquals2 */:
                    avm1_0x49_ActionEquals2(executionContext);
                    break;
                case 78 /* ActionGetMember */:
                    avm1_0x4E_ActionGetMember(executionContext);
                    break;
                case 66 /* ActionInitArray */:
                    avm1_0x42_ActionInitArray(executionContext);
                    break;
                case 67 /* ActionInitObject */:
                    avm1_0x43_ActionInitObject(executionContext);
                    break;
                case 83 /* ActionNewMethod */:
                    avm1_0x53_ActionNewMethod(executionContext);
                    break;
                case 64 /* ActionNewObject */:
                    avm1_0x40_ActionNewObject(executionContext);
                    break;
                case 79 /* ActionSetMember */:
                    avm1_0x4F_ActionSetMember(executionContext);
                    break;
                case 69 /* ActionTargetPath */:
                    avm1_0x45_ActionTargetPath(executionContext);
                    break;
                case 148 /* ActionWith */:
                    avm1_0x94_ActionWith(executionContext, args);
                    break;
                case 74 /* ActionToNumber */:
                    avm1_0x4A_ActionToNumber(executionContext);
                    break;
                case 75 /* ActionToString */:
                    avm1_0x4B_ActionToString(executionContext);
                    break;
                case 68 /* ActionTypeOf */:
                    avm1_0x44_ActionTypeOf(executionContext);
                    break;
                case 71 /* ActionAdd2 */:
                    avm1_0x47_ActionAdd2(executionContext);
                    break;
                case 72 /* ActionLess2 */:
                    avm1_0x48_ActionLess2(executionContext);
                    break;
                case 63 /* ActionModulo */:
                    avm1_0x3F_ActionModulo(executionContext);
                    break;
                case 96 /* ActionBitAnd */:
                    avm1_0x60_ActionBitAnd(executionContext);
                    break;
                case 99 /* ActionBitLShift */:
                    avm1_0x63_ActionBitLShift(executionContext);
                    break;
                case 97 /* ActionBitOr */:
                    avm1_0x61_ActionBitOr(executionContext);
                    break;
                case 100 /* ActionBitRShift */:
                    avm1_0x64_ActionBitRShift(executionContext);
                    break;
                case 101 /* ActionBitURShift */:
                    avm1_0x65_ActionBitURShift(executionContext);
                    break;
                case 98 /* ActionBitXor */:
                    avm1_0x62_ActionBitXor(executionContext);
                    break;
                case 81 /* ActionDecrement */:
                    avm1_0x51_ActionDecrement(executionContext);
                    break;
                case 80 /* ActionIncrement */:
                    avm1_0x50_ActionIncrement(executionContext);
                    break;
                case 76 /* ActionPushDuplicate */:
                    avm1_0x4C_ActionPushDuplicate(executionContext);
                    break;
                case 62 /* ActionReturn */:
                    avm1_0x3E_ActionReturn(executionContext);
                    break;
                case 77 /* ActionStackSwap */:
                    avm1_0x4D_ActionStackSwap(executionContext);
                    break;
                case 135 /* ActionStoreRegister */:
                    avm1_0x87_ActionStoreRegister(executionContext, args);
                    break;

                case 84 /* ActionInstanceOf */:
                    avm1_0x54_ActionInstanceOf(executionContext);
                    break;
                case 85 /* ActionEnumerate2 */:
                    avm1_0x55_ActionEnumerate2(executionContext);
                    break;
                case 102 /* ActionStrictEquals */:
                    avm1_0x66_ActionStrictEquals(executionContext);
                    break;
                case 103 /* ActionGreater */:
                    avm1_0x67_ActionGreater(executionContext);
                    break;
                case 104 /* ActionStringGreater */:
                    avm1_0x68_ActionStringGreater(executionContext);
                    break;

                case 142 /* ActionDefineFunction2 */:
                    avm1_0x8E_ActionDefineFunction2(executionContext, args);
                    break;
                case 105 /* ActionExtends */:
                    avm1_0x69_ActionExtends(executionContext);
                    break;
                case 43 /* ActionCastOp */:
                    avm1_0x2B_ActionCastOp(executionContext);
                    break;
                case 44 /* ActionImplementsOp */:
                    avm1_0x2C_ActionImplementsOp(executionContext);
                    break;
                case 143 /* ActionTry */:
                    avm1_0x8F_ActionTry(executionContext, args);
                    break;
                case 42 /* ActionThrow */:
                    avm1_0x2A_ActionThrow(executionContext);
                    break;

                case 45 /* ActionFSCommand2 */:
                    avm1_0x2D_ActionFSCommand2(executionContext);
                    break;
                case 137 /* ActionStrictMode */:
                    avm1_0x89_ActionStrictMode(executionContext, args);
                    break;
                case 0 /* None */:
                    executionContext.isEndOfActions = true;
                    break;
                default:
                    throw new Error('Unknown action code: ' + actionCode);
            }
            return shallBranch;
        }

        function interpretActionWithRecovery(executionContext, parsedAction) {
            var currentContext;
            var result;
            try  {
                result = interpretAction(executionContext, parsedAction);

                executionContext.recoveringFromError = false;
            } catch (e) {
                // handling AVM1 errors
                currentContext = executionContext.context;
                if ((AVM1.avm1ErrorsEnabled.value && !currentContext.isTryCatchListening) || e instanceof AS2CriticalError) {
                    throw e;
                }
                if (e instanceof AS2Error) {
                    throw e;
                }

                Telemetry.instance.reportTelemetry({ topic: 'error', error: 1 /* AVM1_ERROR */ });

                if (!executionContext.recoveringFromError) {
                    if (currentContext.errorsIgnored++ >= MAX_AVM1_ERRORS_LIMIT) {
                        throw new AS2CriticalError('long running script -- AVM1 errors limit is reached');
                    }
                    console.error('AVM1 error: ' + e);
                    var avm2 = Shumway.AVM2.Runtime.AVM2;
                    avm2.instance.exceptions.push({
                        source: 'avm1', message: e.message,
                        stack: e.stack });
                    executionContext.recoveringFromError = true;
                }
            }
            return result;
        }

        function interpretActions(actionsData, scopeContainer, constantPool, registers) {
            var currentContext = AVM1.AS2Context.instance;

            if (!actionsData.ir) {
                var stream = new AVM1.ActionsDataStream(actionsData.bytes, currentContext.swfVersion);
                var parser = new AVM1.ActionsDataParser(stream);
                parser.dataId = actionsData.id;
                var analyzer = new AVM1.ActionsDataAnalyzer();
                actionsData.ir = analyzer.analyze(parser);

                if (AVM1.avm1CompilerEnabled.value) {
                    try  {
                        var c = new ActionsDataCompiler();
                        actionsData.ir.compiled = c.generate(actionsData.ir);
                    } catch (e) {
                        console.error('Unable to compile AVM1 function: ' + e);
                    }
                }
            }
            var ir = actionsData.ir;
            var compiled = ir.compiled;

            var stack = [];
            var isSwfVersion5 = currentContext.swfVersion >= 5;
            var actionTracer = ActionTracerFactory.get();
            var scope = scopeContainer.scope;

            var executionContext = {
                context: currentContext,
                global: currentContext.globals,
                scopeContainer: scopeContainer,
                scope: scope,
                actionTracer: actionTracer,
                constantPool: constantPool,
                registers: registers,
                stack: stack,
                isSwfVersion5: isSwfVersion5,
                recoveringFromError: false,
                isEndOfActions: false
            };

            if (scope._nativeAS3Object && scope._nativeAS3Object._deferScriptExecution) {
                currentContext.deferScriptExecution = true;
            }

            if (compiled) {
                return compiled(executionContext);
            }

            var instructionsExecuted = 0;
            var abortExecutionAt = currentContext.abortExecutionAt;

            if (AVM1.avm1DebuggerEnabled.value && (AVM1.Debugger.pause || AVM1.Debugger.breakpoints[ir.dataId])) {
                debugger;
            }

            var position = 0;
            var nextAction = ir.actions[position];

            while (nextAction && !executionContext.isEndOfActions) {
                // let's check timeout/Date.now every some number of instructions
                if (instructionsExecuted++ % CHECK_AVM1_HANG_EVERY === 0 && Date.now() >= abortExecutionAt) {
                    throw new AS2CriticalError('long running script -- AVM1 instruction hang timeout');
                }

                var shallBranch = interpretActionWithRecovery(executionContext, nextAction.action);
                if (shallBranch) {
                    position = nextAction.conditionalJumpTo;
                } else {
                    position = nextAction.next;
                }
                nextAction = ir.actions[position];
            }
            return stack.pop();
        }

        // Bare-minimum JavaScript code generator to make debugging better.
        var ActionsDataCompiler = (function () {
            function ActionsDataCompiler() {
                if (!ActionsDataCompiler.cachedCalls) {
                    ActionsDataCompiler.cachedCalls = generateActionCalls();
                }
            }
            ActionsDataCompiler.prototype.convertArgs = function (args, id, res) {
                var parts = [];
                for (var i = 0; i < args.length; i++) {
                    var arg = args[i];
                    if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {
                        if (arg instanceof AVM1.ParsedPushConstantAction) {
                            var hint = '';
                            var currentConstantPool = res.constantPool;
                            if (currentConstantPool) {
                                var constant = currentConstantPool[arg.constantIndex];
                                hint = constant === undefined ? 'undefined' : JSON.stringify(constant);

                                // preventing code breakage due to bad constant
                                hint = hint.indexOf('*/') >= 0 ? '' : ' /* ' + hint + ' */';
                            }
                            parts.push('constantPool[' + arg.constantIndex + ']' + hint);
                        } else if (arg instanceof AVM1.ParsedPushRegisterAction) {
                            parts.push('registers[' + arg.registerNumber + ']');
                        } else if (arg instanceof AVM1.AS2ActionsData) {
                            var resName = 'code_' + id + '_' + i;
                            res[resName] = arg;
                            parts.push('res.' + resName);
                        } else {
                            notImplemented('Unknown AVM1 action argument type');
                        }
                    } else if (arg === undefined) {
                        parts.push('undefined'); // special case
                    } else {
                        parts.push(JSON.stringify(arg));
                    }
                }
                return parts.join(',');
            };
            ActionsDataCompiler.prototype.convertAction = function (item, id, res) {
                switch (item.action.actionCode) {
                    case 153 /* ActionJump */:
                    case 62 /* ActionReturn */:
                        return '';
                    case 136 /* ActionConstantPool */:
                        res.constantPool = item.action.args[0];
                        return '  constantPool = [' + this.convertArgs(item.action.args[0], id, res) + '];\n' + '  ectx.constantPool = constantPool;\n';
                    case 150 /* ActionPush */:
                        return '  stack.push(' + this.convertArgs(item.action.args, id, res) + ');\n';
                    case 138 /* ActionWaitForFrame */:
                    case 141 /* ActionWaitForFrame2 */:
                        return '  if (calls.' + item.action.actionName + '(ectx,[' + this.convertArgs(item.action.args, id, res) + '])) { position = ' + item.conditionalJumpTo + '; break; }\n';
                    case 157 /* ActionIf */:
                        return '  if (!!stack.pop()) { position = ' + item.conditionalJumpTo + '; break; }\n';
                    default:
                        var result = '  calls.' + item.action.actionName + '(ectx' + (item.action.args ? ',[' + this.convertArgs(item.action.args, id, res) + ']' : '') + ');\n';
                        return result;
                }
            };
            ActionsDataCompiler.prototype.checkAvm1Timeout = function (ectx) {
                if (Date.now() >= ectx.context.abortExecutionAt) {
                    throw new AS2CriticalError('long running script -- AVM1 instruction hang timeout');
                }
            };
            ActionsDataCompiler.prototype.generate = function (ir) {
                var _this = this;
                var blocks = ir.blocks;
                var res = {};
                var uniqueId = 0;
                var debugName = ir.dataId;
                var fn = 'return function avm1gen_' + debugName + '(ectx) {\n' + 'var position = 0;\n' + 'var checkTimeAfter = 0;\n' + 'var constantPool = ectx.constantPool, registers = ectx.registers, stack = ectx.stack;\n';
                if (AVM1.avm1DebuggerEnabled.value) {
                    fn += '/* Running ' + debugName + ' */ ' + 'if (Shumway.AVM1.Debugger.pause || Shumway.AVM1.Debugger.breakpoints.' + debugName + ') { debugger; }\n';
                }
                fn += 'while (!ectx.isEndOfActions) {\n' + 'if (checkTimeAfter <= 0) { checkTimeAfter = ' + CHECK_AVM1_HANG_EVERY + '; checkTimeout(ectx); }\n' + 'switch(position) {\n';
                blocks.forEach(function (b) {
                    fn += ' case ' + b.label + ':\n';
                    b.items.forEach(function (item) {
                        fn += _this.convertAction(item, uniqueId++, res);
                    });
                    fn += '  position = ' + b.jump + ';\n' + '  checkTimeAfter -= ' + b.items.length + ';\n' + '  break;\n';
                });
                fn += ' default: ectx.isEndOfActions = true; break;\n}\n}\n' + 'return stack.pop();};';
                return (new Function('calls', 'res', 'checkTimeout', fn))(ActionsDataCompiler.cachedCalls, res, this.checkAvm1Timeout);
            };
            return ActionsDataCompiler;
        })();

        var ActionTracerFactory = (function () {
            function ActionTracerFactory() {
            }
            ActionTracerFactory.get = function () {
                return AVM1.avm1TraceEnabled.value ? ActionTracerFactory.tracer : ActionTracerFactory.nullTracer;
            };
            ActionTracerFactory.tracer = (function () {
                var indentation = 0;
                return {
                    print: function (parsedAction, stack) {
                        var position = parsedAction.position;
                        var actionCode = parsedAction.actionCode;
                        var actionName = parsedAction.actionName;
                        var stackDump = [];
                        for (var q = 0; q < stack.length; q++) {
                            var item = stack[q];
                            stackDump.push(item && typeof item === 'object' ? '[' + (item.constructor && item.constructor.name ? item.constructor.name : 'Object') + ']' : item);
                        }

                        var indent = new Array(indentation + 1).join('..');

                        console.log('AVM1 trace: ' + indent + position + ': ' + actionName + '(' + actionCode.toString(16) + '), ' + 'stack=' + stackDump);
                    },
                    indent: function () {
                        indentation++;
                    },
                    unindent: function () {
                        indentation--;
                    },
                    message: function (msg) {
                        console.log('AVM1 trace: ------- ' + msg);
                    }
                };
            })();

            ActionTracerFactory.nullTracer = {
                print: function (parsedAction, stack) {
                },
                indent: function () {
                },
                unindent: function () {
                },
                message: function (msg) {
                }
            };
            return ActionTracerFactory;
        })();
    })(Shumway.AVM1 || (Shumway.AVM1 = {}));
    var AVM1 = Shumway.AVM1;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations undxr the License.
*/
///<reference path='references.ts' />
var ASNative = Shumway.AVM2.AS.ASNative;
var ASObject = Shumway.AVM2.AS.ASObject;
var flash = Shumway.AVM2.AS.flash;
var Shumway;
(function (Shumway) {
    (function (AVM1) {
        var AS2Utils = (function (_super) {
            __extends(AS2Utils, _super);
            function AS2Utils() {
                false && _super.call(this);
            }
            // JS -> AS Bindings
            // static getTarget:(A:ASObject) => any;
            // static addEventHandlerProxy:(A:ASObject, B:string, C:string, D:ASFunction = null) => any;
            // AS -> JS Bindings
            AS2Utils.addProperty = function (obj, propertyName, getter, setter, enumerable) {
                if (typeof enumerable === "undefined") { enumerable = true; }
                obj.asDefinePublicProperty(propertyName, {
                    get: getter,
                    set: setter || undefined,
                    enumerable: enumerable,
                    configurable: true
                });
            };

            AS2Utils.resolveTarget = function (target_mc) {
                if (typeof target_mc === "undefined") { target_mc = undefined; }
                return AVM1.AS2Context.instance.resolveTarget(target_mc);
            };

            AS2Utils.resolveLevel = function (level) {
                level = +level;
                return AVM1.AS2Context.instance.resolveLevel(level);
            };

            Object.defineProperty(AS2Utils, "currentStage", {
                get: function () {
                    return AVM1.AS2Context.instance.stage;
                },
                enumerable: true,
                configurable: true
            });

            AS2Utils.getAS2Object = function (as3Object) {
                return AVM1.getAS2Object(as3Object);
            };

            AS2Utils._installObjectMethods = function () {
                var c = ASObject, p = c.asGetPublicProperty('prototype');
                c.asSetPublicProperty('registerClass', function registerClass(name, theClass) {
                    var classes = AVM1.AS2Context.instance.classes || (AVM1.AS2Context.instance.classes = {});
                    classes[name] = theClass;
                });
                p.asDefinePublicProperty('addProperty', {
                    value: function addProperty(name, getter, setter) {
                        if (typeof name !== 'string' || name === '') {
                            return false;
                        }
                        if (typeof getter !== 'function') {
                            return false;
                        }
                        if (typeof setter !== 'function' && setter !== null) {
                            return false;
                        }
                        this.asDefinePublicProperty(name, {
                            get: getter,
                            set: setter || undefined,
                            configurable: true,
                            enumerable: true
                        });
                        return true;
                    },
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
            };
            AS2Utils.classInitializer = null;

            AS2Utils.initializer = null;

            AS2Utils.classSymbols = null;

            AS2Utils.instanceSymbols = null;
            return AS2Utils;
        })(ASNative);
        AVM1.AS2Utils = AS2Utils;

        function initDefaultListeners(thisArg) {
            var defaultListeners = thisArg.asGetPublicProperty('_as2DefaultListeners');
            if (!defaultListeners) {
                return;
            }
            for (var i = 0; i < defaultListeners.length; i++) {
                var p = defaultListeners[i];
                p.asGetPublicProperty('setter').call(thisArg, p.value);
            }
        }
        AVM1.initDefaultListeners = initDefaultListeners;

        function getAS2Object(as3Object) {
            if (!as3Object) {
                return null;
            }
            if (as3Object._as2Object) {
                return as3Object._as2Object;
            }
            if (flash.display.MovieClip.isType(as3Object)) {
                if (as3Object._as2SymbolClass) {
                    var ctor = as3Object._as2SymbolClass;
                    return new ctor(as3Object);
                }
                return new Shumway.AVM2.AS.avm1lib.AS2MovieClip(as3Object);
            }
            if (flash.display.SimpleButton.isType(as3Object)) {
                return new Shumway.AVM2.AS.avm1lib.AS2Button(as3Object);
            }
            if (flash.text.TextField.isType(as3Object)) {
                return new Shumway.AVM2.AS.avm1lib.AS2TextField(as3Object);
            }
            if (flash.display.BitmapData.isType(as3Object)) {
                return new as3Object;
            }

            return null;
        }
        AVM1.getAS2Object = getAS2Object;
    })(Shumway.AVM1 || (Shumway.AVM1 = {}));
    var AVM1 = Shumway.AVM1;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations undxr the License.
            */
            // Class: AS2Button
            (function (avm1lib) {
                var somewhatImplemented = Shumway.Debug.somewhatImplemented;

                var StateTransitions;
                (function (StateTransitions) {
                    StateTransitions[StateTransitions["IdleToOverUp"] = 0x001] = "IdleToOverUp";
                    StateTransitions[StateTransitions["OverUpToIdle"] = 0x002] = "OverUpToIdle";
                    StateTransitions[StateTransitions["OverUpToOverDown"] = 0x004] = "OverUpToOverDown";
                    StateTransitions[StateTransitions["OverDownToOverUp"] = 0x008] = "OverDownToOverUp";
                    StateTransitions[StateTransitions["OverDownToOutDown"] = 0x010] = "OverDownToOutDown";
                    StateTransitions[StateTransitions["OutDownToOverDown"] = 0x020] = "OutDownToOverDown";
                    StateTransitions[StateTransitions["OutDownToIdle"] = 0x040] = "OutDownToIdle";
                    StateTransitions[StateTransitions["IdleToOverDown"] = 0x080] = "IdleToOverDown";
                    StateTransitions[StateTransitions["OverDownToIdle"] = 0x100] = "OverDownToIdle";
                })(StateTransitions || (StateTransitions = {}));

                /**
                * Key codes below 32 aren't interpreted as char codes, but are mapped to specific buttons instead.
                * This array uses the key code as the index and KeyboardEvent.keyCode values matching the
                * specific keys as the value.
                * @type {number[]}
                */
                var AVM1KeyCodeMap = [-1, 37, 39, 36, 35, 45, 46, -1, 8, -1, -1, -1, -1, 13, 38, 40, 33, 34, 9, 27];

                var AS2Button = (function (_super) {
                    __extends(AS2Button, _super);
                    function AS2Button(nativeButton) {
                        false && _super.call(this);
                        if (nativeButton) {
                            this._init(nativeButton);
                        }
                    }
                    // JS -> AS Bindings
                    // AS -> JS Bindings
                    // __as3Object: flash.display.SimpleButton;
                    AS2Button.prototype._init = function (nativeButton) {
                        this._nativeAS3Object = nativeButton;
                        Shumway.AVM1.initDefaultListeners(this);
                        if (!nativeButton._symbol || !nativeButton._symbol.buttonActions) {
                            return;
                        }
                        this._nativeAS3Object.addEventListener('addedToStage', this._addListeners.bind(this));
                        this._nativeAS3Object.addEventListener('removedFromStage', this._removeListeners.bind(this));
                        var requiredListeners = this._requiredListeners = Object.create(null);
                        var actions = this._actions = nativeButton._symbol.buttonActions;
                        for (var i = 0; i < actions.length; i++) {
                            var action = actions[i];
                            if (!action.actionsBlock) {
                                action.actionsBlock = new Shumway.AVM1.AS2ActionsData(action.actionsData, 'i' + i);
                            }
                            if (action.keyCode) {
                                requiredListeners['keyDown'] = this._keyDownHandler.bind(this);
                                continue;
                            }
                            var type;
                            switch (action.stateTransitionFlags) {
                                case 64 /* OutDownToIdle */:
                                    type = 'releaseOutside';
                                    break;
                                case 1 /* IdleToOverUp */:
                                    type = 'rollOver';
                                    break;
                                case 2 /* OverUpToIdle */:
                                    type = 'rollOut';
                                    break;
                                case 4 /* OverUpToOverDown */:
                                    type = 'mouseDown';
                                    break;
                                case 8 /* OverDownToOverUp */:
                                    type = 'mouseUp';
                                    break;
                                case 16 /* OverDownToOutDown */:
                                case 32 /* OutDownToOverDown */:
                                    somewhatImplemented('AVM1 drag over/out button actions');
                                    break;
                                case 128 /* IdleToOverDown */:
                                case 256 /* OverDownToIdle */:
                                    somewhatImplemented('AVM1 drag trackAsMenu over/out button actions');
                                    break;
                                default:
                                    warn('Unknown AVM1 button action type: ' + action.stateTransitionFlags);
                                    continue;
                            }
                            requiredListeners[type] = this._mouseEventHandler.bind(this, action.stateTransitionFlags);
                        }
                    };

                    AS2Button.prototype._addListeners = function () {
                        for (var type in this._requiredListeners) {
                            // on(key) works even if the button doesn't have focus, so we listen on the stage.
                            // TODO: we probably need to filter these events somehow if an AVM1 swf is loaded into
                            // an AVM2 one.
                            var target = type === 'keyDown' ? this._nativeAS3Object.stage : this._nativeAS3Object;
                            target.addEventListener(type, this._requiredListeners[type]);
                        }
                    };
                    AS2Button.prototype._removeListeners = function () {
                        for (var type in this._requiredListeners) {
                            var target = type === 'keyDown' ? this._nativeAS3Object.stage : this._nativeAS3Object;
                            target.removeEventListener(type, this._requiredListeners[type]);
                        }
                    };

                    AS2Button.prototype._keyDownHandler = function (event) {
                        var actions = this._actions;
                        for (var i = 0; i < actions.length; i++) {
                            var action = actions[i];
                            if (!action.keyCode) {
                                continue;
                            }
                            if ((action.keyCode < 32 && AVM1KeyCodeMap[action.keyCode] === event.asGetPublicProperty('keyCode')) || action.keyCode === event.asGetPublicProperty('charCode')) {
                                this._runAction(action);
                            }
                        }
                    };

                    AS2Button.prototype._mouseEventHandler = function (type) {
                        var actions = this._actions;
                        for (var i = 0; i < actions.length; i++) {
                            var action = actions[i];
                            if (action.stateTransitionFlags === type) {
                                this._runAction(action);
                            }
                        }
                    };

                    AS2Button.prototype._runAction = function (action) {
                        var avm1Context = this._nativeAS3Object.loaderInfo._avm1Context;
                        avm1Context.executeActions(action.actionsBlock, this._nativeAS3Object.stage, Shumway.AVM1.AS2Utils.getAS2Object(this._nativeAS3Object._parent));
                    };
                    Object.defineProperty(AS2Button.prototype, "_as3Object", {
                        get: function () {
                            return this._nativeAS3Object;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AS2Button.classInitializer = null;

                    AS2Button.initializer = null;

                    AS2Button.classSymbols = null;

                    AS2Button.instanceSymbols = null;
                    return AS2Button;
                })(AS.ASNative);
                avm1lib.AS2Button = AS2Button;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations undxr the License.
            */
            // Class: AS2Globals
            (function (avm1lib) {
                var assert = Shumway.Debug.assert;
                var notImplemented = Shumway.Debug.notImplemented;

                var TextFormat = Shumway.AVM2.AS.flash.text.TextFormat;
                var AS2Context = Shumway.AVM1.AS2Context;
                var Natives = Shumway.AVM2.AS.Natives;

                var AS2Globals = (function (_super) {
                    __extends(AS2Globals, _super);
                    function AS2Globals() {
                        false && _super.call(this);
                        notImplemented("Dummy Constructor: public avm1lib.AS2Globals");
                    }
                    // AS -> JS Bindings
                    AS2Globals._addInternalClasses = function (proto) {
                        var obj = proto;
                        obj.asSetPublicProperty('Object', AS.ASObject);
                        obj.asSetPublicProperty('Function', AS.ASFunction);
                        obj.asSetPublicProperty('Array', AS.ASArray);
                        obj.asSetPublicProperty('Number', AS.ASNumber);
                        obj.asSetPublicProperty('Math', AS.ASMath);
                        obj.asSetPublicProperty('Boolean', AS.ASBoolean);
                        obj.asSetPublicProperty('Date', AS.ASDate);
                        obj.asSetPublicProperty('RegExp', AS.ASRegExp);
                        obj.asSetPublicProperty('String', AS.ASString);
                    };

                    AS2Globals.prototype.ASSetPropFlags = function (obj, children, flags, allowFalse) {
                        // flags (from bit 0): dontenum, dontdelete, readonly, ....
                        // TODO
                    };
                    AS2Globals.prototype._addToPendingScripts = function (subject, fn, args) {
                        if (typeof args === "undefined") { args = null; }
                        release || assert(fn, 'invalid function in _addToPendingScripts');
                        AS2Context.instance.addToPendingScripts(function () {
                            fn.apply(subject, args);
                        });
                    };

                    /**
                    * AS2 escapes slightly more characters than JS's encodeURIComponent, and even more than
                    * the deprecated JS version of escape. That leaves no other option but to do manual post-
                    * processing of the encoded result. :/
                    *
                    * Luckily, unescape isn't thus afflicted - it happily unescapes all the additional things
                    * we escape here.
                    */
                    AS2Globals.prototype.escape = function (str) {
                        var result = encodeURIComponent(str);
                        return result.replace(/\!|'|\(|\)|\*|-|\.|_|~/g, function (char) {
                            switch (char) {
                                case '*':
                                    return '%2A';
                                case '-':
                                    return '%2D';
                                case '.':
                                    return '%2E';
                                case '_':
                                    return '%5F';
                                default:
                                    return globalEscape(char);
                            }
                        });
                    };

                    AS2Globals.prototype.unescape = function (str) {
                        return decodeURIComponent(str);
                    };

                    AS2Globals.prototype._setLevel = function (level /*uint*/ , loader) {
                        level = level >>> 0;
                        AS2Context.instance.stage._as2SetLevel(level, loader);
                    };
                    AS2Globals.prototype.trace = function (expression) {
                        Natives.print(expression);
                    };
                    AS2Globals.classInitializer = null;

                    AS2Globals.initializer = function () {
                        // The AS2 version of TextFormat has an additional method "getTextExtent".
                        // We install that here so we don't need to have a full AS2 version of
                        // TextFormat and take care to return that everywhere when in AS2 mode.
                        TextFormat.prototype.asDefinePublicProperty('getTextExtent', {
                            value: avm1lib.AS2TextFormat.prototype._as2GetTextExtent,
                            writable: false,
                            enumerable: false,
                            configurable: false
                        });
                    };

                    AS2Globals.classSymbols = null;

                    AS2Globals.instanceSymbols = [
                        "_global!", "flash", "$asfunction", "call!", "chr!",
                        "clearInterval!", "clearTimeout!", "duplicateMovieClip!",
                        "fscommand", "getAS2Property!", "getTimer!",
                        "getURL!", "getVersion!", "gotoAndPlay!", "gotoAndStop!",
                        "gotoLabel!", "ifFrameLoaded!", "int!", "length!", "loadMovie!",
                        "loadMovieNum!", "loadVariables!", "mbchr!", "mblength!",
                        "mbord!", "mbsubstring!", "nextFrame!", "nextScene!", "ord!",
                        "play!", "prevFrame!", "prevScene!", "print!", "printAsBitmap!",
                        "printAsBitmapNum!", "printNum!", "random!",
                        "removeMovieClip!", "setInterval!", "setAS2Property!",
                        "setTimeout!", "showRedrawRegions!", "startDrag!", "stop!",
                        "stopAllSounds!", "stopDrag!", "substring!", "targetPath!",
                        "toggleHighQuality!", "unloadMovie!",
                        "unloadMovieNum!", "updateAfterEvent!"];
                    return AS2Globals;
                })(AS.ASNative);
                avm1lib.AS2Globals = AS2Globals;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));

var globalEscape = this['escape'];
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations undxr the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            ///<reference path='references.ts' />
            (function (avm1lib) {
                var construct = Shumway.AVM2.Runtime.construct;
                var AS2Context = Shumway.AVM1.AS2Context;
                var getAS2Object = Shumway.AVM1.getAS2Object;

                var AS2MovieClip = (function (_super) {
                    __extends(AS2MovieClip, _super);
                    function AS2MovieClip(nativeMovieClip) {
                        false && _super.call(this);
                        this._nativeAS3Object = nativeMovieClip;
                    }
                    // AS -> JS Bindings
                    // __as3Object: flash.display.MovieClip;
                    AS2MovieClip.prototype._init = function (nativeMovieClip) {
                        if (!nativeMovieClip) {
                            return;
                        }
                        this._nativeAS3Object = nativeMovieClip;
                        nativeMovieClip._as2Object = this;
                        Shumway.AVM1.initDefaultListeners(this);
                    };
                    Object.defineProperty(AS2MovieClip.prototype, "_as3Object", {
                        get: function () {
                            return this._nativeAS3Object;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    AS2MovieClip.prototype.attachBitmap = function (bmp, depth, pixelSnapping, smoothing) {
                        if (typeof pixelSnapping === "undefined") { pixelSnapping = 'auto'; }
                        if (typeof smoothing === "undefined") { smoothing = false; }
                        var bitmap = construct(AS.flash.display.Bitmap, [bmp, pixelSnapping, smoothing]);
                        this._insertChildAtDepth(bitmap, depth);
                    };

                    AS2MovieClip.prototype._constructMovieClipSymbol = function (symbolId, name) {
                        var theClass = AS2Context.instance.classes && AS2Context.instance.classes[symbolId];
                        var symbol = AS2Context.instance.getAsset(symbolId);

                        var mc = AS.flash.display.MovieClip.initializeFrom(symbol);
                        AS.flash.display.MovieClip.instanceConstructorNoInitialize.call(mc);
                        mc._as2SymbolClass = theClass;
                        mc._name = name;

                        return mc;
                    };
                    AS2MovieClip.prototype._callFrame = function (frame) {
                        var nativeAS3Object = this._nativeAS3Object;
                        nativeAS3Object._callFrame(frame);
                    };
                    AS2MovieClip.prototype._insertChildAtDepth = function (mc, depth) {
                        var nativeAS3Object = this._nativeAS3Object;
                        nativeAS3Object.addChildAtDepth(mc, Math.min(nativeAS3Object.numChildren, depth));

                        // Bitmaps aren't reflected in AS2, so the rest here doesn't apply.
                        if (AS.flash.display.Bitmap.isType(mc)) {
                            return null;
                        }
                        var as2mc = getAS2Object(mc);
                        var name = mc.name;
                        if (name) {
                            this.asSetPublicProperty(name, as2mc);
                        }
                        return as2mc;
                    };

                    AS2MovieClip.prototype.getInstanceAtDepth = function (depth) {
                        var nativeObject = this._nativeAS3Object;
                        for (var i = 0, numChildren = nativeObject.numChildren; i < numChildren; i++) {
                            var child = nativeObject.getChildAt(i);

                            // child is null if it hasn't been constructed yet. This can happen in InitActionBlocks.
                            if (child && child._depth === depth) {
                                // Somewhat absurdly, this method returns the mc if a bitmap is at the given depth.
                                if (AS.flash.display.Bitmap.isType(child)) {
                                    return this;
                                }
                                return getAS2Object(child);
                            }
                        }
                        return null;
                    };
                    AS2MovieClip.prototype.getNextHighestDepth = function () {
                        var nativeObject = this._nativeAS3Object;
                        var maxDepth = 0;
                        for (var i = 0, numChildren = nativeObject.numChildren; i < numChildren; i++) {
                            var child = nativeObject.getChildAt(i);
                            if (child._depth > maxDepth) {
                                maxDepth = child._depth;
                            }
                        }
                        return maxDepth + 1;
                    };

                    AS2MovieClip.prototype._duplicate = function (name, depth, initObject) {
                        var nativeAS3Object = this._nativeAS3Object;
                        nativeAS3Object._duplicate(name, depth, initObject);
                    };
                    AS2MovieClip.prototype._gotoLabel = function (label) {
                        var nativeAS3Object = this._nativeAS3Object;
                        nativeAS3Object._gotoFrame(label, null);
                    };
                    AS2MovieClip.classInitializer = null;

                    AS2MovieClip.initializer = null;

                    AS2MovieClip.classSymbols = null;

                    AS2MovieClip.instanceSymbols = ["__lookupChild!", "__targetPath!"];
                    return AS2MovieClip;
                })(AS.ASNative);
                avm1lib.AS2MovieClip = AS2MovieClip;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations undxr the License.
            */
            // Class: AS2MovieClipLoader
            (function (avm1lib) {
                var AS2MovieClipLoader = (function (_super) {
                    __extends(AS2MovieClipLoader, _super);
                    function AS2MovieClipLoader() {
                        false && _super.call(this);
                    }
                    Object.defineProperty(AS2MovieClipLoader.prototype, "_as3Object", {
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        // __bytesLoaded: number;
                        get: function () {
                            return this._nativeAS3Object;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AS2MovieClipLoader.prototype._setAS3Object = function (nativeLoader) {
                        this._nativeAS3Object = nativeLoader;
                    };
                    Object.defineProperty(AS2MovieClipLoader.prototype, "_bytesLoaded", {
                        get: function () {
                            var nativeAS3Object = this._nativeAS3Object;
                            return nativeAS3Object._contentLoaderInfo._bytesLoaded;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AS2MovieClipLoader.classInitializer = null;

                    AS2MovieClipLoader.initializer = null;

                    AS2MovieClipLoader.classSymbols = null;

                    AS2MovieClipLoader.instanceSymbols = null;
                    return AS2MovieClipLoader;
                })(AS.ASNative);
                avm1lib.AS2MovieClipLoader = AS2MovieClipLoader;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations undxr the License.
*/
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            (function (avm1lib) {
                var BitmapData = Shumway.AVM2.AS.flash.display.BitmapData;
                var asCoerceString = Shumway.AVM2.Runtime.asCoerceString;
                var AS2Context = Shumway.AVM1.AS2Context;

                var AS2BitmapData = (function (_super) {
                    __extends(AS2BitmapData, _super);
                    function AS2BitmapData(bitmapData, pixelSnapping, smoothing) {
                        false && _super.call(this);
                    }
                    AS2BitmapData.loadBitmap = function (symbolId) {
                        symbolId = asCoerceString(symbolId);
                        var symbol = AS2Context.instance.getAsset(symbolId);
                        if (symbol instanceof Shumway.Timeline.BitmapSymbol) {
                            var bitmap = AS2BitmapData.initializeFrom(symbol);
                            bitmap.class.instanceConstructorNoInitialize.call(bitmap);
                            return bitmap;
                        }
                        return null;
                    };
                    AS2BitmapData.classInitializer = null;

                    AS2BitmapData.initializer = null;

                    AS2BitmapData.classSymbols = null;

                    AS2BitmapData.instanceSymbols = null;
                    return AS2BitmapData;
                })(BitmapData);
                avm1lib.AS2BitmapData = AS2BitmapData;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations undxr the License.
            */
            // Class: AS2TextField
            (function (avm1lib) {
                var getAS2Object = Shumway.AVM1.getAS2Object;

                var AS2TextField = (function (_super) {
                    __extends(AS2TextField, _super);
                    function AS2TextField(nativeTextField) {
                        false && _super.call(this);

                        this._variable = '';
                        this._init(nativeTextField);
                    }
                    // JS -> AS Bindings
                    // AS -> JS Bindings
                    AS2TextField.prototype._init = function (nativeTextField) {
                        this._nativeAS3Object = nativeTextField;
                        nativeTextField._as2Object = this;
                        Shumway.AVM1.initDefaultListeners(this);
                    };
                    Object.defineProperty(AS2TextField.prototype, "_as3Object", {
                        get: function () {
                            return this._nativeAS3Object;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AS2TextField.prototype, "variable", {
                        get: function () {
                            return this._variable;
                        },
                        set: function (name) {
                            if (name === this._variable) {
                                return;
                            }
                            this._variable = name;
                            var instance = this._nativeAS3Object;
                            var hasPath = name.indexOf('.') >= 0 || name.indexOf(':') >= 0;
                            var clip;
                            if (hasPath) {
                                var targetPath = name.split(/[.:\/]/g);
                                name = targetPath.pop();
                                if (targetPath[0] == '_root' || targetPath[0] === '') {
                                    clip = getAS2Object(instance.root);
                                    targetPath.shift();
                                    if (targetPath[0] === '') {
                                        targetPath.shift();
                                    }
                                } else {
                                    clip = getAS2Object(instance._parent);
                                }
                                while (targetPath.length > 0) {
                                    var childName = targetPath.shift();
                                    clip = clip.asGetPublicProperty(childName) || clip[childName];
                                    if (!clip) {
                                        throw new Error('Cannot find ' + childName + ' variable');
                                    }
                                }
                            } else {
                                clip = getAS2Object(instance._parent);
                            }
                            if (!clip.asHasProperty(undefined, name, 0)) {
                                clip.asSetPublicProperty(name, instance.text);
                            }
                            instance._addEventListener('advanceFrame', function () {
                                instance.text = '' + clip.asGetPublicProperty(name);
                            });
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AS2TextField.classInitializer = null;

                    AS2TextField.initializer = null;

                    AS2TextField.classSymbols = null;

                    AS2TextField.instanceSymbols = null;
                    return AS2TextField;
                })(AS.ASNative);
                avm1lib.AS2TextField = AS2TextField;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (AVM2) {
        (function (AS) {
            /**
            * Copyright 2014 Mozilla Foundation
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            * http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations undxr the License.
            */
            // Class: AS2TextField
            (function (avm1lib) {
                var TextField = Shumway.AVM2.AS.flash.text.TextField;
                var TextFormat = Shumway.AVM2.AS.flash.text.TextFormat;

                var AS2TextFormat = (function (_super) {
                    __extends(AS2TextFormat, _super);
                    function AS2TextFormat() {
                        _super.apply(this, arguments);
                    }
                    AS2TextFormat.prototype._as2GetTextExtent = function (text, width) {
                        var measureTextField = AS2TextFormat._measureTextField;
                        if (!measureTextField) {
                            measureTextField = new TextField();
                            measureTextField.multiline = true;
                            AS2TextFormat._measureTextField = measureTextField;
                        }
                        if (!isNaN(width) && width > 0) {
                            measureTextField.width = width + 4;
                            measureTextField.wordWrap = true;
                        } else {
                            measureTextField.wordWrap = false;
                        }
                        measureTextField.defaultTextFormat = this;
                        measureTextField.text = text;
                        var result = {};
                        var textWidth = measureTextField.textWidth;
                        var textHeight = measureTextField.textHeight;
                        result.asSetPublicProperty('width', textWidth);
                        result.asSetPublicProperty('height', textHeight);
                        result.asSetPublicProperty('textFieldWidth', textWidth + 4);
                        result.asSetPublicProperty('textFieldHeight', textHeight + 4);
                        var metrics = measureTextField.getLineMetrics(0);
                        result.asSetPublicProperty('ascent', metrics.asGetPublicProperty('ascent'));
                        result.asSetPublicProperty('descent', metrics.asGetPublicProperty('descent'));
                        return result;
                    };
                    return AS2TextFormat;
                })(TextFormat);
                avm1lib.AS2TextFormat = AS2TextFormat;
            })(AS.avm1lib || (AS.avm1lib = {}));
            var avm1lib = AS.avm1lib;
        })(AVM2.AS || (AVM2.AS = {}));
        var AS = AVM2.AS;
    })(Shumway.AVM2 || (Shumway.AVM2 = {}));
    var AVM2 = Shumway.AVM2;
})(Shumway || (Shumway = {}));
// ///<reference path='../flash/references.ts' />
///<reference path='../avm1/references.ts' />
///<reference path='AS2Button.ts' />
///<reference path='AS2Globals.ts' />
///<reference path='AS2MovieClip.ts' />
///<reference path='AS2MovieClipLoader.ts' />
///<reference path='AS2BitmapData.ts' />
///<reference path='AS2TextField.ts' />
///<reference path='AS2TextFormat.ts' />
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/avm2.d.ts' />
///<reference path='stream.ts' />
///<reference path='parser.ts' />
///<reference path='analyze.ts' />
///<reference path='context.ts' />
///<reference path='interpreter.ts' />
///<reference path='AS2Utils.ts' />
///<reference path='flash.d.ts' />
///<reference path='../avm1lib/references.ts' />
//# sourceMappingURL=avm1.js.map

console.timeEnd("Load AVM1 Dependencies");
/*
* Copyright 2013 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (Player) {
        Player.timelineBuffer = new Shumway.Tools.Profiler.TimelineBuffer("Player");
        Player.counter = new Shumway.Metrics.Counter(!release);

        Player.writer = null;

        function enterTimeline(name, data) {
            Player.writer && Player.writer.enter(name);
            profile && Player.timelineBuffer && Player.timelineBuffer.enter(name, data);
        }
        Player.enterTimeline = enterTimeline;

        function leaveTimeline(name, data) {
            Player.writer && Player.writer.leave(name);
            profile && Player.timelineBuffer && Player.timelineBuffer.leave(name, data);
        }
        Player.leaveTimeline = leaveTimeline;
    })(Shumway.Player || (Shumway.Player = {}));
    var Player = Shumway.Player;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    var OptionSet = Shumway.Options.OptionSet;

    var shumwayOptions = Shumway.Settings.shumwayOptions;

    Shumway.playerOptions = shumwayOptions.register(new OptionSet("Player Options"));

    Shumway.frameEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Enable Frame Execution", "boolean", true, "Enable frame execution."));

    Shumway.timerEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Enable Timers", "boolean", true, "Enable timer events."));

    Shumway.pumpEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Enable Pump", "boolean", true, "Enable display tree serialization."));

    Shumway.pumpRateOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Pump Rate", "number", 80, "Number of times / second that the display list is synchronized.", { range: { min: 1, max: 120, step: 1 } }));

    Shumway.frameRateOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Frame Rate", "number", -1, "Override a movie's frame rate, set to -1 to use the movies default frame rate.", { range: { min: -1, max: 120, step: 1 } }));

    Shumway.tracePlayerOption = Shumway.playerOptions.register(new Shumway.Options.Option("tp", "Trace Player", "number", 0, "Trace player every n frames.", { range: { min: 0, max: 512, step: 1 } }));

    Shumway.frameRateMultiplierOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Frame Rate Multiplier", "number", 1, "Play frames at a faster rate.", { range: { min: 1, max: 16, step: 1 } }));

    Shumway.dontSkipFramesOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Disables Frame Skipping", "boolean", false, "Play all frames, e.g. no skipping frame during throttle."));

    Shumway.playAllSymbolsOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbols", "boolean", false, "Plays all SWF symbols automatically."));

    Shumway.playSymbolOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbol Number", "number", 0, "Select symbol by Id.", { range: { min: 0, max: 20000, step: 1 } }));

    Shumway.playSymbolFrameDurationOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbol Duration", "number", 0, "How many frames to play, 0 for all frames of the movie clip.", { range: { min: 0, max: 128, step: 1 } }));

    Shumway.playSymbolCountOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbol Count", "number", -1, "Select symbol count.", { range: { min: 0, max: 20000, step: 1 } }));

    Shumway.stageScaleOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Stage Scale", "number", 1, "Scales the symbols.", { range: { min: 0.1, max: 16, step: 0.01 } }));
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    var FrameScheduler = (function () {
        function FrameScheduler() {
            this._expectedNextFrameAt = performance.now();
            this._drawStats = [];
            this._drawStatsSum = 0;
            this._drawStarted = 0;
            this._drawsSkipped = 0;
            this._expectedNextFrameAt = performance.now();
            this._onTime = true;
            this._trackDelta = false;
            this._delta = 0;
            this._onTimeDelta = 0;
        }
        Object.defineProperty(FrameScheduler.prototype, "shallSkipDraw", {
            get: function () {
                if (this._drawsSkipped >= FrameScheduler.MAX_DRAWS_TO_SKIP) {
                    return false;
                }
                var averageDraw = this._drawStats.length < FrameScheduler.STATS_TO_REMEMBER ? 0 : this._drawStatsSum / this._drawStats.length;
                var estimatedDrawEnd = performance.now() + averageDraw;
                return estimatedDrawEnd + FrameScheduler.INTERVAL_PADDING_MS > this._expectedNextFrameAt;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(FrameScheduler.prototype, "nextFrameIn", {
            get: function () {
                return Math.max(0, this._expectedNextFrameAt - performance.now());
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(FrameScheduler.prototype, "isOnTime", {
            get: function () {
                return this._onTime;
            },
            enumerable: true,
            configurable: true
        });

        FrameScheduler.prototype.startFrame = function (frameRate) {
            var interval = 1000 / frameRate;

            var adjustedInterval = interval;
            var delta = this._onTimeDelta + this._delta;
            if (delta !== 0) {
                if (delta < 0) {
                    adjustedInterval *= FrameScheduler.SPEED_ADJUST_RATE;
                } else if (delta > 0) {
                    adjustedInterval /= FrameScheduler.SPEED_ADJUST_RATE;
                }
                this._onTimeDelta += (interval - adjustedInterval);
            }

            this._expectedNextFrameAt += adjustedInterval;
            this._onTime = true;
        };

        FrameScheduler.prototype.endFrame = function () {
            var estimatedNextFrameStart = performance.now() + FrameScheduler.INTERVAL_PADDING_MS;
            if (estimatedNextFrameStart > this._expectedNextFrameAt) {
                if (this._trackDelta) {
                    this._onTimeDelta += (this._expectedNextFrameAt - estimatedNextFrameStart);
                    console.log(this._onTimeDelta);
                }
                this._expectedNextFrameAt = estimatedNextFrameStart;
                this._onTime = false;
            }
        };

        FrameScheduler.prototype.startDraw = function () {
            this._drawsSkipped = 0;
            this._drawStarted = performance.now();
        };

        FrameScheduler.prototype.endDraw = function () {
            var drawTime = performance.now() - this._drawStarted;
            this._drawStats.push(drawTime);
            this._drawStatsSum += drawTime;
            while (this._drawStats.length > FrameScheduler.STATS_TO_REMEMBER) {
                this._drawStatsSum -= this._drawStats.shift();
            }
        };

        FrameScheduler.prototype.skipDraw = function () {
            this._drawsSkipped++;
        };

        FrameScheduler.prototype.setDelta = function (value) {
            if (!this._trackDelta) {
                return;
            }
            this._delta = value;
        };

        FrameScheduler.prototype.startTrackDelta = function () {
            this._trackDelta = true;
        };

        FrameScheduler.prototype.endTrackDelta = function () {
            if (!this._trackDelta) {
                return;
            }
            this._trackDelta = false;
            this._delta = 0;
            this._onTimeDelta = 0;
        };
        FrameScheduler.STATS_TO_REMEMBER = 50;
        FrameScheduler.MAX_DRAWS_TO_SKIP = 2;
        FrameScheduler.INTERVAL_PADDING_MS = 4;
        FrameScheduler.SPEED_ADJUST_RATE = 0.9;
        return FrameScheduler;
    })();
    Shumway.FrameScheduler = FrameScheduler;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    (function (Remoting) {
        /**
        * Copyright 2014 Mozilla Foundation
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        (function (Player) {
            var MessageTag = Shumway.Remoting.MessageTag;
            var MessageBits = Shumway.Remoting.MessageBits;

            var flash = Shumway.AVM2.AS.flash;

            var display = Shumway.AVM2.AS.flash.display;

            var BitmapData = Shumway.AVM2.AS.flash.display.BitmapData;

            var DisplayObjectFlags = Shumway.AVM2.AS.flash.display.DisplayObjectFlags;

            var BlendMode = Shumway.AVM2.AS.flash.display.BlendMode;
            var PixelSnapping = Shumway.AVM2.AS.flash.display.PixelSnapping;
            var VisitorFlags = Shumway.AVM2.AS.flash.display.VisitorFlags;

            var Point = Shumway.AVM2.AS.flash.geom.Point;
            var Bounds = Shumway.Bounds;

            var assert = Shumway.Debug.assert;
            var writer = Shumway.Player.writer;

            var PlayerChannelSerializer = (function () {
                function PlayerChannelSerializer() {
                    this.phase = 0 /* Objects */;
                    this.roots = null;
                }
                PlayerChannelSerializer.prototype.begin = function (displayObject) {
                    this.roots = [displayObject];
                };

                PlayerChannelSerializer.prototype.remoteObjects = function () {
                    this.phase = 0 /* Objects */;
                    var roots = this.roots;
                    for (var i = 0; i < roots.length; i++) {
                        Shumway.Player.enterTimeline("remoting objects");
                        this.writeDisplayObject(roots[i]);
                        Shumway.Player.leaveTimeline("remoting objects");
                    }
                };

                PlayerChannelSerializer.prototype.remoteReferences = function () {
                    this.phase = 1 /* References */;
                    var roots = this.roots;
                    for (var i = 0; i < roots.length; i++) {
                        Shumway.Player.enterTimeline("remoting references");
                        this.writeDisplayObject(roots[i]);
                        Shumway.Player.leaveTimeline("remoting references");
                    }
                };

                PlayerChannelSerializer.prototype.writeDisplayObject = function (displayObject) {
                    var serializer = this;
                    var roots = this.roots;
                    displayObject.visit(function (displayObject) {
                        serializer.writeUpdateFrame(displayObject);

                        // Collect more roots?
                        if (roots && displayObject.mask) {
                            var root = displayObject.mask._findFurthestAncestorOrSelf();
                            Shumway.ArrayUtilities.pushUnique(roots, root);
                        }
                        return 0 /* Continue */;
                    }, 16 /* Filter */, DisplayObjectFlags.Dirty);
                };

                PlayerChannelSerializer.prototype.writeStage = function (stage) {
                    writer && writer.writeLn("Sending Stage");
                    var serializer = this;
                    this.output.writeInt(104 /* UpdateStage */);
                    this.output.writeInt(stage._id);
                    this.output.writeInt(stage.color);
                    this.writeRectangle(new Bounds(0, 0, stage.stageWidth * 20, stage.stageHeight * 20));
                };

                PlayerChannelSerializer.prototype.writeGraphics = function (graphics) {
                    if (graphics._isDirty) {
                        writer && writer.writeLn("Sending Graphics: " + graphics._id);
                        var textures = graphics.getUsedTextures();
                        var numTextures = textures.length;
                        for (var i = 0; i < numTextures; i++) {
                            this.writeBitmapData(textures[i]);
                        }
                        this.output.writeInt(101 /* UpdateGraphics */);
                        this.output.writeInt(graphics._id);
                        this.output.writeInt(-1);
                        this.writeRectangle(graphics._getContentBounds());
                        this.pushAsset(graphics.getGraphicsData().toPlainObject());
                        this.output.writeInt(numTextures);
                        for (var i = 0; i < numTextures; i++) {
                            this.output.writeInt(textures[i]._id);
                        }
                        graphics._isDirty = false;
                    }
                };

                PlayerChannelSerializer.prototype.writeBitmapData = function (bitmapData) {
                    if (bitmapData._isDirty) {
                        writer && writer.writeLn("Sending BitmapData: " + bitmapData._id);
                        this.output.writeInt(102 /* UpdateBitmapData */);
                        this.output.writeInt(bitmapData._id);
                        this.output.writeInt(bitmapData._symbol ? bitmapData._symbol.id : -1);
                        this.writeRectangle(bitmapData._getContentBounds());
                        this.output.writeInt(bitmapData._type);
                        this.pushAsset(bitmapData.getDataBuffer().toPlainObject());
                        bitmapData._isDirty = false;
                    }
                };

                PlayerChannelSerializer.prototype.writeTextContent = function (textContent) {
                    if (textContent.flags & Shumway.TextContentFlags.Dirty) {
                        writer && writer.writeLn("Sending TextContent: " + textContent._id);
                        this.output.writeInt(103 /* UpdateTextContent */);
                        this.output.writeInt(textContent._id);
                        this.output.writeInt(-1);
                        this.writeRectangle(textContent.bounds);
                        this.writeMatrix(textContent.matrix || flash.geom.Matrix.FROZEN_IDENTITY_MATRIX);
                        this.output.writeInt(textContent.backgroundColor);
                        this.output.writeInt(textContent.borderColor);
                        this.output.writeInt(textContent.autoSize);
                        this.output.writeBoolean(textContent.wordWrap);
                        this.pushAsset(textContent.plainText);
                        this.pushAsset(textContent.textRunData.toPlainObject());
                        var coords = textContent.coords;
                        if (coords) {
                            var numCoords = coords.length;
                            this.output.writeInt(numCoords);
                            for (var i = 0; i < numCoords; i++) {
                                this.output.writeInt(coords[i]);
                            }
                        } else {
                            this.output.writeInt(0);
                        }
                        textContent.flags &= ~Shumway.TextContentFlags.Dirty;
                    }
                };

                PlayerChannelSerializer.prototype.writeFont = function (font) {
                    // Device fonts can be skipped, they obviously should exist on the device.
                    if (font.fontType === 'embedded') {
                        writer && writer.writeLn("Sending Font: " + font._id);
                        var symbol = font._symbol;
                        release || assert(symbol);
                        this.output.writeInt(200 /* RegisterFont */);
                        this.output.writeInt(font._id);
                        this.output.writeBoolean(symbol.bold);
                        this.output.writeBoolean(symbol.italic);
                        this.pushAsset(symbol.data);
                    }
                };

                /**
                * Writes the number of display objects this display object clips.
                */
                PlayerChannelSerializer.prototype.writeClip = function (displayObject) {
                    if (displayObject._clipDepth >= 0 && displayObject._parent) {
                        // Clips in GFX land don't use absolute clip depth numbers. Instead we need to encode
                        // the number of siblings you want to clip. If children are removed or added, GFX clip
                        // values need to be recomputed.
                        var i = displayObject._parent.getChildIndex(displayObject);
                        var j = displayObject._parent.getClipDepthIndex(displayObject._clipDepth);
                        for (var k = i + 1; k <= i; k++) {
                            // assert(displayObject._parent.getChildAt(k)._depth > displayObject._depth && displayObject._parent.getChildAt(k)._depth <= displayObject._clipDepth);
                        }
                        release || assert(j - i >= 0);
                        this.output.writeInt(j - i);
                    } else {
                        this.output.writeInt(-1);
                    }
                };

                PlayerChannelSerializer.prototype.writeUpdateFrame = function (displayObject) {
                    // Write Header
                    this.output.writeInt(100 /* UpdateFrame */);
                    this.output.writeInt(displayObject._id);

                    writer && writer.writeLn("Sending UpdateFrame: " + displayObject.debugName());

                    var hasMask = false;
                    var hasMatrix = displayObject._hasFlags(1048576 /* DirtyMatrix */);
                    var hasColorTransform = displayObject._hasFlags(33554432 /* DirtyColorTransform */);
                    var hasMiscellaneousProperties = displayObject._hasFlags(268435456 /* DirtyMiscellaneousProperties */);

                    // Check if any children need to be written. These are remoting children, not just display object children.
                    var hasRemotableChildren = false;
                    if (this.phase === 1 /* References */) {
                        hasRemotableChildren = displayObject._hasAnyFlags(2097152 /* DirtyChildren */ | 4194304 /* DirtyGraphics */ | 16777216 /* DirtyBitmapData */ | 8388608 /* DirtyTextContent */);
                        hasMask = displayObject._hasFlags(67108864 /* DirtyMask */);
                    }
                    var bitmap = null;
                    if (display.Bitmap.isType(displayObject)) {
                        bitmap = displayObject;
                    }

                    // Checks if the computed clip value needs to be written.
                    var hasClip = displayObject._hasFlags(134217728 /* DirtyClipDepth */);

                    // Write Has Bits
                    var hasBits = 0;
                    hasBits |= hasMatrix ? 1 /* HasMatrix */ : 0;
                    hasBits |= hasColorTransform ? 8 /* HasColorTransform */ : 0;
                    hasBits |= hasMask ? 64 /* HasMask */ : 0;
                    hasBits |= hasClip ? 128 /* HasClip */ : 0;
                    hasBits |= hasMiscellaneousProperties ? 32 /* HasMiscellaneousProperties */ : 0;
                    hasBits |= hasRemotableChildren ? 4 /* HasChildren */ : 0;
                    this.output.writeInt(hasBits);

                    // Write Properties
                    if (hasMatrix) {
                        this.writeMatrix(displayObject._getMatrix());
                    }
                    if (hasColorTransform) {
                        this.writeColorTransform(displayObject._colorTransform);
                    }
                    if (hasMask) {
                        this.output.writeInt(displayObject.mask ? displayObject.mask._id : -1);
                    }
                    if (hasClip) {
                        this.writeClip(displayObject);
                    }
                    if (hasMiscellaneousProperties) {
                        this.output.writeInt(BlendMode.toNumber(displayObject._blendMode));
                        this.output.writeBoolean(displayObject._hasFlags(1 /* Visible */));
                        if (bitmap) {
                            this.output.writeInt(PixelSnapping.toNumber(bitmap.pixelSnapping));
                            this.output.writeInt(bitmap.smoothing ? 1 : 0);
                        } else {
                            this.output.writeInt(PixelSnapping.toNumber(PixelSnapping.AUTO));
                            this.output.writeInt(1);
                        }
                    }

                    var graphics = displayObject._getGraphics();
                    var textContent = displayObject._getTextContent();
                    if (hasRemotableChildren) {
                        writer && writer.enter("Children: {");
                        if (bitmap) {
                            if (bitmap.bitmapData) {
                                this.output.writeInt(1);
                                this.output.writeInt(134217728 /* Asset */ | bitmap.bitmapData._id);
                            } else {
                                this.output.writeInt(0);
                            }
                        } else {
                            // Check if we have a graphics object and write that as a child first.
                            var count = (graphics || textContent) ? 1 : 0;
                            var children = displayObject._children;
                            if (children) {
                                count += children.length;
                            }
                            this.output.writeInt(count);
                            if (graphics) {
                                writer && writer.writeLn("Reference Graphics: " + graphics._id);
                                this.output.writeInt(134217728 /* Asset */ | graphics._id);
                            } else if (textContent) {
                                writer && writer.writeLn("Reference TextContent: " + textContent._id);
                                this.output.writeInt(134217728 /* Asset */ | textContent._id);
                            }

                            // Write all the display object children.
                            if (children) {
                                for (var i = 0; i < children.length; i++) {
                                    writer && writer.writeLn("Reference DisplayObject: " + children[i].debugName());
                                    this.output.writeInt(children[i]._id);

                                    // Make sure children with a clip depth are getting visited.
                                    if (children[i]._clipDepth >= 0) {
                                        children[i]._setFlags(134217728 /* DirtyClipDepth */);
                                    }
                                }
                            }
                        }
                        writer && writer.leave("}");
                    }
                    if (this.phase === 1 /* References */) {
                        displayObject._removeFlags(DisplayObjectFlags.Dirty);
                    }

                    // Visit remotable child objects that are not otherwise visited.
                    if (graphics) {
                        this.writeGraphics(graphics);
                    } else if (textContent) {
                        this.writeTextContent(textContent);
                    } else if (bitmap) {
                        if (bitmap.bitmapData) {
                            this.writeBitmapData(bitmap.bitmapData);
                        }
                    }
                };

                PlayerChannelSerializer.prototype.writeDrawToBitmap = function (bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                    if (typeof matrix === "undefined") { matrix = null; }
                    if (typeof colorTransform === "undefined") { colorTransform = null; }
                    if (typeof blendMode === "undefined") { blendMode = null; }
                    if (typeof clipRect === "undefined") { clipRect = null; }
                    if (typeof smoothing === "undefined") { smoothing = false; }
                    this.output.writeInt(201 /* DrawToBitmap */);
                    this.output.writeInt(bitmapData._id);
                    if (BitmapData.isType(source)) {
                        this.output.writeInt(134217728 /* Asset */ | source._id);
                    } else {
                        this.output.writeInt(source._id);
                    }

                    var hasBits = 0;
                    hasBits |= matrix ? 1 /* HasMatrix */ : 0;
                    hasBits |= colorTransform ? 8 /* HasColorTransform */ : 0;
                    hasBits |= clipRect ? 16 /* HasClipRect */ : 0;

                    this.output.writeInt(hasBits);
                    if (matrix) {
                        this.writeMatrix(matrix);
                    }
                    if (colorTransform) {
                        this.writeColorTransform(colorTransform);
                    }
                    if (clipRect) {
                        this.writeRectangle(Bounds.FromRectangle(clipRect));
                    }
                    this.output.writeInt(BlendMode.toNumber(blendMode));
                    this.output.writeBoolean(smoothing);
                };

                PlayerChannelSerializer.prototype.writeMatrix = function (matrix) {
                    var output = this.output;
                    output.writeFloat(matrix.a);
                    output.writeFloat(matrix.b);
                    output.writeFloat(matrix.c);
                    output.writeFloat(matrix.d);
                    output.writeFloat(matrix.tx);
                    output.writeFloat(matrix.ty);
                };

                PlayerChannelSerializer.prototype.writeRectangle = function (bounds) {
                    var output = this.output;

                    // TODO: check if we should write bounds instead. Depends on what's more useful in GFX-land.
                    output.writeInt(bounds.xMin);
                    output.writeInt(bounds.yMin);
                    output.writeInt(bounds.width);
                    output.writeInt(bounds.height);
                };

                PlayerChannelSerializer.prototype.writeColorTransform = function (colorTransform) {
                    var output = this.output;
                    var rM = colorTransform.redMultiplier;
                    var gM = colorTransform.greenMultiplier;
                    var bM = colorTransform.blueMultiplier;
                    var aM = colorTransform.alphaMultiplier;
                    var rO = colorTransform.redOffset;
                    var gO = colorTransform.greenOffset;
                    var bO = colorTransform.blueOffset;
                    var aO = colorTransform.alphaOffset;

                    var identityOffset = rO === gO && gO === bO && bO === aO && aO === 0;
                    var identityColorMultiplier = rM === gM && gM === bM && bM === 1;

                    if (identityOffset && identityColorMultiplier) {
                        if (aM === 1) {
                            output.writeInt(0 /* Identity */);
                        } else {
                            output.writeInt(1 /* AlphaMultiplierOnly */);
                            output.writeFloat(aM);
                        }
                    } else {
                        output.writeInt(2 /* All */);
                        output.writeFloat(rM);
                        output.writeFloat(gM);
                        output.writeFloat(bM);
                        output.writeFloat(aM);
                        output.writeInt(rO);
                        output.writeInt(gO);
                        output.writeInt(bO);
                        output.writeInt(aO);
                    }
                };

                PlayerChannelSerializer.prototype.writeRequestBitmapData = function (bitmapData) {
                    writer && writer.writeLn("Sending BitmapData Request");
                    this.output.writeInt(105 /* RequestBitmapData */);
                    this.output.writeInt(bitmapData._id);
                };

                PlayerChannelSerializer.prototype.pushAsset = function (asset) {
                    this.output.writeInt(this.outputAssets.length);
                    this.outputAssets.push(asset);
                };
                return PlayerChannelSerializer;
            })();
            Player.PlayerChannelSerializer = PlayerChannelSerializer;

            (function (EventKind) {
                EventKind[EventKind["Focus"] = 0] = "Focus";
                EventKind[EventKind["Mouse"] = 1] = "Mouse";
                EventKind[EventKind["Keyboard"] = 2] = "Keyboard";
            })(Player.EventKind || (Player.EventKind = {}));
            var EventKind = Player.EventKind;

            var PlayerChannelDeserializer = (function () {
                function PlayerChannelDeserializer() {
                }
                PlayerChannelDeserializer.prototype.readEvent = function () {
                    var input = this.input;
                    var tag = input.readInt();
                    switch (tag) {
                        case 300 /* MouseEvent */:
                            return this._readMouseEvent();
                        case 301 /* KeyboardEvent */:
                            return this._readKeyboardEvent();
                        case 302 /* FocusEvent */:
                            return this._readFocusEvent();
                    }
                    release || assert(false, 'Unknown MessageReader tag: ' + tag);
                };

                PlayerChannelDeserializer.prototype._readFocusEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    return {
                        kind: 0 /* Focus */,
                        type: typeId
                    };
                };

                PlayerChannelDeserializer.prototype._readMouseEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    var type = Shumway.Remoting.MouseEventNames[typeId];
                    var pX = input.readFloat();
                    var pY = input.readFloat();
                    var buttons = input.readInt();
                    var flags = input.readInt();
                    return {
                        kind: 1 /* Mouse */,
                        type: type,
                        point: new Point(pX, pY),
                        ctrlKey: !!(flags & 1 /* CtrlKey */),
                        altKey: !!(flags & 2 /* AltKey */),
                        shiftKey: !!(flags & 4 /* ShiftKey */),
                        buttons: buttons
                    };
                };

                PlayerChannelDeserializer.prototype._readKeyboardEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    var type = Shumway.Remoting.KeyboardEventNames[typeId];
                    var keyCode = input.readInt();
                    var charCode = input.readInt();
                    var location = input.readInt();
                    var flags = input.readInt();
                    return {
                        kind: 2 /* Keyboard */,
                        type: type,
                        keyCode: keyCode,
                        charCode: charCode,
                        location: location,
                        ctrlKey: !!(flags & 1 /* CtrlKey */),
                        altKey: !!(flags & 2 /* AltKey */),
                        shiftKey: !!(flags & 4 /* ShiftKey */)
                    };
                };
                return PlayerChannelDeserializer;
            })();
            Player.PlayerChannelDeserializer = PlayerChannelDeserializer;
        })(Remoting.Player || (Remoting.Player = {}));
        var Player = Remoting.Player;
    })(Shumway.Remoting || (Shumway.Remoting = {}));
    var Remoting = Shumway.Remoting;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (_Player) {
        var assert = Shumway.Debug.assert;
        var flash = Shumway.AVM2.AS.flash;

        var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
        var AVM2 = Shumway.AVM2.Runtime.AVM2;
        var avm1lib = Shumway.AVM2.AS.avm1lib;

        var Event = Shumway.AVM2.AS.flash.events.Event;

        var DisplayObject = Shumway.AVM2.AS.flash.display.DisplayObject;

        var EventDispatcher = Shumway.AVM2.AS.flash.events.EventDispatcher;

        var Loader = Shumway.AVM2.AS.flash.display.Loader;

        var MouseEventDispatcher = Shumway.AVM2.AS.flash.ui.MouseEventDispatcher;

        var KeyboardEventDispatcher = Shumway.AVM2.AS.flash.ui.KeyboardEventDispatcher;

        /**
        * Shumway Player
        *
        * This class brings everything together. Load the swf, runs the event loop and
        * synchronizes the frame tree with the display list.
        */
        var Player = (function () {
            function Player() {
                this._framesPlayed = 0;
                this.externalCallback = null;
                /**
                * Time since the last time we've synchronized the display list.
                */
                this._lastPumpTime = 0;
                /**
                * Page Visibility API visible state.
                */
                this._isPageVisible = true;
                /**
                * Page focus state.
                */
                this._hasFocus = true;
                this._keyboardEventDispatcher = new KeyboardEventDispatcher();
                this._mouseEventDispatcher = new MouseEventDispatcher();
                this._writer = new Shumway.IndentingWriter();
                AVM2.instance.globals['Shumway.Player.Utils'] = this;
            }
            /**
            * Abstract method to notify about updates.
            * @param updates
            * @param assets
            */
            Player.prototype.onSendUpdates = function (updates, assets, async) {
                if (typeof async === "undefined") { async = true; }
                throw new Error('This method is abstract');
                return null;
            };

            /**
            * Whether we can get away with rendering at a lower rate.
            */
            Player.prototype._shouldThrottleDownRendering = function () {
                return !this._isPageVisible;
            };

            /**
            * Whether we can get away with executing frames at a lower rate.
            */
            Player.prototype._shouldThrottleDownFrameExecution = function () {
                return !this._isPageVisible;
            };

            Player.prototype.load = function (url) {
                release || assert(!this._loader, "Can't load twice.");
                var self = this;
                var stage = this._stage = new flash.display.Stage();
                var loader = this._loader = flash.display.Loader.getRootLoader();
                var loaderInfo = this._loaderInfo = loader.contentLoaderInfo;

                if (Shumway.playAllSymbolsOption.value) {
                    this._playAllSymbols();
                    loaderInfo._allowCodeExecution = false;
                } else {
                    var startPromise = loader._startPromise;
                    startPromise.then(function () {
                        if (loaderInfo.actionScriptVersion === flash.display.ActionScriptVersion.ACTIONSCRIPT2) {
                            var AS2Key = avm1lib.AS2Key;
                            var AS2Mouse = avm1lib.AS2Mouse;
                            AS2Key.asCallPublicProperty('__bind', [stage]);
                            AS2Mouse.asCallPublicProperty('__bind', [stage]);
                            var avm1Context = loaderInfo._avm1Context;
                            stage.addEventListener('frameConstructed', avm1Context.flushPendingScripts.bind(avm1Context), false, Number.MAX_VALUE);
                        }

                        var root = loader.content;
                        stage._loaderInfo = loaderInfo;
                        stage.frameRate = loaderInfo.frameRate;
                        stage.stageWidth = loaderInfo.width;
                        stage.stageHeight = loaderInfo.height;
                        stage.color = Shumway.ColorUtilities.RGBAToARGB(loaderInfo._colorRGBA);
                        stage.addChildAtDepth(root, 0);
                        self._enterLoops();
                    });
                }
                this._loader.load(new flash.net.URLRequest(url));
            };

            Player.prototype.processEventUpdates = function (updates) {
                var deserializer = new Shumway.Remoting.Player.PlayerChannelDeserializer();
                var EventKind = Shumway.Remoting.Player.EventKind;
                var FocusEventType = Shumway.Remoting.FocusEventType;

                deserializer.input = updates;

                var event = deserializer.readEvent();
                switch ((event.kind)) {
                    case 2 /* Keyboard */:
                        // If the stage doesn't have a focus then dispatch events on the stage
                        // directly.
                        var target = this._stage.focus ? this._stage.focus : this._stage;
                        this._keyboardEventDispatcher.target = target;
                        this._keyboardEventDispatcher.dispatchKeyboardEvent(event);
                        break;
                    case 1 /* Mouse */:
                        this._mouseEventDispatcher.stage = this._stage;
                        this._mouseEventDispatcher.handleMouseEvent(event);
                        break;
                    case 0 /* Focus */:
                        var focusType = event.type;
                        switch (focusType) {
                            case 0 /* DocumentHidden */:
                                this._isPageVisible = false;
                                break;
                            case 1 /* DocumentVisible */:
                                this._isPageVisible = true;
                                break;
                            case 2 /* WindowBlur */:
                                // TODO: This is purposely disabled so that applications don't pause when they are out of
                                // focus while the debugging window is open.
                                // EventDispatcher.broadcastEventDispatchQueue.dispatchEvent(Event.getBroadcastInstance(Event.DEACTIVATE));
                                this._hasFocus = false;
                                break;
                            case 3 /* WindowFocus */:
                                EventDispatcher.broadcastEventDispatchQueue.dispatchEvent(Event.getBroadcastInstance(Event.ACTIVATE));
                                this._hasFocus = true;
                                break;
                        }
                        break;
                }
            };

            Player.prototype._enterLoops = function () {
                this._enterEventLoop();
            };

            Player.prototype._pumpDisplayListUpdates = function () {
                this.syncDisplayObject(this._stage);
            };

            Player.prototype.syncDisplayObject = function (displayObject, async) {
                if (typeof async === "undefined") { async = true; }
                var updates = new DataBuffer();
                var assets = [];
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.output = updates;
                serializer.outputAssets = assets;

                if (flash.display.Stage.isType(displayObject)) {
                    serializer.writeStage(displayObject);
                }

                serializer.begin(displayObject);
                serializer.remoteObjects();
                serializer.remoteReferences();
                updates.writeInt(0 /* EOF */);

                _Player.enterTimeline("remoting assets");
                var output = this.onSendUpdates(updates, assets, async);
                _Player.leaveTimeline("remoting assets");

                return output;
            };

            Player.prototype.requestBitmapData = function (bitmapData) {
                var output = new DataBuffer();
                var assets = [];
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.output = output;
                serializer.outputAssets = assets;
                serializer.writeRequestBitmapData(bitmapData);
                output.writeInt(0 /* EOF */);
                return this.onSendUpdates(output, assets, false);
            };

            Player.prototype.registerFont = function (font) {
                var updates = new DataBuffer();
                var assets = [];
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.output = updates;
                serializer.outputAssets = assets;
                serializer.writeFont(font);
                this.onSendUpdates(updates, assets);
            };

            Player.prototype.drawToBitmap = function (bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                if (typeof matrix === "undefined") { matrix = null; }
                if (typeof colorTransform === "undefined") { colorTransform = null; }
                if (typeof blendMode === "undefined") { blendMode = null; }
                if (typeof clipRect === "undefined") { clipRect = null; }
                if (typeof smoothing === "undefined") { smoothing = false; }
                var updates = new DataBuffer();
                var assets = [];
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.output = updates;
                serializer.outputAssets = assets;

                serializer.writeBitmapData(bitmapData);

                if (flash.display.BitmapData.isType(source)) {
                    serializer.writeBitmapData(source);
                } else {
                    var displayObject = source;

                    serializer.begin(displayObject);
                    serializer.remoteObjects();
                    serializer.remoteReferences();
                }

                serializer.writeDrawToBitmap(bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing);

                updates.writeInt(0 /* EOF */);

                _Player.enterTimeline("sendUpdates");
                this.onSendUpdates(updates, assets, false);
                _Player.leaveTimeline("sendUpdates");
            };

            Player.prototype.requestRendering = function () {
                this._pumpDisplayListUpdates();
            };

            /**
            * Update the frame container with the latest changes from the display list.
            */
            Player.prototype._pumpUpdates = function () {
                if (!Shumway.dontSkipFramesOption.value) {
                    if (this._shouldThrottleDownRendering()) {
                        return;
                    }
                    var timeSinceLastPump = performance.now() - this._lastPumpTime;
                    if (timeSinceLastPump < (1000 / Shumway.pumpRateOption.value)) {
                        return;
                    }
                }
                _Player.enterTimeline("pump");
                if (Shumway.pumpEnabledOption.value) {
                    this._pumpDisplayListUpdates();
                    this._lastPumpTime = performance.now();
                }
                _Player.leaveTimeline("pump");
            };

            Player.prototype._leaveSyncLoop = function () {
                release || assert(this._frameTimeout > -1);
                clearInterval(this._frameTimeout);
            };

            Player.prototype._getFrameInterval = function () {
                var frameRate = Shumway.frameRateOption.value;
                if (frameRate < 0) {
                    frameRate = this._stage.frameRate;
                }
                return Math.floor(1000 / frameRate);
            };

            Player.prototype._enterEventLoop = function () {
                var self = this;
                var stage = this._stage;
                var rootInitialized = false;
                var runFrameScripts = !Shumway.playAllSymbolsOption.value;
                var dontSkipFrames = Shumway.dontSkipFramesOption.value;
                (function tick() {
                    // TODO: change this to the mode described in http://www.craftymind.com/2008/04/18/updated-elastic-racetrack-for-flash-9-and-avm2/
                    self._frameTimeout = setTimeout(tick, self._getFrameInterval());
                    if (!dontSkipFrames && (!Shumway.frameEnabledOption.value && runFrameScripts || self._shouldThrottleDownFrameExecution())) {
                        return;
                    }
                    stage.scaleX = stage.scaleY = Shumway.stageScaleOption.value;
                    for (var i = 0; i < Shumway.frameRateMultiplierOption.value; i++) {
                        _Player.enterTimeline("eventLoop");
                        var start = performance.now();
                        DisplayObject.performFrameNavigation(stage, true, runFrameScripts);
                        _Player.counter.count("performFrameNavigation", 1, performance.now() - start);
                        self._framesPlayed++;
                        if (Shumway.tracePlayerOption.value > 0 && (self._framesPlayed % Shumway.tracePlayerOption.value === 0)) {
                            self._tracePlayer();
                        }
                        Loader.progress();
                        _Player.leaveTimeline("eventLoop");
                    }
                    if (rootInitialized) {
                        stage.render();
                    } else {
                        rootInitialized = true;
                    }
                    self._pumpUpdates();
                    self.onFrameProcessed();
                })();
            };

            Player.prototype._tracePlayer = function () {
                var writer = this._writer;
                writer.enter("Frame: " + this._framesPlayed);

                Shumway.AVM2.counter.traceSorted(writer, true);
                Shumway.AVM2.counter.clear();

                Shumway.Player.counter.traceSorted(writer, true);
                Shumway.Player.counter.clear();

                writer.writeLn("advancableInstances: " + flash.display.DisplayObject._advancableInstances.length);
                writer.outdent();
            };

            Player.prototype._leaveEventLoop = function () {
                release || assert(this._frameTimeout > -1);
                clearInterval(this._frameTimeout);
                this._frameTimeout = -1;
            };

            Player.prototype._playAllSymbols = function () {
                var stage = this._stage;
                var loader = this._loader;
                var loaderInfo = this._loaderInfo;
                var self = this;

                loaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, function onProgress() {
                    var root = loader.content;
                    if (!root) {
                        return;
                    }
                    loaderInfo.removeEventListener(flash.events.ProgressEvent.PROGRESS, onProgress);
                    self._enterLoops();
                });

                loaderInfo.addEventListener(flash.events.Event.COMPLETE, function onProgress() {
                    stage.stageWidth = 1024;
                    stage.stageHeight = 1024;

                    var symbols = [];
                    loaderInfo._dictionary.forEach(function (symbol, key) {
                        if (symbol instanceof Shumway.Timeline.DisplaySymbol) {
                            symbols.push(symbol);
                        }
                    });

                    function show(symbol) {
                        flash.display.DisplayObject.reset();
                        flash.display.MovieClip.reset();
                        var symbolInstance = symbol.symbolClass.initializeFrom(symbol);
                        symbol.symbolClass.instanceConstructorNoInitialize.call(symbolInstance);
                        if (symbol instanceof Shumway.Timeline.BitmapSymbol) {
                            symbolInstance = new flash.display.Bitmap(symbolInstance);
                        }
                        while (stage.numChildren > 0) {
                            stage.removeChildAt(0);
                        }
                        stage.addChild(symbolInstance);
                    }

                    var nextSymbolIndex = 0;
                    function showNextSymbol() {
                        var symbol;
                        if (Shumway.playSymbolOption.value > 0) {
                            symbol = loaderInfo.getSymbolById(Shumway.playSymbolOption.value);
                            if (symbol instanceof Shumway.Timeline.DisplaySymbol) {
                            } else {
                                symbol = null;
                            }
                        } else {
                            symbol = symbols[nextSymbolIndex++];
                            if (nextSymbolIndex === symbols.length) {
                                nextSymbolIndex = 0;
                            }
                            if (Shumway.playSymbolCountOption.value >= 0 && nextSymbolIndex > Shumway.playSymbolCountOption.value) {
                                nextSymbolIndex = 0;
                            }
                        }
                        var frames = 1;
                        if (symbol && symbol.id > 0) {
                            show(symbol);
                            if (symbol instanceof Shumway.Timeline.SpriteSymbol) {
                                frames = symbol.numFrames;
                            }
                        }
                        if (Shumway.playSymbolFrameDurationOption.value > 0) {
                            frames = Shumway.playSymbolFrameDurationOption.value;
                        }
                        setTimeout(showNextSymbol, self._getFrameInterval() * frames);
                    }
                    setTimeout(showNextSymbol, self._getFrameInterval());
                });
            };

            Player.prototype.processExternalCallback = function (request) {
                if (!this.externalCallback) {
                    return;
                }

                try  {
                    request.result = this.externalCallback(request.functionName, request.args);
                } catch (e) {
                    request.error = e.message;
                }
            };

            Player.prototype.onExternalCommand = function (command) {
                throw new Error('This method is abstract');
            };

            Player.prototype.onFrameProcessed = function () {
                throw new Error('This method is abstract');
            };

            Player.prototype.createExternalInterfaceService = function () {
                var isEnabled;
                var player = this;
                return {
                    get enabled() {
                        if (isEnabled === undefined) {
                            var cmd = { action: 'isEnabled' };
                            player.onExternalCommand(cmd);
                            isEnabled = cmd.result;
                        }
                        return isEnabled;
                    },
                    initJS: function (callback) {
                        player.externalCallback = callback;
                        var cmd = { action: 'initJS' };
                        player.onExternalCommand(cmd);
                    },
                    registerCallback: function (functionName) {
                        var cmd = { action: 'register', functionName: functionName, remove: false };
                        player.onExternalCommand(cmd);
                    },
                    unregisterCallback: function (functionName) {
                        var cmd = { action: 'register', functionName: functionName, remove: true };
                        player.onExternalCommand(cmd);
                    },
                    eval: function (expression) {
                        var cmd = { action: 'eval', expression: expression };
                        player.onExternalCommand(cmd);
                        return cmd.result;
                    },
                    call: function (request) {
                        var cmd = { action: 'call', request: request };
                        player.onExternalCommand(cmd);
                        return cmd.result;
                    },
                    getId: function () {
                        var cmd = { action: 'getId' };
                        player.onExternalCommand(cmd);
                        return cmd.result;
                    }
                };
            };
            Player._syncFrameRate = 60;
            return Player;
        })();
        _Player.Player = Player;
    })(Shumway.Player || (Shumway.Player = {}));
    var Player = Shumway.Player;
})(Shumway || (Shumway = {}));
/* -*- Mode: js; js-indent-level: 2; indent-tabs-mode: nil; tab-width: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    var BinaryFileReader = Shumway.BinaryFileReader;
    var AbcFile = Shumway.AVM2.ABC.AbcFile;
    var AVM2 = Shumway.AVM2.Runtime.AVM2;
    var assert = Shumway.Debug.assert;

    function createAVM2(builtinPath, libraryPath, avm1Path, sysMode, appMode, next) {
        function loadAVM1(next) {
            new BinaryFileReader(avm1Path).readAll(null, function (buffer) {
                avm2.systemDomain.executeAbc(new AbcFile(new Uint8Array(buffer), avm1Path));
                next();
            });
        }

        var avm2;
        release || assert(builtinPath);
        new BinaryFileReader(builtinPath).readAll(null, function (buffer) {
            AVM2.initialize(sysMode, appMode, avm1Path ? loadAVM1 : null);
            avm2 = AVM2.instance;
            Shumway.AVM2.AS.linkNatives(avm2);
            console.time("Execute builtin.abc");

            // Avoid loading more Abcs while the builtins are loaded
            avm2.builtinsLoaded = false;

            // avm2.systemDomain.onMessage.register('classCreated', Stubs.onClassCreated);
            avm2.systemDomain.executeAbc(new AbcFile(new Uint8Array(buffer), "builtin.abc"));
            avm2.builtinsLoaded = true;
            console.timeEnd("Execute builtin.abc");

            // If library is shell.abc, then just go ahead and run it now since
            // it's not worth doing it lazily given that it is so small.
            if (typeof libraryPath === 'string') {
                new BinaryFileReader(libraryPath).readAll(null, function (buffer) {
                    avm2.systemDomain.executeAbc(new AbcFile(new Uint8Array(buffer), libraryPath));
                    next(avm2);
                });
                return;
            }

            var libraryPathInfo = libraryPath;
            if (!AVM2.isPlayerglobalLoaded()) {
                AVM2.loadPlayerglobal(libraryPathInfo.abcs, libraryPathInfo.catalog).then(function () {
                    next(avm2);
                });
            }
        });
    }
    Shumway.createAVM2 = createAVM2;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    (function (_Player) {
        (function (Window) {
            var Player = Shumway.Player.Player;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

            var WindowPlayer = (function (_super) {
                __extends(WindowPlayer, _super);
                function WindowPlayer(window, parent) {
                    _super.call(this);
                    this._window = window;
                    this._parent = parent || window.parent;
                    this._window.addEventListener('message', function (e) {
                        this.onWindowMessage(e.data);
                    }.bind(this));
                    //this._window.addEventListener('syncmessage', function (e) {
                    //  this.onWindowMessage(e.detail);
                    //}.bind(this));
                }
                WindowPlayer.prototype.onSendUpdates = function (updates, assets, async) {
                    if (typeof async === "undefined") { async = true; }
                    var bytes = updates.getBytes();
                    var message = {
                        type: 'player',
                        updates: bytes,
                        assets: assets,
                        result: undefined
                    };
                    var transferList = [bytes.buffer];
                    if (!async) {
                        // TODO var result = this._parent.postSyncMessage(message, '*', transferList);
                        var event = this._parent.document.createEvent('CustomEvent');
                        event.initCustomEvent('syncmessage', false, false, message);
                        this._parent.dispatchEvent(event);
                        var result = message.result;
                        return DataBuffer.FromPlainObject(result);
                    }
                    this._parent.postMessage(message, '*', transferList);
                    return null;
                };

                WindowPlayer.prototype.onExternalCommand = function (command) {
                    var event = this._parent.document.createEvent('CustomEvent');
                    event.initCustomEvent('syncmessage', false, false, {
                        type: 'external',
                        request: command
                    });
                    this._parent.dispatchEvent(event);
                };

                WindowPlayer.prototype.onFrameProcessed = function () {
                    this._parent.postMessage({
                        type: 'frame'
                    }, '*');
                };

                WindowPlayer.prototype.onWindowMessage = function (data) {
                    if (typeof data === 'object' && data !== null) {
                        switch (data.type) {
                            case 'gfx':
                                var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
                                var updates = DataBuffer.FromArrayBuffer(data.updates.buffer);
                                this.processEventUpdates(updates);
                                break;
                            case 'externalCallback':
                                this.processExternalCallback(data.request);
                                break;
                            case 'options':
                                Shumway.Settings.setSettings(data.settings);
                                break;
                            case 'timeline':
                                switch (data.request) {
                                    case 'AVM2':
                                        if (data.cmd === 'clear') {
                                            Shumway.AVM2.timelineBuffer.reset();
                                            break;
                                        }
                                        this._parent.postMessage({
                                            type: 'timelineResponse',
                                            request: data.request,
                                            timeline: Shumway.AVM2.timelineBuffer
                                        }, '*');
                                        break;
                                    case 'Player':
                                        if (data.cmd === 'clear') {
                                            Shumway.Player.timelineBuffer.reset();
                                            break;
                                        }
                                        this._parent.postMessage({
                                            type: 'timelineResponse',
                                            request: data.request,
                                            timeline: Shumway.Player.timelineBuffer
                                        }, '*');
                                        break;
                                    case 'SWF':
                                        if (data.cmd === 'clear') {
                                            Shumway.SWF.timelineBuffer.reset();
                                            break;
                                        }
                                        this._parent.postMessage({
                                            type: 'timelineResponse',
                                            request: data.request,
                                            timeline: Shumway.SWF.timelineBuffer
                                        }, '*');
                                        break;
                                }
                                break;
                        }
                    }
                };
                return WindowPlayer;
            })(Player);
            Window.WindowPlayer = WindowPlayer;
        })(_Player.Window || (_Player.Window = {}));
        var Window = _Player.Window;
    })(Shumway.Player || (Shumway.Player = {}));
    var Player = Shumway.Player;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (_Player) {
        (function (Test) {
            var Player = Shumway.Player.Player;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;

            var TestPlayer = (function (_super) {
                __extends(TestPlayer, _super);
                function TestPlayer() {
                    _super.call(this);

                    // TODO this is temporary worker to test postMessage tranfers
                    this._worker = Shumway.Player.Test.FakeSyncWorker.instance;
                    this._worker.addEventListener('message', this._onWorkerMessage.bind(this));
                    //this._worker.addEventListener('syncmessage', this._onWorkerMessage.bind(this));
                }
                TestPlayer.prototype.onSendUpdates = function (updates, assets, async) {
                    if (typeof async === "undefined") { async = true; }
                    var bytes = updates.getBytes();
                    var message = {
                        type: 'player',
                        updates: bytes,
                        assets: assets
                    };
                    var transferList = [bytes.buffer];
                    if (!async) {
                        var result = this._worker.postSyncMessage(message, transferList);
                        return DataBuffer.FromPlainObject(result);
                    }
                    this._worker.postMessage(message, transferList);
                    return null;
                };

                TestPlayer.prototype.onExternalCommand = function (command) {
                    this._worker.postSyncMessage({
                        type: 'external',
                        command: command
                    });
                };

                TestPlayer.prototype.onFrameProcessed = function () {
                    this._worker.postMessage({
                        type: 'frame'
                    });
                };

                TestPlayer.prototype._onWorkerMessage = function (e) {
                    var data = e.data;
                    if (typeof data !== 'object' || data === null) {
                        return;
                    }
                    switch (data.type) {
                        case 'gfx':
                            var updates = DataBuffer.FromArrayBuffer(e.data.updates.buffer);
                            this.processEventUpdates(updates);
                            break;
                        case 'externalCallback':
                            this.processExternalCallback(data.request);
                            return;
                    }
                };
                return TestPlayer;
            })(Player);
            Test.TestPlayer = TestPlayer;
        })(_Player.Test || (_Player.Test = {}));
        var Test = _Player.Test;
    })(Shumway.Player || (Shumway.Player = {}));
    var Player = Shumway.Player;
})(Shumway || (Shumway = {}));
/**
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var Shumway;
(function (Shumway) {
    (function (Player) {
        (function (Test) {
            var FakeSyncWorker = (function () {
                function FakeSyncWorker() {
                    this._worker = new Worker(FakeSyncWorker.WORKER_PATH);
                    this._onsyncmessageListeners = [];
                }
                Object.defineProperty(FakeSyncWorker, "instance", {
                    get: function () {
                        if (!FakeSyncWorker._singelton) {
                            FakeSyncWorker._singelton = new FakeSyncWorker();
                        }
                        return FakeSyncWorker._singelton;
                    },
                    enumerable: true,
                    configurable: true
                });

                FakeSyncWorker.prototype.addEventListener = function (type, listener, useCapture) {
                    if (type !== 'syncmessage') {
                        this._worker.addEventListener(type, listener, useCapture);
                    } else {
                        this._onsyncmessageListeners.push(listener);
                    }
                };

                FakeSyncWorker.prototype.removeEventListener = function (type, listener, useCapture) {
                    if (type === 'syncmessage') {
                        var i = this._onsyncmessageListeners.indexOf(listener);
                        if (i >= 0) {
                            this._onsyncmessageListeners.splice(i, 1);
                        }
                        return;
                    }
                    this._worker.removeEventListener(type, listener, useCapture);
                };

                FakeSyncWorker.prototype.postMessage = function (message, ports) {
                    this._worker.postMessage(message, ports);
                };

                FakeSyncWorker.prototype.postSyncMessage = function (message, ports) {
                    var listener = this._onsyncmessageListeners[0];
                    if (listener) {
                        var ev = { data: message };
                        if (typeof listener === 'function') {
                            return listener(ev);
                        } else {
                            return listener.handleEvent(ev);
                        }
                    }
                };
                FakeSyncWorker.WORKER_PATH = '../../src/player/fakechannel.js';
                return FakeSyncWorker;
            })();
            Test.FakeSyncWorker = FakeSyncWorker;
        })(Player.Test || (Player.Test = {}));
        var Test = Player.Test;
    })(Shumway.Player || (Shumway.Player = {}));
    var Player = Shumway.Player;
})(Shumway || (Shumway = {}));
/*
* Copyright 2014 Mozilla Foundation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
/// <reference path='../../build/ts/swf.d.ts' />
/// <reference path='../../build/ts/flash.d.ts' />
///<reference path='module.ts' />
///<reference path='options.ts' />
///<reference path='frameScheduler.ts' />
///<reference path='remotingPlayer.ts' />
///<reference path='player.ts' />
///<reference path='avmLoader.ts' />
///<reference path='window/windowPlayer.ts' />
///<reference path='test/testPlayer.ts' />
///<reference path='test/fakeSyncWorker.ts' />
//# sourceMappingURL=player.js.map

console.timeEnd("Load Player Dependencies");
